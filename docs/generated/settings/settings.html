<table>
<thead><tr><th>Setting</th><th>Type</th><th>Default</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>audit.event.disable.list</code></td><td>string</td><td><code></code></td><td>the list of event audit disable, use ',' as separator</td></tr>
<tr><td><code>audit.log.enabled</code></td><td>boolean</td><td><code>true</code></td><td>the switch of the audit log</td></tr>
<tr><td><code>audit.refresh.interval</code></td><td>integer</td><td><code>10</code></td><td>interval seconds for settings refresh</td></tr>
<tr><td><code>audit.sql.inject.bypass.enabled</code></td><td>boolean</td><td><code>true</code></td><td>the switch whether sql injection open</td></tr>
<tr><td><code>audit.sql.length</code></td><td>integer</td><td><code>10000</code></td><td>the limitation of the sql length</td></tr>
<tr><td><code>audit.sql.length.bypass.enabled</code></td><td>boolean</td><td><code>true</code></td><td>the switch whether the limitation for sql length be opened</td></tr>
<tr><td><code>changefeed.experimental_poll_interval</code></td><td>duration</td><td><code>1s</code></td><td>polling interval for the prototype changefeed implementation (WARNING: may compromise cluster stability or correctness; do not edit without supervision)</td></tr>
<tr><td><code>changefeed.push.enabled</code></td><td>boolean</td><td><code>true</code></td><td>if set, changed are pushed instead of pulled. This requires the kv.rangefeed.enabled setting.</td></tr>
<tr><td><code>cloudsink.http.custom_ca</code></td><td>string</td><td><code></code></td><td>custom root CA (appended to system's default CAs) for verifying certificates when interacting with HTTPS storage</td></tr>
<tr><td><code>cloudsink.timeout</code></td><td>duration</td><td><code>10m0s</code></td><td>the timeout for load/dump storage operations</td></tr>
<tr><td><code>cluster.organization</code></td><td>string</td><td><code></code></td><td>organization name</td></tr>
<tr><td><code>cluster.preserve_downgrade_option</code></td><td>string</td><td><code></code></td><td>disable (automatic or manual) cluster version upgrade from the specified version until reset</td></tr>
<tr><td><code>compactor.enabled</code></td><td>boolean</td><td><code>true</code></td><td>when false, the system will reclaim space occupied by deleted data less aggressively</td></tr>
<tr><td><code>compactor.max_record_age</code></td><td>duration</td><td><code>24h0m0s</code></td><td>discard suggestions not processed within this duration (WARNING: may compromise cluster stability or correctness; do not edit without supervision)</td></tr>
<tr><td><code>compactor.min_interval</code></td><td>duration</td><td><code>15s</code></td><td>minimum time interval to wait before compacting (WARNING: may compromise cluster stability or correctness; do not edit without supervision)</td></tr>
<tr><td><code>compactor.threshold_available_fraction</code></td><td>float</td><td><code>0.1</code></td><td>consider suggestions for at least the given percentage of the available logical space (zero to disable) (WARNING: may compromise cluster stability or correctness; do not edit without supervision)</td></tr>
<tr><td><code>compactor.threshold_bytes</code></td><td>byte size</td><td><code>256 MiB</code></td><td>minimum expected logical space reclamation required before considering an aggregated suggestion (WARNING: may compromise cluster stability or correctness; do not edit without supervision)</td></tr>
<tr><td><code>compactor.threshold_used_fraction</code></td><td>float</td><td><code>0.1</code></td><td>consider suggestions for at least the given percentage of the used logical space (zero to disable) (WARNING: may compromise cluster stability or correctness; do not edit without supervision)</td></tr>
<tr><td><code>debug.panic_on_failed_assertions</code></td><td>boolean</td><td><code>false</code></td><td>panic when an assertion fails rather than reporting</td></tr>
<tr><td><code>diagnostics.forced_stat_reset.interval</code></td><td>duration</td><td><code>2h0m0s</code></td><td>interval after which pending diagnostics statistics should be discarded even if not reported</td></tr>
<tr><td><code>diagnostics.reporting.enabled</code></td><td>boolean</td><td><code>true</code></td><td>enable reporting diagnostic metrics to znbase labs</td></tr>
<tr><td><code>diagnostics.reporting.interval</code></td><td>duration</td><td><code>1h0m0s</code></td><td>interval at which diagnostics data should be reported (should be shorter than diagnostics.forced_stat_reset.interval)</td></tr>
<tr><td><code>diagnostics.reporting.send_crash_reports</code></td><td>boolean</td><td><code>true</code></td><td>send crash and panic reports</td></tr>
<tr><td><code>engine.online.adjustable.parameters</code></td><td>string</td><td><code></code></td><td>engine.online.adjustable.parameters</td></tr>
<tr><td><code>external.graphite.endpoint</code></td><td>string</td><td><code></code></td><td>if nonempty, push server metrics to the Graphite or Carbon server at the specified host:port</td></tr>
<tr><td><code>external.graphite.interval</code></td><td>duration</td><td><code>10s</code></td><td>the interval at which metrics are pushed to Graphite (if enabled)</td></tr>
<tr><td><code>feature.request.nodecert.enabled</code></td><td>boolean</td><td><code>false</code></td><td>set to true to enable the user who has "admin" role request node user cert and primary key, false to disable; default is false</td></tr>
<tr><td><code>flashback.revert.consistency</code></td><td>boolean</td><td><code>true</code></td><td>set to true to make the recovery process is consistent, but the performance is worse;Setting to false recovery interrupts have intermediate states, but better performance</td></tr>
<tr><td><code>gossip.maxhops</code></td><td>integer</td><td><code>5</code></td><td>the maxhops which gossip's distance can reach</td></tr>
<tr><td><code>jobs.registry.leniency</code></td><td>duration</td><td><code>1m0s</code></td><td>the amount of time to defer any attempts to reschedule a job</td></tr>
<tr><td><code>jobs.retention_time</code></td><td>duration</td><td><code>336h0m0s</code></td><td>the amount of time to retain records for completed jobs before</td></tr>
<tr><td><code>jobs.scheduler.enabled</code></td><td>boolean</td><td><code>true</code></td><td>enable/disable job scheduler</td></tr>
<tr><td><code>jobs.scheduler.max_jobs_per_iteration</code></td><td>integer</td><td><code>10</code></td><td>how many schedules to start per iteration; setting to 0 turns off this limit</td></tr>
<tr><td><code>jobs.scheduler.pace</code></td><td>duration</td><td><code>1m0s</code></td><td>how often to scan system.scheduled_jobs table</td></tr>
<tr><td><code>kv.allocator.lease_rebalancing_aggressiveness</code></td><td>float</td><td><code>1</code></td><td>set greater than 1.0 to rebalance leases toward load more aggressively, or between 0 and 1.0 to be more conservative about rebalancing leases</td></tr>
<tr><td><code>kv.allocator.load_based_lease_rebalancing.enabled</code></td><td>boolean</td><td><code>true</code></td><td>set to enable rebalancing of range leases based on load and latency</td></tr>
<tr><td><code>kv.allocator.load_based_rebalancing</code></td><td>enumeration</td><td><code>2</code></td><td>whether to rebalance based on the distribution of QPS across stores [off = 0, leases = 1, leases and replicas = 2]</td></tr>
<tr><td><code>kv.allocator.qps_rebalance_threshold</code></td><td>float</td><td><code>0.25</code></td><td>minimum fraction away from the mean a store's QPS (such as queries per second) can be before it is considered overfull or underfull</td></tr>
<tr><td><code>kv.allocator.range_rebalance_threshold</code></td><td>float</td><td><code>0.05</code></td><td>minimum fraction away from the mean a store's range count can be before it is considered overfull or underfull</td></tr>
<tr><td><code>kv.bulk_io_write.addsstable_max_rate</code></td><td>float</td><td><code>1.7976931348623157E+308</code></td><td>maximum number of AddSSTable requests per second for a single store</td></tr>
<tr><td><code>kv.bulk_io_write.concurrent_addsstable_requests</code></td><td>integer</td><td><code>1</code></td><td>number of AddSSTable requests a store will handle concurrently before queuing</td></tr>
<tr><td><code>kv.bulk_io_write.concurrent_export_requests</code></td><td>integer</td><td><code>3</code></td><td>number of export requests a store will handle concurrently before queuing</td></tr>
<tr><td><code>kv.bulk_io_write.concurrent_import_requests</code></td><td>integer</td><td><code>1</code></td><td>number of import requests a store will handle concurrently before queuing</td></tr>
<tr><td><code>kv.bulk_io_write.max_rate</code></td><td>byte size</td><td><code>1.0 TiB</code></td><td>the rate limit (bytes/sec) to use for writes to disk on behalf of bulk io ops</td></tr>
<tr><td><code>kv.bulk_io_write.small_write_size</code></td><td>byte size</td><td><code>400 KiB</code></td><td>size below which a 'bulk' write will be performed as a normal write instead</td></tr>
<tr><td><code>kv.bulk_sst.sync_size</code></td><td>byte size</td><td><code>2.0 MiB</code></td><td>threshold after which non-Rocks SST writes must fsync (0 disables)</td></tr>
<tr><td><code>kv.closed_timestamp.close_fraction</code></td><td>float</td><td><code>0.2</code></td><td>fraction of closed timestamp target duration specifying how frequently the closed timestamp is advanced</td></tr>
<tr><td><code>kv.closed_timestamp.follower_reads_enabled</code></td><td>boolean</td><td><code>true</code></td><td>allow (all) replicas to serve consistent historical reads based on closed timestamp information</td></tr>
<tr><td><code>kv.closed_timestamp.target_duration</code></td><td>duration</td><td><code>30s</code></td><td>if nonzero, attempt to provide closed timestamp notifications for timestamps trailing cluster time by approximately this duration</td></tr>
<tr><td><code>kv.consistency.queue_concurrency</code></td><td>integer</td><td><code>1</code></td><td>consistencyQueue is used to check range consistency. This cluster setting is used to adjust the degree of parallelism dynamically.</td></tr>
<tr><td><code>kv.follower_read.follower_high_priority</code></td><td>boolean</td><td><code>false</code></td><td>whether follower read with high priority is allowed</td></tr>
<tr><td><code>kv.follower_read.target_multiple</code></td><td>float</td><td><code>3</code></td><td>if above 1, encourages the distsender to perform a read against the closest replica if a request is older than kv.closed_timestamp.target_duration * (1 + kv.closed_timestamp.close_fraction * this) less a clock uncertainty interval. This value also is used to create follower_timestamp(). (WARNING: may compromise cluster stability or correctness; do not edit without supervision)</td></tr>
<tr><td><code>kv.gc.queue_concurrency</code></td><td>integer</td><td><code>1</code></td><td>gcQueue manages a queue of replicas slated to be scanned in their entirety using the MVCC versions iterator. This cluster setting is used to adjust the degree of parallelism dynamically.</td></tr>
<tr><td><code>kv.load.batch_size</code></td><td>byte size</td><td><code>32 MiB</code></td><td>the maximum size of the payload in an AddSSTable request (WARNING: may compromise cluster stability or correctness; do not edit without supervision)</td></tr>
<tr><td><code>kv.load.buffer.size</code></td><td>byte size</td><td><code>64 MiB</code></td><td>bulkadder's cache size (WARNING: may compromise cluster stability or correctness; do not edit without supervision)</td></tr>
<tr><td><code>kv.load.concurrency</code></td><td>integer</td><td><code>4</code></td><td>number of concurrent goroutines that convert kv data during load (WARNING: may compromise cluster stability or correctness; do not edit without supervision)</td></tr>
<tr><td><code>kv.load.flush.size</code></td><td>byte size</td><td><code>16 MiB</code></td><td>when this value is reached, the data in sstbatch is flushed once, that is, the data in kvch is consumed (WARNING: may compromise cluster stability or correctness; do not edit without supervision)</td></tr>
<tr><td><code>kv.load.ingest.concurrency</code></td><td>integer</td><td><code>4</code></td><td>concurrent number of coroutines written to SST file (WARNING: may compromise cluster stability or correctness; do not edit without supervision)</td></tr>
<tr><td><code>kv.load.kafka.concurrency</code></td><td>integer</td><td><code>2</code></td><td>concurrent number of coroutines consumer kafka data (WARNING: may compromise cluster stability or correctness; do not edit without supervision)</td></tr>
<tr><td><code>kv.load.kafka.flush_duration</code></td><td>duration</td><td><code>5s</code></td><td>kafka pushes data each time (WARNING: may compromise cluster stability or correctness; do not edit without supervision)</td></tr>
<tr><td><code>kv.load.kvch.cap</code></td><td>integer</td><td><code>10</code></td><td>the capacity of the kv channel during the load process (WARNING: may compromise cluster stability or correctness; do not edit without supervision)</td></tr>
<tr><td><code>kv.load.kvrecord.size</code></td><td>integer</td><td><code>5000</code></td><td>kv records the maximum number, when it is exceeded, it is placed in the kv channel (WARNING: may compromise cluster stability or correctness; do not edit without supervision)</td></tr>
<tr><td><code>kv.load.record.batch.size</code></td><td>integer</td><td><code>500</code></td><td>read the maximum number of file records, when it is exceeded, put it in the record channel (WARNING: may compromise cluster stability or correctness; do not edit without supervision)</td></tr>
<tr><td><code>kv.load.recordch.size</code></td><td>integer</td><td><code>2</code></td><td>recordCh size (WARNING: may compromise cluster stability or correctness; do not edit without supervision)</td></tr>
<tr><td><code>kv.load.revert.batch_size</code></td><td>integer</td><td><code>500000</code></td><td>revertTableDefaultBatchSize is the default batch size for reverting tables. This only needs to be small enough to keep raft/rocks happy -- there is no reply size to worry about. (WARNING: may compromise cluster stability or correctness; do not edit without supervision)</td></tr>
<tr><td><code>kv.load.sort.batch.size</code></td><td>byte size</td><td><code>48 MiB</code></td><td>the maximum value of the total cache memory space in the ingestkv process, if it exceeds this value, it is directly flushed to sstbatch (WARNING: may compromise cluster stability or correctness; do not edit without supervision)</td></tr>
<tr><td><code>kv.load.split_size</code></td><td>byte size</td><td><code>2.0 GiB</code></td><td>the maximum size of large file split size (WARNING: may compromise cluster stability or correctness; do not edit without supervision)</td></tr>
<tr><td><code>kv.lock_table.coordinator_liveness_push_delay</code></td><td>duration</td><td><code>50ms</code></td><td>the delay before pushing in order to detect coordinator failures of conflicting transactions</td></tr>
<tr><td><code>kv.lock_table.deadlock_detection_push_delay</code></td><td>duration</td><td><code>100ms</code></td><td>the delay before pushing in order to detect dependency cycles between transactions</td></tr>
<tr><td><code>kv.raft.command.max_size</code></td><td>byte size</td><td><code>64 MiB</code></td><td>maximum size of a raft command</td></tr>
<tr><td><code>kv.raft_log.disable_synchronization_unsafe</code></td><td>boolean</td><td><code>false</code></td><td>set to true to disable synchronization on Raft log writes to persistent storage. Setting to true risks data loss or data corruption on server crashes. The setting is meant for internal testing only and SHOULD NOT be used in production.</td></tr>
<tr><td><code>kv.raft_log.queue_concurrency</code></td><td>integer</td><td><code>4</code></td><td>raftLogQueue manages a queue of replicas slated to have their raft logs truncated by removing unneeded entries. This cluster setting is used to adjust the degree of parallelism dynamically.</td></tr>
<tr><td><code>kv.raft_snapshot.queue_concurrency</code></td><td>integer</td><td><code>1</code></td><td>raftSnapshotQueue manages a queue of replicas which may need to catch a replica up with a snapshot to their range. This cluster setting is used to adjust the degree of parallelism dynamically.</td></tr>
<tr><td><code>kv.range.backpressure_range_size_multiplier</code></td><td>float</td><td><code>2</code></td><td>multiple of range_max_bytes that a range is allowed to grow to without splitting before writes to that range are blocked, or 0 to disable</td></tr>
<tr><td><code>kv.range_descriptor_cache.size</code></td><td>integer</td><td><code>1000000</code></td><td>maximum number of entries in the range descriptor and leaseholder caches</td></tr>
<tr><td><code>kv.range_merge.queue_concurrency</code></td><td>integer</td><td><code>1</code></td><td>the current implementation of merges requires rewriting the right-hand data onto the left-hand range, even when the ranges are collocated. This isexpensive, so limit to one merge at a time.Note that a value lower than 1 is ignored.</td></tr>
<tr><td><code>kv.range_merge.queue_enabled</code></td><td>boolean</td><td><code>true</code></td><td>whether the automatic merge queue is enabled</td></tr>
<tr><td><code>kv.range_merge.queue_interval</code></td><td>duration</td><td><code>1s</code></td><td>how long the merge queue waits between processing replicas (WARNING: may compromise cluster stability or correctness; do not edit without supervision)</td></tr>
<tr><td><code>kv.range_split.by_load_enabled</code></td><td>boolean</td><td><code>true</code></td><td>allow automatic splits of ranges based on where load is concentrated</td></tr>
<tr><td><code>kv.range_split.load_qps_threshold</code></td><td>integer</td><td><code>250</code></td><td>the QPS over which, the range becomes a candidate for load based splitting</td></tr>
<tr><td><code>kv.range_split.queue_concurrency</code></td><td>integer</td><td><code>4</code></td><td>splitQueue manages a queue of ranges slated to be split due to size or along intersecting zone config boundaries. This cluster setting is used to adjust the degree of parallelism dynamically.</td></tr>
<tr><td><code>kv.rangefeed.concurrent_catchup_iterators</code></td><td>integer</td><td><code>64</code></td><td>number of rangefeeds catchup iterators a store will allow concurrently before queueing</td></tr>
<tr><td><code>kv.rangefeed.enabled</code></td><td>boolean</td><td><code>false</code></td><td>if set, rangefeed registration is enabled</td></tr>
<tr><td><code>kv.replicate.queue_concurrency</code></td><td>integer</td><td><code>1</code></td><td>replicateQueue manages a queue of replicas which may need to add an additional replica to their range. This cluster setting is used to adjust the degree of parallelism dynamically.</td></tr>
<tr><td><code>kv.replicate_gc.queue_concurrency</code></td><td>integer</td><td><code>1</code></td><td>replicaGCQueue manages a queue of replicas to be considered for garbage collections. The GC process asynchronously removes local data for ranges that have been rebalanced away from this store. This cluster setting is used to adjust the degree of parallelism dynamically.</td></tr>
<tr><td><code>kv.snapshot_rebalance.max_rate</code></td><td>byte size</td><td><code>8.0 MiB</code></td><td>the rate limit (bytes/sec) to use for rebalance and upreplication snapshots</td></tr>
<tr><td><code>kv.snapshot_recovery.max_rate</code></td><td>byte size</td><td><code>8.0 MiB</code></td><td>the rate limit (bytes/sec) to use for recovery snapshots</td></tr>
<tr><td><code>kv.timeseries_maintenance.queue_concurrency</code></td><td>integer</td><td><code>1</code></td><td>timeSeriesMaintenanceQueue identifies replicas that contain time series data and performs necessary data maintenance on the time series located in the replica. This cluster setting is used to adjust the degree of parallelism dynamically.</td></tr>
<tr><td><code>kv.transaction.auto_commit_ddl</code></td><td>boolean</td><td><code>false</code></td><td>if set, DDL transaction can commit implicitly with begin commit</td></tr>
<tr><td><code>kv.transaction.cluster_isolationlevel</code></td><td>isolation</td><td><code>SERIALIZABLE</code></td><td>transactional commits default with transactional cluster_isolationlevel [DEFAULT = SERIALIZABLE, READ COMMITTED = READ COMMITTED, READ UNCOMMITTED = READ COMMITTED, REPEATABLE READ = SERIALIZABLE, SERIALIZABLE = SERIALIZABLE, SNAPSHOT = SERIALIZABLE, DEFAULT = SERIALIZABLE, READ COMMITTED = READ COMMITTED, READ UNCOMMITTED = READ COMMITTED, REPEATABLE READ = SERIALIZABLE, SERIALIZABLE = SERIALIZABLE, SNAPSHOT = SERIALIZABLE]</td></tr>
<tr><td><code>kv.transaction.max_intents_bytes</code></td><td>integer</td><td><code>262144</code></td><td>maximum number of bytes used to track locks in transactions</td></tr>
<tr><td><code>kv.transaction.max_refresh_attempts</code></td><td>integer</td><td><code>5</code></td><td>number of the maximum number of times a single transactional batch can trigger a refresh spans attempt</td></tr>
<tr><td><code>kv.transaction.max_refresh_spans_bytes</code></td><td>integer</td><td><code>256000</code></td><td>maximum number of bytes used to track refresh spans in serializable transactions</td></tr>
<tr><td><code>kv.transaction.parallel_commits_enabled</code></td><td>boolean</td><td><code>true</code></td><td>if enabled, transactional commits will be parallelized with transactional writes</td></tr>
<tr><td><code>kv.transaction.write_pipelining_enabled</code></td><td>boolean</td><td><code>true</code></td><td>if enabled, transactional writes are pipelined through Raft consensus</td></tr>
<tr><td><code>kv.transaction.write_pipelining_max_batch_size</code></td><td>integer</td><td><code>128</code></td><td>if non-zero, defines that maximum size batch that will be pipelined through Raft consensus</td></tr>
<tr><td><code>kv.transaction.write_pipelining_max_outstanding_size</code></td><td>byte size</td><td><code>256 KiB</code></td><td>maximum number of bytes used to track in-flight pipelined writes before disabling pipelining</td></tr>
<tr><td><code>mail.receiver</code></td><td>string</td><td><code></code></td><td>receiver mail can be specified as a comma separated list, e.g. alert_1@inspur.com,alert_2@inspur.com.</td></tr>
<tr><td><code>mail.refresh.interval</code></td><td>integer</td><td><code>10</code></td><td>interval seconds for settings refresh</td></tr>
<tr><td><code>mail.sender.password</code></td><td>string</td><td><code></code></td><td>sender password</td></tr>
<tr><td><code>mail.sender.smtp.server</code></td><td>string</td><td><code></code></td><td>smtp server with port</td></tr>
<tr><td><code>mail.sender.username</code></td><td>string</td><td><code></code></td><td>sender username</td></tr>
<tr><td><code>mail.tls.enabled</code></td><td>boolean</td><td><code>false</code></td><td>enable tls or not</td></tr>
<tr><td><code>password.validate.check_user_name.enabled</code></td><td>boolean</td><td><code>true</code></td><td>whether check passwords are similar to the username</td></tr>
<tr><td><code>password.validate.max_length</code></td><td>integer</td><td><code>63</code></td><td>the maximum length accepted for passwords set in cleartext via SQL. Note that -1 means no length limit.</td></tr>
<tr><td><code>password.validate.min_length</code></td><td>integer</td><td><code>8</code></td><td>the minimum length accepted for passwords set in cleartext via SQL. Note that a value lower than 1 is ignored: passwords cannot be empty in any case.</td></tr>
<tr><td><code>password.validate.mixed_case_count</code></td><td>integer</td><td><code>1</code></td><td>the minimum number of uppercase and lowercase letters accepted for passwords set in cleartext via SQL</td></tr>
<tr><td><code>password.validate.number_count</code></td><td>integer</td><td><code>1</code></td><td>the minimum number of digits accepted for passwords set in cleartext via SQL</td></tr>
<tr><td><code>password.validate.special_char_count</code></td><td>integer</td><td><code>1</code></td><td>the minimum number of special characters accepted for passwords set in cleartext via SQL</td></tr>
<tr><td><code>rocksdb.ingest_backpressure.delay_l0_file</code></td><td>duration</td><td><code>200ms</code></td><td>delay to add to SST ingestions per file in L0 over the configured limit</td></tr>
<tr><td><code>rocksdb.ingest_backpressure.l0_file_count_threshold</code></td><td>integer</td><td><code>20</code></td><td>number of L0 files after which to backpressure SST ingestions</td></tr>
<tr><td><code>rocksdb.ingest_backpressure.max_delay</code></td><td>duration</td><td><code>5s</code></td><td>maximum amount of time to backpressure a single SST ingestion</td></tr>
<tr><td><code>rocksdb.ingest_backpressure.pending_compaction_threshold</code></td><td>byte size</td><td><code>64 GiB</code></td><td>pending compaction estimate above which to backpressure SST ingestions</td></tr>
<tr><td><code>rocksdb.min_wal_sync_interval</code></td><td>duration</td><td><code>0s</code></td><td>minimum duration between syncs of the RocksDB WAL</td></tr>
<tr><td><code>rocksdb.online.adjustable.parameters</code></td><td>string</td><td><code></code></td><td>rocksdb.online.adjustable.parameters</td></tr>
<tr><td><code>schemachanger.backfiller.buffer_size</code></td><td>byte size</td><td><code>196 MiB</code></td><td>amount to buffer in memory during backfills</td></tr>
<tr><td><code>schemachanger.backfiller.max_sst_size</code></td><td>byte size</td><td><code>16 MiB</code></td><td>target size for ingested files during backfills</td></tr>
<tr><td><code>schemachanger.bulk_index_backfill.batch_size</code></td><td>integer</td><td><code>5000</code></td><td>number of rows to process at a time during bulk index backfill</td></tr>
<tr><td><code>schemachanger.bulk_index_backfill.enabled</code></td><td>boolean</td><td><code>true</code></td><td>backfill indexes in bulk via addsstable</td></tr>
<tr><td><code>schemachanger.lease.duration</code></td><td>duration</td><td><code>5m0s</code></td><td>the duration of a schema change lease</td></tr>
<tr><td><code>schemachanger.lease.renew_fraction</code></td><td>float</td><td><code>0.5</code></td><td>the fraction of schemachanger.lease_duration remaining to trigger a renew of the lease</td></tr>
<tr><td><code>server.clock.forward_jump_check_enabled</code></td><td>boolean</td><td><code>false</code></td><td>if enabled, forward clock jumps > max_offset/2 will cause a panic</td></tr>
<tr><td><code>server.clock.persist_upper_bound_interval</code></td><td>duration</td><td><code>0s</code></td><td>the interval between persisting the wall time upper bound of the clock. The clock does not generate a wall time greater than the persisted timestamp and will panic if it sees a wall time greater than this value. When znbase starts, it waits for the wall time to catch-up till this persisted timestamp. This guarantees monotonic wall time across server restarts. Not setting this or setting a value of 0 disables this feature.</td></tr>
<tr><td><code>server.consistency_check.interval</code></td><td>duration</td><td><code>24h0m0s</code></td><td>the time between range consistency checks; set to 0 to disable consistency checking</td></tr>
<tr><td><code>server.declined_reservation_timeout</code></td><td>duration</td><td><code>1s</code></td><td>the amount of time to consider the store throttled for up-replication after a reservation was declined</td></tr>
<tr><td><code>server.eventlog.ttl</code></td><td>duration</td><td><code>2160h0m0s</code></td><td>if nonzero, event log entries older than this duration are deleted every 10m0s. Should not be lowered below 24 hours.</td></tr>
<tr><td><code>server.failed_reservation_timeout</code></td><td>duration</td><td><code>5s</code></td><td>the amount of time to consider the store throttled for up-replication after a failed reservation call</td></tr>
<tr><td><code>server.goroutine_dump.num_goroutines_threshold</code></td><td>integer</td><td><code>1000</code></td><td>a threshold beyond which if number of goroutines increases, then goroutine dump can be triggered</td></tr>
<tr><td><code>server.goroutine_dump.total_dump_size_limit</code></td><td>byte size</td><td><code>500 MiB</code></td><td>total size of goroutine dumps to be kept. Dumps are GC'ed in the order of creation time. The latest dump is always kept even if its size exceeds the limit.</td></tr>
<tr><td><code>server.heap_profile.max_profiles</code></td><td>integer</td><td><code>5</code></td><td>maximum number of profiles to be kept. Profiles with lower score are GC'ed, but latest profile is always kept.</td></tr>
<tr><td><code>server.heap_profile.system_memory_threshold_fraction</code></td><td>float</td><td><code>0.85</code></td><td>fraction of system memory beyond which if Rss increases, then heap profile is triggered</td></tr>
<tr><td><code>server.host_based_authentication.configuration</code></td><td>string</td><td><code></code></td><td>host-based authentication configuration to use during connection authentication</td></tr>
<tr><td><code>server.rangelog.ttl</code></td><td>duration</td><td><code>720h0m0s</code></td><td>if nonzero, range log entries older than this duration are deleted every 10m0s. Should not be lowered below 24 hours.</td></tr>
<tr><td><code>server.remote_debugging.mode</code></td><td>string</td><td><code>local</code></td><td>set to enable remote debugging, localhost-only or disable (any, local, off)</td></tr>
<tr><td><code>server.shutdown.drain_wait</code></td><td>duration</td><td><code>0s</code></td><td>the amount of time a server waits in an unready state before proceeding with the rest of the shutdown process</td></tr>
<tr><td><code>server.shutdown.query_wait</code></td><td>duration</td><td><code>10s</code></td><td>the server will wait for at least this amount of time for active queries to finish</td></tr>
<tr><td><code>server.sql_connections.max_limit</code></td><td>integer</td><td><code>-1</code></td><td>the maximum limit accepted for connection set in cleartext via SQL</td></tr>
<tr><td><code>server.sql_session_timeout</code></td><td>integer</td><td><code>0</code></td><td>default duration the session is permitted to be idle before it is closed by server</td></tr>
<tr><td><code>server.time_until_store_dead</code></td><td>duration</td><td><code>5m0s</code></td><td>the time after which if there is no new gossiped information about a store, it is considered dead</td></tr>
<tr><td><code>server.web_session_timeout</code></td><td>duration</td><td><code>168h0m0s</code></td><td>the duration that a newly created web session will be valid</td></tr>
<tr><td><code>sql.casesensitive.enabled</code></td><td>boolean</td><td><code>false</code></td><td>if enabled, all identifier will be casesensitve</td></tr>
<tr><td><code>sql.defaults.casesensitive.enabled</code></td><td>boolean</td><td><code>false</code></td><td>default value for CaseSensitive mode; CaseInsensitive by default</td></tr>
<tr><td><code>sql.defaults.default_int_size</code></td><td>integer</td><td><code>8</code></td><td>the size, in bytes, of an INT type</td></tr>
<tr><td><code>sql.defaults.distsql</code></td><td>enumeration</td><td><code>1</code></td><td>default distributed SQL execution mode [off = 0, auto = 1, on = 2]</td></tr>
<tr><td><code>sql.defaults.experimental_distsql_planning</code></td><td>enumeration</td><td><code>0</code></td><td>default experimental_distsql_planning mode [off = 0, on = 1]</td></tr>
<tr><td><code>sql.defaults.experimental_vectorize</code></td><td>enumeration</td><td><code>0</code></td><td>default experimental_vectorize mode [off = 0, auto = 1, on = 2, always = 3]</td></tr>
<tr><td><code>sql.defaults.implicit_select_for_update.enabled</code></td><td>boolean</td><td><code>false</code></td><td>default value for enable_implicit_select_for_update session setting; enables FOR UPDATE locking during the row-fetch phase of mutation statements</td></tr>
<tr><td><code>sql.defaults.optimizer</code></td><td>enumeration</td><td><code>1</code></td><td>default cost-based optimizer mode [off = 0, on = 1, local = 2]</td></tr>
<tr><td><code>sql.defaults.primary_key_changes.enabled</code></td><td>boolean</td><td><code>true</code></td><td>default value for enable_primary_key_changes session setting; allows use of primary key changes by default</td></tr>
<tr><td><code>sql.defaults.reorder_joins_limit</code></td><td>integer</td><td><code>4</code></td><td>default number of joins to reorder</td></tr>
<tr><td><code>sql.defaults.replicate_table_in_sync.enabled</code></td><td>boolean</td><td><code>false</code></td><td>default value for replicate_table_in_sync session setting; allows use of primary key changes by default</td></tr>
<tr><td><code>sql.defaults.results_buffer.size</code></td><td>byte size</td><td><code>16 KiB</code></td><td>default size of the buffer that accumulates results for a statement or a batch of statements before they are sent to the client. This can be overridden on an individual connection with the 'results_buffer_size' parameter. Note that auto-retries generally only happen while no results have been delivered to the client, so reducing this size can increase the number of retriable errors a client receives. On the other hand, increasing the buffer size can increase the delay until the client receives the first result row. Updating the setting only affects new connections. Setting to 0 disables any buffering.</td></tr>
<tr><td><code>sql.defaults.serial_normalization</code></td><td>enumeration</td><td><code>0</code></td><td>default handling of SERIAL in table definitions [rowid = 0, virtual_sequence = 1, sql_sequence = 2]</td></tr>
<tr><td><code>sql.defaults.vectorize_row_count_threshold</code></td><td>integer</td><td><code>1000</code></td><td>default vectorize row count threshold</td></tr>
<tr><td><code>sql.defaults.zigzag_join.enabled</code></td><td>boolean</td><td><code>true</code></td><td>default value for enable_zigzag_join session setting; allows use of zig-zag join by default</td></tr>
<tr><td><code>sql.distsql.distribute_index_joins</code></td><td>boolean</td><td><code>true</code></td><td>if set, for index joins we instantiate a join reader on every node that has a stream; if not set, we use a single join reader</td></tr>
<tr><td><code>sql.distsql.flow_stream_timeout</code></td><td>duration</td><td><code>10s</code></td><td>amount of time incoming streams wait for a flow to be set up before erroring out</td></tr>
<tr><td><code>sql.distsql.hashjoin_bashash.enabled</code></td><td>boolean</td><td><code>false</code></td><td>if set we plan interleaved table joins instead of merge joins when possible</td></tr>
<tr><td><code>sql.distsql.hashjoin_pnr.enabled</code></td><td>boolean</td><td><code>false</code></td><td>if set we plan interleaved table joins instead of merge joins when possible</td></tr>
<tr><td><code>sql.distsql.hashjoin_prpd.enabled</code></td><td>boolean</td><td><code>false</code></td><td>if set we plan interleaved table joins instead of merge joins when possible</td></tr>
<tr><td><code>sql.distsql.interleaved_joins.enabled</code></td><td>boolean</td><td><code>true</code></td><td>if set we plan interleaved table joins instead of merge joins when possible</td></tr>
<tr><td><code>sql.distsql.max_running_flows</code></td><td>integer</td><td><code>500</code></td><td>maximum number of concurrent flows that can be run on a node</td></tr>
<tr><td><code>sql.distsql.merge_joins.enabled</code></td><td>boolean</td><td><code>true</code></td><td>if set, we plan merge joins when possible</td></tr>
<tr><td><code>sql.distsql.opt.orderedsync</code></td><td>boolean</td><td><code>false</code></td><td>we set the orderedsync syncexec switch here</td></tr>
<tr><td><code>sql.distsql.opt.parallelsetting</code></td><td>integer</td><td><code>5</code></td><td>we set the concurrency here,the defalut value is 5,the most min value is 5</td></tr>
<tr><td><code>sql.distsql.sendopt</code></td><td>boolean</td><td><code>false</code></td><td>decode row and add row unsync</td></tr>
<tr><td><code>sql.distsql.serverzone</code></td><td>string</td><td><code>+08:00</code></td><td>record server zone</td></tr>
<tr><td><code>sql.distsql.temp_file.experimental</code></td><td>boolean</td><td><code>false</code></td><td>set to true to enable use of temp_file_store for distributed sql sorts or hash. but it's an experimental prod.</td></tr>
<tr><td><code>sql.distsql.temp_storage.joins</code></td><td>boolean</td><td><code>true</code></td><td>set to true to enable use of disk for distributed sql joins. Note that disabling this can have negative impact on memory usage and performance.</td></tr>
<tr><td><code>sql.distsql.temp_storage.sorts</code></td><td>boolean</td><td><code>true</code></td><td>set to true to enable use of disk for distributed sql sorts. Note that disabling this can have negative impact on memory usage and performance.</td></tr>
<tr><td><code>sql.distsql.temp_storage.workmem</code></td><td>byte size</td><td><code>64 MiB</code></td><td>maximum amount of memory in bytes a processor can use before falling back to temp storage</td></tr>
<tr><td><code>sql.metrics.statement_details.dump_to_logs</code></td><td>boolean</td><td><code>false</code></td><td>dump collected statement statistics to node logs when periodically cleared</td></tr>
<tr><td><code>sql.metrics.statement_details.enabled</code></td><td>boolean</td><td><code>true</code></td><td>collect per-statement query statistics</td></tr>
<tr><td><code>sql.metrics.statement_details.plan_collection.enabled</code></td><td>boolean</td><td><code>true</code></td><td>periodically save a logical plan for each fingerprint</td></tr>
<tr><td><code>sql.metrics.statement_details.plan_collection.period</code></td><td>duration</td><td><code>5m0s</code></td><td>the time until a new logical plan is collected</td></tr>
<tr><td><code>sql.metrics.statement_details.threshold</code></td><td>duration</td><td><code>0s</code></td><td>minimum execution time to cause statistics to be collected</td></tr>
<tr><td><code>sql.notices.enabled</code></td><td>boolean</td><td><code>true</code></td><td>enable notices in the server/client protocol being sent</td></tr>
<tr><td><code>sql.opt.operator.aggregator</code></td><td>boolean</td><td><code>false</code></td><td>for tablereader parallel and unsync</td></tr>
<tr><td><code>sql.opt.operator.aggregator.parallelnum</code></td><td>integer</td><td><code>4</code></td><td>for tablereader parallel nums,max 8</td></tr>
<tr><td><code>sql.opt.operator.distributedbatch</code></td><td>boolean</td><td><code>false</code></td><td>for distributedbatch</td></tr>
<tr><td><code>sql.opt.operator.distributedbatch.parallelnum</code></td><td>integer</td><td><code>4</code></td><td>for distributedbatch parallel nums</td></tr>
<tr><td><code>sql.opt.operator.hashjoiner</code></td><td>boolean</td><td><code>false</code></td><td>for hashjoin opt</td></tr>
<tr><td><code>sql.opt.operator.hashjoiner.parallelnum</code></td><td>integer</td><td><code>4</code></td><td>for hashjoin woker nums, max 32</td></tr>
<tr><td><code>sql.opt.operator.hashjoiner.replicatable.enabled</code></td><td>boolean</td><td><code>true</code></td><td>for replication table hashjoin</td></tr>
<tr><td><code>sql.opt.operator.sorter</code></td><td>boolean</td><td><code>false</code></td><td>for sort opt</td></tr>
<tr><td><code>sql.opt.operator.sorter.parallelnum</code></td><td>integer</td><td><code>2</code></td><td>for sort nums</td></tr>
<tr><td><code>sql.opt.operator.tablereader</code></td><td>boolean</td><td><code>false</code></td><td>for tablereader parallel and unsync</td></tr>
<tr><td><code>sql.opt.operator.tablereader.parallelnum</code></td><td>integer</td><td><code>4</code></td><td>for tablereader parallel nums,max 32</td></tr>
<tr><td><code>sql.opt.optbuilder.startwith.enabled</code></td><td>boolean</td><td><code>false</code></td><td>if set, enable Oracle's Recursive function</td></tr>
<tr><td><code>sql.parallel_scans.enabled</code></td><td>boolean</td><td><code>true</code></td><td>parallelizes scanning different ranges when the maximum result size can be deduced</td></tr>
<tr><td><code>sql.query_cache.enabled</code></td><td>boolean</td><td><code>true</code></td><td>enable the query cache</td></tr>
<tr><td><code>sql.stats.automatic_collection.enabled</code></td><td>boolean</td><td><code>true</code></td><td>automatic statistics collection mode</td></tr>
<tr><td><code>sql.stats.automatic_collection.fraction_stale_rows</code></td><td>float</td><td><code>0.2</code></td><td>target fraction of stale rows per table that will trigger a statistics refresh</td></tr>
<tr><td><code>sql.stats.automatic_collection.max_fraction_idle</code></td><td>float</td><td><code>0.9</code></td><td>maximum fraction of time that automatic statistics sampler processors are idle</td></tr>
<tr><td><code>sql.stats.automatic_collection.min_stale_rows</code></td><td>integer</td><td><code>500</code></td><td>target minimum number of stale rows per table that will trigger a statistics refresh</td></tr>
<tr><td><code>sql.stats.histogram_collection.enabled</code></td><td>boolean</td><td><code>false</code></td><td>histogram collection mode</td></tr>
<tr><td><code>sql.stats.post_events.enabled</code></td><td>boolean</td><td><code>false</code></td><td>if set, an event is shown for every CREATE STATISTICS job</td></tr>
<tr><td><code>sql.status.check_stat_time.enabled</code></td><td>boolean</td><td><code>true</code></td><td>check stats expired time</td></tr>
<tr><td><code>sql.tablecache.lease.refresh_limit</code></td><td>integer</td><td><code>50</code></td><td>maximum number of tables to periodically refresh leases for</td></tr>
<tr><td><code>sql.trace.log_statement_execute</code></td><td>boolean</td><td><code>false</code></td><td>set to true to enable logging of executed statements</td></tr>
<tr><td><code>sql.trace.session_eventlog.enabled</code></td><td>boolean</td><td><code>false</code></td><td>set to true to enable session tracing</td></tr>
<tr><td><code>sql.trace.txn.enable_threshold</code></td><td>duration</td><td><code>0s</code></td><td>duration beyond which all transactions are traced (set to 0 to disable)</td></tr>
<tr><td><code>timeseries.storage.enabled</code></td><td>boolean</td><td><code>true</code></td><td>if set, periodic timeseries data is stored within the cluster; disabling is not recommended unless you are storing the data elsewhere</td></tr>
<tr><td><code>timeseries.storage.resolution_10s.ttl</code></td><td>duration</td><td><code>240h0m0s</code></td><td>the maximum age of time series data stored at the 10 second resolution. Data older than this is subject to rollup and deletion.</td></tr>
<tr><td><code>timeseries.storage.resolution_30m.ttl</code></td><td>duration</td><td><code>2160h0m0s</code></td><td>the maximum age of time series data stored at the 30 minute resolution. Data older than this is subject to deletion.</td></tr>
<tr><td><code>trace.debug.enable</code></td><td>boolean</td><td><code>false</code></td><td>if set, traces for recent requests can be seen in the /debug page</td></tr>
<tr><td><code>trace.lightstep.token</code></td><td>string</td><td><code></code></td><td>if set, traces go to Lightstep using this token</td></tr>
<tr><td><code>trace.zipkin.collector</code></td><td>string</td><td><code></code></td><td>if set, traces go to the given Zipkin instance (example: '127.0.0.1:9411'); ignored if trace.lightstep.token is set</td></tr>
<tr><td><code>version</code></td><td>custom validation</td><td><code>19.1-10</code></td><td>set the active cluster version in the format '<major>.<minor>'</td></tr>
</tbody>
</table>
