// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sql/sqlbase/structured.proto

package sqlbase

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import roachpb "github.com/znbasedb/znbase/pkg/roachpb"
import hlc "github.com/znbasedb/znbase/pkg/util/hlc"

import github_com_znbasedb_znbase_pkg_roachpb "github.com/znbasedb/znbase/pkg/roachpb"
import github_com_lib_pq_oid "github.com/lib/pq/oid"

import bytes "bytes"

import github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"

import io "io"

import github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type ConstraintValidity int32

const (
	// The constraint is valid for all rows.
	ConstraintValidity_Validated ConstraintValidity = 0
	// The constraint has not yet been validated for all rows (and will not be
	// validated until VALIDATE CONSTRAINT is used).
	ConstraintValidity_Unvalidated ConstraintValidity = 1
	// The constraint was just added, but the validation for existing rows is not
	// yet complete. If validation fails, the constraint will be dropped.
	ConstraintValidity_Validating ConstraintValidity = 2
	// The constraint is being dropped in the schema changer.
	ConstraintValidity_Dropping ConstraintValidity = 3
)

var ConstraintValidity_name = map[int32]string{
	0: "Validated",
	1: "Unvalidated",
	2: "Validating",
	3: "Dropping",
}
var ConstraintValidity_value = map[string]int32{
	"Validated":   0,
	"Unvalidated": 1,
	"Validating":  2,
	"Dropping":    3,
}

func (x ConstraintValidity) Enum() *ConstraintValidity {
	p := new(ConstraintValidity)
	*p = x
	return p
}
func (x ConstraintValidity) String() string {
	return proto.EnumName(ConstraintValidity_name, int32(x))
}
func (x *ConstraintValidity) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConstraintValidity_value, data, "ConstraintValidity")
	if err != nil {
		return err
	}
	*x = ConstraintValidity(value)
	return nil
}
func (ConstraintValidity) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{0}
}

// These mirror the types supported by sql/coltypes.
//
// Note: when adding constants to this list or renaming constants,
// verify with PostgreSQL what the type name should be in
// information_schema.columns.data_type, and modify
// (*ColumnType).InformationSchemaVisibleType() accordingly.
//
type ColumnType_SemanticType int32

const (
	ColumnType_BOOL           ColumnType_SemanticType = 0
	ColumnType_INT            ColumnType_SemanticType = 1
	ColumnType_FLOAT          ColumnType_SemanticType = 2
	ColumnType_DECIMAL        ColumnType_SemanticType = 3
	ColumnType_DATE           ColumnType_SemanticType = 4
	ColumnType_TIMESTAMP      ColumnType_SemanticType = 5
	ColumnType_INTERVAL       ColumnType_SemanticType = 6
	ColumnType_STRING         ColumnType_SemanticType = 7
	ColumnType_BYTES          ColumnType_SemanticType = 8
	ColumnType_TIMESTAMPTZ    ColumnType_SemanticType = 9
	ColumnType_COLLATEDSTRING ColumnType_SemanticType = 10
	ColumnType_NAME           ColumnType_SemanticType = 11
	ColumnType_OID            ColumnType_SemanticType = 12
	// NULL is not supported as a table column type, however it can be
	// transferred through distsql streams.
	ColumnType_NULL       ColumnType_SemanticType = 13
	ColumnType_UUID       ColumnType_SemanticType = 14
	ColumnType_ARRAY      ColumnType_SemanticType = 15
	ColumnType_INET       ColumnType_SemanticType = 16
	ColumnType_TIME       ColumnType_SemanticType = 17
	ColumnType_JSONB      ColumnType_SemanticType = 18
	ColumnType_TUPLE      ColumnType_SemanticType = 20
	ColumnType_BIT        ColumnType_SemanticType = 21
	ColumnType_INT2VECTOR ColumnType_SemanticType = 200
	ColumnType_OIDVECTOR  ColumnType_SemanticType = 201
	ColumnType_ENUM       ColumnType_SemanticType = 202
	ColumnType_SET        ColumnType_SemanticType = 203
)

var ColumnType_SemanticType_name = map[int32]string{
	0:   "BOOL",
	1:   "INT",
	2:   "FLOAT",
	3:   "DECIMAL",
	4:   "DATE",
	5:   "TIMESTAMP",
	6:   "INTERVAL",
	7:   "STRING",
	8:   "BYTES",
	9:   "TIMESTAMPTZ",
	10:  "COLLATEDSTRING",
	11:  "NAME",
	12:  "OID",
	13:  "NULL",
	14:  "UUID",
	15:  "ARRAY",
	16:  "INET",
	17:  "TIME",
	18:  "JSONB",
	20:  "TUPLE",
	21:  "BIT",
	200: "INT2VECTOR",
	201: "OIDVECTOR",
	202: "ENUM",
	203: "SET",
}
var ColumnType_SemanticType_value = map[string]int32{
	"BOOL":           0,
	"INT":            1,
	"FLOAT":          2,
	"DECIMAL":        3,
	"DATE":           4,
	"TIMESTAMP":      5,
	"INTERVAL":       6,
	"STRING":         7,
	"BYTES":          8,
	"TIMESTAMPTZ":    9,
	"COLLATEDSTRING": 10,
	"NAME":           11,
	"OID":            12,
	"NULL":           13,
	"UUID":           14,
	"ARRAY":          15,
	"INET":           16,
	"TIME":           17,
	"JSONB":          18,
	"TUPLE":          20,
	"BIT":            21,
	"INT2VECTOR":     200,
	"OIDVECTOR":      201,
	"ENUM":           202,
	"SET":            203,
}

func (x ColumnType_SemanticType) Enum() *ColumnType_SemanticType {
	p := new(ColumnType_SemanticType)
	*p = x
	return p
}
func (x ColumnType_SemanticType) String() string {
	return proto.EnumName(ColumnType_SemanticType_name, int32(x))
}
func (x *ColumnType_SemanticType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ColumnType_SemanticType_value, data, "ColumnType_SemanticType")
	if err != nil {
		return err
	}
	*x = ColumnType_SemanticType(value)
	return nil
}
func (ColumnType_SemanticType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{0, 0}
}

type ColumnType_VisibleType int32

const (
	ColumnType_NONE             ColumnType_VisibleType = 0
	ColumnType_INTEGER          ColumnType_VisibleType = 1
	ColumnType_SMALLINT         ColumnType_VisibleType = 2
	ColumnType_BIGINT           ColumnType_VisibleType = 3
	ColumnType_REAL             ColumnType_VisibleType = 5
	ColumnType_DOUBLE_PRECISION ColumnType_VisibleType = 6
	ColumnType_VARCHAR          ColumnType_VisibleType = 7
	ColumnType_CHAR             ColumnType_VisibleType = 8
	ColumnType_QCHAR            ColumnType_VisibleType = 9
	ColumnType_VARBIT           ColumnType_VisibleType = 10
	ColumnType_TIMESTAMPP       ColumnType_VisibleType = 11
)

var ColumnType_VisibleType_name = map[int32]string{
	0:  "NONE",
	1:  "INTEGER",
	2:  "SMALLINT",
	3:  "BIGINT",
	5:  "REAL",
	6:  "DOUBLE_PRECISION",
	7:  "VARCHAR",
	8:  "CHAR",
	9:  "QCHAR",
	10: "VARBIT",
	11: "TIMESTAMPP",
}
var ColumnType_VisibleType_value = map[string]int32{
	"NONE":             0,
	"INTEGER":          1,
	"SMALLINT":         2,
	"BIGINT":           3,
	"REAL":             5,
	"DOUBLE_PRECISION": 6,
	"VARCHAR":          7,
	"CHAR":             8,
	"QCHAR":            9,
	"VARBIT":           10,
	"TIMESTAMPP":       11,
}

func (x ColumnType_VisibleType) Enum() *ColumnType_VisibleType {
	p := new(ColumnType_VisibleType)
	*p = x
	return p
}
func (x ColumnType_VisibleType) String() string {
	return proto.EnumName(ColumnType_VisibleType_name, int32(x))
}
func (x *ColumnType_VisibleType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ColumnType_VisibleType_value, data, "ColumnType_VisibleType")
	if err != nil {
		return err
	}
	*x = ColumnType_VisibleType(value)
	return nil
}
func (ColumnType_VisibleType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{0, 1}
}

type ForeignKeyReference_Action int32

const (
	ForeignKeyReference_NO_ACTION   ForeignKeyReference_Action = 0
	ForeignKeyReference_RESTRICT    ForeignKeyReference_Action = 1
	ForeignKeyReference_SET_NULL    ForeignKeyReference_Action = 2
	ForeignKeyReference_SET_DEFAULT ForeignKeyReference_Action = 3
	ForeignKeyReference_CASCADE     ForeignKeyReference_Action = 4
)

var ForeignKeyReference_Action_name = map[int32]string{
	0: "NO_ACTION",
	1: "RESTRICT",
	2: "SET_NULL",
	3: "SET_DEFAULT",
	4: "CASCADE",
}
var ForeignKeyReference_Action_value = map[string]int32{
	"NO_ACTION":   0,
	"RESTRICT":    1,
	"SET_NULL":    2,
	"SET_DEFAULT": 3,
	"CASCADE":     4,
}

func (x ForeignKeyReference_Action) Enum() *ForeignKeyReference_Action {
	p := new(ForeignKeyReference_Action)
	*p = x
	return p
}
func (x ForeignKeyReference_Action) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(ForeignKeyReference_Action_name, int32(x))
}
func (x *ForeignKeyReference_Action) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ForeignKeyReference_Action_value, data, "ForeignKeyReference_Action")
	if err != nil {
		return err
	}
	*x = ForeignKeyReference_Action(value)
	return nil
}
func (ForeignKeyReference_Action) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{1, 0}
}

// Match is the algorithm used to compare composite keys.
type ForeignKeyReference_Match int32

const (
	ForeignKeyReference_SIMPLE  ForeignKeyReference_Match = 0
	ForeignKeyReference_FULL    ForeignKeyReference_Match = 1
	ForeignKeyReference_PARTIAL ForeignKeyReference_Match = 2
)

var ForeignKeyReference_Match_name = map[int32]string{
	0: "SIMPLE",
	1: "FULL",
	2: "PARTIAL",
}
var ForeignKeyReference_Match_value = map[string]int32{
	"SIMPLE":  0,
	"FULL":    1,
	"PARTIAL": 2,
}

func (x ForeignKeyReference_Match) Enum() *ForeignKeyReference_Match {
	p := new(ForeignKeyReference_Match)
	*p = x
	return p
}
func (x ForeignKeyReference_Match) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(ForeignKeyReference_Match_name, int32(x))
}
func (x *ForeignKeyReference_Match) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ForeignKeyReference_Match_value, data, "ForeignKeyReference_Match")
	if err != nil {
		return err
	}
	*x = ForeignKeyReference_Match(value)
	return nil
}
func (ForeignKeyReference_Match) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{1, 1}
}

// The direction of a column in the index.
type IndexDescriptor_Direction int32

const (
	IndexDescriptor_ASC  IndexDescriptor_Direction = 0
	IndexDescriptor_DESC IndexDescriptor_Direction = 1
)

var IndexDescriptor_Direction_name = map[int32]string{
	0: "ASC",
	1: "DESC",
}
var IndexDescriptor_Direction_value = map[string]int32{
	"ASC":  0,
	"DESC": 1,
}

func (x IndexDescriptor_Direction) Enum() *IndexDescriptor_Direction {
	p := new(IndexDescriptor_Direction)
	*p = x
	return p
}
func (x IndexDescriptor_Direction) String() string {
	return proto.EnumName(IndexDescriptor_Direction_name, int32(x))
}
func (x *IndexDescriptor_Direction) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(IndexDescriptor_Direction_value, data, "IndexDescriptor_Direction")
	if err != nil {
		return err
	}
	*x = IndexDescriptor_Direction(value)
	return nil
}
func (IndexDescriptor_Direction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{7, 0}
}

// The direction of a column in the index.
type IndexDescriptor_Type int32

const (
	IndexDescriptor_FORWARD  IndexDescriptor_Type = 0
	IndexDescriptor_INVERTED IndexDescriptor_Type = 1
)

var IndexDescriptor_Type_name = map[int32]string{
	0: "FORWARD",
	1: "INVERTED",
}
var IndexDescriptor_Type_value = map[string]int32{
	"FORWARD":  0,
	"INVERTED": 1,
}

func (x IndexDescriptor_Type) Enum() *IndexDescriptor_Type {
	p := new(IndexDescriptor_Type)
	*p = x
	return p
}
func (x IndexDescriptor_Type) String() string {
	return proto.EnumName(IndexDescriptor_Type_name, int32(x))
}
func (x *IndexDescriptor_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(IndexDescriptor_Type_value, data, "IndexDescriptor_Type")
	if err != nil {
		return err
	}
	*x = IndexDescriptor_Type(value)
	return nil
}
func (IndexDescriptor_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{7, 1}
}

type ConstraintToUpdate_ConstraintType int32

const (
	ConstraintToUpdate_CHECK       ConstraintToUpdate_ConstraintType = 0
	ConstraintToUpdate_FOREIGN_KEY ConstraintToUpdate_ConstraintType = 1
	// NOT NULL constraints being added are represented by a dummy check
	// constraint so that a multi-state schema change, including a bulk
	// validation step, can occur. The check field contains the dummy
	// constraint.
	ConstraintToUpdate_NOT_NULL ConstraintToUpdate_ConstraintType = 2
)

var ConstraintToUpdate_ConstraintType_name = map[int32]string{
	0: "CHECK",
	1: "FOREIGN_KEY",
	2: "NOT_NULL",
}
var ConstraintToUpdate_ConstraintType_value = map[string]int32{
	"CHECK":       0,
	"FOREIGN_KEY": 1,
	"NOT_NULL":    2,
}

func (x ConstraintToUpdate_ConstraintType) Enum() *ConstraintToUpdate_ConstraintType {
	p := new(ConstraintToUpdate_ConstraintType)
	*p = x
	return p
}
func (x ConstraintToUpdate_ConstraintType) String() string {
	return proto.EnumName(ConstraintToUpdate_ConstraintType_name, int32(x))
}
func (x *ConstraintToUpdate_ConstraintType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConstraintToUpdate_ConstraintType_value, data, "ConstraintToUpdate_ConstraintType")
	if err != nil {
		return err
	}
	*x = ConstraintToUpdate_ConstraintType(value)
	return nil
}
func (ConstraintToUpdate_ConstraintType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{8, 0}
}

// A descriptor within a mutation is unavailable for reads, writes
// and deletes. It is only available for implicit (internal to
// the database) writes and deletes depending on the state of the mutation.
type DescriptorMutation_State int32

const (
	// Not used.
	DescriptorMutation_UNKNOWN DescriptorMutation_State = 0
	// Operations can use this invisible descriptor to implicitly
	// delete entries.
	// Column: A descriptor in this state is invisible to
	// INSERT and UPDATE. DELETE must delete a column in this state.
	// Index: A descriptor in this state is invisible to an INSERT.
	// UPDATE must delete the old value of the index but doesn't write
	// the new value. DELETE must delete the index.
	//
	// When deleting a descriptor, all descriptor related data
	// (column or index data) can only be mass deleted once
	// all the nodes have transitioned to the DELETE_ONLY state.
	DescriptorMutation_DELETE_ONLY DescriptorMutation_State = 1
	// Operations can use this invisible descriptor to implicitly
	// write and delete entries.
	// Column: INSERT will populate this column with the default
	// value. UPDATE ignores this descriptor. DELETE must delete
	// the column.
	// Index: INSERT, UPDATE and DELETE treat this index like any
	// other index.
	//
	// When adding a descriptor, all descriptor related data
	// (column default or index data) can only be backfilled once
	// all nodes have transitioned into the DELETE_AND_WRITE_ONLY state.
	DescriptorMutation_DELETE_AND_WRITE_ONLY DescriptorMutation_State = 2
)

var DescriptorMutation_State_name = map[int32]string{
	0: "UNKNOWN",
	1: "DELETE_ONLY",
	2: "DELETE_AND_WRITE_ONLY",
}
var DescriptorMutation_State_value = map[string]int32{
	"UNKNOWN":               0,
	"DELETE_ONLY":           1,
	"DELETE_AND_WRITE_ONLY": 2,
}

func (x DescriptorMutation_State) Enum() *DescriptorMutation_State {
	p := new(DescriptorMutation_State)
	*p = x
	return p
}
func (x DescriptorMutation_State) String() string {
	return proto.EnumName(DescriptorMutation_State_name, int32(x))
}
func (x *DescriptorMutation_State) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DescriptorMutation_State_value, data, "DescriptorMutation_State")
	if err != nil {
		return err
	}
	*x = DescriptorMutation_State(value)
	return nil
}
func (DescriptorMutation_State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{11, 0}
}

// Direction of mutation.
type DescriptorMutation_Direction int32

const (
	// Not used.
	DescriptorMutation_NONE DescriptorMutation_Direction = 0
	// Descriptor is being added.
	DescriptorMutation_ADD DescriptorMutation_Direction = 1
	// Descriptor is being dropped.
	DescriptorMutation_DROP DescriptorMutation_Direction = 2
)

var DescriptorMutation_Direction_name = map[int32]string{
	0: "NONE",
	1: "ADD",
	2: "DROP",
}
var DescriptorMutation_Direction_value = map[string]int32{
	"NONE": 0,
	"ADD":  1,
	"DROP": 2,
}

func (x DescriptorMutation_Direction) Enum() *DescriptorMutation_Direction {
	p := new(DescriptorMutation_Direction)
	*p = x
	return p
}
func (x DescriptorMutation_Direction) String() string {
	return proto.EnumName(DescriptorMutation_Direction_name, int32(x))
}
func (x *DescriptorMutation_Direction) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DescriptorMutation_Direction_value, data, "DescriptorMutation_Direction")
	if err != nil {
		return err
	}
	*x = DescriptorMutation_Direction(value)
	return nil
}
func (DescriptorMutation_Direction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{11, 1}
}

// State is set if this TableDescriptor is in the process of being added or deleted.
// A non-public table descriptor cannot be leased.
// A schema changer observing DROP set will truncate the table and delete the
// descriptor.
// It is illegal to transition DROP to any other state.
type TableDescriptor_State int32

const (
	// Not used.
	TableDescriptor_PUBLIC TableDescriptor_State = 0
	// Descriptor is being added.
	TableDescriptor_ADD TableDescriptor_State = 1
	// Descriptor is being dropped.
	TableDescriptor_DROP TableDescriptor_State = 2
	// Descriptor is offline (e.g. for bulk-ingestion). See offline_reason.
	TableDescriptor_OFFLINE TableDescriptor_State = 3
)

var TableDescriptor_State_name = map[int32]string{
	0: "PUBLIC",
	1: "ADD",
	2: "DROP",
	3: "OFFLINE",
}
var TableDescriptor_State_value = map[string]int32{
	"PUBLIC":  0,
	"ADD":     1,
	"DROP":    2,
	"OFFLINE": 3,
}

func (x TableDescriptor_State) Enum() *TableDescriptor_State {
	p := new(TableDescriptor_State)
	*p = x
	return p
}
func (x TableDescriptor_State) String() string {
	return proto.EnumName(TableDescriptor_State_name, int32(x))
}
func (x *TableDescriptor_State) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TableDescriptor_State_value, data, "TableDescriptor_State")
	if err != nil {
		return err
	}
	*x = TableDescriptor_State(value)
	return nil
}
func (TableDescriptor_State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{12, 0}
}

// AuditMode indicates which auditing actions to take when this table is used.
type TableDescriptor_AuditMode int32

const (
	TableDescriptor_DISABLED  TableDescriptor_AuditMode = 0
	TableDescriptor_READWRITE TableDescriptor_AuditMode = 1
)

var TableDescriptor_AuditMode_name = map[int32]string{
	0: "DISABLED",
	1: "READWRITE",
}
var TableDescriptor_AuditMode_value = map[string]int32{
	"DISABLED":  0,
	"READWRITE": 1,
}

func (x TableDescriptor_AuditMode) Enum() *TableDescriptor_AuditMode {
	p := new(TableDescriptor_AuditMode)
	*p = x
	return p
}
func (x TableDescriptor_AuditMode) String() string {
	return proto.EnumName(TableDescriptor_AuditMode_name, int32(x))
}
func (x *TableDescriptor_AuditMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TableDescriptor_AuditMode_value, data, "TableDescriptor_AuditMode")
	if err != nil {
		return err
	}
	*x = TableDescriptor_AuditMode(value)
	return nil
}
func (TableDescriptor_AuditMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{12, 1}
}

type FunctionTriggerType_Match int32

const (
	FunctionTriggerType_DML_TRIGGER   FunctionTriggerType_Match = 0
	FunctionTriggerType_EVENT_TRIGGER FunctionTriggerType_Match = 1
	FunctionTriggerType_NOT_TRIGGER   FunctionTriggerType_Match = 2
)

var FunctionTriggerType_Match_name = map[int32]string{
	0: "DML_TRIGGER",
	1: "EVENT_TRIGGER",
	2: "NOT_TRIGGER",
}
var FunctionTriggerType_Match_value = map[string]int32{
	"DML_TRIGGER":   0,
	"EVENT_TRIGGER": 1,
	"NOT_TRIGGER":   2,
}

func (x FunctionTriggerType_Match) Enum() *FunctionTriggerType_Match {
	p := new(FunctionTriggerType_Match)
	*p = x
	return p
}
func (x FunctionTriggerType_Match) String() string {
	return proto.EnumName(FunctionTriggerType_Match_name, int32(x))
}
func (x *FunctionTriggerType_Match) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(FunctionTriggerType_Match_value, data, "FunctionTriggerType_Match")
	if err != nil {
		return err
	}
	*x = FunctionTriggerType_Match(value)
	return nil
}
func (FunctionTriggerType_Match) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{16, 0}
}

// State is set if this FunctionDescriptor is in the process of being added or deleted.
// A non-public function descriptor cannot be leased.
// A schema changer observing DROP set will truncate the function and delete the
// descriptor.
// It is illegal to transition DROP to any other state.
type FunctionDescriptor_State int32

const (
	// Not used.
	FunctionDescriptor_PUBLIC FunctionDescriptor_State = 0
	// Descriptor is being added.
	FunctionDescriptor_ADD FunctionDescriptor_State = 1
	// Descriptor is being dropped.
	FunctionDescriptor_DROP FunctionDescriptor_State = 2
	// Descriptor is being MODIFIED.
	FunctionDescriptor_MODIFY FunctionDescriptor_State = 3
)

var FunctionDescriptor_State_name = map[int32]string{
	0: "PUBLIC",
	1: "ADD",
	2: "DROP",
	3: "MODIFY",
}
var FunctionDescriptor_State_value = map[string]int32{
	"PUBLIC": 0,
	"ADD":    1,
	"DROP":   2,
	"MODIFY": 3,
}

func (x FunctionDescriptor_State) Enum() *FunctionDescriptor_State {
	p := new(FunctionDescriptor_State)
	*p = x
	return p
}
func (x FunctionDescriptor_State) String() string {
	return proto.EnumName(FunctionDescriptor_State_name, int32(x))
}
func (x *FunctionDescriptor_State) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(FunctionDescriptor_State_value, data, "FunctionDescriptor_State")
	if err != nil {
		return err
	}
	*x = FunctionDescriptor_State(value)
	return nil
}
func (FunctionDescriptor_State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{18, 0}
}

type ColumnType struct {
	SemanticType ColumnType_SemanticType `protobuf:"varint,1,opt,name=semantic_type,json=semanticType,enum=znbase.sql.sqlbase.ColumnType_SemanticType" json:"semantic_type"`
	// INT, DECIMAL, CHAR and BINARY
	Width int32 `protobuf:"varint,2,opt,name=width" json:"width"`
	// DECIMAL
	// Also FLOAT pre-2.1 (this was incorrect.)
	Precision int32 `protobuf:"varint,3,opt,name=precision" json:"precision"`
	// The length of each dimension in the array. A dimension of -1 means that
	// no bound was specified for that dimension.
	ArrayDimensions []int32 `protobuf:"varint,4,rep,name=array_dimensions,json=arrayDimensions" json:"array_dimensions,omitempty"`
	// Collated STRING, CHAR, and VARCHAR
	Locale *string `protobuf:"bytes,5,opt,name=locale" json:"locale,omitempty"`
	// Alias for any types where our internal representation is different than
	// the user specification. Examples are INT4, FLOAT4, etc. Mostly for Postgres
	// compatibility.
	VisibleType ColumnType_VisibleType `protobuf:"varint,6,opt,name=visible_type,json=visibleType,enum=znbase.sql.sqlbase.ColumnType_VisibleType" json:"visible_type"`
	// Only used if the kind is ARRAY.
	ArrayContents *ColumnType_SemanticType `protobuf:"varint,7,opt,name=array_contents,json=arrayContents,enum=znbase.sql.sqlbase.ColumnType_SemanticType" json:"array_contents,omitempty"`
	// Only used if the kind is TUPLE
	TupleContents   []ColumnType `protobuf:"bytes,8,rep,name=tuple_contents,json=tupleContents" json:"tuple_contents"`
	TupleLabels     []string     `protobuf:"bytes,9,rep,name=tuple_labels,json=tupleLabels" json:"tuple_labels,omitempty"`
	VisibleTypeName string       `protobuf:"bytes,10,opt,name=VisibleTypeName" json:"VisibleTypeName"`
	EnumContents    []string     `protobuf:"bytes,11,rep,name=enum_contents,json=enumContents" json:"enum_contents,omitempty"`
	SetContents     []string     `protobuf:"bytes,12,rep,name=set_contents,json=setContents" json:"set_contents,omitempty"`
}

func (m *ColumnType) Reset()         { *m = ColumnType{} }
func (m *ColumnType) String() string { return proto.CompactTextString(m) }
func (*ColumnType) ProtoMessage()    {}
func (*ColumnType) Descriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{0}
}
func (m *ColumnType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ColumnType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnType.Merge(dst, src)
}
func (m *ColumnType) XXX_Size() int {
	return m.Size()
}
func (m *ColumnType) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnType.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnType proto.InternalMessageInfo

type ForeignKeyReference struct {
	Table    ID                 `protobuf:"varint,1,opt,name=table,casttype=ID" json:"table"`
	Index    IndexID            `protobuf:"varint,2,opt,name=index,casttype=IndexID" json:"index"`
	Name     string             `protobuf:"bytes,3,opt,name=name" json:"name"`
	Validity ConstraintValidity `protobuf:"varint,4,opt,name=validity,enum=znbase.sql.sqlbase.ConstraintValidity" json:"validity"`
	// If this FK only uses a prefix of the columns in its index, we record how
	// many to avoid spuriously counting the additional cols as used by this FK.
	SharedPrefixLen int32                      `protobuf:"varint,5,opt,name=shared_prefix_len,json=sharedPrefixLen" json:"shared_prefix_len"`
	OnDelete        ForeignKeyReference_Action `protobuf:"varint,6,opt,name=on_delete,json=onDelete,enum=znbase.sql.sqlbase.ForeignKeyReference_Action" json:"on_delete"`
	OnUpdate        ForeignKeyReference_Action `protobuf:"varint,7,opt,name=on_update,json=onUpdate,enum=znbase.sql.sqlbase.ForeignKeyReference_Action" json:"on_update"`
	// This is only important for composite keys. For all prior matches before
	// the addition of this value, MATCH SIMPLE will be used.
	Match ForeignKeyReference_Match `protobuf:"varint,8,opt,name=match,enum=znbase.sql.sqlbase.ForeignKeyReference_Match" json:"match"`
}

func (m *ForeignKeyReference) Reset()         { *m = ForeignKeyReference{} }
func (m *ForeignKeyReference) String() string { return proto.CompactTextString(m) }
func (*ForeignKeyReference) ProtoMessage()    {}
func (*ForeignKeyReference) Descriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{1}
}
func (m *ForeignKeyReference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ForeignKeyReference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ForeignKeyReference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ForeignKeyReference.Merge(dst, src)
}
func (m *ForeignKeyReference) XXX_Size() int {
	return m.Size()
}
func (m *ForeignKeyReference) XXX_DiscardUnknown() {
	xxx_messageInfo_ForeignKeyReference.DiscardUnknown(m)
}

var xxx_messageInfo_ForeignKeyReference proto.InternalMessageInfo

// ForeignKeyConstraint is the new (as of 19.2 and VersionTopLevelForeignKeys)
// representation for foreign keys. It's stored on the TableDescriptor and is
// designed to be agnostic to which indexes are available on both the origin
// and referenced tables, so that the optimizer can have full freedom to choose
// the best possible index to satisfy constraint checks at runtime.
type ForeignKeyConstraint struct {
	OriginTableID       ID                         `protobuf:"varint,1,opt,name=origin_table_id,json=originTableId,casttype=ID" json:"origin_table_id"`
	OriginColumnIDs     []ColumnID                 `protobuf:"varint,2,rep,name=origin_column_ids,json=originColumnIds,casttype=ColumnID" json:"origin_column_ids,omitempty"`
	ReferencedColumnIDs []ColumnID                 `protobuf:"varint,3,rep,name=referenced_column_ids,json=referencedColumnIds,casttype=ColumnID" json:"referenced_column_ids,omitempty"`
	ReferencedTableID   ID                         `protobuf:"varint,4,opt,name=referenced_table_id,json=referencedTableId,casttype=ID" json:"referenced_table_id"`
	Name                string                     `protobuf:"bytes,5,opt,name=name" json:"name"`
	Validity            ConstraintValidity         `protobuf:"varint,6,opt,name=validity,enum=znbase.sql.sqlbase.ConstraintValidity" json:"validity"`
	OnDelete            ForeignKeyReference_Action `protobuf:"varint,7,opt,name=on_delete,json=onDelete,enum=znbase.sql.sqlbase.ForeignKeyReference_Action" json:"on_delete"`
	OnUpdate            ForeignKeyReference_Action `protobuf:"varint,8,opt,name=on_update,json=onUpdate,enum=znbase.sql.sqlbase.ForeignKeyReference_Action" json:"on_update"`
	// This is only important for composite keys. For all prior matches before
	// the addition of this value, MATCH SIMPLE will be used.
	Match ForeignKeyReference_Match `protobuf:"varint,9,opt,name=match,enum=znbase.sql.sqlbase.ForeignKeyReference_Match" json:"match"`
	// LegacyOriginIndex is the ID of the index used for the FK on the origin
	// table. In versions 19.1 and earlier, foreign keys were represented by
	// fields on the index that they use. In versions 19.2 and later, we preserve
	// the semantics of the older FKs which were tied to indexes by specifying
	// the index as a field on this proto, since the migration process to have
	// top-level FK fields on the table descriptor requires two releases. In 20.1,
	// when all 19.2 nodes will be correctly handling the new FK representation,
	// we will perform a migration to upgrade all table descriptors.
	LegacyOriginIndex IndexID `protobuf:"varint,10,opt,name=legacy_origin_index,json=legacyOriginIndex,casttype=IndexID" json:"legacy_origin_index"`
	// LegacyReferencedIndex is the ID of the index used for the FK on the
	// referenced side. See the comment for LegacyOriginIndex.
	LegacyReferencedIndex IndexID `protobuf:"varint,11,opt,name=legacy_referenced_index,json=legacyReferencedIndex,casttype=IndexID" json:"legacy_referenced_index"`
	// These fields are set when upgrading an old-style FK (stored on the index)
	// into this kind. The purpose is to permit validation that downgrading this
	// representation to the old representation (which happens when the cluster
	// is in a mixed-version state containing VersionTopLevelForeignKeys) was done
	// without creating any accidental changes to the foreign key references.
	// They are only read and written in a mixed 19.1/19.2 cluster.
	LegacyUpgradedFromOriginReference     ForeignKeyReference `protobuf:"bytes,12,opt,name=legacy_upgraded_from_origin_reference,json=legacyUpgradedFromOriginReference" json:"legacy_upgraded_from_origin_reference"`             // Deprecated: Do not use.
	LegacyUpgradedFromReferencedReference ForeignKeyReference `protobuf:"bytes,13,opt,name=legacy_upgraded_from_referenced_reference,json=legacyUpgradedFromReferencedReference" json:"legacy_upgraded_from_referenced_reference"` // Deprecated: Do not use.
}

func (m *ForeignKeyConstraint) Reset()         { *m = ForeignKeyConstraint{} }
func (m *ForeignKeyConstraint) String() string { return proto.CompactTextString(m) }
func (*ForeignKeyConstraint) ProtoMessage()    {}
func (*ForeignKeyConstraint) Descriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{2}
}
func (m *ForeignKeyConstraint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ForeignKeyConstraint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ForeignKeyConstraint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ForeignKeyConstraint.Merge(dst, src)
}
func (m *ForeignKeyConstraint) XXX_Size() int {
	return m.Size()
}
func (m *ForeignKeyConstraint) XXX_DiscardUnknown() {
	xxx_messageInfo_ForeignKeyConstraint.DiscardUnknown(m)
}

var xxx_messageInfo_ForeignKeyConstraint proto.InternalMessageInfo

type ColumnDescriptor struct {
	Name     string     `protobuf:"bytes,1,opt,name=name" json:"name"`
	ID       ColumnID   `protobuf:"varint,2,opt,name=id,casttype=ColumnID" json:"id"`
	Type     ColumnType `protobuf:"bytes,3,opt,name=type" json:"type"`
	Nullable bool       `protobuf:"varint,4,opt,name=nullable" json:"nullable"`
	// Default expression to use to populate the column on insert if no
	// value is provided.
	DefaultExpr *string `protobuf:"bytes,5,opt,name=default_expr,json=defaultExpr" json:"default_expr,omitempty"`
	Hidden      bool    `protobuf:"varint,6,opt,name=hidden" json:"hidden"`
	// Ids of sequences used in this column's DEFAULT expression, in calls to nextval().
	UsesSequenceIds []ID `protobuf:"varint,10,rep,name=uses_sequence_ids,json=usesSequenceIds,casttype=ID" json:"uses_sequence_ids,omitempty"`
	// Expression to use to compute the value of this column if this is a
	// computed column.
	ComputeExpr              *string `protobuf:"bytes,11,opt,name=compute_expr,json=computeExpr" json:"compute_expr,omitempty"`
	IsHashPartitionCol       bool    `protobuf:"varint,12,opt,name=is_hash,json=isHash" json:"is_hash"`
	Onupdatecurrenttimestamp bool    `protobuf:"varint,13,opt,name=onupdatecurrenttimestamp" json:"onupdatecurrenttimestamp"`
	InhCount                 uint32  `protobuf:"varint,14,opt,name=inh_count,json=inhCount" json:"inh_count"`
	IsInherits               bool    `protobuf:"varint,15,opt,name=is_inherits,json=isInherits" json:"is_inherits"`
	// method for the descriptorProto interface.
	Privileges *PrivilegeDescriptor `protobuf:"bytes,16,opt,name=privileges" json:"privileges,omitempty"`
	// ID of the parent table.
	ParentID ID `protobuf:"varint,17,opt,name=parent_id,json=parentId,casttype=ID" json:"parent_id"`
	// If this is a column of an Updatable View, updatableViewDependsColName will record the name of
	// column which it depends on.
	UpdatableViewDependsColName string `protobuf:"bytes,18,opt,name=updatableViewDependsColName" json:"updatableViewDependsColName"`
	// Ids of sequences that the column owns.
	OwnsSequenceIds []ID `protobuf:"varint,19,rep,name=owns_sequence_ids,json=ownsSequenceIds,casttype=ID" json:"owns_sequence_ids,omitempty"`
}

func (m *ColumnDescriptor) Reset()         { *m = ColumnDescriptor{} }
func (m *ColumnDescriptor) String() string { return proto.CompactTextString(m) }
func (*ColumnDescriptor) ProtoMessage()    {}
func (*ColumnDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{3}
}
func (m *ColumnDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ColumnDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnDescriptor.Merge(dst, src)
}
func (m *ColumnDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *ColumnDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnDescriptor proto.InternalMessageInfo

// ColumnFamilyDescriptor is set of columns stored together in one kv entry.
type ColumnFamilyDescriptor struct {
	Name string   `protobuf:"bytes,1,opt,name=name" json:"name"`
	ID   FamilyID `protobuf:"varint,2,opt,name=id,casttype=FamilyID" json:"id"`
	// A list of column names of which the family is comprised. This list
	// parallels the column_ids list. If duplicating the storage of the column
	// names here proves to be prohibitive, we could clear this field before
	// saving and reconstruct it after loading.
	ColumnNames []string `protobuf:"bytes,3,rep,name=column_names,json=columnNames" json:"column_names,omitempty"`
	// A list of column ids of which the family is comprised. This list parallels
	// the column_names list.
	ColumnIDs []ColumnID `protobuf:"varint,4,rep,name=column_ids,json=columnIds,casttype=ColumnID" json:"column_ids,omitempty"`
	// If nonzero, the column involved in the single column optimization.
	//
	// Families store columns in a ValueType_TUPLE as repeated <columnID><data>
	// entries. As a space optimization and for backward compatibility, a single
	// column is written without the column id prefix. Because more columns could
	// be added, it would be ambiguous which column was stored when read back in,
	// so this field supplies it.
	DefaultColumnID ColumnID `protobuf:"varint,5,opt,name=default_column_id,json=defaultColumnId,casttype=ColumnID" json:"default_column_id"`
}

func (m *ColumnFamilyDescriptor) Reset()         { *m = ColumnFamilyDescriptor{} }
func (m *ColumnFamilyDescriptor) String() string { return proto.CompactTextString(m) }
func (*ColumnFamilyDescriptor) ProtoMessage()    {}
func (*ColumnFamilyDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{4}
}
func (m *ColumnFamilyDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnFamilyDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ColumnFamilyDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnFamilyDescriptor.Merge(dst, src)
}
func (m *ColumnFamilyDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *ColumnFamilyDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnFamilyDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnFamilyDescriptor proto.InternalMessageInfo

// InterleaveDescriptor represents an index (either primary or secondary) that
// is interleaved into another table's data.
//
// Example:
// Table 1 -> /a/b
// Table 2 -> /a/b/c
// Table 3 -> /a/b/c/d
//
// There are two components (table 2 is the parent and table 1 is the
// grandparent) with shared lengths 2 and 1.
type InterleaveDescriptor struct {
	// Ancestors contains the nesting of interleaves in the order they appear in
	// an encoded key. This means they are always in the far-to-near ancestor
	// order (e.g. grand-grand-parent, grand-parent, parent).
	Ancestors []InterleaveDescriptor_Ancestor `protobuf:"bytes,1,rep,name=ancestors" json:"ancestors"`
}

func (m *InterleaveDescriptor) Reset()         { *m = InterleaveDescriptor{} }
func (m *InterleaveDescriptor) String() string { return proto.CompactTextString(m) }
func (*InterleaveDescriptor) ProtoMessage()    {}
func (*InterleaveDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{5}
}
func (m *InterleaveDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterleaveDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *InterleaveDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterleaveDescriptor.Merge(dst, src)
}
func (m *InterleaveDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *InterleaveDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_InterleaveDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_InterleaveDescriptor proto.InternalMessageInfo

type InterleaveDescriptor_Ancestor struct {
	// TableID the ID of the table being interleaved into.
	TableID ID `protobuf:"varint,1,opt,name=table_id,json=tableId,casttype=ID" json:"table_id"`
	// IndexID is the ID of the parent index being interleaved into.
	IndexID IndexID `protobuf:"varint,2,opt,name=index_id,json=indexId,casttype=IndexID" json:"index_id"`
	// SharedPrefixLen is how many fields are shared between a parent and child
	// being interleaved, excluding any fields shared between parent and
	// grandparent. Thus, the sum of SharedPrefixLens in the components of an
	// InterleaveDescriptor is never more than the number of fields in the index
	// being interleaved.
	// In znbase 1.0, this value did not exist and thus a check for > 0
	// must be performed prior to its use.
	SharedPrefixLen uint32 `protobuf:"varint,3,opt,name=shared_prefix_len,json=sharedPrefixLen" json:"shared_prefix_len"`
}

func (m *InterleaveDescriptor_Ancestor) Reset()         { *m = InterleaveDescriptor_Ancestor{} }
func (m *InterleaveDescriptor_Ancestor) String() string { return proto.CompactTextString(m) }
func (*InterleaveDescriptor_Ancestor) ProtoMessage()    {}
func (*InterleaveDescriptor_Ancestor) Descriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{5, 0}
}
func (m *InterleaveDescriptor_Ancestor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterleaveDescriptor_Ancestor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *InterleaveDescriptor_Ancestor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterleaveDescriptor_Ancestor.Merge(dst, src)
}
func (m *InterleaveDescriptor_Ancestor) XXX_Size() int {
	return m.Size()
}
func (m *InterleaveDescriptor_Ancestor) XXX_DiscardUnknown() {
	xxx_messageInfo_InterleaveDescriptor_Ancestor.DiscardUnknown(m)
}

var xxx_messageInfo_InterleaveDescriptor_Ancestor proto.InternalMessageInfo

// PartitioningDescriptor represents the partitioning of an index into spans
// of keys addressable by a zone config. The key encoding is unchanged. Each
// partition may optionally be itself divided into further partitions, called
// subpartitions.
type PartitioningDescriptor struct {
	// NumColumns is how large of a prefix of the columns in an index are used in
	// the function mapping column values to partitions. If this is a
	// subpartition, this is offset to start from the end of the parent
	// partition's columns. If NumColumns is 0, then there is no partitioning.
	NumColumns uint32 `protobuf:"varint,1,opt,name=num_columns,json=numColumns" json:"num_columns"`
	// Exactly one of List or Range is required to be non-empty if NumColumns is
	// non-zero.
	List            []PartitioningDescriptor_List  `protobuf:"bytes,2,rep,name=list" json:"list"`
	Range           []PartitioningDescriptor_Range `protobuf:"bytes,3,rep,name=range" json:"range"`
	LocationNums    int32                          `protobuf:"varint,4,opt,name=location_nums,json=locationNums" json:"location_nums"`
	IsHashPartition bool                           `protobuf:"varint,5,opt,name=isHashPartition" json:"isHashPartition"`
}

func (m *PartitioningDescriptor) Reset()         { *m = PartitioningDescriptor{} }
func (m *PartitioningDescriptor) String() string { return proto.CompactTextString(m) }
func (*PartitioningDescriptor) ProtoMessage()    {}
func (*PartitioningDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{6}
}
func (m *PartitioningDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitioningDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *PartitioningDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitioningDescriptor.Merge(dst, src)
}
func (m *PartitioningDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *PartitioningDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitioningDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_PartitioningDescriptor proto.InternalMessageInfo

// List represents a list partitioning, which maps individual tuples to
// partitions.
type PartitioningDescriptor_List struct {
	// Name is the partition name.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name"`
	// Values is an unordered set of the tuples included in this partition. Each
	// tuple is encoded with the EncDatum value encoding. DEFAULT is encoded as
	// NOT NULL followed by PartitionDefaultVal encoded as a non-sorting
	// uvarint.
	Values [][]byte `protobuf:"bytes,2,rep,name=values" json:"values,omitempty"`
	// locatespacename store the locate name of this partition
	LocateSpaceName *roachpb.LocationValue `protobuf:"bytes,3,opt,name=locate_space_name,json=locateSpaceName" json:"locate_space_name,omitempty"`
	// Subpartitioning represents a further partitioning of this list partition.
	Subpartitioning PartitioningDescriptor `protobuf:"bytes,4,opt,name=subpartitioning" json:"subpartitioning"`
}

func (m *PartitioningDescriptor_List) Reset()         { *m = PartitioningDescriptor_List{} }
func (m *PartitioningDescriptor_List) String() string { return proto.CompactTextString(m) }
func (*PartitioningDescriptor_List) ProtoMessage()    {}
func (*PartitioningDescriptor_List) Descriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{6, 0}
}
func (m *PartitioningDescriptor_List) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitioningDescriptor_List) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *PartitioningDescriptor_List) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitioningDescriptor_List.Merge(dst, src)
}
func (m *PartitioningDescriptor_List) XXX_Size() int {
	return m.Size()
}
func (m *PartitioningDescriptor_List) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitioningDescriptor_List.DiscardUnknown(m)
}

var xxx_messageInfo_PartitioningDescriptor_List proto.InternalMessageInfo

// Range represents a range partitioning, which maps ranges of tuples to
// partitions by specifying exclusive upper bounds. The range partitions in a
// PartitioningDescriptor are required be sorted by UpperBound.
type PartitioningDescriptor_Range struct {
	// Name is the partition name.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name"`
	// FromInclusive is the inclusive lower bound of this range partition. It is
	// encoded with the EncDatum value encoding. MINVALUE and MAXVALUE are
	// encoded as NOT NULL followed by a PartitionSpecialValCode encoded as a
	// non-sorting uvarint.
	FromInclusive []byte `protobuf:"bytes,3,opt,name=from_inclusive,json=fromInclusive" json:"from_inclusive,omitempty"`
	// ToExclusive is the exclusive upper bound of this range partition. It is
	// encoded in the same way as From.
	ToExclusive []byte `protobuf:"bytes,2,opt,name=to_exclusive,json=toExclusive" json:"to_exclusive,omitempty"`
	// locatespacename store the locate name of this partition
	LocateSpaceName *roachpb.LocationValue `protobuf:"bytes,4,opt,name=locate_space_name,json=locateSpaceName" json:"locate_space_name,omitempty"`
}

func (m *PartitioningDescriptor_Range) Reset()         { *m = PartitioningDescriptor_Range{} }
func (m *PartitioningDescriptor_Range) String() string { return proto.CompactTextString(m) }
func (*PartitioningDescriptor_Range) ProtoMessage()    {}
func (*PartitioningDescriptor_Range) Descriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{6, 1}
}
func (m *PartitioningDescriptor_Range) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitioningDescriptor_Range) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *PartitioningDescriptor_Range) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitioningDescriptor_Range.Merge(dst, src)
}
func (m *PartitioningDescriptor_Range) XXX_Size() int {
	return m.Size()
}
func (m *PartitioningDescriptor_Range) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitioningDescriptor_Range.DiscardUnknown(m)
}

var xxx_messageInfo_PartitioningDescriptor_Range proto.InternalMessageInfo

// IndexDescriptor describes an index (primary or secondary).
//
// Sample field values on the following table:
//
//   CREATE TABLE t (
//     k1 INT NOT NULL,   // column ID: 1
//     k2 INT NOT NULL,   // column ID: 2
//     u INT NULL,        // column ID: 3
//     v INT NULL,        // column ID: 4
//     w INT NULL,        // column ID: 5
//     CONSTRAINT "primary" PRIMARY KEY (k1, k2),
//     INDEX k1v (k1, v) STORING (w),
//     FAMILY "primary" (k1, k2, u, v, w)
//   )
//
// Primary index:
//   name:                primary
//   id:                  1
//   unique:              true
//   column_names:        k1, k2
//   column_directions:   ASC, ASC
//   column_ids:          1, 2   // k1, k2
//
// [old STORING encoding] Index k1v (k1, v) STORING (w):
//   name:                k1v
//   id:                  2
//   unique:              false
//   column_names:        k1, v
//   column_directions:   ASC, ASC
//   store_column_names:  w
//   column_ids:          1, 4   // k1, v
//   extra_column_ids:    2, 5   // k2, w
//
// [new STORING encoding] Index k1v (k1, v) STORING (w):
//   name:                k1v
//   id:                  2
//   unique:              false
//   column_names:        k1, v
//   column_directions:   ASC, ASC
//   store_column_names:  w
//   column_ids:          1, 4   // k1, v
//   extra_column_ids:    2      // k2
//   store_column_ids:    5      // w
type IndexDescriptor struct {
	Name   string  `protobuf:"bytes,1,opt,name=name" json:"name"`
	ID     IndexID `protobuf:"varint,2,opt,name=id,casttype=IndexID" json:"id"`
	Unique bool    `protobuf:"varint,3,opt,name=unique" json:"unique"`
	// An ordered list of column names of which the index is comprised; these
	// columns do not include any additional stored columns (which are in
	// stored_column_names). This list parallels the column_ids list.
	//
	// Note: if duplicating the storage of the column names here proves to be
	// prohibitive, we could clear this field before saving and reconstruct it
	// after loading.
	ColumnNames []string `protobuf:"bytes,4,rep,name=ColumnNames" json:"ColumnNames,omitempty"`
	// The sort direction of each column in column_names.
	ColumnDirections []IndexDescriptor_Direction `protobuf:"varint,8,rep,name=column_directions,json=columnDirections,enum=znbase.sql.sqlbase.IndexDescriptor_Direction" json:"column_directions,omitempty"`
	// An ordered list of column names which the index stores in addition to the
	// columns which are explicitly part of the index (STORING clause). Only used
	// for secondary indexes.
	StoreColumnNames []string `protobuf:"bytes,5,rep,name=store_column_names,json=storeColumnNames" json:"store_column_names,omitempty"`
	// An ordered list of column IDs of which the index is comprised. This list
	// parallels the column_names list and does not include any additional stored
	// columns.
	ColumnIDs []ColumnID `protobuf:"varint,6,rep,name=column_ids,json=columnIds,casttype=ColumnID" json:"column_ids,omitempty"`
	// An ordered list of IDs for the additional columns associated with the
	// index:
	//  - implicit columns, which are all the primary key columns that are not
	//    already part of the index (i.e. PrimaryIndex.column_ids - column_ids).
	//  - stored columns (the columns in store_column_names) if this index uses the
	//    old STORING encoding (key-encoded data).
	//
	// Only used for secondary indexes.
	// For non-unique indexes, these columns are appended to the key.
	// For unique indexes, these columns are stored in the value (unless the key
	// contains a NULL value: then the extra columns are appended to the key to
	// unique-ify it).
	// This distinction exists because we want to be able to insert an entry using
	// a single conditional put on the key.
	ExtraColumnIDs []ColumnID `protobuf:"varint,7,rep,name=extra_column_ids,json=extraColumnIds,casttype=ColumnID" json:"extra_column_ids,omitempty"`
	// An ordered list of column IDs that parallels store_column_names if this
	// index uses the new STORING encoding (value-encoded data, always in the KV
	// value).
	StoreColumnIDs []ColumnID `protobuf:"varint,14,rep,name=store_column_ids,json=storeColumnIds,casttype=ColumnID" json:"store_column_ids,omitempty"`
	// CompositeColumnIDs contains an ordered list of IDs of columns that appear
	// in the index and have a composite encoding. Includes IDs from both
	// column_ids and extra_column_ids.
	CompositeColumnIDs []ColumnID            `protobuf:"varint,13,rep,name=composite_column_ids,json=compositeColumnIds,casttype=ColumnID" json:"composite_column_ids,omitempty"`
	ForeignKey         ForeignKeyReference   `protobuf:"bytes,9,opt,name=foreign_key,json=foreignKey" json:"foreign_key"`
	ReferencedBy       []ForeignKeyReference `protobuf:"bytes,10,rep,name=referenced_by,json=referencedBy" json:"referenced_by"`
	// Interleave, if it's not the zero value, describes how this index's data is
	// interleaved into another index's data.
	Interleave InterleaveDescriptor `protobuf:"bytes,11,opt,name=interleave" json:"interleave"`
	// InterleavedBy contains a reference to every table/index that is interleaved
	// into this one.
	InterleavedBy []ForeignKeyReference `protobuf:"bytes,12,rep,name=interleaved_by,json=interleavedBy" json:"interleaved_by"`
	// Partitioning, if it's not the zero value, describes how this index's data
	// is partitioned into spans of keys each addressable by zone configs.
	Partitioning PartitioningDescriptor `protobuf:"bytes,15,opt,name=partitioning" json:"partitioning"`
	// Type is the type of index, inverted or forward.
	Type IndexDescriptor_Type `protobuf:"varint,16,opt,name=type,enum=znbase.sql.sqlbase.IndexDescriptor_Type" json:"type"`
	// locatespacename store the locate name of this index
	LocateSpaceName *roachpb.LocationValue `protobuf:"bytes,17,opt,name=locate_space_name,json=locateSpaceName" json:"locate_space_name,omitempty"`
	LocationNums    int32                  `protobuf:"varint,18,opt,name=location_nums,json=locationNums" json:"location_nums"`
	PredExpr        string                 `protobuf:"bytes,19,opt,name=pred_expr,json=predExpr" json:"pred_expr"`
	IsLocal         bool                   `protobuf:"varint,20,opt,name=isLocal" json:"isLocal"`
	IsFunc          []bool                 `protobuf:"varint,21,rep,name=isFunc" json:"isFunc,omitempty"`
	IsRealFunc      []bool                 `protobuf:"varint,22,rep,name=isRealFunc" json:"isRealFunc,omitempty"`
	// EncodingType represents what sort of k/v encoding is used to store this descriptor on disk.
	// As of now, this includes the existing secondary index encoding, or the primary index encoding.
	// N.B. This field is only recognized on secondary indexes.
	EncodingType IndexDescriptorEncodingType `protobuf:"varint,23,opt,name=encoding_type,json=encodingType,casttype=IndexDescriptorEncodingType" json:"encoding_type"`
	// Disabled is used by the DROP PRIMARY KEY command to mark
	// that this index is disabled for further use.
	Disabled bool `protobuf:"varint,24,opt,name=disabled" json:"disabled"`
}

func (m *IndexDescriptor) Reset()         { *m = IndexDescriptor{} }
func (m *IndexDescriptor) String() string { return proto.CompactTextString(m) }
func (*IndexDescriptor) ProtoMessage()    {}
func (*IndexDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{7}
}
func (m *IndexDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *IndexDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexDescriptor.Merge(dst, src)
}
func (m *IndexDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *IndexDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_IndexDescriptor proto.InternalMessageInfo

// ConstraintToUpdate represents a constraint to be added to the table and
// validated for existing rows. More generally, in the future, when we support
// adding constraints that are unvalidated for existing rows and can be
// validated later using VALIDATE CONSTRAINT, this mutation will also represent
// either adding an unvalidated constraint or validating an existing constraint.
//
// This mutation effects changes only in the backfill step of the schema
// changer: First, a new version of the table descriptor with the constraint
// added is published, after all columns being added have been backfilled. After
// waiting for the constraint to be enforced for writes on all nodes, the
// constraint is then validated for all existing rows. This ensures that
// constraints added to columns that are being added are correctly enforced
// before the column becomes public.
type ConstraintToUpdate struct {
	ConstraintType ConstraintToUpdate_ConstraintType `protobuf:"varint,1,req,name=constraint_type,json=constraintType,enum=znbase.sql.sqlbase.ConstraintToUpdate_ConstraintType" json:"constraint_type"`
	Name           string                            `protobuf:"bytes,2,req,name=name" json:"name"`
	Check          TableDescriptor_CheckConstraint   `protobuf:"bytes,3,opt,name=check" json:"check"`
	// All fields past 3 haven't been persisted before 19.2.
	ForeignKey    ForeignKeyConstraint `protobuf:"bytes,4,opt,name=foreign_key,json=foreignKey" json:"foreign_key"`
	NotNullColumn ColumnID             `protobuf:"varint,6,opt,name=not_null_column,json=notNullColumn,casttype=ColumnID" json:"not_null_column"`
}

func (m *ConstraintToUpdate) Reset()         { *m = ConstraintToUpdate{} }
func (m *ConstraintToUpdate) String() string { return proto.CompactTextString(m) }
func (*ConstraintToUpdate) ProtoMessage()    {}
func (*ConstraintToUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{8}
}
func (m *ConstraintToUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConstraintToUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ConstraintToUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConstraintToUpdate.Merge(dst, src)
}
func (m *ConstraintToUpdate) XXX_Size() int {
	return m.Size()
}
func (m *ConstraintToUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_ConstraintToUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_ConstraintToUpdate proto.InternalMessageInfo

// PrimaryKeySwap is a mutation corresponding to the atomic swap phase
// during a primary key change where old versions of indexes are exchanged for
// updated versions, and the table's new primary key is written into the descriptor.
type PrimaryKeySwap struct {
	// old_primary_index_id is the ID of the old primary index for the table.
	OldPrimaryIndexId IndexID `protobuf:"varint,4,opt,name=old_primary_index_id,json=oldPrimaryIndexId,casttype=IndexID" json:"old_primary_index_id"`
	// new_primary_index_id is the ID of the new primary index for the table.
	NewPrimaryIndexId IndexID `protobuf:"varint,1,opt,name=new_primary_index_id,json=newPrimaryIndexId,casttype=IndexID" json:"new_primary_index_id"`
	// old_indexes and new_indexes are lists of IndexID's where the i'th index in old_indexes will be
	// swapped out with the i'th index in new_indexes.
	OldIndexes []IndexID `protobuf:"varint,2,rep,name=old_indexes,json=oldIndexes,casttype=IndexID" json:"old_indexes,omitempty"`
	NewIndexes []IndexID `protobuf:"varint,3,rep,name=new_indexes,json=newIndexes,casttype=IndexID" json:"new_indexes,omitempty"`
	// new_primary_index_name is the name of the primary key when added as a
	// new constraint to a table without a primary key. In other cases, it is
	// the empty string.
	NewPrimaryIndexName string `protobuf:"bytes,5,opt,name=new_primary_index_name,json=newPrimaryIndexName" json:"new_primary_index_name"`
}

func (m *PrimaryKeySwap) Reset()         { *m = PrimaryKeySwap{} }
func (m *PrimaryKeySwap) String() string { return proto.CompactTextString(m) }
func (*PrimaryKeySwap) ProtoMessage()    {}
func (*PrimaryKeySwap) Descriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{9}
}
func (m *PrimaryKeySwap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrimaryKeySwap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *PrimaryKeySwap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrimaryKeySwap.Merge(dst, src)
}
func (m *PrimaryKeySwap) XXX_Size() int {
	return m.Size()
}
func (m *PrimaryKeySwap) XXX_DiscardUnknown() {
	xxx_messageInfo_PrimaryKeySwap.DiscardUnknown(m)
}

var xxx_messageInfo_PrimaryKeySwap proto.InternalMessageInfo

// MaterializedViewRefresh is a mutation corresponding to a request to
// refresh a materialized view. The mutation operates by backfilling the
// result of the view query into the indexes specified by the mutation.
type MaterializedViewRefresh struct {
	// NewPrimaryIndex is the new primary index of the view to backfill into.
	// NewPrimaryIndex and NewIndexes below are copies of the existing indexes on
	// the view, but with different ID's.
	NewPrimaryIndex IndexDescriptor `protobuf:"bytes,1,opt,name=new_primary_index,json=newPrimaryIndex" json:"new_primary_index"`
	// NewIndexes are the new set of indexes to backfill the view into.
	NewIndexes []IndexDescriptor `protobuf:"bytes,2,rep,name=new_indexes,json=newIndexes" json:"new_indexes"`
	// AsOf is the timestamp to perform the view query at.
	AsOf hlc.Timestamp `protobuf:"bytes,3,opt,name=as_of,json=asOf" json:"as_of"`
}

func (m *MaterializedViewRefresh) Reset()         { *m = MaterializedViewRefresh{} }
func (m *MaterializedViewRefresh) String() string { return proto.CompactTextString(m) }
func (*MaterializedViewRefresh) ProtoMessage()    {}
func (*MaterializedViewRefresh) Descriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{10}
}
func (m *MaterializedViewRefresh) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MaterializedViewRefresh) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *MaterializedViewRefresh) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MaterializedViewRefresh.Merge(dst, src)
}
func (m *MaterializedViewRefresh) XXX_Size() int {
	return m.Size()
}
func (m *MaterializedViewRefresh) XXX_DiscardUnknown() {
	xxx_messageInfo_MaterializedViewRefresh.DiscardUnknown(m)
}

var xxx_messageInfo_MaterializedViewRefresh proto.InternalMessageInfo

// A DescriptorMutation represents a column or an index that
// has either been added or dropped and hasn't yet transitioned
// into a stable state: completely backfilled and visible, or
// completely deleted. A table descriptor in the middle of a
// schema change will have a DescriptorMutation FIFO queue
// containing each column/index descriptor being added or dropped.
// Mutations for constraints work differently from columns and
// indexes; see the documentation for ConstraintToUpdate.
type DescriptorMutation struct {
	// Types that are valid to be assigned to Descriptor_:
	//	*DescriptorMutation_Column
	//	*DescriptorMutation_Index
	//	*DescriptorMutation_Constraint
	//	*DescriptorMutation_PrimaryKeySwap
	//	*DescriptorMutation_MaterializedViewRefresh
	Descriptor_ isDescriptorMutation_Descriptor_ `protobuf_oneof:"descriptor"`
	State       DescriptorMutation_State         `protobuf:"varint,3,opt,name=state,enum=znbase.sql.sqlbase.DescriptorMutation_State" json:"state"`
	Direction   DescriptorMutation_Direction     `protobuf:"varint,4,opt,name=direction,enum=znbase.sql.sqlbase.DescriptorMutation_Direction" json:"direction"`
	// The mutation id used to group mutations that should be applied together.
	// This is used for situations like creating a unique column, which
	// involve adding two mutations: one for the column, and another for the
	// unique constraint index.
	MutationID MutationID `protobuf:"varint,5,opt,name=mutation_id,json=mutationId,casttype=MutationID" json:"mutation_id"`
	// Indicates that this mutation is a rollback.
	Rollback bool `protobuf:"varint,7,opt,name=rollback" json:"rollback"`
}

func (m *DescriptorMutation) Reset()         { *m = DescriptorMutation{} }
func (m *DescriptorMutation) String() string { return proto.CompactTextString(m) }
func (*DescriptorMutation) ProtoMessage()    {}
func (*DescriptorMutation) Descriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{11}
}
func (m *DescriptorMutation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DescriptorMutation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *DescriptorMutation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DescriptorMutation.Merge(dst, src)
}
func (m *DescriptorMutation) XXX_Size() int {
	return m.Size()
}
func (m *DescriptorMutation) XXX_DiscardUnknown() {
	xxx_messageInfo_DescriptorMutation.DiscardUnknown(m)
}

var xxx_messageInfo_DescriptorMutation proto.InternalMessageInfo

type isDescriptorMutation_Descriptor_ interface {
	isDescriptorMutation_Descriptor_()
	MarshalTo([]byte) (int, error)
	Size() int
}

type DescriptorMutation_Column struct {
	Column *ColumnDescriptor `protobuf:"bytes,1,opt,name=column,oneof"`
}
type DescriptorMutation_Index struct {
	Index *IndexDescriptor `protobuf:"bytes,2,opt,name=index,oneof"`
}
type DescriptorMutation_Constraint struct {
	Constraint *ConstraintToUpdate `protobuf:"bytes,8,opt,name=constraint,oneof"`
}
type DescriptorMutation_PrimaryKeySwap struct {
	PrimaryKeySwap *PrimaryKeySwap `protobuf:"bytes,9,opt,name=primaryKeySwap,oneof"`
}
type DescriptorMutation_MaterializedViewRefresh struct {
	MaterializedViewRefresh *MaterializedViewRefresh `protobuf:"bytes,10,opt,name=materializedViewRefresh,oneof"`
}

func (*DescriptorMutation_Column) isDescriptorMutation_Descriptor_()                  {}
func (*DescriptorMutation_Index) isDescriptorMutation_Descriptor_()                   {}
func (*DescriptorMutation_Constraint) isDescriptorMutation_Descriptor_()              {}
func (*DescriptorMutation_PrimaryKeySwap) isDescriptorMutation_Descriptor_()          {}
func (*DescriptorMutation_MaterializedViewRefresh) isDescriptorMutation_Descriptor_() {}

func (m *DescriptorMutation) GetDescriptor_() isDescriptorMutation_Descriptor_ {
	if m != nil {
		return m.Descriptor_
	}
	return nil
}

func (m *DescriptorMutation) GetColumn() *ColumnDescriptor {
	if x, ok := m.GetDescriptor_().(*DescriptorMutation_Column); ok {
		return x.Column
	}
	return nil
}

func (m *DescriptorMutation) GetIndex() *IndexDescriptor {
	if x, ok := m.GetDescriptor_().(*DescriptorMutation_Index); ok {
		return x.Index
	}
	return nil
}

func (m *DescriptorMutation) GetConstraint() *ConstraintToUpdate {
	if x, ok := m.GetDescriptor_().(*DescriptorMutation_Constraint); ok {
		return x.Constraint
	}
	return nil
}

func (m *DescriptorMutation) GetPrimaryKeySwap() *PrimaryKeySwap {
	if x, ok := m.GetDescriptor_().(*DescriptorMutation_PrimaryKeySwap); ok {
		return x.PrimaryKeySwap
	}
	return nil
}

func (m *DescriptorMutation) GetMaterializedViewRefresh() *MaterializedViewRefresh {
	if x, ok := m.GetDescriptor_().(*DescriptorMutation_MaterializedViewRefresh); ok {
		return x.MaterializedViewRefresh
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*DescriptorMutation) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _DescriptorMutation_OneofMarshaler, _DescriptorMutation_OneofUnmarshaler, _DescriptorMutation_OneofSizer, []interface{}{
		(*DescriptorMutation_Column)(nil),
		(*DescriptorMutation_Index)(nil),
		(*DescriptorMutation_Constraint)(nil),
		(*DescriptorMutation_PrimaryKeySwap)(nil),
		(*DescriptorMutation_MaterializedViewRefresh)(nil),
	}
}

func _DescriptorMutation_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*DescriptorMutation)
	// descriptor
	switch x := m.Descriptor_.(type) {
	case *DescriptorMutation_Column:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Column); err != nil {
			return err
		}
	case *DescriptorMutation_Index:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Index); err != nil {
			return err
		}
	case *DescriptorMutation_Constraint:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Constraint); err != nil {
			return err
		}
	case *DescriptorMutation_PrimaryKeySwap:
		_ = b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PrimaryKeySwap); err != nil {
			return err
		}
	case *DescriptorMutation_MaterializedViewRefresh:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.MaterializedViewRefresh); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("DescriptorMutation.Descriptor_ has unexpected type %T", x)
	}
	return nil
}

func _DescriptorMutation_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*DescriptorMutation)
	switch tag {
	case 1: // descriptor.column
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ColumnDescriptor)
		err := b.DecodeMessage(msg)
		m.Descriptor_ = &DescriptorMutation_Column{msg}
		return true, err
	case 2: // descriptor.index
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IndexDescriptor)
		err := b.DecodeMessage(msg)
		m.Descriptor_ = &DescriptorMutation_Index{msg}
		return true, err
	case 8: // descriptor.constraint
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ConstraintToUpdate)
		err := b.DecodeMessage(msg)
		m.Descriptor_ = &DescriptorMutation_Constraint{msg}
		return true, err
	case 9: // descriptor.primaryKeySwap
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PrimaryKeySwap)
		err := b.DecodeMessage(msg)
		m.Descriptor_ = &DescriptorMutation_PrimaryKeySwap{msg}
		return true, err
	case 10: // descriptor.materializedViewRefresh
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MaterializedViewRefresh)
		err := b.DecodeMessage(msg)
		m.Descriptor_ = &DescriptorMutation_MaterializedViewRefresh{msg}
		return true, err
	default:
		return false, nil
	}
}

func _DescriptorMutation_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*DescriptorMutation)
	// descriptor
	switch x := m.Descriptor_.(type) {
	case *DescriptorMutation_Column:
		s := proto.Size(x.Column)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DescriptorMutation_Index:
		s := proto.Size(x.Index)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DescriptorMutation_Constraint:
		s := proto.Size(x.Constraint)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DescriptorMutation_PrimaryKeySwap:
		s := proto.Size(x.PrimaryKeySwap)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DescriptorMutation_MaterializedViewRefresh:
		s := proto.Size(x.MaterializedViewRefresh)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// A TableDescriptor represents a table or view and is stored in a
// structured metadata key. The TableDescriptor has a globally-unique ID,
// while its member {Column,Index}Descriptors have locally-unique IDs.
type TableDescriptor struct {
	// The table name. It should be normalized using NormalizeName() before
	// comparing it.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name"`
	ID   ID     `protobuf:"varint,3,opt,name=id,casttype=ID" json:"id"`
	// ID of the parent database.
	ParentID ID `protobuf:"varint,4,opt,name=parent_id,json=parentId,casttype=ID" json:"parent_id"`
	// Monotonically increasing version of the table descriptor.
	//
	// The design maintains two invariant:
	// 1. Two safe versions: A transaction at a particular timestamp is
	//    allowed to use one of two versions of a table descriptor:
	//    the one that would be read from the store at that timestamp,
	//    and the one behind it in version.
	// 2. Two leased version: There can be valid leases on at most the 2
	//    latest versions of a table in the cluster at any time. New leases
	//    are only granted on the latest version.
	//
	// The database must maintain correctness in light of there being two
	// versions of a descriptor that can be used.
	//
	// Multiple schema change mutations can be grouped together on a
	// particular version increment.
	Version          DescriptorVersion `protobuf:"varint,5,opt,name=version,casttype=DescriptorVersion" json:"version"`
	ReplicationTable bool              `protobuf:"varint,6,opt,name=replication_table,json=replicationTable" json:"replication_table"`
	// Last modification time of the table descriptor.
	ModificationTime hlc.Timestamp      `protobuf:"bytes,7,opt,name=modification_time,json=modificationTime" json:"modification_time"`
	Columns          []ColumnDescriptor `protobuf:"bytes,8,rep,name=columns" json:"columns"`
	// next_column_id is used to ensure that deleted column ids are not reused.
	NextColumnID ColumnID `protobuf:"varint,9,opt,name=next_column_id,json=nextColumnId,casttype=ColumnID" json:"next_column_id"`
	// families holds information about the column families of this table.
	// This list has at least length 1, in which case all columns are stored in the same family.
	// families is stored in sorted order by family ID.
	Families []ColumnFamilyDescriptor `protobuf:"bytes,22,rep,name=families" json:"families"`
	// next_family_id is used to ensure that deleted family ids are not reused.
	NextFamilyID FamilyID        `protobuf:"varint,23,opt,name=next_family_id,json=nextFamilyId,casttype=FamilyID" json:"next_family_id"`
	PrimaryIndex IndexDescriptor `protobuf:"bytes,10,opt,name=primary_index,json=primaryIndex" json:"primary_index"`
	// indexes are all the secondary indexes.
	Indexes []IndexDescriptor `protobuf:"bytes,11,rep,name=indexes" json:"indexes"`
	// next_index_id is used to ensure that deleted index ids are not reused.
	NextIndexID IndexID              `protobuf:"varint,12,opt,name=next_index_id,json=nextIndexId,casttype=IndexID" json:"next_index_id"`
	Privileges  *PrivilegeDescriptor `protobuf:"bytes,13,opt,name=privileges" json:"privileges,omitempty"`
	// Columns or indexes being added or deleted in a FIFO order.
	Mutations []DescriptorMutation               `protobuf:"bytes,14,rep,name=mutations" json:"mutations"`
	Lease     *TableDescriptor_SchemaChangeLease `protobuf:"bytes,15,opt,name=lease" json:"lease,omitempty"` // Deprecated: Do not use.
	// An id for the next group of mutations to be applied together.
	NextMutationID MutationID `protobuf:"varint,16,opt,name=next_mutation_id,json=nextMutationId,casttype=MutationID" json:"next_mutation_id"`
	// format_version declares which sql to key:value mapping is being used to
	// represent the data in this table.
	FormatVersion FormatVersion `protobuf:"varint,17,opt,name=format_version,json=formatVersion,casttype=FormatVersion" json:"format_version"`
	// locatespacename store the locate name of this table
	LocateSpaceName *roachpb.LocationValue             `protobuf:"bytes,18,opt,name=locate_space_name,json=locateSpaceName" json:"locate_space_name,omitempty"`
	State           TableDescriptor_State              `protobuf:"varint,19,opt,name=state,enum=znbase.sql.sqlbase.TableDescriptor_State" json:"state"`
	Checks          []*TableDescriptor_CheckConstraint `protobuf:"bytes,20,rep,name=checks" json:"checks,omitempty"`
	// A list of draining names. The draining name entries are drained from
	// the cluster wide name caches by incrementing the version for this
	// descriptor and ensuring that there are no leases on prior
	// versions of the descriptor. This field is then cleared and the version
	// of the descriptor incremented.
	DrainingNames []TableDescriptor_NameInfo `protobuf:"bytes,21,rep,name=draining_names,json=drainingNames" json:"draining_names"`
	// The TableDescriptor is used for views in addition to tables. Views
	// use mostly the same fields as tables, but need to track the actual
	// query from the view definition as well.
	//
	// For now we only track a string representation of the query. This prevents
	// us from easily supporting things like renames of the dependencies of a
	// view. Eventually we'll want to switch to a semantic encoding of the query
	// that relies on IDs rather than names so that we can support renames of
	// fields relied on by the query, as Postgres does.
	//
	// Note: The presence of this field is used to determine whether or not
	// a TableDescriptor represents a view.
	ViewQuery string `protobuf:"bytes,24,opt,name=view_query,json=viewQuery" json:"view_query"`
	// The IDs of all relations that this depends on.
	// Only ever populated if this descriptor is for a view.
	DependsOn []ID `protobuf:"varint,25,rep,name=dependsOn,casttype=ID" json:"dependsOn,omitempty"`
	// All references to this table/view from other views in the system, tracked
	// down to the column/index so that we can restrict changes to them while
	// they're still being referred to.
	DependedOnBy []TableDescriptor_Reference `protobuf:"bytes,26,rep,name=dependedOnBy" json:"dependedOnBy"`
	// Mutation jobs queued for execution in a FIFO order. Remains synchronized
	// with the mutations list.
	MutationJobs []TableDescriptor_MutationJob `protobuf:"bytes,27,rep,name=mutationJobs" json:"mutationJobs"`
	// The presence of sequence_opts indicates that this descriptor is for a sequence.
	SequenceOpts *TableDescriptor_SequenceOpts `protobuf:"bytes,28,opt,name=sequence_opts,json=sequenceOpts" json:"sequence_opts,omitempty"`
	// The drop time is set when a table is truncated or dropped,
	// based on the current time in nanoseconds since the epoch.
	// Use this timestamp + GC TTL to start deleting the table's
	// contents.
	//
	// TODO(vivek): Replace with the ModificationTime. This has been
	// added only for migration purposes.
	DropTime int64 `protobuf:"varint,29,opt,name=drop_time,json=dropTime" json:"drop_time"`
	// ReplacementOf tracks prior IDs by which this table went -- e.g. when
	// TRUNCATE creates a replacement of a table and swaps it in for the the old
	// one, it should note on the new table the ID of the table it replaced. This
	// can be used when trying to track a table's history across truncatations.
	ReplacementOf TableDescriptor_Replacement `protobuf:"bytes,30,opt,name=replacement_of,json=replacementOf" json:"replacement_of"`
	AuditMode     TableDescriptor_AuditMode   `protobuf:"varint,31,opt,name=audit_mode,json=auditMode,enum=znbase.sql.sqlbase.TableDescriptor_AuditMode" json:"audit_mode"`
	// The job id for a drop job is the id in the system.jobs table of the
	// dropping of this table.
	DropJobID int64 `protobuf:"varint,32,opt,name=drop_job_id,json=dropJobId" json:"drop_job_id"`
	// The schema elements that have been dropped and whose underlying
	// data needs to be gc-ed. These schema elements have already transitioned
	// through the drop state machine when they were in the above mutations
	// list, and can be safely deleted. The names for these schema elements
	// can be reused. This list is separate because mutations can
	// lie in this list for a long time (gc deadline) and should not block
	// the execution of other schema changes on the table.
	//
	// TODO(vivekmenezes): This is currently only used by the non-interleaved drop
	// index case. Also use for dropped interleaved indexes and columns.
	GCMutations     []TableDescriptor_GCDescriptorMutation `protobuf:"bytes,33,rep,name=gc_mutations,json=gcMutations" json:"gc_mutations"`
	LocationNums    int32                                  `protobuf:"varint,34,opt,name=location_nums,json=locationNums" json:"location_nums"`
	IsHashPartition bool                                   `protobuf:"varint,35,opt,name=isHashPartition" json:"isHashPartition"`
	HashParts       int32                                  `protobuf:"varint,36,opt,name=hashParts" json:"hashParts"`
	HashField       string                                 `protobuf:"bytes,37,opt,name=hashField" json:"hashField"`
	// key is partitionID, value is engine type supported by replicas.
	EngineTypeSetMap map[uint32]*TableDescriptor_MapValue `protobuf:"bytes,38,rep,name=engine_type_set_map,json=engineTypeSetMap" json:"engine_type_set_map,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Inherits         []ID                                 `protobuf:"varint,39,rep,name=inherits,casttype=ID" json:"inherits,omitempty"`
	InheritsBy       []ID                                 `protobuf:"varint,40,rep,name=inheritsby,casttype=ID" json:"inheritsby,omitempty"`
	// Temporary table support will be added to ZNBase starting from 20.1. The temporary
	// flag is set to true for all temporary tables. All table descriptors created
	// before 20.1 refer to persistent tables, so lack of the flag being set implies
	// the table is persistent.
	Temporary     bool  `protobuf:"varint,41,opt,name=temporary" json:"temporary"`
	CreateByTable bool  `protobuf:"varint,42,opt,name=createByTable" json:"createByTable"`
	MaxColumnID   int32 `protobuf:"varint,43,opt,name=maxColumnID" json:"maxColumnID"`
	// Variables to support Updatable View. The viewUpdatable flag is set to true for updatable view.
	// viewDependsOn records the tableDescriptor/viewDescriptor id which updatable view depends on.
	ViewUpdatable bool   `protobuf:"varint,44,opt,name=viewUpdatable" json:"viewUpdatable"`
	ViewDependsOn uint32 `protobuf:"varint,45,opt,name=viewDependsOn" json:"viewDependsOn"`
	// Variable to store comments for table.
	Comments string `protobuf:"bytes,46,opt,name=comments" json:"comments"`
	// IsMaterializedView indicates whether this view is materialized or not.
	// A materialized view has the view query results stored durably on disk
	// as a table. The data on disk is refreshed with the REFRESH MATERIALIZED
	// VIEW command. This flag is only set when ViewQuery != "".
	IsMaterializedView bool   `protobuf:"varint,47,opt,name=is_materialized_view,json=isMaterializedView" json:"is_materialized_view"`
	CreateQuery        string `protobuf:"bytes,48,opt,name=create_query,json=createQuery" json:"create_query"`
	// CreateAsOfTime is initialized to zero for the first
	// version of a table and is populated from the MVCC timestamp of the read
	// like ModificationTime. See Descriptor.Table().
	// CreateAsOfSystemTime is used for CREATE TABLE ... AS ...
	CreateAsOfTime hlc.Timestamp `protobuf:"bytes,49,opt,name=create_as_of_time,json=createAsOfTime" json:"create_as_of_time"`
}

func (m *TableDescriptor) Reset()         { *m = TableDescriptor{} }
func (m *TableDescriptor) String() string { return proto.CompactTextString(m) }
func (*TableDescriptor) ProtoMessage()    {}
func (*TableDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{12}
}
func (m *TableDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *TableDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableDescriptor.Merge(dst, src)
}
func (m *TableDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *TableDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_TableDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_TableDescriptor proto.InternalMessageInfo

func (m *TableDescriptor) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TableDescriptor) GetID() ID {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *TableDescriptor) GetParentID() ID {
	if m != nil {
		return m.ParentID
	}
	return 0
}

func (m *TableDescriptor) GetVersion() DescriptorVersion {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *TableDescriptor) GetReplicationTable() bool {
	if m != nil {
		return m.ReplicationTable
	}
	return false
}

func (m *TableDescriptor) GetModificationTime() hlc.Timestamp {
	if m != nil {
		return m.ModificationTime
	}
	return hlc.Timestamp{}
}

func (m *TableDescriptor) GetColumns() []ColumnDescriptor {
	if m != nil {
		return m.Columns
	}
	return nil
}

func (m *TableDescriptor) GetNextColumnID() ColumnID {
	if m != nil {
		return m.NextColumnID
	}
	return 0
}

func (m *TableDescriptor) GetFamilies() []ColumnFamilyDescriptor {
	if m != nil {
		return m.Families
	}
	return nil
}

func (m *TableDescriptor) GetNextFamilyID() FamilyID {
	if m != nil {
		return m.NextFamilyID
	}
	return 0
}

func (m *TableDescriptor) GetPrimaryIndex() IndexDescriptor {
	if m != nil {
		return m.PrimaryIndex
	}
	return IndexDescriptor{}
}

func (m *TableDescriptor) GetIndexes() []IndexDescriptor {
	if m != nil {
		return m.Indexes
	}
	return nil
}

func (m *TableDescriptor) GetNextIndexID() IndexID {
	if m != nil {
		return m.NextIndexID
	}
	return 0
}

func (m *TableDescriptor) GetPrivileges() *PrivilegeDescriptor {
	if m != nil {
		return m.Privileges
	}
	return nil
}

func (m *TableDescriptor) GetMutations() []DescriptorMutation {
	if m != nil {
		return m.Mutations
	}
	return nil
}

// Deprecated: Do not use.
func (m *TableDescriptor) GetLease() *TableDescriptor_SchemaChangeLease {
	if m != nil {
		return m.Lease
	}
	return nil
}

func (m *TableDescriptor) GetNextMutationID() MutationID {
	if m != nil {
		return m.NextMutationID
	}
	return 0
}

func (m *TableDescriptor) GetFormatVersion() FormatVersion {
	if m != nil {
		return m.FormatVersion
	}
	return 0
}

func (m *TableDescriptor) GetLocateSpaceName() *roachpb.LocationValue {
	if m != nil {
		return m.LocateSpaceName
	}
	return nil
}

func (m *TableDescriptor) GetState() TableDescriptor_State {
	if m != nil {
		return m.State
	}
	return TableDescriptor_PUBLIC
}

func (m *TableDescriptor) GetChecks() []*TableDescriptor_CheckConstraint {
	if m != nil {
		return m.Checks
	}
	return nil
}

func (m *TableDescriptor) GetDrainingNames() []TableDescriptor_NameInfo {
	if m != nil {
		return m.DrainingNames
	}
	return nil
}

func (m *TableDescriptor) GetViewQuery() string {
	if m != nil {
		return m.ViewQuery
	}
	return ""
}

func (m *TableDescriptor) GetDependsOn() []ID {
	if m != nil {
		return m.DependsOn
	}
	return nil
}

func (m *TableDescriptor) GetDependedOnBy() []TableDescriptor_Reference {
	if m != nil {
		return m.DependedOnBy
	}
	return nil
}

func (m *TableDescriptor) GetMutationJobs() []TableDescriptor_MutationJob {
	if m != nil {
		return m.MutationJobs
	}
	return nil
}

func (m *TableDescriptor) GetSequenceOpts() *TableDescriptor_SequenceOpts {
	if m != nil {
		return m.SequenceOpts
	}
	return nil
}

func (m *TableDescriptor) GetDropTime() int64 {
	if m != nil {
		return m.DropTime
	}
	return 0
}

func (m *TableDescriptor) GetReplacementOf() TableDescriptor_Replacement {
	if m != nil {
		return m.ReplacementOf
	}
	return TableDescriptor_Replacement{}
}

func (m *TableDescriptor) GetAuditMode() TableDescriptor_AuditMode {
	if m != nil {
		return m.AuditMode
	}
	return TableDescriptor_DISABLED
}

func (m *TableDescriptor) GetDropJobID() int64 {
	if m != nil {
		return m.DropJobID
	}
	return 0
}

func (m *TableDescriptor) GetGCMutations() []TableDescriptor_GCDescriptorMutation {
	if m != nil {
		return m.GCMutations
	}
	return nil
}

func (m *TableDescriptor) GetLocationNums() int32 {
	if m != nil {
		return m.LocationNums
	}
	return 0
}

func (m *TableDescriptor) GetIsHashPartition() bool {
	if m != nil {
		return m.IsHashPartition
	}
	return false
}

func (m *TableDescriptor) GetHashParts() int32 {
	if m != nil {
		return m.HashParts
	}
	return 0
}

func (m *TableDescriptor) GetHashField() string {
	if m != nil {
		return m.HashField
	}
	return ""
}

func (m *TableDescriptor) GetEngineTypeSetMap() map[uint32]*TableDescriptor_MapValue {
	if m != nil {
		return m.EngineTypeSetMap
	}
	return nil
}

func (m *TableDescriptor) GetInherits() []ID {
	if m != nil {
		return m.Inherits
	}
	return nil
}

func (m *TableDescriptor) GetInheritsBy() []ID {
	if m != nil {
		return m.InheritsBy
	}
	return nil
}

func (m *TableDescriptor) GetTemporary() bool {
	if m != nil {
		return m.Temporary
	}
	return false
}

func (m *TableDescriptor) GetCreateByTable() bool {
	if m != nil {
		return m.CreateByTable
	}
	return false
}

func (m *TableDescriptor) GetMaxColumnID() int32 {
	if m != nil {
		return m.MaxColumnID
	}
	return 0
}

func (m *TableDescriptor) GetViewUpdatable() bool {
	if m != nil {
		return m.ViewUpdatable
	}
	return false
}

func (m *TableDescriptor) GetViewDependsOn() uint32 {
	if m != nil {
		return m.ViewDependsOn
	}
	return 0
}

func (m *TableDescriptor) GetComments() string {
	if m != nil {
		return m.Comments
	}
	return ""
}

func (m *TableDescriptor) GetIsMaterializedView() bool {
	if m != nil {
		return m.IsMaterializedView
	}
	return false
}

func (m *TableDescriptor) GetCreateQuery() string {
	if m != nil {
		return m.CreateQuery
	}
	return ""
}

func (m *TableDescriptor) GetCreateAsOfTime() hlc.Timestamp {
	if m != nil {
		return m.CreateAsOfTime
	}
	return hlc.Timestamp{}
}

// The schema update lease. A single goroutine across a znbase cluster
// can own it, and will execute pending schema changes for this table.
// Since the execution of a pending schema change is through transactions,
// it is legal for more than one goroutine to attempt to execute it. This
// lease reduces write contention on the schema change.
type TableDescriptor_SchemaChangeLease struct {
	NodeID github_com_znbasedb_znbase_pkg_roachpb.NodeID `protobuf:"varint,1,opt,name=node_id,json=nodeId,casttype=github.com/znbasedb/znbase/pkg/roachpb.NodeID" json:"node_id"`
	// Nanoseconds since the Unix epoch.
	ExpirationTime int64 `protobuf:"varint,2,opt,name=expiration_time,json=expirationTime" json:"expiration_time"`
}

func (m *TableDescriptor_SchemaChangeLease) Reset()         { *m = TableDescriptor_SchemaChangeLease{} }
func (m *TableDescriptor_SchemaChangeLease) String() string { return proto.CompactTextString(m) }
func (*TableDescriptor_SchemaChangeLease) ProtoMessage()    {}
func (*TableDescriptor_SchemaChangeLease) Descriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{12, 0}
}
func (m *TableDescriptor_SchemaChangeLease) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableDescriptor_SchemaChangeLease) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *TableDescriptor_SchemaChangeLease) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableDescriptor_SchemaChangeLease.Merge(dst, src)
}
func (m *TableDescriptor_SchemaChangeLease) XXX_Size() int {
	return m.Size()
}
func (m *TableDescriptor_SchemaChangeLease) XXX_DiscardUnknown() {
	xxx_messageInfo_TableDescriptor_SchemaChangeLease.DiscardUnknown(m)
}

var xxx_messageInfo_TableDescriptor_SchemaChangeLease proto.InternalMessageInfo

type TableDescriptor_CheckConstraint struct {
	Expr     string             `protobuf:"bytes,1,opt,name=expr" json:"expr"`
	Name     string             `protobuf:"bytes,2,opt,name=name" json:"name"`
	Validity ConstraintValidity `protobuf:"varint,3,opt,name=validity,enum=znbase.sql.sqlbase.ConstraintValidity" json:"validity"`
	// An ordered list of column IDs used by the check constraint.
	ColumnIDs  []ColumnID `protobuf:"varint,5,rep,name=column_ids,json=columnIds,casttype=ColumnID" json:"column_ids,omitempty"`
	Able       bool       `protobuf:"varint,6,opt,name=able" json:"able"`
	IsInherits bool       `protobuf:"varint,7,opt,name=is_inherits,json=isInherits" json:"is_inherits"`
	InhCount   uint32     `protobuf:"varint,8,opt,name=inh_count,json=inhCount" json:"inh_count"`
}

func (m *TableDescriptor_CheckConstraint) Reset()         { *m = TableDescriptor_CheckConstraint{} }
func (m *TableDescriptor_CheckConstraint) String() string { return proto.CompactTextString(m) }
func (*TableDescriptor_CheckConstraint) ProtoMessage()    {}
func (*TableDescriptor_CheckConstraint) Descriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{12, 1}
}
func (m *TableDescriptor_CheckConstraint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableDescriptor_CheckConstraint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *TableDescriptor_CheckConstraint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableDescriptor_CheckConstraint.Merge(dst, src)
}
func (m *TableDescriptor_CheckConstraint) XXX_Size() int {
	return m.Size()
}
func (m *TableDescriptor_CheckConstraint) XXX_DiscardUnknown() {
	xxx_messageInfo_TableDescriptor_CheckConstraint.DiscardUnknown(m)
}

var xxx_messageInfo_TableDescriptor_CheckConstraint proto.InternalMessageInfo

// A table descriptor is named through a name map stored in the
// system.namespace table: a map from {parent_id, table_name} -> id.
// This name map can be cached for performance on a node in the cluster
// making reassigning a name complicated. In particular, since a
// name cannot be withdrawn across a cluster in a transaction at
// timestamp T, we have to worry about the following:
//
// 1. A table is dropped at T, and the name and descriptor are still
// cached and used by transactions at timestamps >= T.
// 2. A table is renamed from foo to bar at T, and both names foo and bar
// can be used by transactions at timestamps >= T.
// 3. A name foo is reassigned from one table to another at T, and the name
// foo can reference two different tables at timestamps >= T.
//
// The system ensures that a name can be resolved only to a single
// descriptor at a timestamp thereby permitting 1 and 2, but not 3
// (the name references two tables).
//
// The transaction at T is followed by a time period when names no longer
// a part of the namespace are drained from the system. Once the old name
// is drained from the system another transaction at timestamp S is
// executed to release the name for future use. The interval from T to S
// is called the name drain interval: If the T transaction is removing
// the name foo then, at timestamps above S, foo can no longer be resolved.
//
// Consider a transaction at T in which name B is dropped, a new name C is
// created. Name C is viable as soon as the transaction commits.
// When the transaction at S commits, the name B is released for reuse.
//
// The transaction at S runs through the schema changer, with the system
// returning a response to the client initiating transaction T only after
// transaction at S is committed. So effectively the SQL transaction once
// it returns can be followed by SQL transactions that do not observe
// old name mappings.
//
// Note: an exception to this is #19925 which needs to be fixed.
//
// In order for transaction at S to act properly the system.namespace
// table entry for an old name references the descriptor who was the
// prior owner of the name requiring draining.
//
// Before T:   B -> Desc B
//
// After T and before S: B -> Desc B, C -> Desc C
//
// After S: C -> Desc C
//
// Between T and S the name B is drained and the system is unable
// to assign it to another descriptor.
//
// BEGIN;
// RENAME foo TO bar;
// CREATE foo;
//
// will fail because CREATE foo is executed at T.
//
// RENAME foo TO bar;
// CREATE foo;
//
// will succeed because the RENAME returns after S and CREATE foo is
// executed after S.
//
// The above scheme suffers from the problem that a transaction can observe
// the partial effect of a committed transaction during the drain interval.
// For instance during the drain interval a transaction can see the correct
// assignment for C, and the old assignments for B.
//
type TableDescriptor_NameInfo struct {
	// The database that the table belonged to before the rename (tables can be
	// renamed from one db to another).
	ParentID ID     `protobuf:"varint,1,opt,name=parent_id,json=parentId,casttype=ID" json:"parent_id"`
	Name     string `protobuf:"bytes,2,opt,name=name" json:"name"`
}

func (m *TableDescriptor_NameInfo) Reset()         { *m = TableDescriptor_NameInfo{} }
func (m *TableDescriptor_NameInfo) String() string { return proto.CompactTextString(m) }
func (*TableDescriptor_NameInfo) ProtoMessage()    {}
func (*TableDescriptor_NameInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{12, 2}
}
func (m *TableDescriptor_NameInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableDescriptor_NameInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *TableDescriptor_NameInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableDescriptor_NameInfo.Merge(dst, src)
}
func (m *TableDescriptor_NameInfo) XXX_Size() int {
	return m.Size()
}
func (m *TableDescriptor_NameInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TableDescriptor_NameInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TableDescriptor_NameInfo proto.InternalMessageInfo

type TableDescriptor_Reference struct {
	// The ID of the relation that depends on this one.
	ID ID `protobuf:"varint,1,opt,name=id,casttype=ID" json:"id"`
	// If applicable, the ID of this table's index that is referenced by the
	// dependent relation.
	IndexID IndexID `protobuf:"varint,2,opt,name=index_id,json=indexId,casttype=IndexID" json:"index_id"`
	// The IDs of this table's columns that are referenced by the dependent
	// relation.
	ColumnIDs []ColumnID `protobuf:"varint,3,rep,name=column_ids,json=columnIds,casttype=ColumnID" json:"column_ids,omitempty"`
}

func (m *TableDescriptor_Reference) Reset()         { *m = TableDescriptor_Reference{} }
func (m *TableDescriptor_Reference) String() string { return proto.CompactTextString(m) }
func (*TableDescriptor_Reference) ProtoMessage()    {}
func (*TableDescriptor_Reference) Descriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{12, 3}
}
func (m *TableDescriptor_Reference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableDescriptor_Reference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *TableDescriptor_Reference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableDescriptor_Reference.Merge(dst, src)
}
func (m *TableDescriptor_Reference) XXX_Size() int {
	return m.Size()
}
func (m *TableDescriptor_Reference) XXX_DiscardUnknown() {
	xxx_messageInfo_TableDescriptor_Reference.DiscardUnknown(m)
}

var xxx_messageInfo_TableDescriptor_Reference proto.InternalMessageInfo

type TableDescriptor_MutationJob struct {
	// The mutation id of this mutation job.
	MutationID MutationID `protobuf:"varint,1,opt,name=mutation_id,json=mutationId,casttype=MutationID" json:"mutation_id"`
	// The job id for a mutation job is the id in the system.jobs table of the
	// schema change job executing the mutation referenced by mutation_id.
	JobID int64 `protobuf:"varint,2,opt,name=job_id,json=jobId" json:"job_id"`
}

func (m *TableDescriptor_MutationJob) Reset()         { *m = TableDescriptor_MutationJob{} }
func (m *TableDescriptor_MutationJob) String() string { return proto.CompactTextString(m) }
func (*TableDescriptor_MutationJob) ProtoMessage()    {}
func (*TableDescriptor_MutationJob) Descriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{12, 4}
}
func (m *TableDescriptor_MutationJob) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableDescriptor_MutationJob) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *TableDescriptor_MutationJob) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableDescriptor_MutationJob.Merge(dst, src)
}
func (m *TableDescriptor_MutationJob) XXX_Size() int {
	return m.Size()
}
func (m *TableDescriptor_MutationJob) XXX_DiscardUnknown() {
	xxx_messageInfo_TableDescriptor_MutationJob.DiscardUnknown(m)
}

var xxx_messageInfo_TableDescriptor_MutationJob proto.InternalMessageInfo

type TableDescriptor_SequenceOpts struct {
	// How much to increment the sequence by when nextval() is called.
	Increment int64 `protobuf:"varint,1,opt,name=increment" json:"increment"`
	// Minimum value of the sequence.
	MinValue int64 `protobuf:"varint,2,opt,name=min_value,json=minValue" json:"min_value"`
	// Maximum value of the sequence.
	MaxValue int64 `protobuf:"varint,3,opt,name=max_value,json=maxValue" json:"max_value"`
	// Start value of the sequence.
	Start int64 `protobuf:"varint,4,opt,name=start" json:"start"`
	// Whether the sequence is virtual.
	Virtual bool `protobuf:"varint,5,opt,name=virtual" json:"virtual"`
	// Sequence Cache
	Cache int64 `protobuf:"varint,6,opt,name=cache" json:"cache"`
	// Whether the sequence is cycle.
	Cycle bool `protobuf:"varint,7,opt,name=cycle" json:"cycle"`
	// Whether has ever been over the maxval.
	EverOver bool `protobuf:"varint,8,opt,name=ever_over,json=everOver" json:"ever_over"`
	// Whether has ever call nextval.
	IsCall        bool                                       `protobuf:"varint,9,opt,name=is_call,json=isCall" json:"is_call"`
	SequenceOwner TableDescriptor_SequenceOpts_SequenceOwner `protobuf:"bytes,10,opt,name=sequence_owner,json=sequenceOwner" json:"sequence_owner"`
}

func (m *TableDescriptor_SequenceOpts) Reset()         { *m = TableDescriptor_SequenceOpts{} }
func (m *TableDescriptor_SequenceOpts) String() string { return proto.CompactTextString(m) }
func (*TableDescriptor_SequenceOpts) ProtoMessage()    {}
func (*TableDescriptor_SequenceOpts) Descriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{12, 5}
}
func (m *TableDescriptor_SequenceOpts) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableDescriptor_SequenceOpts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *TableDescriptor_SequenceOpts) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableDescriptor_SequenceOpts.Merge(dst, src)
}
func (m *TableDescriptor_SequenceOpts) XXX_Size() int {
	return m.Size()
}
func (m *TableDescriptor_SequenceOpts) XXX_DiscardUnknown() {
	xxx_messageInfo_TableDescriptor_SequenceOpts.DiscardUnknown(m)
}

var xxx_messageInfo_TableDescriptor_SequenceOpts proto.InternalMessageInfo

type TableDescriptor_SequenceOpts_SequenceOwner struct {
	// Sequence Owner's Column ID
	OwnerColumnID ColumnID `protobuf:"varint,1,opt,name=owner_column_id,json=ownerColumnId,casttype=ColumnID" json:"owner_column_id"`
	// Sequence Owner's Table ID
	OwnerTableID ID `protobuf:"varint,2,opt,name=owner_table_id,json=ownerTableId,casttype=ID" json:"owner_table_id"`
}

func (m *TableDescriptor_SequenceOpts_SequenceOwner) Reset() {
	*m = TableDescriptor_SequenceOpts_SequenceOwner{}
}
func (m *TableDescriptor_SequenceOpts_SequenceOwner) String() string {
	return proto.CompactTextString(m)
}
func (*TableDescriptor_SequenceOpts_SequenceOwner) ProtoMessage() {}
func (*TableDescriptor_SequenceOpts_SequenceOwner) Descriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{12, 5, 0}
}
func (m *TableDescriptor_SequenceOpts_SequenceOwner) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableDescriptor_SequenceOpts_SequenceOwner) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *TableDescriptor_SequenceOpts_SequenceOwner) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableDescriptor_SequenceOpts_SequenceOwner.Merge(dst, src)
}
func (m *TableDescriptor_SequenceOpts_SequenceOwner) XXX_Size() int {
	return m.Size()
}
func (m *TableDescriptor_SequenceOpts_SequenceOwner) XXX_DiscardUnknown() {
	xxx_messageInfo_TableDescriptor_SequenceOpts_SequenceOwner.DiscardUnknown(m)
}

var xxx_messageInfo_TableDescriptor_SequenceOpts_SequenceOwner proto.InternalMessageInfo

type TableDescriptor_Replacement struct {
	ID ID `protobuf:"varint,1,opt,name=id,casttype=ID" json:"id"`
	// Time is just used for debugging purposes. It is not used in business
	// logic. It is an HLC rather than just wall time only for historical
	// reasons. Prior to 20.1 it was populated with the commit timestamp of the
	// transaction which created this replacement. In 20.1 and after it is
	// populated with the read timestamp at which the descriptor being
	// replaced was read.
	Time hlc.Timestamp `protobuf:"bytes,2,opt,name=time" json:"time"`
}

func (m *TableDescriptor_Replacement) Reset()         { *m = TableDescriptor_Replacement{} }
func (m *TableDescriptor_Replacement) String() string { return proto.CompactTextString(m) }
func (*TableDescriptor_Replacement) ProtoMessage()    {}
func (*TableDescriptor_Replacement) Descriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{12, 6}
}
func (m *TableDescriptor_Replacement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableDescriptor_Replacement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *TableDescriptor_Replacement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableDescriptor_Replacement.Merge(dst, src)
}
func (m *TableDescriptor_Replacement) XXX_Size() int {
	return m.Size()
}
func (m *TableDescriptor_Replacement) XXX_DiscardUnknown() {
	xxx_messageInfo_TableDescriptor_Replacement.DiscardUnknown(m)
}

var xxx_messageInfo_TableDescriptor_Replacement proto.InternalMessageInfo

type TableDescriptor_GCDescriptorMutation struct {
	IndexID  IndexID `protobuf:"varint,1,opt,name=index_id,json=indexId,casttype=IndexID" json:"index_id"`
	DropTime int64   `protobuf:"varint,2,opt,name=drop_time,json=dropTime" json:"drop_time"` // Deprecated: Do not use.
	// The job id for a mutation job is the id in the system.jobs table of the
	// schema change job executing the mutation referenced by mutation_id.
	JobID int64 `protobuf:"varint,3,opt,name=job_id,json=jobId" json:"job_id"` // Deprecated: Do not use.
}

func (m *TableDescriptor_GCDescriptorMutation) Reset()         { *m = TableDescriptor_GCDescriptorMutation{} }
func (m *TableDescriptor_GCDescriptorMutation) String() string { return proto.CompactTextString(m) }
func (*TableDescriptor_GCDescriptorMutation) ProtoMessage()    {}
func (*TableDescriptor_GCDescriptorMutation) Descriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{12, 7}
}
func (m *TableDescriptor_GCDescriptorMutation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableDescriptor_GCDescriptorMutation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *TableDescriptor_GCDescriptorMutation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableDescriptor_GCDescriptorMutation.Merge(dst, src)
}
func (m *TableDescriptor_GCDescriptorMutation) XXX_Size() int {
	return m.Size()
}
func (m *TableDescriptor_GCDescriptorMutation) XXX_DiscardUnknown() {
	xxx_messageInfo_TableDescriptor_GCDescriptorMutation.DiscardUnknown(m)
}

var xxx_messageInfo_TableDescriptor_GCDescriptorMutation proto.InternalMessageInfo

type TableDescriptor_MapValue struct {
	Value []string `protobuf:"bytes,1,rep,name=value" json:"value,omitempty"`
}

func (m *TableDescriptor_MapValue) Reset()         { *m = TableDescriptor_MapValue{} }
func (m *TableDescriptor_MapValue) String() string { return proto.CompactTextString(m) }
func (*TableDescriptor_MapValue) ProtoMessage()    {}
func (*TableDescriptor_MapValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{12, 9}
}
func (m *TableDescriptor_MapValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableDescriptor_MapValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *TableDescriptor_MapValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableDescriptor_MapValue.Merge(dst, src)
}
func (m *TableDescriptor_MapValue) XXX_Size() int {
	return m.Size()
}
func (m *TableDescriptor_MapValue) XXX_DiscardUnknown() {
	xxx_messageInfo_TableDescriptor_MapValue.DiscardUnknown(m)
}

var xxx_messageInfo_TableDescriptor_MapValue proto.InternalMessageInfo

// DatabaseDescriptor represents a namespace (aka database) and is stored
// in a structured metadata key. The DatabaseDescriptor has a globally-unique
// ID shared with the TableDescriptor ID.
// Permissions are applied to all tables in the namespace.
type DatabaseDescriptor struct {
	Name       string               `protobuf:"bytes,1,opt,name=name" json:"name"`
	ID         ID                   `protobuf:"varint,2,opt,name=id,casttype=ID" json:"id"`
	Privileges *PrivilegeDescriptor `protobuf:"bytes,3,opt,name=privileges" json:"privileges,omitempty"`
	Schemas    []SchemaDescriptor   `protobuf:"bytes,4,rep,name=schemas" json:"schemas"`
}

func (m *DatabaseDescriptor) Reset()         { *m = DatabaseDescriptor{} }
func (m *DatabaseDescriptor) String() string { return proto.CompactTextString(m) }
func (*DatabaseDescriptor) ProtoMessage()    {}
func (*DatabaseDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{13}
}
func (m *DatabaseDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *DatabaseDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseDescriptor.Merge(dst, src)
}
func (m *DatabaseDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *DatabaseDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseDescriptor proto.InternalMessageInfo

func (m *DatabaseDescriptor) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DatabaseDescriptor) GetID() ID {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *DatabaseDescriptor) GetPrivileges() *PrivilegeDescriptor {
	if m != nil {
		return m.Privileges
	}
	return nil
}

func (m *DatabaseDescriptor) GetSchemas() []SchemaDescriptor {
	if m != nil {
		return m.Schemas
	}
	return nil
}

// Descriptor is a union type holding either a table or database descriptor.
type Descriptor struct {
	// Types that are valid to be assigned to Union:
	//	*Descriptor_Table
	//	*Descriptor_Database
	//	*Descriptor_Schema
	//	*Descriptor_Function
	Union isDescriptor_Union `protobuf_oneof:"union"`
}

func (m *Descriptor) Reset()         { *m = Descriptor{} }
func (m *Descriptor) String() string { return proto.CompactTextString(m) }
func (*Descriptor) ProtoMessage()    {}
func (*Descriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{14}
}
func (m *Descriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Descriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *Descriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Descriptor.Merge(dst, src)
}
func (m *Descriptor) XXX_Size() int {
	return m.Size()
}
func (m *Descriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_Descriptor.DiscardUnknown(m)
}

var xxx_messageInfo_Descriptor proto.InternalMessageInfo

type isDescriptor_Union interface {
	isDescriptor_Union()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Descriptor_Table struct {
	Table *TableDescriptor `protobuf:"bytes,1,opt,name=table,oneof"`
}
type Descriptor_Database struct {
	Database *DatabaseDescriptor `protobuf:"bytes,2,opt,name=database,oneof"`
}
type Descriptor_Schema struct {
	Schema *SchemaDescriptor `protobuf:"bytes,3,opt,name=schema,oneof"`
}
type Descriptor_Function struct {
	Function *FunctionDescriptor `protobuf:"bytes,4,opt,name=function,oneof"`
}

func (*Descriptor_Table) isDescriptor_Union()    {}
func (*Descriptor_Database) isDescriptor_Union() {}
func (*Descriptor_Schema) isDescriptor_Union()   {}
func (*Descriptor_Function) isDescriptor_Union() {}

func (m *Descriptor) GetUnion() isDescriptor_Union {
	if m != nil {
		return m.Union
	}
	return nil
}

func (m *Descriptor) GetTable() *TableDescriptor {
	if x, ok := m.GetUnion().(*Descriptor_Table); ok {
		return x.Table
	}
	return nil
}

func (m *Descriptor) GetDatabase() *DatabaseDescriptor {
	if x, ok := m.GetUnion().(*Descriptor_Database); ok {
		return x.Database
	}
	return nil
}

func (m *Descriptor) GetSchema() *SchemaDescriptor {
	if x, ok := m.GetUnion().(*Descriptor_Schema); ok {
		return x.Schema
	}
	return nil
}

func (m *Descriptor) GetFunction() *FunctionDescriptor {
	if x, ok := m.GetUnion().(*Descriptor_Function); ok {
		return x.Function
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Descriptor) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Descriptor_OneofMarshaler, _Descriptor_OneofUnmarshaler, _Descriptor_OneofSizer, []interface{}{
		(*Descriptor_Table)(nil),
		(*Descriptor_Database)(nil),
		(*Descriptor_Schema)(nil),
		(*Descriptor_Function)(nil),
	}
}

func _Descriptor_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Descriptor)
	// union
	switch x := m.Union.(type) {
	case *Descriptor_Table:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Table); err != nil {
			return err
		}
	case *Descriptor_Database:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Database); err != nil {
			return err
		}
	case *Descriptor_Schema:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Schema); err != nil {
			return err
		}
	case *Descriptor_Function:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Function); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Descriptor.Union has unexpected type %T", x)
	}
	return nil
}

func _Descriptor_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Descriptor)
	switch tag {
	case 1: // union.table
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TableDescriptor)
		err := b.DecodeMessage(msg)
		m.Union = &Descriptor_Table{msg}
		return true, err
	case 2: // union.database
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DatabaseDescriptor)
		err := b.DecodeMessage(msg)
		m.Union = &Descriptor_Database{msg}
		return true, err
	case 3: // union.schema
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SchemaDescriptor)
		err := b.DecodeMessage(msg)
		m.Union = &Descriptor_Schema{msg}
		return true, err
	case 4: // union.function
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FunctionDescriptor)
		err := b.DecodeMessage(msg)
		m.Union = &Descriptor_Function{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Descriptor_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Descriptor)
	// union
	switch x := m.Union.(type) {
	case *Descriptor_Table:
		s := proto.Size(x.Table)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Descriptor_Database:
		s := proto.Size(x.Database)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Descriptor_Schema:
		s := proto.Size(x.Schema)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Descriptor_Function:
		s := proto.Size(x.Function)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type SchemaDescriptor struct {
	Name       string               `protobuf:"bytes,1,opt,name=name" json:"name"`
	ID         ID                   `protobuf:"varint,2,opt,name=id,casttype=ID" json:"id"`
	Privileges *PrivilegeDescriptor `protobuf:"bytes,3,opt,name=privileges" json:"privileges,omitempty"`
	// ID of the parent database.
	ParentID ID `protobuf:"varint,4,opt,name=parent_id,json=parentId,casttype=ID" json:"parent_id"`
}

func (m *SchemaDescriptor) Reset()         { *m = SchemaDescriptor{} }
func (m *SchemaDescriptor) String() string { return proto.CompactTextString(m) }
func (*SchemaDescriptor) ProtoMessage()    {}
func (*SchemaDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{15}
}
func (m *SchemaDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *SchemaDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaDescriptor.Merge(dst, src)
}
func (m *SchemaDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *SchemaDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaDescriptor proto.InternalMessageInfo

func (m *SchemaDescriptor) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SchemaDescriptor) GetID() ID {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *SchemaDescriptor) GetPrivileges() *PrivilegeDescriptor {
	if m != nil {
		return m.Privileges
	}
	return nil
}

func (m *SchemaDescriptor) GetParentID() ID {
	if m != nil {
		return m.ParentID
	}
	return 0
}

type FunctionTriggerType struct {
}

func (m *FunctionTriggerType) Reset()         { *m = FunctionTriggerType{} }
func (m *FunctionTriggerType) String() string { return proto.CompactTextString(m) }
func (*FunctionTriggerType) ProtoMessage()    {}
func (*FunctionTriggerType) Descriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{16}
}
func (m *FunctionTriggerType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FunctionTriggerType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *FunctionTriggerType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FunctionTriggerType.Merge(dst, src)
}
func (m *FunctionTriggerType) XXX_Size() int {
	return m.Size()
}
func (m *FunctionTriggerType) XXX_DiscardUnknown() {
	xxx_messageInfo_FunctionTriggerType.DiscardUnknown(m)
}

var xxx_messageInfo_FunctionTriggerType proto.InternalMessageInfo

type FuncArgDescriptor struct {
	Name             string                    `protobuf:"bytes,1,opt,name=name" json:"name"`
	ID               ColumnID                  `protobuf:"varint,2,opt,name=id,casttype=ColumnID" json:"id"`
	Oid              github_com_lib_pq_oid.Oid `protobuf:"varint,8,opt,name=oid,casttype=github.com/lib/pq/oid.Oid" json:"oid"`
	Type             ColumnType                `protobuf:"bytes,3,opt,name=type" json:"type"`
	ColumnTypeString string                    `protobuf:"bytes,4,opt,name=columnTypeString" json:"columnTypeString"`
	Nullable         bool                      `protobuf:"varint,5,opt,name=nullable" json:"nullable"`
	// Expression to use to compute the value of this column if this is a
	// computed column.
	ComputeExpr string `protobuf:"bytes,6,opt,name=compute_expr,json=computeExpr" json:"compute_expr"`
	InOutMode   string `protobuf:"bytes,7,opt,name=inOutMode" json:"inOutMode"`
}

func (m *FuncArgDescriptor) Reset()         { *m = FuncArgDescriptor{} }
func (m *FuncArgDescriptor) String() string { return proto.CompactTextString(m) }
func (*FuncArgDescriptor) ProtoMessage()    {}
func (*FuncArgDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{17}
}
func (m *FuncArgDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FuncArgDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *FuncArgDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FuncArgDescriptor.Merge(dst, src)
}
func (m *FuncArgDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *FuncArgDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_FuncArgDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_FuncArgDescriptor proto.InternalMessageInfo

type FunctionDescriptor struct {
	Name       string               `protobuf:"bytes,1,opt,name=name" json:"name"`
	ID         ID                   `protobuf:"varint,2,opt,name=id,casttype=ID" json:"id"`
	Privileges *PrivilegeDescriptor `protobuf:"bytes,3,opt,name=privileges" json:"privileges,omitempty"`
	// ID of the parent database.
	ParentID      ID                            `protobuf:"varint,4,opt,name=parent_id,json=parentId,casttype=ID" json:"parent_id"`
	TxnID         ID                            `protobuf:"varint,5,opt,name=transactionId,casttype=ID" json:"transactionId"`
	Version       DescriptorVersion             `protobuf:"varint,6,opt,name=version,casttype=DescriptorVersion" json:"version"`
	Args          []FuncArgDescriptor           `protobuf:"bytes,7,rep,name=args" json:"args"`
	ArgNum        uint32                        `protobuf:"varint,8,opt,name=argNum" json:"argNum"`
	IsProcedure   bool                          `protobuf:"varint,9,opt,name=isProcedure" json:"isProcedure"`
	TriggerType   FunctionTriggerType           `protobuf:"bytes,10,opt,name=triggerType" json:"triggerType"`
	ReturnType    string                        `protobuf:"bytes,11,opt,name=returnType" json:"returnType"`
	RetOid        github_com_lib_pq_oid.Oid     `protobuf:"varint,12,opt,name=retOid,casttype=github.com/lib/pq/oid.Oid" json:"retOid"`
	Language      string                        `protobuf:"bytes,13,opt,name=language" json:"language"`
	State         FunctionDescriptor_State      `protobuf:"varint,15,opt,name=state,enum=znbase.sql.sqlbase.FunctionDescriptor_State" json:"state"`
	FuncDef       string                        `protobuf:"bytes,16,opt,name=funcDef" json:"funcDef"`
	DrainingNames []FunctionDescriptor_NameInfo `protobuf:"bytes,17,rep,name=draining_names,json=drainingNames" json:"draining_names"`
	DropTime      int64                         `protobuf:"varint,18,opt,name=drop_time,json=dropTime" json:"drop_time"`
	FullFuncName  string                        `protobuf:"bytes,19,opt,name=fullFuncName" json:"fullFuncName"`
	DropJobID     int64                         `protobuf:"varint,20,opt,name=drop_job_id,json=dropJobId" json:"drop_job_id"`
	// Mutation jobs queued for execution in a FIFO order. Remains synchronized
	// with the mutations list.
	MutationJobs []FunctionDescriptor_MutationJob `protobuf:"bytes,21,rep,name=mutationJobs" json:"mutationJobs"`
	// The schema elements that have been dropped and whose underlying
	// data needs to be gc-ed. These schema elements have already transitioned
	// through the drop state machine when they were in the above mutations
	// list, and can be safely deleted. The names for these schema elements
	// can be reused. This list is separate because mutations can
	// lie in this list for a long time (gc deadline) and should not block
	// the execution of other schema changes on the function.
	//
	// TODO(vivekmenezes): This is currently only used by the non-interleaved drop
	// index case. Also use for dropped interleaved indexes and columns.
	GCMutations      []FunctionDescriptor_GCDescriptorMutation `protobuf:"bytes,22,rep,name=gc_mutations,json=gcMutations" json:"gc_mutations"`
	Hashsql          string                                    `protobuf:"bytes,23,opt,name=hashsql" json:"hashsql"`
	FilePath         string                                    `protobuf:"bytes,24,opt,name=file_path,json=filePath" json:"file_path"`
	FileName         string                                    `protobuf:"bytes,25,opt,name=file_name,json=fileName" json:"file_name"`
	ModificationTime hlc.Timestamp                             `protobuf:"bytes,26,opt,name=ModificationTime" json:"ModificationTime"`
}

func (m *FunctionDescriptor) Reset()         { *m = FunctionDescriptor{} }
func (m *FunctionDescriptor) String() string { return proto.CompactTextString(m) }
func (*FunctionDescriptor) ProtoMessage()    {}
func (*FunctionDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{18}
}
func (m *FunctionDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FunctionDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *FunctionDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FunctionDescriptor.Merge(dst, src)
}
func (m *FunctionDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *FunctionDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_FunctionDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_FunctionDescriptor proto.InternalMessageInfo

func (m *FunctionDescriptor) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FunctionDescriptor) GetID() ID {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *FunctionDescriptor) GetPrivileges() *PrivilegeDescriptor {
	if m != nil {
		return m.Privileges
	}
	return nil
}

func (m *FunctionDescriptor) GetParentID() ID {
	if m != nil {
		return m.ParentID
	}
	return 0
}

func (m *FunctionDescriptor) GetTxnID() ID {
	if m != nil {
		return m.TxnID
	}
	return 0
}

func (m *FunctionDescriptor) GetVersion() DescriptorVersion {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *FunctionDescriptor) GetArgs() []FuncArgDescriptor {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *FunctionDescriptor) GetArgNum() uint32 {
	if m != nil {
		return m.ArgNum
	}
	return 0
}

func (m *FunctionDescriptor) GetIsProcedure() bool {
	if m != nil {
		return m.IsProcedure
	}
	return false
}

func (m *FunctionDescriptor) GetTriggerType() FunctionTriggerType {
	if m != nil {
		return m.TriggerType
	}
	return FunctionTriggerType{}
}

func (m *FunctionDescriptor) GetReturnType() string {
	if m != nil {
		return m.ReturnType
	}
	return ""
}

func (m *FunctionDescriptor) GetRetOid() github_com_lib_pq_oid.Oid {
	if m != nil {
		return m.RetOid
	}
	return 0
}

func (m *FunctionDescriptor) GetLanguage() string {
	if m != nil {
		return m.Language
	}
	return ""
}

func (m *FunctionDescriptor) GetState() FunctionDescriptor_State {
	if m != nil {
		return m.State
	}
	return FunctionDescriptor_PUBLIC
}

func (m *FunctionDescriptor) GetFuncDef() string {
	if m != nil {
		return m.FuncDef
	}
	return ""
}

func (m *FunctionDescriptor) GetDrainingNames() []FunctionDescriptor_NameInfo {
	if m != nil {
		return m.DrainingNames
	}
	return nil
}

func (m *FunctionDescriptor) GetDropTime() int64 {
	if m != nil {
		return m.DropTime
	}
	return 0
}

func (m *FunctionDescriptor) GetFullFuncName() string {
	if m != nil {
		return m.FullFuncName
	}
	return ""
}

func (m *FunctionDescriptor) GetDropJobID() int64 {
	if m != nil {
		return m.DropJobID
	}
	return 0
}

func (m *FunctionDescriptor) GetMutationJobs() []FunctionDescriptor_MutationJob {
	if m != nil {
		return m.MutationJobs
	}
	return nil
}

func (m *FunctionDescriptor) GetGCMutations() []FunctionDescriptor_GCDescriptorMutation {
	if m != nil {
		return m.GCMutations
	}
	return nil
}

func (m *FunctionDescriptor) GetHashsql() string {
	if m != nil {
		return m.Hashsql
	}
	return ""
}

func (m *FunctionDescriptor) GetFilePath() string {
	if m != nil {
		return m.FilePath
	}
	return ""
}

func (m *FunctionDescriptor) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *FunctionDescriptor) GetModificationTime() hlc.Timestamp {
	if m != nil {
		return m.ModificationTime
	}
	return hlc.Timestamp{}
}

type FunctionDescriptor_NameInfo struct {
	// The database that the function belonged to before the rename (functions can be
	// renamed from one db to another).
	ParentID ID     `protobuf:"varint,1,opt,name=parent_id,json=parentId,casttype=ID" json:"parent_id"`
	Name     string `protobuf:"bytes,2,opt,name=name" json:"name"`
}

func (m *FunctionDescriptor_NameInfo) Reset()         { *m = FunctionDescriptor_NameInfo{} }
func (m *FunctionDescriptor_NameInfo) String() string { return proto.CompactTextString(m) }
func (*FunctionDescriptor_NameInfo) ProtoMessage()    {}
func (*FunctionDescriptor_NameInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{18, 0}
}
func (m *FunctionDescriptor_NameInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FunctionDescriptor_NameInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *FunctionDescriptor_NameInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FunctionDescriptor_NameInfo.Merge(dst, src)
}
func (m *FunctionDescriptor_NameInfo) XXX_Size() int {
	return m.Size()
}
func (m *FunctionDescriptor_NameInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FunctionDescriptor_NameInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FunctionDescriptor_NameInfo proto.InternalMessageInfo

type FunctionDescriptor_MutationJob struct {
	// The mutation id of this mutation job.
	MutationID MutationID `protobuf:"varint,1,opt,name=mutation_id,json=mutationId,casttype=MutationID" json:"mutation_id"`
	// The job id for a mutation job is the id in the system.jobs table of the
	// schema change job executing the mutation referenced by mutation_id.
	JobID int64 `protobuf:"varint,2,opt,name=job_id,json=jobId" json:"job_id"`
}

func (m *FunctionDescriptor_MutationJob) Reset()         { *m = FunctionDescriptor_MutationJob{} }
func (m *FunctionDescriptor_MutationJob) String() string { return proto.CompactTextString(m) }
func (*FunctionDescriptor_MutationJob) ProtoMessage()    {}
func (*FunctionDescriptor_MutationJob) Descriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{18, 1}
}
func (m *FunctionDescriptor_MutationJob) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FunctionDescriptor_MutationJob) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *FunctionDescriptor_MutationJob) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FunctionDescriptor_MutationJob.Merge(dst, src)
}
func (m *FunctionDescriptor_MutationJob) XXX_Size() int {
	return m.Size()
}
func (m *FunctionDescriptor_MutationJob) XXX_DiscardUnknown() {
	xxx_messageInfo_FunctionDescriptor_MutationJob.DiscardUnknown(m)
}

var xxx_messageInfo_FunctionDescriptor_MutationJob proto.InternalMessageInfo

type FunctionDescriptor_GCDescriptorMutation struct {
	IndexID  IndexID `protobuf:"varint,1,opt,name=index_id,json=indexId,casttype=IndexID" json:"index_id"`
	DropTime int64   `protobuf:"varint,2,opt,name=drop_time,json=dropTime" json:"drop_time"`
	// The job id for a mutation job is the id in the system.jobs function of the
	// schema change job executing the mutation referenced by mutation_id.
	JobID int64 `protobuf:"varint,3,opt,name=job_id,json=jobId" json:"job_id"`
}

func (m *FunctionDescriptor_GCDescriptorMutation) Reset() {
	*m = FunctionDescriptor_GCDescriptorMutation{}
}
func (m *FunctionDescriptor_GCDescriptorMutation) String() string { return proto.CompactTextString(m) }
func (*FunctionDescriptor_GCDescriptorMutation) ProtoMessage()    {}
func (*FunctionDescriptor_GCDescriptorMutation) Descriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{18, 2}
}
func (m *FunctionDescriptor_GCDescriptorMutation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FunctionDescriptor_GCDescriptorMutation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *FunctionDescriptor_GCDescriptorMutation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FunctionDescriptor_GCDescriptorMutation.Merge(dst, src)
}
func (m *FunctionDescriptor_GCDescriptorMutation) XXX_Size() int {
	return m.Size()
}
func (m *FunctionDescriptor_GCDescriptorMutation) XXX_DiscardUnknown() {
	xxx_messageInfo_FunctionDescriptor_GCDescriptorMutation.DiscardUnknown(m)
}

var xxx_messageInfo_FunctionDescriptor_GCDescriptorMutation proto.InternalMessageInfo

type CursorDescriptor struct {
	Name              string               `protobuf:"bytes,1,opt,name=name" json:"name"`
	ID                ID                   `protobuf:"varint,2,opt,name=id,casttype=ID" json:"id"`
	QueryString       string               `protobuf:"bytes,3,opt,name=query_string,json=queryString" json:"query_string"`
	Position          int64                `protobuf:"varint,4,opt,name=position" json:"position"`
	MaxRownum         int64                `protobuf:"varint,5,opt,name=max_rownum,json=maxRownum" json:"max_rownum"`
	Columns           []ColumnDescriptor   `protobuf:"bytes,6,rep,name=columns" json:"columns"`
	State             uint32               `protobuf:"varint,7,opt,name=state" json:"state"`
	CurVarDescriptors []VariableDescriptor `protobuf:"bytes,8,rep,name=curVarDescriptors" json:"curVarDescriptors"`
	PrimaryIndex      []string             `protobuf:"bytes,9,rep,name=primaryIndex" json:"primaryIndex,omitempty"`
	TableName         string               `protobuf:"bytes,10,opt,name=tableName" json:"tableName"`
	TxnState          string               `protobuf:"bytes,11,opt,name=txnState" json:"txnState"`
}

func (m *CursorDescriptor) Reset()         { *m = CursorDescriptor{} }
func (m *CursorDescriptor) String() string { return proto.CompactTextString(m) }
func (*CursorDescriptor) ProtoMessage()    {}
func (*CursorDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{19}
}
func (m *CursorDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CursorDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *CursorDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CursorDescriptor.Merge(dst, src)
}
func (m *CursorDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *CursorDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_CursorDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_CursorDescriptor proto.InternalMessageInfo

func (m *CursorDescriptor) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CursorDescriptor) GetID() ID {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *CursorDescriptor) GetQueryString() string {
	if m != nil {
		return m.QueryString
	}
	return ""
}

func (m *CursorDescriptor) GetPosition() int64 {
	if m != nil {
		return m.Position
	}
	return 0
}

func (m *CursorDescriptor) GetMaxRownum() int64 {
	if m != nil {
		return m.MaxRownum
	}
	return 0
}

func (m *CursorDescriptor) GetColumns() []ColumnDescriptor {
	if m != nil {
		return m.Columns
	}
	return nil
}

func (m *CursorDescriptor) GetState() uint32 {
	if m != nil {
		return m.State
	}
	return 0
}

func (m *CursorDescriptor) GetCurVarDescriptors() []VariableDescriptor {
	if m != nil {
		return m.CurVarDescriptors
	}
	return nil
}

func (m *CursorDescriptor) GetPrimaryIndex() []string {
	if m != nil {
		return m.PrimaryIndex
	}
	return nil
}

func (m *CursorDescriptor) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *CursorDescriptor) GetTxnState() string {
	if m != nil {
		return m.TxnState
	}
	return ""
}

type VariableDescriptor struct {
	Name     string           `protobuf:"bytes,1,opt,name=name" json:"name"`
	ID       ID               `protobuf:"varint,2,opt,name=id,casttype=ID" json:"id"`
	Column   ColumnDescriptor `protobuf:"bytes,3,opt,name=column" json:"column"`
	TxnState string           `protobuf:"bytes,4,opt,name=txnState" json:"txnState"`
}

func (m *VariableDescriptor) Reset()         { *m = VariableDescriptor{} }
func (m *VariableDescriptor) String() string { return proto.CompactTextString(m) }
func (*VariableDescriptor) ProtoMessage()    {}
func (*VariableDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_structured_73c01a8eb8520736, []int{20}
}
func (m *VariableDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VariableDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *VariableDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VariableDescriptor.Merge(dst, src)
}
func (m *VariableDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *VariableDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_VariableDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_VariableDescriptor proto.InternalMessageInfo

func (m *VariableDescriptor) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *VariableDescriptor) GetID() ID {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *VariableDescriptor) GetColumn() ColumnDescriptor {
	if m != nil {
		return m.Column
	}
	return ColumnDescriptor{}
}

func (m *VariableDescriptor) GetTxnState() string {
	if m != nil {
		return m.TxnState
	}
	return ""
}

func init() {
	proto.RegisterType((*ColumnType)(nil), "znbase.sql.sqlbase.ColumnType")
	proto.RegisterType((*ForeignKeyReference)(nil), "znbase.sql.sqlbase.ForeignKeyReference")
	proto.RegisterType((*ForeignKeyConstraint)(nil), "znbase.sql.sqlbase.ForeignKeyConstraint")
	proto.RegisterType((*ColumnDescriptor)(nil), "znbase.sql.sqlbase.ColumnDescriptor")
	proto.RegisterType((*ColumnFamilyDescriptor)(nil), "znbase.sql.sqlbase.ColumnFamilyDescriptor")
	proto.RegisterType((*InterleaveDescriptor)(nil), "znbase.sql.sqlbase.InterleaveDescriptor")
	proto.RegisterType((*InterleaveDescriptor_Ancestor)(nil), "znbase.sql.sqlbase.InterleaveDescriptor.Ancestor")
	proto.RegisterType((*PartitioningDescriptor)(nil), "znbase.sql.sqlbase.PartitioningDescriptor")
	proto.RegisterType((*PartitioningDescriptor_List)(nil), "znbase.sql.sqlbase.PartitioningDescriptor.List")
	proto.RegisterType((*PartitioningDescriptor_Range)(nil), "znbase.sql.sqlbase.PartitioningDescriptor.Range")
	proto.RegisterType((*IndexDescriptor)(nil), "znbase.sql.sqlbase.IndexDescriptor")
	proto.RegisterType((*ConstraintToUpdate)(nil), "znbase.sql.sqlbase.ConstraintToUpdate")
	proto.RegisterType((*PrimaryKeySwap)(nil), "znbase.sql.sqlbase.PrimaryKeySwap")
	proto.RegisterType((*MaterializedViewRefresh)(nil), "znbase.sql.sqlbase.MaterializedViewRefresh")
	proto.RegisterType((*DescriptorMutation)(nil), "znbase.sql.sqlbase.DescriptorMutation")
	proto.RegisterType((*TableDescriptor)(nil), "znbase.sql.sqlbase.TableDescriptor")
	proto.RegisterMapType((map[uint32]*TableDescriptor_MapValue)(nil), "znbase.sql.sqlbase.TableDescriptor.EngineTypeSetMapEntry")
	proto.RegisterType((*TableDescriptor_SchemaChangeLease)(nil), "znbase.sql.sqlbase.TableDescriptor.SchemaChangeLease")
	proto.RegisterType((*TableDescriptor_CheckConstraint)(nil), "znbase.sql.sqlbase.TableDescriptor.CheckConstraint")
	proto.RegisterType((*TableDescriptor_NameInfo)(nil), "znbase.sql.sqlbase.TableDescriptor.NameInfo")
	proto.RegisterType((*TableDescriptor_Reference)(nil), "znbase.sql.sqlbase.TableDescriptor.Reference")
	proto.RegisterType((*TableDescriptor_MutationJob)(nil), "znbase.sql.sqlbase.TableDescriptor.MutationJob")
	proto.RegisterType((*TableDescriptor_SequenceOpts)(nil), "znbase.sql.sqlbase.TableDescriptor.SequenceOpts")
	proto.RegisterType((*TableDescriptor_SequenceOpts_SequenceOwner)(nil), "znbase.sql.sqlbase.TableDescriptor.SequenceOpts.SequenceOwner")
	proto.RegisterType((*TableDescriptor_Replacement)(nil), "znbase.sql.sqlbase.TableDescriptor.Replacement")
	proto.RegisterType((*TableDescriptor_GCDescriptorMutation)(nil), "znbase.sql.sqlbase.TableDescriptor.GCDescriptorMutation")
	proto.RegisterType((*TableDescriptor_MapValue)(nil), "znbase.sql.sqlbase.TableDescriptor.MapValue")
	proto.RegisterType((*DatabaseDescriptor)(nil), "znbase.sql.sqlbase.DatabaseDescriptor")
	proto.RegisterType((*Descriptor)(nil), "znbase.sql.sqlbase.Descriptor")
	proto.RegisterType((*SchemaDescriptor)(nil), "znbase.sql.sqlbase.SchemaDescriptor")
	proto.RegisterType((*FunctionTriggerType)(nil), "znbase.sql.sqlbase.FunctionTriggerType")
	proto.RegisterType((*FuncArgDescriptor)(nil), "znbase.sql.sqlbase.FuncArgDescriptor")
	proto.RegisterType((*FunctionDescriptor)(nil), "znbase.sql.sqlbase.FunctionDescriptor")
	proto.RegisterType((*FunctionDescriptor_NameInfo)(nil), "znbase.sql.sqlbase.FunctionDescriptor.NameInfo")
	proto.RegisterType((*FunctionDescriptor_MutationJob)(nil), "znbase.sql.sqlbase.FunctionDescriptor.MutationJob")
	proto.RegisterType((*FunctionDescriptor_GCDescriptorMutation)(nil), "znbase.sql.sqlbase.FunctionDescriptor.GCDescriptorMutation")
	proto.RegisterType((*CursorDescriptor)(nil), "znbase.sql.sqlbase.CursorDescriptor")
	proto.RegisterType((*VariableDescriptor)(nil), "znbase.sql.sqlbase.VariableDescriptor")
	proto.RegisterEnum("znbase.sql.sqlbase.ConstraintValidity", ConstraintValidity_name, ConstraintValidity_value)
	proto.RegisterEnum("znbase.sql.sqlbase.ColumnType_SemanticType", ColumnType_SemanticType_name, ColumnType_SemanticType_value)
	proto.RegisterEnum("znbase.sql.sqlbase.ColumnType_VisibleType", ColumnType_VisibleType_name, ColumnType_VisibleType_value)
	proto.RegisterEnum("znbase.sql.sqlbase.ForeignKeyReference_Action", ForeignKeyReference_Action_name, ForeignKeyReference_Action_value)
	proto.RegisterEnum("znbase.sql.sqlbase.ForeignKeyReference_Match", ForeignKeyReference_Match_name, ForeignKeyReference_Match_value)
	proto.RegisterEnum("znbase.sql.sqlbase.IndexDescriptor_Direction", IndexDescriptor_Direction_name, IndexDescriptor_Direction_value)
	proto.RegisterEnum("znbase.sql.sqlbase.IndexDescriptor_Type", IndexDescriptor_Type_name, IndexDescriptor_Type_value)
	proto.RegisterEnum("znbase.sql.sqlbase.ConstraintToUpdate_ConstraintType", ConstraintToUpdate_ConstraintType_name, ConstraintToUpdate_ConstraintType_value)
	proto.RegisterEnum("znbase.sql.sqlbase.DescriptorMutation_State", DescriptorMutation_State_name, DescriptorMutation_State_value)
	proto.RegisterEnum("znbase.sql.sqlbase.DescriptorMutation_Direction", DescriptorMutation_Direction_name, DescriptorMutation_Direction_value)
	proto.RegisterEnum("znbase.sql.sqlbase.TableDescriptor_State", TableDescriptor_State_name, TableDescriptor_State_value)
	proto.RegisterEnum("znbase.sql.sqlbase.TableDescriptor_AuditMode", TableDescriptor_AuditMode_name, TableDescriptor_AuditMode_value)
	proto.RegisterEnum("znbase.sql.sqlbase.FunctionTriggerType_Match", FunctionTriggerType_Match_name, FunctionTriggerType_Match_value)
	proto.RegisterEnum("znbase.sql.sqlbase.FunctionDescriptor_State", FunctionDescriptor_State_name, FunctionDescriptor_State_value)
}
func (this *ForeignKeyReference) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ForeignKeyReference)
	if !ok {
		that2, ok := that.(ForeignKeyReference)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Table != that1.Table {
		return false
	}
	if this.Index != that1.Index {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Validity != that1.Validity {
		return false
	}
	if this.SharedPrefixLen != that1.SharedPrefixLen {
		return false
	}
	if this.OnDelete != that1.OnDelete {
		return false
	}
	if this.OnUpdate != that1.OnUpdate {
		return false
	}
	if this.Match != that1.Match {
		return false
	}
	return true
}
func (this *ForeignKeyConstraint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ForeignKeyConstraint)
	if !ok {
		that2, ok := that.(ForeignKeyConstraint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.OriginTableID != that1.OriginTableID {
		return false
	}
	if len(this.OriginColumnIDs) != len(that1.OriginColumnIDs) {
		return false
	}
	for i := range this.OriginColumnIDs {
		if this.OriginColumnIDs[i] != that1.OriginColumnIDs[i] {
			return false
		}
	}
	if len(this.ReferencedColumnIDs) != len(that1.ReferencedColumnIDs) {
		return false
	}
	for i := range this.ReferencedColumnIDs {
		if this.ReferencedColumnIDs[i] != that1.ReferencedColumnIDs[i] {
			return false
		}
	}
	if this.ReferencedTableID != that1.ReferencedTableID {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Validity != that1.Validity {
		return false
	}
	if this.OnDelete != that1.OnDelete {
		return false
	}
	if this.OnUpdate != that1.OnUpdate {
		return false
	}
	if this.Match != that1.Match {
		return false
	}
	if this.LegacyOriginIndex != that1.LegacyOriginIndex {
		return false
	}
	if this.LegacyReferencedIndex != that1.LegacyReferencedIndex {
		return false
	}
	if !this.LegacyUpgradedFromOriginReference.Equal(&that1.LegacyUpgradedFromOriginReference) {
		return false
	}
	if !this.LegacyUpgradedFromReferencedReference.Equal(&that1.LegacyUpgradedFromReferencedReference) {
		return false
	}
	return true
}
func (this *PartitioningDescriptor) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PartitioningDescriptor)
	if !ok {
		that2, ok := that.(PartitioningDescriptor)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NumColumns != that1.NumColumns {
		return false
	}
	if len(this.List) != len(that1.List) {
		return false
	}
	for i := range this.List {
		if !this.List[i].Equal(&that1.List[i]) {
			return false
		}
	}
	if len(this.Range) != len(that1.Range) {
		return false
	}
	for i := range this.Range {
		if !this.Range[i].Equal(&that1.Range[i]) {
			return false
		}
	}
	if this.LocationNums != that1.LocationNums {
		return false
	}
	if this.IsHashPartition != that1.IsHashPartition {
		return false
	}
	return true
}
func (this *PartitioningDescriptor_List) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PartitioningDescriptor_List)
	if !ok {
		that2, ok := that.(PartitioningDescriptor_List)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.Values) != len(that1.Values) {
		return false
	}
	for i := range this.Values {
		if !bytes.Equal(this.Values[i], that1.Values[i]) {
			return false
		}
	}
	if !this.LocateSpaceName.Equal(that1.LocateSpaceName) {
		return false
	}
	if !this.Subpartitioning.Equal(&that1.Subpartitioning) {
		return false
	}
	return true
}
func (this *PartitioningDescriptor_Range) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PartitioningDescriptor_Range)
	if !ok {
		that2, ok := that.(PartitioningDescriptor_Range)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !bytes.Equal(this.FromInclusive, that1.FromInclusive) {
		return false
	}
	if !bytes.Equal(this.ToExclusive, that1.ToExclusive) {
		return false
	}
	if !this.LocateSpaceName.Equal(that1.LocateSpaceName) {
		return false
	}
	return true
}
func (this *ConstraintToUpdate) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConstraintToUpdate)
	if !ok {
		that2, ok := that.(ConstraintToUpdate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ConstraintType != that1.ConstraintType {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !this.Check.Equal(&that1.Check) {
		return false
	}
	if !this.ForeignKey.Equal(&that1.ForeignKey) {
		return false
	}
	if this.NotNullColumn != that1.NotNullColumn {
		return false
	}
	return true
}
func (this *PrimaryKeySwap) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PrimaryKeySwap)
	if !ok {
		that2, ok := that.(PrimaryKeySwap)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.OldPrimaryIndexId != that1.OldPrimaryIndexId {
		return false
	}
	if this.NewPrimaryIndexId != that1.NewPrimaryIndexId {
		return false
	}
	if len(this.OldIndexes) != len(that1.OldIndexes) {
		return false
	}
	for i := range this.OldIndexes {
		if this.OldIndexes[i] != that1.OldIndexes[i] {
			return false
		}
	}
	if len(this.NewIndexes) != len(that1.NewIndexes) {
		return false
	}
	for i := range this.NewIndexes {
		if this.NewIndexes[i] != that1.NewIndexes[i] {
			return false
		}
	}
	if this.NewPrimaryIndexName != that1.NewPrimaryIndexName {
		return false
	}
	return true
}
func (this *TableDescriptor_CheckConstraint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TableDescriptor_CheckConstraint)
	if !ok {
		that2, ok := that.(TableDescriptor_CheckConstraint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Expr != that1.Expr {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Validity != that1.Validity {
		return false
	}
	if len(this.ColumnIDs) != len(that1.ColumnIDs) {
		return false
	}
	for i := range this.ColumnIDs {
		if this.ColumnIDs[i] != that1.ColumnIDs[i] {
			return false
		}
	}
	if this.Able != that1.Able {
		return false
	}
	if this.IsInherits != that1.IsInherits {
		return false
	}
	if this.InhCount != that1.InhCount {
		return false
	}
	return true
}
func (this *TableDescriptor_SequenceOpts_SequenceOwner) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TableDescriptor_SequenceOpts_SequenceOwner)
	if !ok {
		that2, ok := that.(TableDescriptor_SequenceOpts_SequenceOwner)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.OwnerColumnID != that1.OwnerColumnID {
		return false
	}
	if this.OwnerTableID != that1.OwnerTableID {
		return false
	}
	return true
}
func (this *TableDescriptor_GCDescriptorMutation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TableDescriptor_GCDescriptorMutation)
	if !ok {
		that2, ok := that.(TableDescriptor_GCDescriptorMutation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.IndexID != that1.IndexID {
		return false
	}
	if this.DropTime != that1.DropTime {
		return false
	}
	if this.JobID != that1.JobID {
		return false
	}
	return true
}
func (m *ColumnType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.SemanticType))
	dAtA[i] = 0x10
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.Width))
	dAtA[i] = 0x18
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.Precision))
	if len(m.ArrayDimensions) > 0 {
		for _, num := range m.ArrayDimensions {
			dAtA[i] = 0x20
			i++
			i = encodeVarintStructured(dAtA, i, uint64(num))
		}
	}
	if m.Locale != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintStructured(dAtA, i, uint64(len(*m.Locale)))
		i += copy(dAtA[i:], *m.Locale)
	}
	dAtA[i] = 0x30
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.VisibleType))
	if m.ArrayContents != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintStructured(dAtA, i, uint64(*m.ArrayContents))
	}
	if len(m.TupleContents) > 0 {
		for _, msg := range m.TupleContents {
			dAtA[i] = 0x42
			i++
			i = encodeVarintStructured(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.TupleLabels) > 0 {
		for _, s := range m.TupleLabels {
			dAtA[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	dAtA[i] = 0x52
	i++
	i = encodeVarintStructured(dAtA, i, uint64(len(m.VisibleTypeName)))
	i += copy(dAtA[i:], m.VisibleTypeName)
	if len(m.EnumContents) > 0 {
		for _, s := range m.EnumContents {
			dAtA[i] = 0x5a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.SetContents) > 0 {
		for _, s := range m.SetContents {
			dAtA[i] = 0x62
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *ForeignKeyReference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForeignKeyReference) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.Table))
	dAtA[i] = 0x10
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.Index))
	dAtA[i] = 0x1a
	i++
	i = encodeVarintStructured(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x20
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.Validity))
	dAtA[i] = 0x28
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.SharedPrefixLen))
	dAtA[i] = 0x30
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.OnDelete))
	dAtA[i] = 0x38
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.OnUpdate))
	dAtA[i] = 0x40
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.Match))
	return i, nil
}

func (m *ForeignKeyConstraint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForeignKeyConstraint) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.OriginTableID))
	if len(m.OriginColumnIDs) > 0 {
		for _, num := range m.OriginColumnIDs {
			dAtA[i] = 0x10
			i++
			i = encodeVarintStructured(dAtA, i, uint64(num))
		}
	}
	if len(m.ReferencedColumnIDs) > 0 {
		for _, num := range m.ReferencedColumnIDs {
			dAtA[i] = 0x18
			i++
			i = encodeVarintStructured(dAtA, i, uint64(num))
		}
	}
	dAtA[i] = 0x20
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.ReferencedTableID))
	dAtA[i] = 0x2a
	i++
	i = encodeVarintStructured(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x30
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.Validity))
	dAtA[i] = 0x38
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.OnDelete))
	dAtA[i] = 0x40
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.OnUpdate))
	dAtA[i] = 0x48
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.Match))
	dAtA[i] = 0x50
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.LegacyOriginIndex))
	dAtA[i] = 0x58
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.LegacyReferencedIndex))
	dAtA[i] = 0x62
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.LegacyUpgradedFromOriginReference.Size()))
	n1, err := m.LegacyUpgradedFromOriginReference.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x6a
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.LegacyUpgradedFromReferencedReference.Size()))
	n2, err := m.LegacyUpgradedFromReferencedReference.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	return i, nil
}

func (m *ColumnDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnDescriptor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintStructured(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x10
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x1a
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.Type.Size()))
	n3, err := m.Type.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x20
	i++
	if m.Nullable {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if m.DefaultExpr != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintStructured(dAtA, i, uint64(len(*m.DefaultExpr)))
		i += copy(dAtA[i:], *m.DefaultExpr)
	}
	dAtA[i] = 0x30
	i++
	if m.Hidden {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if len(m.UsesSequenceIds) > 0 {
		for _, num := range m.UsesSequenceIds {
			dAtA[i] = 0x50
			i++
			i = encodeVarintStructured(dAtA, i, uint64(num))
		}
	}
	if m.ComputeExpr != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintStructured(dAtA, i, uint64(len(*m.ComputeExpr)))
		i += copy(dAtA[i:], *m.ComputeExpr)
	}
	dAtA[i] = 0x60
	i++
	if m.IsHashPartitionCol {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x68
	i++
	if m.Onupdatecurrenttimestamp {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x70
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.InhCount))
	dAtA[i] = 0x78
	i++
	if m.IsInherits {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if m.Privileges != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintStructured(dAtA, i, uint64(m.Privileges.Size()))
		n4, err := m.Privileges.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	dAtA[i] = 0x88
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.ParentID))
	dAtA[i] = 0x92
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintStructured(dAtA, i, uint64(len(m.UpdatableViewDependsColName)))
	i += copy(dAtA[i:], m.UpdatableViewDependsColName)
	if len(m.OwnsSequenceIds) > 0 {
		for _, num := range m.OwnsSequenceIds {
			dAtA[i] = 0x98
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintStructured(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *ColumnFamilyDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnFamilyDescriptor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintStructured(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x10
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.ID))
	if len(m.ColumnNames) > 0 {
		for _, s := range m.ColumnNames {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ColumnIDs) > 0 {
		for _, num := range m.ColumnIDs {
			dAtA[i] = 0x20
			i++
			i = encodeVarintStructured(dAtA, i, uint64(num))
		}
	}
	dAtA[i] = 0x28
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.DefaultColumnID))
	return i, nil
}

func (m *InterleaveDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterleaveDescriptor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ancestors) > 0 {
		for _, msg := range m.Ancestors {
			dAtA[i] = 0xa
			i++
			i = encodeVarintStructured(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *InterleaveDescriptor_Ancestor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterleaveDescriptor_Ancestor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.TableID))
	dAtA[i] = 0x10
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.IndexID))
	dAtA[i] = 0x18
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.SharedPrefixLen))
	return i, nil
}

func (m *PartitioningDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitioningDescriptor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.NumColumns))
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0x12
			i++
			i = encodeVarintStructured(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Range) > 0 {
		for _, msg := range m.Range {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintStructured(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x20
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.LocationNums))
	dAtA[i] = 0x28
	i++
	if m.IsHashPartition {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *PartitioningDescriptor_List) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitioningDescriptor_List) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintStructured(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	if len(m.Values) > 0 {
		for _, b := range m.Values {
			dAtA[i] = 0x12
			i++
			i = encodeVarintStructured(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.LocateSpaceName != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStructured(dAtA, i, uint64(m.LocateSpaceName.Size()))
		n5, err := m.LocateSpaceName.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	dAtA[i] = 0x22
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.Subpartitioning.Size()))
	n6, err := m.Subpartitioning.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	return i, nil
}

func (m *PartitioningDescriptor_Range) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitioningDescriptor_Range) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintStructured(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	if m.ToExclusive != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStructured(dAtA, i, uint64(len(m.ToExclusive)))
		i += copy(dAtA[i:], m.ToExclusive)
	}
	if m.FromInclusive != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStructured(dAtA, i, uint64(len(m.FromInclusive)))
		i += copy(dAtA[i:], m.FromInclusive)
	}
	if m.LocateSpaceName != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStructured(dAtA, i, uint64(m.LocateSpaceName.Size()))
		n7, err := m.LocateSpaceName.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *IndexDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexDescriptor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintStructured(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x10
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x18
	i++
	if m.Unique {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if len(m.ColumnNames) > 0 {
		for _, s := range m.ColumnNames {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.StoreColumnNames) > 0 {
		for _, s := range m.StoreColumnNames {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ColumnIDs) > 0 {
		for _, num := range m.ColumnIDs {
			dAtA[i] = 0x30
			i++
			i = encodeVarintStructured(dAtA, i, uint64(num))
		}
	}
	if len(m.ExtraColumnIDs) > 0 {
		for _, num := range m.ExtraColumnIDs {
			dAtA[i] = 0x38
			i++
			i = encodeVarintStructured(dAtA, i, uint64(num))
		}
	}
	if len(m.ColumnDirections) > 0 {
		for _, num := range m.ColumnDirections {
			dAtA[i] = 0x40
			i++
			i = encodeVarintStructured(dAtA, i, uint64(num))
		}
	}
	dAtA[i] = 0x4a
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.ForeignKey.Size()))
	n8, err := m.ForeignKey.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	if len(m.ReferencedBy) > 0 {
		for _, msg := range m.ReferencedBy {
			dAtA[i] = 0x52
			i++
			i = encodeVarintStructured(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x5a
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.Interleave.Size()))
	n9, err := m.Interleave.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	if len(m.InterleavedBy) > 0 {
		for _, msg := range m.InterleavedBy {
			dAtA[i] = 0x62
			i++
			i = encodeVarintStructured(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.CompositeColumnIDs) > 0 {
		for _, num := range m.CompositeColumnIDs {
			dAtA[i] = 0x68
			i++
			i = encodeVarintStructured(dAtA, i, uint64(num))
		}
	}
	if len(m.StoreColumnIDs) > 0 {
		for _, num := range m.StoreColumnIDs {
			dAtA[i] = 0x70
			i++
			i = encodeVarintStructured(dAtA, i, uint64(num))
		}
	}
	dAtA[i] = 0x7a
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.Partitioning.Size()))
	n10, err := m.Partitioning.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	dAtA[i] = 0x80
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.Type))
	if m.LocateSpaceName != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintStructured(dAtA, i, uint64(m.LocateSpaceName.Size()))
		n11, err := m.LocateSpaceName.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	dAtA[i] = 0x90
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.LocationNums))
	dAtA[i] = 0x9a
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintStructured(dAtA, i, uint64(len(m.PredExpr)))
	i += copy(dAtA[i:], m.PredExpr)
	dAtA[i] = 0xa0
	i++
	dAtA[i] = 0x1
	i++
	if m.IsLocal {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if len(m.IsFunc) > 0 {
		for _, b := range m.IsFunc {
			dAtA[i] = 0xa8
			i++
			dAtA[i] = 0x1
			i++
			if b {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if len(m.IsRealFunc) > 0 {
		for _, b := range m.IsRealFunc {
			dAtA[i] = 0xb0
			i++
			dAtA[i] = 0x1
			i++
			if b {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	dAtA[i] = 0xb8
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.EncodingType))
	dAtA[i] = 0xc0
	i++
	dAtA[i] = 0x1
	i++
	if m.Disabled {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *ConstraintToUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConstraintToUpdate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.ConstraintType))
	dAtA[i] = 0x12
	i++
	i = encodeVarintStructured(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.Check.Size()))
	n12, err := m.Check.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	dAtA[i] = 0x22
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.ForeignKey.Size()))
	n13, err := m.ForeignKey.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n13
	dAtA[i] = 0x30
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.NotNullColumn))
	return i, nil
}

func (m *PrimaryKeySwap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrimaryKeySwap) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.NewPrimaryIndexId))
	if len(m.OldIndexes) > 0 {
		for _, num := range m.OldIndexes {
			dAtA[i] = 0x10
			i++
			i = encodeVarintStructured(dAtA, i, uint64(num))
		}
	}
	if len(m.NewIndexes) > 0 {
		for _, num := range m.NewIndexes {
			dAtA[i] = 0x18
			i++
			i = encodeVarintStructured(dAtA, i, uint64(num))
		}
	}
	dAtA[i] = 0x20
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.OldPrimaryIndexId))
	dAtA[i] = 0x2a
	i++
	i = encodeVarintStructured(dAtA, i, uint64(len(m.NewPrimaryIndexName)))
	i += copy(dAtA[i:], m.NewPrimaryIndexName)
	return i, nil
}

func (m *MaterializedViewRefresh) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MaterializedViewRefresh) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.NewPrimaryIndex.Size()))
	n14, err := m.NewPrimaryIndex.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	if len(m.NewIndexes) > 0 {
		for _, msg := range m.NewIndexes {
			dAtA[i] = 0x12
			i++
			i = encodeVarintStructured(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.AsOf.Size()))
	n15, err := m.AsOf.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n15
	return i, nil
}

func (m *DescriptorMutation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DescriptorMutation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Descriptor_ != nil {
		nn16, err := m.Descriptor_.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn16
	}
	dAtA[i] = 0x18
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.State))
	dAtA[i] = 0x20
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.Direction))
	dAtA[i] = 0x28
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.MutationID))
	dAtA[i] = 0x38
	i++
	if m.Rollback {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *DescriptorMutation_Column) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Column != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStructured(dAtA, i, uint64(m.Column.Size()))
		n17, err := m.Column.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}
func (m *DescriptorMutation_Index) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Index != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStructured(dAtA, i, uint64(m.Index.Size()))
		n18, err := m.Index.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}
func (m *DescriptorMutation_Constraint) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Constraint != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintStructured(dAtA, i, uint64(m.Constraint.Size()))
		n19, err := m.Constraint.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}
func (m *DescriptorMutation_PrimaryKeySwap) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PrimaryKeySwap != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintStructured(dAtA, i, uint64(m.PrimaryKeySwap.Size()))
		n20, err := m.PrimaryKeySwap.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}
func (m *DescriptorMutation_MaterializedViewRefresh) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.MaterializedViewRefresh != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintStructured(dAtA, i, uint64(m.MaterializedViewRefresh.Size()))
		n21, err := m.MaterializedViewRefresh.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}
func (m *TableDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableDescriptor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintStructured(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x18
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x20
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.ParentID))
	dAtA[i] = 0x28
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.Version))
	dAtA[i] = 0x30
	i++
	if m.ReplicationTable {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x3a
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.ModificationTime.Size()))
	n22, err := m.ModificationTime.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n22
	if len(m.Columns) > 0 {
		for _, msg := range m.Columns {
			dAtA[i] = 0x42
			i++
			i = encodeVarintStructured(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x48
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.NextColumnID))
	dAtA[i] = 0x52
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.PrimaryIndex.Size()))
	n23, err := m.PrimaryIndex.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n23
	if len(m.Indexes) > 0 {
		for _, msg := range m.Indexes {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintStructured(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x60
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.NextIndexID))
	if m.Privileges != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintStructured(dAtA, i, uint64(m.Privileges.Size()))
		n24, err := m.Privileges.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if len(m.Mutations) > 0 {
		for _, msg := range m.Mutations {
			dAtA[i] = 0x72
			i++
			i = encodeVarintStructured(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Lease != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintStructured(dAtA, i, uint64(m.Lease.Size()))
		n25, err := m.Lease.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	dAtA[i] = 0x80
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.NextMutationID))
	dAtA[i] = 0x88
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.FormatVersion))
	if m.LocateSpaceName != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintStructured(dAtA, i, uint64(m.LocateSpaceName.Size()))
		n26, err := m.LocateSpaceName.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	dAtA[i] = 0x98
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.State))
	if len(m.Checks) > 0 {
		for _, msg := range m.Checks {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintStructured(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.DrainingNames) > 0 {
		for _, msg := range m.DrainingNames {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintStructured(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Families) > 0 {
		for _, msg := range m.Families {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintStructured(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0xb8
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.NextFamilyID))
	dAtA[i] = 0xc2
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintStructured(dAtA, i, uint64(len(m.ViewQuery)))
	i += copy(dAtA[i:], m.ViewQuery)
	if len(m.DependsOn) > 0 {
		for _, num := range m.DependsOn {
			dAtA[i] = 0xc8
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintStructured(dAtA, i, uint64(num))
		}
	}
	if len(m.DependedOnBy) > 0 {
		for _, msg := range m.DependedOnBy {
			dAtA[i] = 0xd2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintStructured(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.MutationJobs) > 0 {
		for _, msg := range m.MutationJobs {
			dAtA[i] = 0xda
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintStructured(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.SequenceOpts != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintStructured(dAtA, i, uint64(m.SequenceOpts.Size()))
		n27, err := m.SequenceOpts.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	dAtA[i] = 0xe8
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.DropTime))
	dAtA[i] = 0xf2
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.ReplacementOf.Size()))
	n28, err := m.ReplacementOf.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n28
	dAtA[i] = 0xf8
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.AuditMode))
	dAtA[i] = 0x80
	i++
	dAtA[i] = 0x2
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.DropJobID))
	if len(m.GCMutations) > 0 {
		for _, msg := range m.GCMutations {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintStructured(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x90
	i++
	dAtA[i] = 0x2
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.LocationNums))
	dAtA[i] = 0x98
	i++
	dAtA[i] = 0x2
	i++
	if m.IsHashPartition {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0xa0
	i++
	dAtA[i] = 0x2
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.HashParts))
	dAtA[i] = 0xaa
	i++
	dAtA[i] = 0x2
	i++
	i = encodeVarintStructured(dAtA, i, uint64(len(m.HashField)))
	i += copy(dAtA[i:], m.HashField)
	if len(m.EngineTypeSetMap) > 0 {
		keysForEngineTypeSetMap := make([]uint32, 0, len(m.EngineTypeSetMap))
		for k := range m.EngineTypeSetMap {
			keysForEngineTypeSetMap = append(keysForEngineTypeSetMap, uint32(k))
		}
		github_com_gogo_protobuf_sortkeys.Uint32s(keysForEngineTypeSetMap)
		for _, k := range keysForEngineTypeSetMap {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x2
			i++
			v := m.EngineTypeSetMap[uint32(k)]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovStructured(uint64(msgSize))
			}
			mapSize := 1 + sovStructured(uint64(k)) + msgSize
			i = encodeVarintStructured(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintStructured(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintStructured(dAtA, i, uint64(v.Size()))
				n29, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n29
			}
		}
	}
	if len(m.Inherits) > 0 {
		for _, num := range m.Inherits {
			dAtA[i] = 0xb8
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintStructured(dAtA, i, uint64(num))
		}
	}
	if len(m.InheritsBy) > 0 {
		for _, num := range m.InheritsBy {
			dAtA[i] = 0xc0
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintStructured(dAtA, i, uint64(num))
		}
	}
	dAtA[i] = 0xc8
	i++
	dAtA[i] = 0x2
	i++
	if m.Temporary {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0xd0
	i++
	dAtA[i] = 0x2
	i++
	if m.CreateByTable {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0xd8
	i++
	dAtA[i] = 0x2
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.MaxColumnID))
	dAtA[i] = 0xe0
	i++
	dAtA[i] = 0x2
	i++
	if m.ViewUpdatable {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0xe8
	i++
	dAtA[i] = 0x2
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.ViewDependsOn))
	dAtA[i] = 0xf2
	i++
	dAtA[i] = 0x2
	i++
	i = encodeVarintStructured(dAtA, i, uint64(len(m.Comments)))
	i += copy(dAtA[i:], m.Comments)
	dAtA[i] = 0xf8
	i++
	dAtA[i] = 0x2
	i++
	if m.IsMaterializedView {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x82
	i++
	dAtA[i] = 0x3
	i++
	i = encodeVarintStructured(dAtA, i, uint64(len(m.CreateQuery)))
	i += copy(dAtA[i:], m.CreateQuery)
	dAtA[i] = 0x8a
	i++
	dAtA[i] = 0x3
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.CreateAsOfTime.Size()))
	n30, err := m.CreateAsOfTime.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n30
	return i, nil
}

func (m *TableDescriptor_SchemaChangeLease) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableDescriptor_SchemaChangeLease) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.NodeID))
	dAtA[i] = 0x10
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.ExpirationTime))
	return i, nil
}

func (m *TableDescriptor_CheckConstraint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableDescriptor_CheckConstraint) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintStructured(dAtA, i, uint64(len(m.Expr)))
	i += copy(dAtA[i:], m.Expr)
	dAtA[i] = 0x12
	i++
	i = encodeVarintStructured(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x18
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.Validity))
	if len(m.ColumnIDs) > 0 {
		for _, num := range m.ColumnIDs {
			dAtA[i] = 0x28
			i++
			i = encodeVarintStructured(dAtA, i, uint64(num))
		}
	}
	dAtA[i] = 0x30
	i++
	if m.Able {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x38
	i++
	if m.IsInherits {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x40
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.InhCount))
	return i, nil
}

func (m *TableDescriptor_NameInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableDescriptor_NameInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.ParentID))
	dAtA[i] = 0x12
	i++
	i = encodeVarintStructured(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	return i, nil
}

func (m *TableDescriptor_Reference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableDescriptor_Reference) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x10
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.IndexID))
	if len(m.ColumnIDs) > 0 {
		for _, num := range m.ColumnIDs {
			dAtA[i] = 0x18
			i++
			i = encodeVarintStructured(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *TableDescriptor_MutationJob) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableDescriptor_MutationJob) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.MutationID))
	dAtA[i] = 0x10
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.JobID))
	return i, nil
}

func (m *TableDescriptor_SequenceOpts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableDescriptor_SequenceOpts) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.Increment))
	dAtA[i] = 0x10
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.MinValue))
	dAtA[i] = 0x18
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.MaxValue))
	dAtA[i] = 0x20
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.Start))
	dAtA[i] = 0x28
	i++
	if m.Virtual {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x30
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.Cache))
	dAtA[i] = 0x38
	i++
	if m.Cycle {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x40
	i++
	if m.EverOver {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x48
	i++
	if m.IsCall {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x52
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.SequenceOwner.Size()))
	n31, err := m.SequenceOwner.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n31
	return i, nil
}

func (m *TableDescriptor_SequenceOpts_SequenceOwner) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableDescriptor_SequenceOpts_SequenceOwner) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.OwnerColumnID))
	dAtA[i] = 0x10
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.OwnerTableID))
	return i, nil
}

func (m *TableDescriptor_Replacement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableDescriptor_Replacement) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x12
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.Time.Size()))
	n32, err := m.Time.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n32
	return i, nil
}

func (m *TableDescriptor_GCDescriptorMutation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableDescriptor_GCDescriptorMutation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.IndexID))
	dAtA[i] = 0x10
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.DropTime))
	dAtA[i] = 0x18
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.JobID))
	return i, nil
}

func (m *TableDescriptor_MapValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableDescriptor_MapValue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		for _, s := range m.Value {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *DatabaseDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseDescriptor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintStructured(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x10
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.ID))
	if m.Privileges != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStructured(dAtA, i, uint64(m.Privileges.Size()))
		n33, err := m.Privileges.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if len(m.Schemas) > 0 {
		for _, msg := range m.Schemas {
			dAtA[i] = 0x22
			i++
			i = encodeVarintStructured(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Descriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Descriptor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Union != nil {
		nn34, err := m.Union.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn34
	}
	return i, nil
}

func (m *Descriptor_Table) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Table != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStructured(dAtA, i, uint64(m.Table.Size()))
		n35, err := m.Table.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	return i, nil
}
func (m *Descriptor_Database) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Database != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStructured(dAtA, i, uint64(m.Database.Size()))
		n36, err := m.Database.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	return i, nil
}
func (m *Descriptor_Schema) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Schema != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStructured(dAtA, i, uint64(m.Schema.Size()))
		n37, err := m.Schema.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	return i, nil
}
func (m *Descriptor_Function) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Function != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStructured(dAtA, i, uint64(m.Function.Size()))
		n38, err := m.Function.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	return i, nil
}
func (m *SchemaDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaDescriptor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintStructured(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x10
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.ID))
	if m.Privileges != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStructured(dAtA, i, uint64(m.Privileges.Size()))
		n39, err := m.Privileges.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	dAtA[i] = 0x20
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.ParentID))
	return i, nil
}

func (m *FunctionTriggerType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FunctionTriggerType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *FuncArgDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FuncArgDescriptor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintStructured(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x10
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x1a
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.Type.Size()))
	n40, err := m.Type.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n40
	dAtA[i] = 0x22
	i++
	i = encodeVarintStructured(dAtA, i, uint64(len(m.ColumnTypeString)))
	i += copy(dAtA[i:], m.ColumnTypeString)
	dAtA[i] = 0x28
	i++
	if m.Nullable {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x32
	i++
	i = encodeVarintStructured(dAtA, i, uint64(len(m.ComputeExpr)))
	i += copy(dAtA[i:], m.ComputeExpr)
	dAtA[i] = 0x3a
	i++
	i = encodeVarintStructured(dAtA, i, uint64(len(m.InOutMode)))
	i += copy(dAtA[i:], m.InOutMode)
	dAtA[i] = 0x40
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.Oid))
	return i, nil
}

func (m *FunctionDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FunctionDescriptor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintStructured(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x10
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.ID))
	if m.Privileges != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStructured(dAtA, i, uint64(m.Privileges.Size()))
		n41, err := m.Privileges.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	dAtA[i] = 0x20
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.ParentID))
	dAtA[i] = 0x28
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.TxnID))
	dAtA[i] = 0x30
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.Version))
	if len(m.Args) > 0 {
		for _, msg := range m.Args {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintStructured(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x40
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.ArgNum))
	dAtA[i] = 0x48
	i++
	if m.IsProcedure {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x52
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.TriggerType.Size()))
	n42, err := m.TriggerType.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n42
	dAtA[i] = 0x5a
	i++
	i = encodeVarintStructured(dAtA, i, uint64(len(m.ReturnType)))
	i += copy(dAtA[i:], m.ReturnType)
	dAtA[i] = 0x60
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.RetOid))
	dAtA[i] = 0x6a
	i++
	i = encodeVarintStructured(dAtA, i, uint64(len(m.Language)))
	i += copy(dAtA[i:], m.Language)
	dAtA[i] = 0x78
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.State))
	dAtA[i] = 0x82
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintStructured(dAtA, i, uint64(len(m.FuncDef)))
	i += copy(dAtA[i:], m.FuncDef)
	if len(m.DrainingNames) > 0 {
		for _, msg := range m.DrainingNames {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintStructured(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x90
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.DropTime))
	dAtA[i] = 0x9a
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintStructured(dAtA, i, uint64(len(m.FullFuncName)))
	i += copy(dAtA[i:], m.FullFuncName)
	dAtA[i] = 0xa0
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.DropJobID))
	if len(m.MutationJobs) > 0 {
		for _, msg := range m.MutationJobs {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintStructured(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.GCMutations) > 0 {
		for _, msg := range m.GCMutations {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintStructured(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0xba
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintStructured(dAtA, i, uint64(len(m.Hashsql)))
	i += copy(dAtA[i:], m.Hashsql)
	dAtA[i] = 0xc2
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintStructured(dAtA, i, uint64(len(m.FilePath)))
	i += copy(dAtA[i:], m.FilePath)
	dAtA[i] = 0xca
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintStructured(dAtA, i, uint64(len(m.FileName)))
	i += copy(dAtA[i:], m.FileName)
	dAtA[i] = 0xd2
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.ModificationTime.Size()))
	n43, err := m.ModificationTime.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n43
	return i, nil
}

func (m *FunctionDescriptor_NameInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FunctionDescriptor_NameInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.ParentID))
	dAtA[i] = 0x12
	i++
	i = encodeVarintStructured(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	return i, nil
}

func (m *FunctionDescriptor_MutationJob) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FunctionDescriptor_MutationJob) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.MutationID))
	dAtA[i] = 0x10
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.JobID))
	return i, nil
}

func (m *FunctionDescriptor_GCDescriptorMutation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FunctionDescriptor_GCDescriptorMutation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.IndexID))
	dAtA[i] = 0x10
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.DropTime))
	dAtA[i] = 0x18
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.JobID))
	return i, nil
}

func (m *CursorDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CursorDescriptor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintStructured(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x10
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x1a
	i++
	i = encodeVarintStructured(dAtA, i, uint64(len(m.QueryString)))
	i += copy(dAtA[i:], m.QueryString)
	dAtA[i] = 0x20
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.Position))
	dAtA[i] = 0x28
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.MaxRownum))
	if len(m.Columns) > 0 {
		for _, msg := range m.Columns {
			dAtA[i] = 0x32
			i++
			i = encodeVarintStructured(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x38
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.State))
	if len(m.CurVarDescriptors) > 0 {
		for _, msg := range m.CurVarDescriptors {
			dAtA[i] = 0x42
			i++
			i = encodeVarintStructured(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PrimaryIndex) > 0 {
		for _, s := range m.PrimaryIndex {
			dAtA[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	dAtA[i] = 0x52
	i++
	i = encodeVarintStructured(dAtA, i, uint64(len(m.TableName)))
	i += copy(dAtA[i:], m.TableName)
	dAtA[i] = 0x5a
	i++
	i = encodeVarintStructured(dAtA, i, uint64(len(m.TxnState)))
	i += copy(dAtA[i:], m.TxnState)
	return i, nil
}

func (m *VariableDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VariableDescriptor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintStructured(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x10
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x1a
	i++
	i = encodeVarintStructured(dAtA, i, uint64(m.Column.Size()))
	n44, err := m.Column.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n44
	dAtA[i] = 0x22
	i++
	i = encodeVarintStructured(dAtA, i, uint64(len(m.TxnState)))
	i += copy(dAtA[i:], m.TxnState)
	return i, nil
}

func encodeVarintStructured(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ColumnType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovStructured(uint64(m.SemanticType))
	n += 1 + sovStructured(uint64(m.Width))
	n += 1 + sovStructured(uint64(m.Precision))
	if len(m.ArrayDimensions) > 0 {
		for _, e := range m.ArrayDimensions {
			n += 1 + sovStructured(uint64(e))
		}
	}
	if m.Locale != nil {
		l = len(*m.Locale)
		n += 1 + l + sovStructured(uint64(l))
	}
	n += 1 + sovStructured(uint64(m.VisibleType))
	if m.ArrayContents != nil {
		n += 1 + sovStructured(uint64(*m.ArrayContents))
	}
	if len(m.TupleContents) > 0 {
		for _, e := range m.TupleContents {
			l = e.Size()
			n += 1 + l + sovStructured(uint64(l))
		}
	}
	if len(m.TupleLabels) > 0 {
		for _, s := range m.TupleLabels {
			l = len(s)
			n += 1 + l + sovStructured(uint64(l))
		}
	}
	l = len(m.VisibleTypeName)
	n += 1 + l + sovStructured(uint64(l))
	if len(m.EnumContents) > 0 {
		for _, s := range m.EnumContents {
			l = len(s)
			n += 1 + l + sovStructured(uint64(l))
		}
	}
	if len(m.SetContents) > 0 {
		for _, s := range m.SetContents {
			l = len(s)
			n += 1 + l + sovStructured(uint64(l))
		}
	}
	return n
}

func (m *ForeignKeyReference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovStructured(uint64(m.Table))
	n += 1 + sovStructured(uint64(m.Index))
	l = len(m.Name)
	n += 1 + l + sovStructured(uint64(l))
	n += 1 + sovStructured(uint64(m.Validity))
	n += 1 + sovStructured(uint64(m.SharedPrefixLen))
	n += 1 + sovStructured(uint64(m.OnDelete))
	n += 1 + sovStructured(uint64(m.OnUpdate))
	n += 1 + sovStructured(uint64(m.Match))
	return n
}

func (m *ForeignKeyConstraint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovStructured(uint64(m.OriginTableID))
	if len(m.OriginColumnIDs) > 0 {
		for _, e := range m.OriginColumnIDs {
			n += 1 + sovStructured(uint64(e))
		}
	}
	if len(m.ReferencedColumnIDs) > 0 {
		for _, e := range m.ReferencedColumnIDs {
			n += 1 + sovStructured(uint64(e))
		}
	}
	n += 1 + sovStructured(uint64(m.ReferencedTableID))
	l = len(m.Name)
	n += 1 + l + sovStructured(uint64(l))
	n += 1 + sovStructured(uint64(m.Validity))
	n += 1 + sovStructured(uint64(m.OnDelete))
	n += 1 + sovStructured(uint64(m.OnUpdate))
	n += 1 + sovStructured(uint64(m.Match))
	n += 1 + sovStructured(uint64(m.LegacyOriginIndex))
	n += 1 + sovStructured(uint64(m.LegacyReferencedIndex))
	l = m.LegacyUpgradedFromOriginReference.Size()
	n += 1 + l + sovStructured(uint64(l))
	l = m.LegacyUpgradedFromReferencedReference.Size()
	n += 1 + l + sovStructured(uint64(l))
	return n
}

func (m *ColumnDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovStructured(uint64(l))
	n += 1 + sovStructured(uint64(m.ID))
	l = m.Type.Size()
	n += 1 + l + sovStructured(uint64(l))
	n += 2
	if m.DefaultExpr != nil {
		l = len(*m.DefaultExpr)
		n += 1 + l + sovStructured(uint64(l))
	}
	n += 2
	if len(m.UsesSequenceIds) > 0 {
		for _, e := range m.UsesSequenceIds {
			n += 1 + sovStructured(uint64(e))
		}
	}
	if m.ComputeExpr != nil {
		l = len(*m.ComputeExpr)
		n += 1 + l + sovStructured(uint64(l))
	}
	n += 2
	n += 2
	n += 1 + sovStructured(uint64(m.InhCount))
	n += 2
	if m.Privileges != nil {
		l = m.Privileges.Size()
		n += 2 + l + sovStructured(uint64(l))
	}
	n += 2 + sovStructured(uint64(m.ParentID))
	l = len(m.UpdatableViewDependsColName)
	n += 2 + l + sovStructured(uint64(l))
	if len(m.OwnsSequenceIds) > 0 {
		for _, e := range m.OwnsSequenceIds {
			n += 2 + sovStructured(uint64(e))
		}
	}
	return n
}

func (m *ColumnFamilyDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovStructured(uint64(l))
	n += 1 + sovStructured(uint64(m.ID))
	if len(m.ColumnNames) > 0 {
		for _, s := range m.ColumnNames {
			l = len(s)
			n += 1 + l + sovStructured(uint64(l))
		}
	}
	if len(m.ColumnIDs) > 0 {
		for _, e := range m.ColumnIDs {
			n += 1 + sovStructured(uint64(e))
		}
	}
	n += 1 + sovStructured(uint64(m.DefaultColumnID))
	return n
}

func (m *InterleaveDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ancestors) > 0 {
		for _, e := range m.Ancestors {
			l = e.Size()
			n += 1 + l + sovStructured(uint64(l))
		}
	}
	return n
}

func (m *InterleaveDescriptor_Ancestor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovStructured(uint64(m.TableID))
	n += 1 + sovStructured(uint64(m.IndexID))
	n += 1 + sovStructured(uint64(m.SharedPrefixLen))
	return n
}

func (m *PartitioningDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovStructured(uint64(m.NumColumns))
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovStructured(uint64(l))
		}
	}
	if len(m.Range) > 0 {
		for _, e := range m.Range {
			l = e.Size()
			n += 1 + l + sovStructured(uint64(l))
		}
	}
	n += 1 + sovStructured(uint64(m.LocationNums))
	n += 2
	return n
}

func (m *PartitioningDescriptor_List) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovStructured(uint64(l))
	if len(m.Values) > 0 {
		for _, b := range m.Values {
			l = len(b)
			n += 1 + l + sovStructured(uint64(l))
		}
	}
	if m.LocateSpaceName != nil {
		l = m.LocateSpaceName.Size()
		n += 1 + l + sovStructured(uint64(l))
	}
	l = m.Subpartitioning.Size()
	n += 1 + l + sovStructured(uint64(l))
	return n
}

func (m *PartitioningDescriptor_Range) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovStructured(uint64(l))
	if m.ToExclusive != nil {
		l = len(m.ToExclusive)
		n += 1 + l + sovStructured(uint64(l))
	}
	if m.FromInclusive != nil {
		l = len(m.FromInclusive)
		n += 1 + l + sovStructured(uint64(l))
	}
	if m.LocateSpaceName != nil {
		l = m.LocateSpaceName.Size()
		n += 1 + l + sovStructured(uint64(l))
	}
	return n
}

func (m *IndexDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovStructured(uint64(l))
	n += 1 + sovStructured(uint64(m.ID))
	n += 2
	if len(m.ColumnNames) > 0 {
		for _, s := range m.ColumnNames {
			l = len(s)
			n += 1 + l + sovStructured(uint64(l))
		}
	}
	if len(m.StoreColumnNames) > 0 {
		for _, s := range m.StoreColumnNames {
			l = len(s)
			n += 1 + l + sovStructured(uint64(l))
		}
	}
	if len(m.ColumnIDs) > 0 {
		for _, e := range m.ColumnIDs {
			n += 1 + sovStructured(uint64(e))
		}
	}
	if len(m.ExtraColumnIDs) > 0 {
		for _, e := range m.ExtraColumnIDs {
			n += 1 + sovStructured(uint64(e))
		}
	}
	if len(m.ColumnDirections) > 0 {
		for _, e := range m.ColumnDirections {
			n += 1 + sovStructured(uint64(e))
		}
	}
	l = m.ForeignKey.Size()
	n += 1 + l + sovStructured(uint64(l))
	if len(m.ReferencedBy) > 0 {
		for _, e := range m.ReferencedBy {
			l = e.Size()
			n += 1 + l + sovStructured(uint64(l))
		}
	}
	l = m.Interleave.Size()
	n += 1 + l + sovStructured(uint64(l))
	if len(m.InterleavedBy) > 0 {
		for _, e := range m.InterleavedBy {
			l = e.Size()
			n += 1 + l + sovStructured(uint64(l))
		}
	}
	if len(m.CompositeColumnIDs) > 0 {
		for _, e := range m.CompositeColumnIDs {
			n += 1 + sovStructured(uint64(e))
		}
	}
	if len(m.StoreColumnIDs) > 0 {
		for _, e := range m.StoreColumnIDs {
			n += 1 + sovStructured(uint64(e))
		}
	}
	l = m.Partitioning.Size()
	n += 1 + l + sovStructured(uint64(l))
	n += 2 + sovStructured(uint64(m.Type))
	if m.LocateSpaceName != nil {
		l = m.LocateSpaceName.Size()
		n += 2 + l + sovStructured(uint64(l))
	}
	n += 2 + sovStructured(uint64(m.LocationNums))
	l = len(m.PredExpr)
	n += 2 + l + sovStructured(uint64(l))
	n += 3
	if len(m.IsFunc) > 0 {
		n += 3 * len(m.IsFunc)
	}
	if len(m.IsRealFunc) > 0 {
		n += 3 * len(m.IsRealFunc)
	}
	n += 2 + sovStructured(uint64(m.EncodingType))
	n += 3
	return n
}

func (m *ConstraintToUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovStructured(uint64(m.ConstraintType))
	l = len(m.Name)
	n += 1 + l + sovStructured(uint64(l))
	l = m.Check.Size()
	n += 1 + l + sovStructured(uint64(l))
	l = m.ForeignKey.Size()
	n += 1 + l + sovStructured(uint64(l))
	n += 1 + sovStructured(uint64(m.NotNullColumn))
	return n
}

func (m *PrimaryKeySwap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovStructured(uint64(m.NewPrimaryIndexId))
	if len(m.OldIndexes) > 0 {
		for _, e := range m.OldIndexes {
			n += 1 + sovStructured(uint64(e))
		}
	}
	if len(m.NewIndexes) > 0 {
		for _, e := range m.NewIndexes {
			n += 1 + sovStructured(uint64(e))
		}
	}
	n += 1 + sovStructured(uint64(m.OldPrimaryIndexId))
	l = len(m.NewPrimaryIndexName)
	n += 1 + l + sovStructured(uint64(l))
	return n
}

func (m *MaterializedViewRefresh) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.NewPrimaryIndex.Size()
	n += 1 + l + sovStructured(uint64(l))
	if len(m.NewIndexes) > 0 {
		for _, e := range m.NewIndexes {
			l = e.Size()
			n += 1 + l + sovStructured(uint64(l))
		}
	}
	l = m.AsOf.Size()
	n += 1 + l + sovStructured(uint64(l))
	return n
}

func (m *DescriptorMutation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Descriptor_ != nil {
		n += m.Descriptor_.Size()
	}
	n += 1 + sovStructured(uint64(m.State))
	n += 1 + sovStructured(uint64(m.Direction))
	n += 1 + sovStructured(uint64(m.MutationID))
	n += 2
	return n
}

func (m *DescriptorMutation_Column) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Column != nil {
		l = m.Column.Size()
		n += 1 + l + sovStructured(uint64(l))
	}
	return n
}
func (m *DescriptorMutation_Index) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != nil {
		l = m.Index.Size()
		n += 1 + l + sovStructured(uint64(l))
	}
	return n
}
func (m *DescriptorMutation_Constraint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constraint != nil {
		l = m.Constraint.Size()
		n += 1 + l + sovStructured(uint64(l))
	}
	return n
}
func (m *DescriptorMutation_PrimaryKeySwap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PrimaryKeySwap != nil {
		l = m.PrimaryKeySwap.Size()
		n += 1 + l + sovStructured(uint64(l))
	}
	return n
}
func (m *DescriptorMutation_MaterializedViewRefresh) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaterializedViewRefresh != nil {
		l = m.MaterializedViewRefresh.Size()
		n += 1 + l + sovStructured(uint64(l))
	}
	return n
}
func (m *TableDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovStructured(uint64(l))
	n += 1 + sovStructured(uint64(m.ID))
	n += 1 + sovStructured(uint64(m.ParentID))
	n += 1 + sovStructured(uint64(m.Version))
	n += 2
	l = m.ModificationTime.Size()
	n += 1 + l + sovStructured(uint64(l))
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovStructured(uint64(l))
		}
	}
	n += 1 + sovStructured(uint64(m.NextColumnID))
	l = m.PrimaryIndex.Size()
	n += 1 + l + sovStructured(uint64(l))
	if len(m.Indexes) > 0 {
		for _, e := range m.Indexes {
			l = e.Size()
			n += 1 + l + sovStructured(uint64(l))
		}
	}
	n += 1 + sovStructured(uint64(m.NextIndexID))
	if m.Privileges != nil {
		l = m.Privileges.Size()
		n += 1 + l + sovStructured(uint64(l))
	}
	if len(m.Mutations) > 0 {
		for _, e := range m.Mutations {
			l = e.Size()
			n += 1 + l + sovStructured(uint64(l))
		}
	}
	if m.Lease != nil {
		l = m.Lease.Size()
		n += 1 + l + sovStructured(uint64(l))
	}
	n += 2 + sovStructured(uint64(m.NextMutationID))
	n += 2 + sovStructured(uint64(m.FormatVersion))
	if m.LocateSpaceName != nil {
		l = m.LocateSpaceName.Size()
		n += 2 + l + sovStructured(uint64(l))
	}
	n += 2 + sovStructured(uint64(m.State))
	if len(m.Checks) > 0 {
		for _, e := range m.Checks {
			l = e.Size()
			n += 2 + l + sovStructured(uint64(l))
		}
	}
	if len(m.DrainingNames) > 0 {
		for _, e := range m.DrainingNames {
			l = e.Size()
			n += 2 + l + sovStructured(uint64(l))
		}
	}
	if len(m.Families) > 0 {
		for _, e := range m.Families {
			l = e.Size()
			n += 2 + l + sovStructured(uint64(l))
		}
	}
	n += 2 + sovStructured(uint64(m.NextFamilyID))
	l = len(m.ViewQuery)
	n += 2 + l + sovStructured(uint64(l))
	if len(m.DependsOn) > 0 {
		for _, e := range m.DependsOn {
			n += 2 + sovStructured(uint64(e))
		}
	}
	if len(m.DependedOnBy) > 0 {
		for _, e := range m.DependedOnBy {
			l = e.Size()
			n += 2 + l + sovStructured(uint64(l))
		}
	}
	if len(m.MutationJobs) > 0 {
		for _, e := range m.MutationJobs {
			l = e.Size()
			n += 2 + l + sovStructured(uint64(l))
		}
	}
	if m.SequenceOpts != nil {
		l = m.SequenceOpts.Size()
		n += 2 + l + sovStructured(uint64(l))
	}
	n += 2 + sovStructured(uint64(m.DropTime))
	l = m.ReplacementOf.Size()
	n += 2 + l + sovStructured(uint64(l))
	n += 2 + sovStructured(uint64(m.AuditMode))
	n += 2 + sovStructured(uint64(m.DropJobID))
	if len(m.GCMutations) > 0 {
		for _, e := range m.GCMutations {
			l = e.Size()
			n += 2 + l + sovStructured(uint64(l))
		}
	}
	n += 2 + sovStructured(uint64(m.LocationNums))
	n += 3
	n += 2 + sovStructured(uint64(m.HashParts))
	l = len(m.HashField)
	n += 2 + l + sovStructured(uint64(l))
	if len(m.EngineTypeSetMap) > 0 {
		for k, v := range m.EngineTypeSetMap {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovStructured(uint64(l))
			}
			mapEntrySize := 1 + sovStructured(uint64(k)) + l
			n += mapEntrySize + 2 + sovStructured(uint64(mapEntrySize))
		}
	}
	if len(m.Inherits) > 0 {
		for _, e := range m.Inherits {
			n += 2 + sovStructured(uint64(e))
		}
	}
	if len(m.InheritsBy) > 0 {
		for _, e := range m.InheritsBy {
			n += 2 + sovStructured(uint64(e))
		}
	}
	n += 3
	n += 3
	n += 2 + sovStructured(uint64(m.MaxColumnID))
	n += 3
	n += 2 + sovStructured(uint64(m.ViewDependsOn))
	l = len(m.Comments)
	n += 2 + l + sovStructured(uint64(l))
	n += 3
	l = len(m.CreateQuery)
	n += 2 + l + sovStructured(uint64(l))
	l = m.CreateAsOfTime.Size()
	n += 2 + l + sovStructured(uint64(l))
	return n
}

func (m *TableDescriptor_SchemaChangeLease) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovStructured(uint64(m.NodeID))
	n += 1 + sovStructured(uint64(m.ExpirationTime))
	return n
}

func (m *TableDescriptor_CheckConstraint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Expr)
	n += 1 + l + sovStructured(uint64(l))
	l = len(m.Name)
	n += 1 + l + sovStructured(uint64(l))
	n += 1 + sovStructured(uint64(m.Validity))
	if len(m.ColumnIDs) > 0 {
		for _, e := range m.ColumnIDs {
			n += 1 + sovStructured(uint64(e))
		}
	}
	n += 2
	n += 2
	n += 1 + sovStructured(uint64(m.InhCount))
	return n
}

func (m *TableDescriptor_NameInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovStructured(uint64(m.ParentID))
	l = len(m.Name)
	n += 1 + l + sovStructured(uint64(l))
	return n
}

func (m *TableDescriptor_Reference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovStructured(uint64(m.ID))
	n += 1 + sovStructured(uint64(m.IndexID))
	if len(m.ColumnIDs) > 0 {
		for _, e := range m.ColumnIDs {
			n += 1 + sovStructured(uint64(e))
		}
	}
	return n
}

func (m *TableDescriptor_MutationJob) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovStructured(uint64(m.MutationID))
	n += 1 + sovStructured(uint64(m.JobID))
	return n
}

func (m *TableDescriptor_SequenceOpts) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovStructured(uint64(m.Increment))
	n += 1 + sovStructured(uint64(m.MinValue))
	n += 1 + sovStructured(uint64(m.MaxValue))
	n += 1 + sovStructured(uint64(m.Start))
	n += 2
	n += 1 + sovStructured(uint64(m.Cache))
	n += 2
	n += 2
	n += 2
	l = m.SequenceOwner.Size()
	n += 1 + l + sovStructured(uint64(l))
	return n
}

func (m *TableDescriptor_SequenceOpts_SequenceOwner) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovStructured(uint64(m.OwnerColumnID))
	n += 1 + sovStructured(uint64(m.OwnerTableID))
	return n
}

func (m *TableDescriptor_Replacement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovStructured(uint64(m.ID))
	l = m.Time.Size()
	n += 1 + l + sovStructured(uint64(l))
	return n
}

func (m *TableDescriptor_GCDescriptorMutation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovStructured(uint64(m.IndexID))
	n += 1 + sovStructured(uint64(m.DropTime))
	n += 1 + sovStructured(uint64(m.JobID))
	return n
}

func (m *TableDescriptor_MapValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Value) > 0 {
		for _, s := range m.Value {
			l = len(s)
			n += 1 + l + sovStructured(uint64(l))
		}
	}
	return n
}

func (m *DatabaseDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovStructured(uint64(l))
	n += 1 + sovStructured(uint64(m.ID))
	if m.Privileges != nil {
		l = m.Privileges.Size()
		n += 1 + l + sovStructured(uint64(l))
	}
	if len(m.Schemas) > 0 {
		for _, e := range m.Schemas {
			l = e.Size()
			n += 1 + l + sovStructured(uint64(l))
		}
	}
	return n
}

func (m *Descriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Union != nil {
		n += m.Union.Size()
	}
	return n
}

func (m *Descriptor_Table) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Table != nil {
		l = m.Table.Size()
		n += 1 + l + sovStructured(uint64(l))
	}
	return n
}
func (m *Descriptor_Database) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Database != nil {
		l = m.Database.Size()
		n += 1 + l + sovStructured(uint64(l))
	}
	return n
}
func (m *Descriptor_Schema) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Schema != nil {
		l = m.Schema.Size()
		n += 1 + l + sovStructured(uint64(l))
	}
	return n
}
func (m *Descriptor_Function) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Function != nil {
		l = m.Function.Size()
		n += 1 + l + sovStructured(uint64(l))
	}
	return n
}
func (m *SchemaDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovStructured(uint64(l))
	n += 1 + sovStructured(uint64(m.ID))
	if m.Privileges != nil {
		l = m.Privileges.Size()
		n += 1 + l + sovStructured(uint64(l))
	}
	n += 1 + sovStructured(uint64(m.ParentID))
	return n
}

func (m *FunctionTriggerType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *FuncArgDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovStructured(uint64(l))
	n += 1 + sovStructured(uint64(m.ID))
	l = m.Type.Size()
	n += 1 + l + sovStructured(uint64(l))
	l = len(m.ColumnTypeString)
	n += 1 + l + sovStructured(uint64(l))
	n += 2
	l = len(m.ComputeExpr)
	n += 1 + l + sovStructured(uint64(l))
	l = len(m.InOutMode)
	n += 1 + l + sovStructured(uint64(l))
	n += 1 + sovStructured(uint64(m.Oid))
	return n
}

func (m *FunctionDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovStructured(uint64(l))
	n += 1 + sovStructured(uint64(m.ID))
	if m.Privileges != nil {
		l = m.Privileges.Size()
		n += 1 + l + sovStructured(uint64(l))
	}
	n += 1 + sovStructured(uint64(m.ParentID))
	n += 1 + sovStructured(uint64(m.TxnID))
	n += 1 + sovStructured(uint64(m.Version))
	if len(m.Args) > 0 {
		for _, e := range m.Args {
			l = e.Size()
			n += 1 + l + sovStructured(uint64(l))
		}
	}
	n += 1 + sovStructured(uint64(m.ArgNum))
	n += 2
	l = m.TriggerType.Size()
	n += 1 + l + sovStructured(uint64(l))
	l = len(m.ReturnType)
	n += 1 + l + sovStructured(uint64(l))
	n += 1 + sovStructured(uint64(m.RetOid))
	l = len(m.Language)
	n += 1 + l + sovStructured(uint64(l))
	n += 1 + sovStructured(uint64(m.State))
	l = len(m.FuncDef)
	n += 2 + l + sovStructured(uint64(l))
	if len(m.DrainingNames) > 0 {
		for _, e := range m.DrainingNames {
			l = e.Size()
			n += 2 + l + sovStructured(uint64(l))
		}
	}
	n += 2 + sovStructured(uint64(m.DropTime))
	l = len(m.FullFuncName)
	n += 2 + l + sovStructured(uint64(l))
	n += 2 + sovStructured(uint64(m.DropJobID))
	if len(m.MutationJobs) > 0 {
		for _, e := range m.MutationJobs {
			l = e.Size()
			n += 2 + l + sovStructured(uint64(l))
		}
	}
	if len(m.GCMutations) > 0 {
		for _, e := range m.GCMutations {
			l = e.Size()
			n += 2 + l + sovStructured(uint64(l))
		}
	}
	l = len(m.Hashsql)
	n += 2 + l + sovStructured(uint64(l))
	l = len(m.FilePath)
	n += 2 + l + sovStructured(uint64(l))
	l = len(m.FileName)
	n += 2 + l + sovStructured(uint64(l))
	l = m.ModificationTime.Size()
	n += 2 + l + sovStructured(uint64(l))
	return n
}

func (m *FunctionDescriptor_NameInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovStructured(uint64(m.ParentID))
	l = len(m.Name)
	n += 1 + l + sovStructured(uint64(l))
	return n
}

func (m *FunctionDescriptor_MutationJob) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovStructured(uint64(m.MutationID))
	n += 1 + sovStructured(uint64(m.JobID))
	return n
}

func (m *FunctionDescriptor_GCDescriptorMutation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovStructured(uint64(m.IndexID))
	n += 1 + sovStructured(uint64(m.DropTime))
	n += 1 + sovStructured(uint64(m.JobID))
	return n
}

func (m *CursorDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovStructured(uint64(l))
	n += 1 + sovStructured(uint64(m.ID))
	l = len(m.QueryString)
	n += 1 + l + sovStructured(uint64(l))
	n += 1 + sovStructured(uint64(m.Position))
	n += 1 + sovStructured(uint64(m.MaxRownum))
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovStructured(uint64(l))
		}
	}
	n += 1 + sovStructured(uint64(m.State))
	if len(m.CurVarDescriptors) > 0 {
		for _, e := range m.CurVarDescriptors {
			l = e.Size()
			n += 1 + l + sovStructured(uint64(l))
		}
	}
	if len(m.PrimaryIndex) > 0 {
		for _, s := range m.PrimaryIndex {
			l = len(s)
			n += 1 + l + sovStructured(uint64(l))
		}
	}
	l = len(m.TableName)
	n += 1 + l + sovStructured(uint64(l))
	l = len(m.TxnState)
	n += 1 + l + sovStructured(uint64(l))
	return n
}

func (m *VariableDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovStructured(uint64(l))
	n += 1 + sovStructured(uint64(m.ID))
	l = m.Column.Size()
	n += 1 + l + sovStructured(uint64(l))
	l = len(m.TxnState)
	n += 1 + l + sovStructured(uint64(l))
	return n
}

func sovStructured(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozStructured(x uint64) (n int) {
	return sovStructured(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ColumnType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SemanticType", wireType)
			}
			m.SemanticType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SemanticType |= (ColumnType_SemanticType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Precision", wireType)
			}
			m.Precision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Precision |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructured
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ArrayDimensions = append(m.ArrayDimensions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructured
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStructured
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ArrayDimensions) == 0 {
					m.ArrayDimensions = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructured
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ArrayDimensions = append(m.ArrayDimensions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ArrayDimensions", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locale", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Locale = &s
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VisibleType", wireType)
			}
			m.VisibleType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VisibleType |= (ColumnType_VisibleType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArrayContents", wireType)
			}
			var v ColumnType_SemanticType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (ColumnType_SemanticType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ArrayContents = &v
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TupleContents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TupleContents = append(m.TupleContents, ColumnType{})
			if err := m.TupleContents[len(m.TupleContents)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TupleLabels", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TupleLabels = append(m.TupleLabels, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VisibleTypeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VisibleTypeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnumContents", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnumContents = append(m.EnumContents, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetContents", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SetContents = append(m.SetContents, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForeignKeyReference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForeignKeyReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForeignKeyReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			m.Table = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Table |= (ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (IndexID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validity", wireType)
			}
			m.Validity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Validity |= (ConstraintValidity(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharedPrefixLen", wireType)
			}
			m.SharedPrefixLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SharedPrefixLen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnDelete", wireType)
			}
			m.OnDelete = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OnDelete |= (ForeignKeyReference_Action(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnUpdate", wireType)
			}
			m.OnUpdate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OnUpdate |= (ForeignKeyReference_Action(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			m.Match = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Match |= (ForeignKeyReference_Match(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForeignKeyConstraint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForeignKeyConstraint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForeignKeyConstraint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginTableID", wireType)
			}
			m.OriginTableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OriginTableID |= (ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructured
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ColumnID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OriginColumnIDs = append(m.OriginColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructured
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStructured
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OriginColumnIDs) == 0 {
					m.OriginColumnIDs = make([]ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructured
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ColumnID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OriginColumnIDs = append(m.OriginColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginColumnIDs", wireType)
			}
		case 3:
			if wireType == 0 {
				var v ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructured
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ColumnID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ReferencedColumnIDs = append(m.ReferencedColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructured
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStructured
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ReferencedColumnIDs) == 0 {
					m.ReferencedColumnIDs = make([]ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructured
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ColumnID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ReferencedColumnIDs = append(m.ReferencedColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferencedColumnIDs", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferencedTableID", wireType)
			}
			m.ReferencedTableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReferencedTableID |= (ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validity", wireType)
			}
			m.Validity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Validity |= (ConstraintValidity(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnDelete", wireType)
			}
			m.OnDelete = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OnDelete |= (ForeignKeyReference_Action(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnUpdate", wireType)
			}
			m.OnUpdate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OnUpdate |= (ForeignKeyReference_Action(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			m.Match = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Match |= (ForeignKeyReference_Match(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LegacyOriginIndex", wireType)
			}
			m.LegacyOriginIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LegacyOriginIndex |= (IndexID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LegacyReferencedIndex", wireType)
			}
			m.LegacyReferencedIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LegacyReferencedIndex |= (IndexID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LegacyUpgradedFromOriginReference", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LegacyUpgradedFromOriginReference.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LegacyUpgradedFromReferencedReference", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LegacyUpgradedFromReferencedReference.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (ColumnID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Type.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nullable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Nullable = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultExpr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DefaultExpr = &s
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hidden", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Hidden = bool(v != 0)
		case 10:
			if wireType == 0 {
				var v ID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructured
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UsesSequenceIds = append(m.UsesSequenceIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructured
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStructured
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UsesSequenceIds) == 0 {
					m.UsesSequenceIds = make([]ID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructured
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UsesSequenceIds = append(m.UsesSequenceIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UsesSequenceIds", wireType)
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputeExpr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ComputeExpr = &s
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsHashPartitionCol", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsHashPartitionCol = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Onupdatecurrenttimestamp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Onupdatecurrenttimestamp = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InhCount", wireType)
			}
			m.InhCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InhCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsInherits", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsInherits = bool(v != 0)
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Privileges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Privileges == nil {
				m.Privileges = &PrivilegeDescriptor{}
			}
			if err := m.Privileges.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentID", wireType)
			}
			m.ParentID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentID |= (ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatableViewDependsColName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatableViewDependsColName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType == 0 {
				var v ID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructured
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OwnsSequenceIds = append(m.OwnsSequenceIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructured
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStructured
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OwnsSequenceIds) == 0 {
					m.OwnsSequenceIds = make([]ID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructured
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OwnsSequenceIds = append(m.OwnsSequenceIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnsSequenceIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnFamilyDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnFamilyDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnFamilyDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (FamilyID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColumnNames = append(m.ColumnNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructured
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ColumnID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColumnIDs = append(m.ColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructured
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStructured
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColumnIDs) == 0 {
					m.ColumnIDs = make([]ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructured
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ColumnID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColumnIDs = append(m.ColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIDs", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultColumnID", wireType)
			}
			m.DefaultColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultColumnID |= (ColumnID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterleaveDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterleaveDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterleaveDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ancestors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ancestors = append(m.Ancestors, InterleaveDescriptor_Ancestor{})
			if err := m.Ancestors[len(m.Ancestors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterleaveDescriptor_Ancestor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ancestor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ancestor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= (ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= (IndexID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharedPrefixLen", wireType)
			}
			m.SharedPrefixLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SharedPrefixLen |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitioningDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitioningDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitioningDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumColumns", wireType)
			}
			m.NumColumns = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumColumns |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, PartitioningDescriptor_List{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Range = append(m.Range, PartitioningDescriptor_Range{})
			if err := m.Range[len(m.Range)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocationNums", wireType)
			}
			m.LocationNums = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocationNums |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsHashPartition", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsHashPartition = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitioningDescriptor_List) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: List: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: List: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, make([]byte, postIndex-iNdEx))
			copy(m.Values[len(m.Values)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocateSpaceName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocateSpaceName == nil {
				m.LocateSpaceName = &roachpb.LocationValue{}
			}
			if err := m.LocateSpaceName.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subpartitioning", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Subpartitioning.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitioningDescriptor_Range) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Range: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Range: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToExclusive", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToExclusive = append(m.ToExclusive[:0], dAtA[iNdEx:postIndex]...)
			if m.ToExclusive == nil {
				m.ToExclusive = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromInclusive", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromInclusive = append(m.FromInclusive[:0], dAtA[iNdEx:postIndex]...)
			if m.FromInclusive == nil {
				m.FromInclusive = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocateSpaceName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocateSpaceName == nil {
				m.LocateSpaceName = &roachpb.LocationValue{}
			}
			if err := m.LocateSpaceName.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (IndexID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unique", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Unique = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColumnNames = append(m.ColumnNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreColumnNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoreColumnNames = append(m.StoreColumnNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructured
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ColumnID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColumnIDs = append(m.ColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructured
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStructured
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColumnIDs) == 0 {
					m.ColumnIDs = make([]ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructured
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ColumnID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColumnIDs = append(m.ColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIDs", wireType)
			}
		case 7:
			if wireType == 0 {
				var v ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructured
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ColumnID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ExtraColumnIDs = append(m.ExtraColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructured
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStructured
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ExtraColumnIDs) == 0 {
					m.ExtraColumnIDs = make([]ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructured
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ColumnID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ExtraColumnIDs = append(m.ExtraColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraColumnIDs", wireType)
			}
		case 8:
			if wireType == 0 {
				var v IndexDescriptor_Direction
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructured
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (IndexDescriptor_Direction(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColumnDirections = append(m.ColumnDirections, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructured
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStructured
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ColumnDirections) == 0 {
					m.ColumnDirections = make([]IndexDescriptor_Direction, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v IndexDescriptor_Direction
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructured
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (IndexDescriptor_Direction(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColumnDirections = append(m.ColumnDirections, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnDirections", wireType)
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForeignKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ForeignKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferencedBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReferencedBy = append(m.ReferencedBy, ForeignKeyReference{})
			if err := m.ReferencedBy[len(m.ReferencedBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interleave", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Interleave.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterleavedBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterleavedBy = append(m.InterleavedBy, ForeignKeyReference{})
			if err := m.InterleavedBy[len(m.InterleavedBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType == 0 {
				var v ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructured
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ColumnID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CompositeColumnIDs = append(m.CompositeColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructured
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStructured
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CompositeColumnIDs) == 0 {
					m.CompositeColumnIDs = make([]ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructured
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ColumnID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CompositeColumnIDs = append(m.CompositeColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CompositeColumnIDs", wireType)
			}
		case 14:
			if wireType == 0 {
				var v ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructured
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ColumnID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.StoreColumnIDs = append(m.StoreColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructured
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStructured
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.StoreColumnIDs) == 0 {
					m.StoreColumnIDs = make([]ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructured
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ColumnID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.StoreColumnIDs = append(m.StoreColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreColumnIDs", wireType)
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partitioning", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Partitioning.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (IndexDescriptor_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocateSpaceName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocateSpaceName == nil {
				m.LocateSpaceName = &roachpb.LocationValue{}
			}
			if err := m.LocateSpaceName.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocationNums", wireType)
			}
			m.LocationNums = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocationNums |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredExpr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PredExpr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLocal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLocal = bool(v != 0)
		case 21:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructured
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IsFunc = append(m.IsFunc, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructured
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStructured
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.IsFunc) == 0 {
					m.IsFunc = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructured
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IsFunc = append(m.IsFunc, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFunc", wireType)
			}
		case 22:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructured
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IsRealFunc = append(m.IsRealFunc, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructured
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStructured
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.IsRealFunc) == 0 {
					m.IsRealFunc = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructured
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IsRealFunc = append(m.IsRealFunc, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRealFunc", wireType)
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncodingType", wireType)
			}
			m.EncodingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EncodingType |= (IndexDescriptorEncodingType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConstraintToUpdate) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConstraintToUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConstraintToUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstraintType", wireType)
			}
			m.ConstraintType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConstraintType |= (ConstraintToUpdate_ConstraintType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Check", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Check.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForeignKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ForeignKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotNullColumn", wireType)
			}
			m.NotNullColumn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NotNullColumn |= (ColumnID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("constraint_type")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("name")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrimaryKeySwap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrimaryKeySwap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrimaryKeySwap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewPrimaryIndexId", wireType)
			}
			m.NewPrimaryIndexId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewPrimaryIndexId |= (IndexID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v IndexID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructured
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (IndexID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OldIndexes = append(m.OldIndexes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructured
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStructured
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OldIndexes) == 0 {
					m.OldIndexes = make([]IndexID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v IndexID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructured
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (IndexID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OldIndexes = append(m.OldIndexes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OldIndexes", wireType)
			}
		case 3:
			if wireType == 0 {
				var v IndexID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructured
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (IndexID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NewIndexes = append(m.NewIndexes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructured
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStructured
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NewIndexes) == 0 {
					m.NewIndexes = make([]IndexID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v IndexID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructured
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (IndexID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NewIndexes = append(m.NewIndexes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NewIndexes", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldPrimaryIndexId", wireType)
			}
			m.OldPrimaryIndexId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OldPrimaryIndexId |= (IndexID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewPrimaryIndexName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewPrimaryIndexName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MaterializedViewRefresh) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MaterializedViewRefresh: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MaterializedViewRefresh: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewPrimaryIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NewPrimaryIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewIndexes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewIndexes = append(m.NewIndexes, IndexDescriptor{})
			if err := m.NewIndexes[len(m.NewIndexes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsOf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AsOf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DescriptorMutation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DescriptorMutation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DescriptorMutation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Column", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ColumnDescriptor{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Descriptor_ = &DescriptorMutation_Column{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IndexDescriptor{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Descriptor_ = &DescriptorMutation_Index{v}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (DescriptorMutation_State(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= (DescriptorMutation_Direction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MutationID", wireType)
			}
			m.MutationID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MutationID |= (MutationID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rollback", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Rollback = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constraint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ConstraintToUpdate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Descriptor_ = &DescriptorMutation_Constraint{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryKeySwap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PrimaryKeySwap{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Descriptor_ = &DescriptorMutation_PrimaryKeySwap{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaterializedViewRefresh", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MaterializedViewRefresh{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Descriptor_ = &DescriptorMutation_MaterializedViewRefresh{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentID", wireType)
			}
			m.ParentID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentID |= (ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (DescriptorVersion(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicationTable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReplicationTable = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModificationTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ModificationTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, ColumnDescriptor{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextColumnID", wireType)
			}
			m.NextColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextColumnID |= (ColumnID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PrimaryIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Indexes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Indexes = append(m.Indexes, IndexDescriptor{})
			if err := m.Indexes[len(m.Indexes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextIndexID", wireType)
			}
			m.NextIndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextIndexID |= (IndexID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Privileges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Privileges == nil {
				m.Privileges = &PrivilegeDescriptor{}
			}
			if err := m.Privileges.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mutations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mutations = append(m.Mutations, DescriptorMutation{})
			if err := m.Mutations[len(m.Mutations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lease", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lease == nil {
				m.Lease = &TableDescriptor_SchemaChangeLease{}
			}
			if err := m.Lease.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextMutationID", wireType)
			}
			m.NextMutationID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextMutationID |= (MutationID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FormatVersion", wireType)
			}
			m.FormatVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FormatVersion |= (FormatVersion(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocateSpaceName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocateSpaceName == nil {
				m.LocateSpaceName = &roachpb.LocationValue{}
			}
			if err := m.LocateSpaceName.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (TableDescriptor_State(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Checks = append(m.Checks, &TableDescriptor_CheckConstraint{})
			if err := m.Checks[len(m.Checks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DrainingNames", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DrainingNames = append(m.DrainingNames, TableDescriptor_NameInfo{})
			if err := m.DrainingNames[len(m.DrainingNames)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Families", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Families = append(m.Families, ColumnFamilyDescriptor{})
			if err := m.Families[len(m.Families)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextFamilyID", wireType)
			}
			m.NextFamilyID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextFamilyID |= (FamilyID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViewQuery", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ViewQuery = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType == 0 {
				var v ID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructured
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DependsOn = append(m.DependsOn, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructured
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStructured
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DependsOn) == 0 {
					m.DependsOn = make([]ID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructured
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DependsOn = append(m.DependsOn, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DependsOn", wireType)
			}
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DependedOnBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DependedOnBy = append(m.DependedOnBy, TableDescriptor_Reference{})
			if err := m.DependedOnBy[len(m.DependedOnBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MutationJobs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MutationJobs = append(m.MutationJobs, TableDescriptor_MutationJob{})
			if err := m.MutationJobs[len(m.MutationJobs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceOpts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SequenceOpts == nil {
				m.SequenceOpts = &TableDescriptor_SequenceOpts{}
			}
			if err := m.SequenceOpts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropTime", wireType)
			}
			m.DropTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DropTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplacementOf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReplacementOf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuditMode", wireType)
			}
			m.AuditMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuditMode |= (TableDescriptor_AuditMode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropJobID", wireType)
			}
			m.DropJobID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DropJobID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GCMutations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GCMutations = append(m.GCMutations, TableDescriptor_GCDescriptorMutation{})
			if err := m.GCMutations[len(m.GCMutations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocationNums", wireType)
			}
			m.LocationNums = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocationNums |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsHashPartition", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsHashPartition = bool(v != 0)
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashParts", wireType)
			}
			m.HashParts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HashParts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashField", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HashField = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EngineTypeSetMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EngineTypeSetMap == nil {
				m.EngineTypeSetMap = make(map[uint32]*TableDescriptor_MapValue)
			}
			var mapkey uint32
			var mapvalue *TableDescriptor_MapValue
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructured
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructured
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructured
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthStructured
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthStructured
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &TableDescriptor_MapValue{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStructured(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthStructured
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.EngineTypeSetMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 39:
			if wireType == 0 {
				var v ID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructured
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Inherits = append(m.Inherits, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructured
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStructured
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Inherits) == 0 {
					m.Inherits = make([]ID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructured
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Inherits = append(m.Inherits, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Inherits", wireType)
			}
		case 40:
			if wireType == 0 {
				var v ID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructured
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.InheritsBy = append(m.InheritsBy, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructured
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStructured
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.InheritsBy) == 0 {
					m.InheritsBy = make([]ID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructured
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.InheritsBy = append(m.InheritsBy, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field InheritsBy", wireType)
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Temporary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Temporary = bool(v != 0)
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateByTable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CreateByTable = bool(v != 0)
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxColumnID", wireType)
			}
			m.MaxColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxColumnID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViewUpdatable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ViewUpdatable = bool(v != 0)
		case 45:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViewDependsOn", wireType)
			}
			m.ViewDependsOn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ViewDependsOn |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 46:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comments", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comments = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 47:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMaterializedView", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsMaterializedView = bool(v != 0)
		case 48:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateQuery", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreateQuery = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 49:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAsOfTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreateAsOfTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableDescriptor_SchemaChangeLease) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaChangeLease: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaChangeLease: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= (github_com_znbasedb_znbase_pkg_roachpb.NodeID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTime", wireType)
			}
			m.ExpirationTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpirationTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableDescriptor_CheckConstraint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckConstraint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckConstraint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validity", wireType)
			}
			m.Validity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Validity |= (ConstraintValidity(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructured
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ColumnID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColumnIDs = append(m.ColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructured
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStructured
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColumnIDs) == 0 {
					m.ColumnIDs = make([]ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructured
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ColumnID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColumnIDs = append(m.ColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIDs", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Able", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Able = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsInherits", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsInherits = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InhCount", wireType)
			}
			m.InhCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InhCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableDescriptor_NameInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NameInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NameInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentID", wireType)
			}
			m.ParentID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentID |= (ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableDescriptor_Reference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= (IndexID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructured
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ColumnID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColumnIDs = append(m.ColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructured
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStructured
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColumnIDs) == 0 {
					m.ColumnIDs = make([]ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructured
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ColumnID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColumnIDs = append(m.ColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableDescriptor_MutationJob) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MutationJob: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MutationJob: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MutationID", wireType)
			}
			m.MutationID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MutationID |= (MutationID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobID", wireType)
			}
			m.JobID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableDescriptor_SequenceOpts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SequenceOpts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SequenceOpts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Increment", wireType)
			}
			m.Increment = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Increment |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinValue", wireType)
			}
			m.MinValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinValue |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxValue", wireType)
			}
			m.MaxValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxValue |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Virtual", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Virtual = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cache", wireType)
			}
			m.Cache = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cache |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cycle", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Cycle = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EverOver", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EverOver = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCall", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCall = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceOwner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SequenceOwner.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableDescriptor_SequenceOpts_SequenceOwner) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SequenceOwner: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SequenceOwner: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerColumnID", wireType)
			}
			m.OwnerColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerColumnID |= (ColumnID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerTableID", wireType)
			}
			m.OwnerTableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerTableID |= (ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableDescriptor_Replacement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Replacement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Replacement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Time.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableDescriptor_GCDescriptorMutation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCDescriptorMutation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCDescriptorMutation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= (IndexID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropTime", wireType)
			}
			m.DropTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DropTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobID", wireType)
			}
			m.JobID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableDescriptor_MapValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MapValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MapValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Privileges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Privileges == nil {
				m.Privileges = &PrivilegeDescriptor{}
			}
			if err := m.Privileges.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schemas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schemas = append(m.Schemas, SchemaDescriptor{})
			if err := m.Schemas[len(m.Schemas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Descriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Descriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Descriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TableDescriptor{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Union = &Descriptor_Table{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DatabaseDescriptor{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Union = &Descriptor_Database{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SchemaDescriptor{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Union = &Descriptor_Schema{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Function", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FunctionDescriptor{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Union = &Descriptor_Function{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Privileges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Privileges == nil {
				m.Privileges = &PrivilegeDescriptor{}
			}
			if err := m.Privileges.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentID", wireType)
			}
			m.ParentID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentID |= (ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FunctionTriggerType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FunctionTriggerType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FunctionTriggerType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FuncArgDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FuncArgDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FuncArgDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (ColumnID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Type.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnTypeString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColumnTypeString = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nullable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Nullable = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputeExpr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ComputeExpr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InOutMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InOutMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oid", wireType)
			}
			m.Oid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Oid |= (github_com_lib_pq_oid.Oid(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FunctionDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FunctionDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FunctionDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Privileges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Privileges == nil {
				m.Privileges = &PrivilegeDescriptor{}
			}
			if err := m.Privileges.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentID", wireType)
			}
			m.ParentID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentID |= (ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnID", wireType)
			}
			m.TxnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxnID |= (ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (DescriptorVersion(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, FuncArgDescriptor{})
			if err := m.Args[len(m.Args)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArgNum", wireType)
			}
			m.ArgNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArgNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsProcedure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsProcedure = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TriggerType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReturnType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReturnType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetOid", wireType)
			}
			m.RetOid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetOid |= (github_com_lib_pq_oid.Oid(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (FunctionDescriptor_State(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FuncDef", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FuncDef = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DrainingNames", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DrainingNames = append(m.DrainingNames, FunctionDescriptor_NameInfo{})
			if err := m.DrainingNames[len(m.DrainingNames)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropTime", wireType)
			}
			m.DropTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DropTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullFuncName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FullFuncName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropJobID", wireType)
			}
			m.DropJobID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DropJobID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MutationJobs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MutationJobs = append(m.MutationJobs, FunctionDescriptor_MutationJob{})
			if err := m.MutationJobs[len(m.MutationJobs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GCMutations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GCMutations = append(m.GCMutations, FunctionDescriptor_GCDescriptorMutation{})
			if err := m.GCMutations[len(m.GCMutations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hashsql", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hashsql = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModificationTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ModificationTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FunctionDescriptor_NameInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NameInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NameInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentID", wireType)
			}
			m.ParentID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentID |= (ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FunctionDescriptor_MutationJob) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MutationJob: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MutationJob: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MutationID", wireType)
			}
			m.MutationID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MutationID |= (MutationID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobID", wireType)
			}
			m.JobID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FunctionDescriptor_GCDescriptorMutation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCDescriptorMutation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCDescriptorMutation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= (IndexID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropTime", wireType)
			}
			m.DropTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DropTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobID", wireType)
			}
			m.JobID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CursorDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CursorDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CursorDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryString = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			m.Position = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Position |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRownum", wireType)
			}
			m.MaxRownum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRownum |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, ColumnDescriptor{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurVarDescriptors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurVarDescriptors = append(m.CurVarDescriptors, VariableDescriptor{})
			if err := m.CurVarDescriptors[len(m.CurVarDescriptors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryIndex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrimaryIndex = append(m.PrimaryIndex, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxnState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VariableDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VariableDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VariableDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Column", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Column.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxnState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStructured(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthStructured
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowStructured
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipStructured(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthStructured = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStructured   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("sql/sqlbase/structured.proto", fileDescriptor_structured_73c01a8eb8520736)
}

var fileDescriptor_structured_73c01a8eb8520736 = []byte{
	// 5478 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x3b, 0x4b, 0x6c, 0x24, 0xc7,
	0x75, 0x9c, 0xff, 0xcc, 0x9b, 0x5f, 0xb3, 0xc8, 0x5d, 0x8d, 0x28, 0x99, 0xe4, 0xce, 0x6a, 0x25,
	0x4a, 0x96, 0xc8, 0x15, 0x65, 0x05, 0xb2, 0x6c, 0xd8, 0x9a, 0x1f, 0x97, 0xb3, 0x3b, 0x9c, 0xa1,
	0x9b, 0x43, 0x2a, 0x2b, 0x18, 0x18, 0x34, 0xa7, 0x8b, 0xc3, 0xb6, 0x7a, 0xba, 0x67, 0xbb, 0x7b,
	0xb8, 0xa4, 0x6f, 0xb9, 0x39, 0xb7, 0x5c, 0x92, 0x5c, 0x02, 0xc3, 0x30, 0x72, 0xf0, 0x35, 0x37,
	0x07, 0x70, 0x80, 0x1c, 0x02, 0x44, 0x49, 0x2e, 0x46, 0x4e, 0x3e, 0x2d, 0x9c, 0x15, 0x0c, 0xe4,
	0xe0, 0x5b, 0x80, 0x1c, 0xf6, 0x14, 0xd4, 0xaf, 0xbb, 0x7a, 0x3e, 0xf4, 0x2c, 0xa5, 0x20, 0xce,
	0x6d, 0xfa, 0xd5, 0x7b, 0xaf, 0xaa, 0x5e, 0xbd, 0x7f, 0xd5, 0xc0, 0xeb, 0xee, 0x13, 0x73, 0xc7,
	0x7d, 0x62, 0x9e, 0x6a, 0x2e, 0xde, 0x71, 0x3d, 0x67, 0xdc, 0xf7, 0xc6, 0x0e, 0xd6, 0xb7, 0x47,
	0x8e, 0xed, 0xd9, 0x08, 0xfd, 0xd8, 0x22, 0x03, 0xdb, 0xee, 0x13, 0x73, 0x9b, 0x23, 0xad, 0x95,
	0xc6, 0x9e, 0x61, 0xee, 0x9c, 0x9b, 0xfd, 0x1d, 0xcf, 0x18, 0x62, 0xd7, 0xd3, 0x86, 0x23, 0x86,
	0xbd, 0xf6, 0x9a, 0xcc, 0x6b, 0xe4, 0x18, 0x17, 0x86, 0x89, 0x07, 0x98, 0x0f, 0xae, 0x0e, 0xec,
	0x81, 0x4d, 0x7f, 0xee, 0x90, 0x5f, 0x1c, 0x7a, 0xdb, 0xb1, 0xb5, 0xfe, 0xf9, 0xe8, 0x74, 0x67,
	0x88, 0x3d, 0x4d, 0xd7, 0x3c, 0x8d, 0xc1, 0xcb, 0x5f, 0xa6, 0x01, 0x6a, 0xb6, 0x39, 0x1e, 0x5a,
	0xdd, 0xab, 0x11, 0x46, 0x27, 0x90, 0x77, 0xf1, 0x50, 0xb3, 0x3c, 0xa3, 0xdf, 0xf3, 0xae, 0x46,
	0xb8, 0x14, 0xd9, 0x8c, 0x6c, 0x15, 0x76, 0xbf, 0xb9, 0x3d, 0xbd, 0xbe, 0xed, 0x80, 0x6c, 0xfb,
	0x88, 0xd3, 0x90, 0x8f, 0x6a, 0xfc, 0x8b, 0x67, 0x1b, 0x4b, 0x6a, 0xce, 0x95, 0x60, 0x68, 0x0d,
	0x12, 0x4f, 0x0d, 0xdd, 0x3b, 0x2f, 0x45, 0x37, 0x23, 0x5b, 0x09, 0x8e, 0xc2, 0x40, 0xa8, 0x0c,
	0x99, 0x91, 0x83, 0xfb, 0x86, 0x6b, 0xd8, 0x56, 0x29, 0x26, 0x8d, 0x07, 0x60, 0xf4, 0x36, 0x28,
	0x9a, 0xe3, 0x68, 0x57, 0x3d, 0xdd, 0x18, 0x62, 0x8b, 0x80, 0xdc, 0x52, 0x7c, 0x33, 0xb6, 0x95,
	0x50, 0x8b, 0x14, 0x5e, 0xf7, 0xc1, 0xe8, 0x36, 0x24, 0x4d, 0xbb, 0xaf, 0x99, 0xb8, 0x94, 0xd8,
	0x8c, 0x6c, 0x65, 0x54, 0xfe, 0x85, 0x8e, 0x20, 0x77, 0x61, 0xb8, 0xc6, 0xa9, 0x89, 0xd9, 0xce,
	0x92, 0x74, 0x67, 0xef, 0xfc, 0x81, 0x9d, 0x9d, 0x30, 0x12, 0x69, 0x63, 0xd9, 0x8b, 0x00, 0x84,
	0x54, 0x28, 0xb0, 0x75, 0xf5, 0x6d, 0xcb, 0xc3, 0x96, 0xe7, 0x96, 0x52, 0x2f, 0x2d, 0x30, 0x35,
	0x4f, 0x59, 0xd4, 0x38, 0x07, 0xf4, 0x08, 0x0a, 0xde, 0x78, 0x64, 0xe2, 0x80, 0x67, 0x7a, 0x33,
	0xb6, 0x95, 0xdd, 0x5d, 0xbf, 0x9e, 0x27, 0x5f, 0x5e, 0x9e, 0xd2, 0xfa, 0xcc, 0xee, 0x40, 0x8e,
	0x31, 0x33, 0xb5, 0x53, 0x6c, 0xba, 0xa5, 0xcc, 0x66, 0x6c, 0x2b, 0xa3, 0x66, 0x29, 0xac, 0x45,
	0x41, 0x68, 0x1b, 0x8a, 0xd2, 0x2e, 0xdb, 0xda, 0x10, 0x97, 0x80, 0x48, 0x8e, 0x33, 0x9c, 0x1c,
	0x44, 0x77, 0x21, 0x8f, 0xad, 0xf1, 0x30, 0x58, 0x5e, 0x96, 0xf2, 0xcc, 0x11, 0xa0, 0x3c, 0xaf,
	0x8b, 0xbd, 0x00, 0x27, 0xc7, 0xe6, 0x75, 0xb1, 0x27, 0x50, 0xca, 0xff, 0x10, 0x85, 0x9c, 0x2c,
	0x07, 0x94, 0x86, 0x78, 0xb5, 0xd3, 0x69, 0x29, 0x4b, 0x28, 0x05, 0xb1, 0x66, 0xbb, 0xab, 0x44,
	0x50, 0x06, 0x12, 0x7b, 0xad, 0x4e, 0xa5, 0xab, 0x44, 0x51, 0x16, 0x52, 0xf5, 0x46, 0xad, 0x79,
	0x50, 0x69, 0x29, 0x31, 0x82, 0x5a, 0xaf, 0x74, 0x1b, 0x4a, 0x1c, 0xe5, 0x21, 0xd3, 0x6d, 0x1e,
	0x34, 0x8e, 0xba, 0x95, 0x83, 0x43, 0x25, 0x81, 0x72, 0x90, 0x6e, 0xb6, 0xbb, 0x0d, 0xf5, 0xa4,
	0xd2, 0x52, 0x92, 0x08, 0x20, 0x79, 0xd4, 0x55, 0x9b, 0xed, 0x07, 0x4a, 0x8a, 0xb0, 0xaa, 0x3e,
	0xee, 0x36, 0x8e, 0x94, 0x34, 0x2a, 0x42, 0xd6, 0xa7, 0xe9, 0x7e, 0xa6, 0x64, 0x10, 0x82, 0x42,
	0xad, 0xd3, 0x6a, 0x55, 0xba, 0x8d, 0x3a, 0xc7, 0x07, 0x32, 0x45, 0xbb, 0x72, 0xd0, 0x50, 0xb2,
	0x64, 0x35, 0x9d, 0x66, 0x5d, 0xc9, 0x51, 0xd0, 0x71, 0xab, 0xa5, 0xe4, 0xc9, 0xaf, 0xe3, 0xe3,
	0x66, 0x5d, 0x29, 0x10, 0xb6, 0x15, 0x55, 0xad, 0x3c, 0x56, 0x8a, 0x04, 0xd8, 0x6c, 0x37, 0xba,
	0x8a, 0x42, 0x7e, 0x91, 0x09, 0x94, 0x65, 0x32, 0xfc, 0xf0, 0xa8, 0xd3, 0xae, 0x2a, 0x88, 0xfc,
	0xec, 0x1e, 0x1f, 0xb6, 0x1a, 0xca, 0x2a, 0xe1, 0x58, 0x6d, 0x76, 0x95, 0x5b, 0xa8, 0x08, 0xd0,
	0x6c, 0x77, 0x77, 0x4f, 0x1a, 0xb5, 0x6e, 0x47, 0x55, 0xbe, 0x88, 0xa0, 0x02, 0x64, 0x3a, 0xcd,
	0x3a, 0xff, 0xfe, 0x17, 0x22, 0x80, 0x78, 0xa3, 0x7d, 0x7c, 0xa0, 0xfc, 0x6b, 0x04, 0xa5, 0x21,
	0x76, 0xd4, 0xe8, 0x2a, 0xff, 0x16, 0x29, 0xc7, 0xd3, 0x2b, 0xca, 0x4a, 0xf9, 0xe7, 0x11, 0xc8,
	0x4a, 0x67, 0x43, 0x57, 0xd7, 0x69, 0x37, 0x94, 0x25, 0x22, 0x2a, 0x22, 0x84, 0x07, 0x0d, 0x55,
	0x89, 0x10, 0x89, 0x1c, 0x1d, 0x54, 0x5a, 0x2d, 0x22, 0xd0, 0x28, 0x91, 0x48, 0xb5, 0xf9, 0x80,
	0xfc, 0xa6, 0x42, 0x54, 0x1b, 0x95, 0x96, 0x92, 0x40, 0xab, 0xa0, 0xd4, 0x3b, 0xc7, 0xd5, 0x56,
	0xa3, 0x77, 0xa8, 0x36, 0x6a, 0xcd, 0xa3, 0x66, 0xa7, 0xad, 0x24, 0x09, 0x9b, 0x93, 0x8a, 0x5a,
	0xdb, 0xaf, 0xa8, 0x4a, 0x8a, 0x20, 0xd3, 0x5f, 0x69, 0xb2, 0x8f, 0x1f, 0xd0, 0x9f, 0x19, 0xc2,
	0xed, 0xa4, 0xa2, 0x92, 0xad, 0x00, 0x2a, 0x00, 0xf8, 0x42, 0x3d, 0x54, 0xb2, 0xe5, 0x78, 0x3a,
	0xae, 0xc4, 0x3f, 0x8e, 0xff, 0xe7, 0xcf, 0x36, 0x96, 0xca, 0xff, 0x1d, 0x87, 0x95, 0x3d, 0xdb,
	0xc1, 0xc6, 0xc0, 0x7a, 0x84, 0xaf, 0x54, 0x7c, 0x86, 0x1d, 0x6c, 0xf5, 0x31, 0xda, 0x84, 0x84,
	0xa7, 0x9d, 0x9a, 0xcc, 0xcd, 0xe4, 0xab, 0x40, 0x14, 0xee, 0xc5, 0xb3, 0x8d, 0x68, 0xb3, 0xae,
	0xb2, 0x01, 0x74, 0x0f, 0x12, 0x86, 0xa5, 0xe3, 0x4b, 0xea, 0x38, 0xf2, 0xd5, 0x22, 0xc7, 0x48,
	0x35, 0x09, 0x90, 0xa0, 0xd1, 0x51, 0x54, 0x82, 0xb8, 0x45, 0x14, 0x37, 0x26, 0x29, 0x2e, 0x85,
	0xa0, 0x7d, 0x48, 0x5f, 0x68, 0xa6, 0xa1, 0x1b, 0xde, 0x55, 0x29, 0x4e, 0x6d, 0xf3, 0xcd, 0xd9,
	0x76, 0x64, 0xb9, 0x9e, 0xa3, 0x19, 0x96, 0x77, 0xc2, 0xb1, 0x39, 0x17, 0x9f, 0x1a, 0xdd, 0x87,
	0x65, 0xf7, 0x5c, 0x73, 0xb0, 0xde, 0x1b, 0x39, 0xf8, 0xcc, 0xb8, 0xec, 0x99, 0xd8, 0xa2, 0x3e,
	0x46, 0xf8, 0xab, 0x22, 0x1b, 0x3e, 0xa4, 0xa3, 0x2d, 0x6c, 0xa1, 0x1f, 0x40, 0xc6, 0xb6, 0x7a,
	0x3a, 0x36, 0xb1, 0x27, 0xfc, 0xcd, 0xf6, 0xac, 0xc9, 0x67, 0x88, 0x66, 0xbb, 0xd2, 0xf7, 0x0c,
	0xdb, 0x12, 0x8b, 0xb0, 0xad, 0x3a, 0xe5, 0xc2, 0x59, 0x8e, 0x47, 0xba, 0xe6, 0x61, 0xee, 0x6b,
	0x6e, 0xcc, 0xf2, 0x98, 0x72, 0x41, 0x4d, 0x48, 0x0c, 0x35, 0xaf, 0x7f, 0x5e, 0x4a, 0x53, 0x76,
	0xef, 0x2d, 0xca, 0xee, 0x80, 0x10, 0x09, 0x57, 0x4e, 0x39, 0x94, 0x3f, 0x85, 0x24, 0x9b, 0x84,
	0x98, 0x65, 0xbb, 0xd3, 0xab, 0xd4, 0xba, 0x44, 0x95, 0x96, 0x88, 0x12, 0xaa, 0x0d, 0x62, 0x5a,
	0xb5, 0x2e, 0x57, 0xc9, 0x46, 0xb7, 0x47, 0x6d, 0x29, 0x4a, 0xac, 0x91, 0x7c, 0xd5, 0x1b, 0x7b,
	0x95, 0xe3, 0x16, 0xd1, 0xcb, 0x2c, 0xa4, 0x6a, 0x95, 0xa3, 0x5a, 0xa5, 0xde, 0x50, 0xe2, 0x6b,
	0xf1, 0x5f, 0xfc, 0xed, 0xfa, 0x52, 0xf9, 0x3e, 0x24, 0xe8, 0x74, 0xd4, 0xa2, 0x9b, 0x07, 0xc4,
	0x8a, 0x96, 0x88, 0x4a, 0xee, 0x11, 0x16, 0x11, 0x42, 0x71, 0x58, 0x51, 0xbb, 0xcd, 0x4a, 0x4b,
	0x89, 0x32, 0x0a, 0xaa, 0x78, 0x91, 0xf2, 0x3f, 0xa7, 0x61, 0x35, 0x58, 0x7b, 0x70, 0xc8, 0xa8,
	0x06, 0x45, 0xdb, 0x31, 0x06, 0x86, 0xd5, 0xa3, 0x7a, 0xd6, 0x33, 0x74, 0xae, 0x83, 0xaf, 0x91,
	0xfd, 0x3c, 0x7f, 0xb6, 0x91, 0xef, 0xd0, 0xe1, 0x2e, 0x19, 0x6d, 0xd6, 0xb9, 0x52, 0xe6, 0x6d,
	0x09, 0xa8, 0xa3, 0x47, 0xb0, 0xcc, 0x99, 0xf4, 0xa9, 0x1b, 0xee, 0x19, 0xba, 0x5b, 0x8a, 0x6e,
	0xc6, 0xb6, 0xf2, 0xd5, 0x8d, 0xe7, 0xcf, 0x36, 0x8a, 0x8c, 0x05, 0x73, 0xd1, 0xcd, 0xba, 0xfb,
	0xe2, 0xd9, 0x46, 0x5a, 0x7c, 0xa8, 0x7c, 0x7a, 0xfe, 0xad, 0xbb, 0xe8, 0x53, 0xb8, 0xe5, 0x08,
	0xd9, 0xea, 0x32, 0xc3, 0x18, 0x65, 0x78, 0xf7, 0xf9, 0xb3, 0x8d, 0x15, 0x5f, 0xf8, 0xfa, 0x6c,
	0xa6, 0x2b, 0xce, 0x24, 0x82, 0xee, 0xa2, 0x0e, 0x48, 0xe0, 0x60, 0xbb, 0x71, 0xba, 0xdd, 0x0d,
	0xbe, 0xdd, 0xe5, 0x80, 0x75, 0x78, 0xcb, 0xcb, 0xce, 0xc4, 0x80, 0xee, 0x1b, 0x5b, 0xe2, 0x5a,
	0x63, 0x4b, 0x7e, 0x25, 0x63, 0x0b, 0x99, 0x4e, 0xea, 0xeb, 0x37, 0x9d, 0xf4, 0xd7, 0x6b, 0x3a,
	0x99, 0xaf, 0x6a, 0x3a, 0xe8, 0xfb, 0xb0, 0x62, 0xe2, 0x81, 0xd6, 0xbf, 0xea, 0x71, 0x95, 0x62,
	0x6e, 0x0f, 0x66, 0xbb, 0xbd, 0x65, 0x86, 0xcb, 0x14, 0x8c, 0x02, 0xd1, 0x03, 0x78, 0x85, 0x33,
	0x90, 0x4e, 0x9b, 0x31, 0xc9, 0xce, 0x66, 0x72, 0x8b, 0xe1, 0x07, 0x27, 0xcf, 0x18, 0xfd, 0x59,
	0x04, 0xee, 0x71, 0x4e, 0xe3, 0xd1, 0xc0, 0xd1, 0x74, 0xac, 0xf7, 0xce, 0x1c, 0x7b, 0x28, 0x16,
	0xe6, 0xb3, 0x2f, 0xe5, 0x36, 0x23, 0x5b, 0xd9, 0xdd, 0xb7, 0x16, 0xdc, 0x75, 0x35, 0x49, 0x16,
	0x50, 0x8a, 0xa8, 0x77, 0x18, 0xf7, 0x63, 0xce, 0x7c, 0xcf, 0xb1, 0x87, 0x6c, 0x23, 0x41, 0x60,
	0xf8, 0xf3, 0x08, 0xbc, 0x3d, 0x73, 0x0d, 0xd2, 0xde, 0x82, 0x75, 0xe4, 0x6f, 0xb6, 0x8e, 0x7b,
	0xd3, 0xeb, 0x08, 0x64, 0xe1, 0xff, 0xe2, 0x9e, 0xe4, 0x2f, 0x93, 0xa0, 0x30, 0x9b, 0xaa, 0x63,
	0xb7, 0xef, 0x18, 0x23, 0xcf, 0x76, 0x7c, 0x4b, 0x88, 0x4c, 0x59, 0xc2, 0x9b, 0x10, 0x35, 0x74,
	0x1e, 0xb4, 0x6e, 0x73, 0x1b, 0x8b, 0x52, 0xa3, 0x0a, 0xac, 0x35, 0x6a, 0xe8, 0xe8, 0x23, 0x88,
	0xd3, 0x6c, 0x34, 0x46, 0xb7, 0xb0, 0x58, 0x8a, 0x47, 0x29, 0xd0, 0x26, 0xa4, 0xad, 0xb1, 0x69,
	0xd2, 0xf0, 0x49, 0x6c, 0x39, 0x2d, 0xb4, 0x53, 0x40, 0x49, 0x0e, 0xa6, 0xe3, 0x33, 0x6d, 0x6c,
	0x7a, 0x3d, 0x7c, 0x39, 0x72, 0x78, 0x3e, 0x9c, 0xe5, 0xb0, 0xc6, 0xe5, 0xc8, 0x41, 0xaf, 0x43,
	0xf2, 0xdc, 0xd0, 0x75, 0x6c, 0x51, 0x73, 0x15, 0x2c, 0x38, 0x0c, 0xed, 0xc2, 0xf2, 0xd8, 0xc5,
	0x6e, 0xcf, 0xc5, 0x4f, 0xc6, 0x44, 0x14, 0xd4, 0x1d, 0x01, 0x75, 0x47, 0x49, 0xee, 0x1e, 0x8a,
	0x04, 0xe1, 0x88, 0x8f, 0x13, 0x6f, 0x73, 0x07, 0x72, 0x7d, 0x7b, 0x38, 0x1a, 0x7b, 0x98, 0x4d,
	0x9a, 0x65, 0x93, 0x72, 0x18, 0x9d, 0xf4, 0x03, 0x48, 0x19, 0x6e, 0xef, 0x5c, 0x73, 0xcf, 0xa9,
	0x06, 0xa5, 0xab, 0x6b, 0x5c, 0x40, 0xa8, 0xe9, 0xee, 0x6b, 0xee, 0xf9, 0xa1, 0xe6, 0x78, 0x06,
	0xb1, 0xb7, 0x9a, 0x6d, 0xaa, 0x49, 0x83, 0xc2, 0xd0, 0x27, 0x50, 0xb2, 0x2d, 0x66, 0xbc, 0xfd,
	0xb1, 0xe3, 0x60, 0xcb, 0xf3, 0xab, 0x22, 0x7a, 0xfe, 0x62, 0xed, 0x73, 0xb1, 0xd0, 0x1d, 0xc8,
	0x18, 0xd6, 0x79, 0xaf, 0x6f, 0x8f, 0x2d, 0xaf, 0x54, 0xa0, 0x27, 0xc3, 0x25, 0x66, 0x58, 0xe7,
	0x35, 0x02, 0x45, 0xf7, 0x20, 0x6b, 0xb8, 0x3d, 0xc3, 0x3a, 0xc7, 0x8e, 0xe1, 0xb9, 0xa5, 0xa2,
	0xc4, 0x17, 0x0c, 0xb7, 0xc9, 0xe1, 0xe8, 0x01, 0x80, 0x5f, 0x75, 0xb9, 0x25, 0x65, 0xbe, 0xf6,
	0x1d, 0x0a, 0xac, 0x40, 0x67, 0x54, 0x89, 0x14, 0x7d, 0x00, 0x99, 0x91, 0x46, 0x56, 0x49, 0x1c,
	0xf2, 0x72, 0x48, 0x59, 0xd2, 0x87, 0x74, 0xc0, 0xf7, 0xc3, 0x69, 0x86, 0xd8, 0xd4, 0xd1, 0x1e,
	0xbc, 0x46, 0x77, 0x48, 0xce, 0xf8, 0xc4, 0xc0, 0x4f, 0xeb, 0x78, 0x84, 0x2d, 0xdd, 0xad, 0xd9,
	0x26, 0xcd, 0xdd, 0x91, 0xa4, 0x8b, 0xd7, 0x21, 0x92, 0xd3, 0xb5, 0x9f, 0x5a, 0x13, 0xa7, 0xbb,
	0x12, 0x3e, 0x5d, 0x82, 0x20, 0x9d, 0xee, 0xc3, 0x78, 0x3a, 0xad, 0x64, 0x1e, 0xc6, 0xd3, 0x19,
	0x05, 0x1e, 0xc6, 0xd3, 0x29, 0x25, 0x5d, 0xfe, 0x49, 0x14, 0x6e, 0x33, 0x0d, 0xdd, 0xd3, 0x86,
	0x86, 0x79, 0xf5, 0x55, 0xad, 0x83, 0x71, 0xe1, 0xd6, 0x41, 0x95, 0x89, 0x06, 0x42, 0x42, 0xc6,
	0x42, 0x21, 0x55, 0x26, 0x02, 0x23, 0x9b, 0x70, 0xd1, 0x47, 0x00, 0x52, 0xac, 0x8c, 0xd3, 0xe5,
	0xbf, 0xfa, 0xfc, 0xd9, 0x46, 0x66, 0x76, 0x84, 0xcc, 0xf4, 0xa5, 0xb8, 0xb8, 0x2c, 0xcc, 0xc3,
	0xe7, 0x40, 0x6d, 0x24, 0x5f, 0xbd, 0xcb, 0xd7, 0x54, 0xac, 0x33, 0x04, 0x41, 0x1e, 0x8e, 0xe0,
	0x7a, 0x68, 0x50, 0x2f, 0xff, 0x22, 0x0a, 0xab, 0x4d, 0xcb, 0xc3, 0x8e, 0x89, 0xb5, 0x0b, 0xe9,
	0xc8, 0xd1, 0x31, 0x64, 0x34, 0xab, 0x8f, 0x5d, 0xcf, 0x76, 0xdc, 0x52, 0x84, 0x16, 0x73, 0xef,
	0xcf, 0x52, 0x97, 0x59, 0xc4, 0xdb, 0x15, 0x4e, 0x29, 0x8a, 0x62, 0x9f, 0xd3, 0xda, 0x2f, 0x23,
	0x90, 0x16, 0xa3, 0xe8, 0x3e, 0xa4, 0x27, 0x32, 0x99, 0x5b, 0x7c, 0x13, 0xa9, 0x70, 0x40, 0x4f,
	0x79, 0x3c, 0x8c, 0x7f, 0x08, 0x69, 0x1a, 0x1e, 0x7a, 0xfe, 0x51, 0x08, 0x3b, 0x14, 0x11, 0x42,
	0x0e, 0x16, 0x29, 0x8a, 0xdb, 0xd4, 0x51, 0x6d, 0x56, 0x1a, 0x1c, 0xa3, 0xf4, 0xaf, 0x08, 0xb1,
	0x1d, 0x85, 0x13, 0xe1, 0xa9, 0xcc, 0xb8, 0xfc, 0xdb, 0x04, 0xdc, 0xf6, 0xcd, 0xdc, 0xb0, 0x06,
	0x92, 0xb0, 0xee, 0x41, 0x96, 0x55, 0x97, 0x44, 0xaa, 0x2e, 0xdf, 0x0b, 0xb7, 0x41, 0x5a, 0x61,
	0x52, 0x38, 0x6a, 0x42, 0xdc, 0x34, 0x5c, 0x8f, 0xa6, 0x5b, 0xd9, 0xdd, 0x9d, 0x99, 0xd6, 0x37,
	0x73, 0x82, 0xed, 0x96, 0xe1, 0x7a, 0x42, 0x1b, 0x09, 0x0b, 0xd4, 0x82, 0x84, 0xa3, 0x59, 0x03,
	0x4c, 0xd5, 0x2b, 0xbb, 0x7b, 0xff, 0x25, 0x78, 0xa9, 0x84, 0x4e, 0x04, 0x72, 0xca, 0x04, 0xbd,
	0x0d, 0x79, 0xd3, 0xee, 0x6b, 0x04, 0xb7, 0x67, 0x8d, 0x87, 0x2e, 0x75, 0xce, 0xa2, 0x44, 0xc8,
	0x89, 0xa1, 0xf6, 0x78, 0x48, 0x2b, 0x6f, 0x23, 0xec, 0xf1, 0xa8, 0xfe, 0x09, 0x97, 0x33, 0x39,
	0xb8, 0xf6, 0xbb, 0x08, 0xc4, 0xc9, 0xea, 0xaf, 0xb1, 0xac, 0xdb, 0x90, 0xbc, 0xd0, 0xcc, 0x31,
	0x66, 0x79, 0x68, 0x4e, 0xe5, 0x5f, 0xa8, 0x09, 0xcb, 0x74, 0x6a, 0xdc, 0x73, 0x47, 0x5a, 0x1f,
	0xf7, 0xfc, 0x6a, 0x29, 0xbb, 0xfb, 0x0d, 0xb1, 0x5f, 0xde, 0x22, 0xda, 0x6e, 0xf1, 0x35, 0x9e,
	0x10, 0x52, 0xb5, 0xc8, 0xe8, 0x8e, 0x08, 0x19, 0xf5, 0x1b, 0x9f, 0x41, 0xd1, 0x1d, 0x9f, 0x8e,
	0x24, 0x81, 0xd0, 0x2d, 0x66, 0x67, 0xf7, 0x52, 0x66, 0x0b, 0xce, 0xaf, 0x98, 0xc2, 0x8c, 0x58,
	0xac, 0x5d, 0xfb, 0x55, 0x04, 0x12, 0x54, 0xb2, 0xd7, 0x6c, 0xf4, 0x0e, 0xe4, 0x3c, 0xbb, 0x87,
	0x2f, 0xfb, 0xe6, 0xd8, 0x35, 0x2e, 0x30, 0xd5, 0xe0, 0x9c, 0x9a, 0xf5, 0xec, 0x86, 0x00, 0xa1,
	0x7b, 0x50, 0xa0, 0x39, 0x83, 0x61, 0x09, 0xa4, 0x18, 0x45, 0xca, 0x13, 0x68, 0x53, 0x00, 0x67,
	0x8b, 0x26, 0x7e, 0x13, 0xd1, 0xb0, 0xe5, 0xf3, 0x84, 0xe1, 0x9f, 0xb2, 0x50, 0xa4, 0xc6, 0xb3,
	0x90, 0x47, 0xbc, 0x27, 0x79, 0xc4, 0x5b, 0x21, 0x8f, 0xe8, 0x5b, 0x20, 0x71, 0x88, 0xaf, 0x43,
	0x72, 0x6c, 0x19, 0x4f, 0xc6, 0x6c, 0x2b, 0x7e, 0xbc, 0x66, 0x30, 0xb4, 0x09, 0xd9, 0x5a, 0xe0,
	0x1a, 0xa9, 0x33, 0xcc, 0xa8, 0x32, 0x08, 0xbd, 0x0b, 0x88, 0x78, 0x0b, 0xdc, 0x0b, 0xb9, 0xd5,
	0x04, 0x45, 0x54, 0xe8, 0x48, 0x6d, 0xae, 0x6f, 0x4d, 0xbe, 0x84, 0x6f, 0xdd, 0x07, 0x05, 0x5f,
	0x7a, 0x8e, 0x26, 0xd7, 0x31, 0x29, 0x4a, 0xbf, 0xfe, 0xfc, 0xd9, 0x46, 0xa1, 0x41, 0xc6, 0x66,
	0x33, 0x29, 0x60, 0x69, 0x4c, 0x77, 0xd1, 0x67, 0xb0, 0xcc, 0x79, 0xe8, 0x86, 0x83, 0x69, 0x1a,
	0xce, 0x1a, 0x62, 0x73, 0xd2, 0xed, 0x09, 0x91, 0x6f, 0xd7, 0x05, 0x95, 0xaa, 0x30, 0x3e, 0x3e,
	0xc0, 0x45, 0x6d, 0xc8, 0x9e, 0xb1, 0xfc, 0xb0, 0xf7, 0x39, 0xbe, 0xa2, 0x49, 0xfc, 0x4b, 0xa4,
	0x91, 0xdc, 0x27, 0x9d, 0xf9, 0x43, 0x48, 0x85, 0xbc, 0x94, 0x9f, 0x9e, 0x5e, 0xd1, 0x5c, 0xe9,
	0xa5, 0x39, 0xe6, 0x02, 0x1e, 0xd5, 0x2b, 0xd4, 0x06, 0x30, 0xfc, 0xb0, 0x40, 0xb3, 0xa9, 0xec,
	0xee, 0xd6, 0xa2, 0xc1, 0xc3, 0xcf, 0x5d, 0xfc, 0x31, 0xd4, 0x85, 0x42, 0xf0, 0x45, 0x17, 0x99,
	0xbb, 0xc9, 0x22, 0xf3, 0x12, 0x93, 0xea, 0x15, 0xea, 0xc2, 0x2a, 0xc9, 0xf0, 0x6c, 0xd7, 0xf0,
	0xb0, 0x7c, 0xe6, 0x79, 0x7a, 0xe6, 0x65, 0x92, 0xdb, 0xd5, 0xc4, 0xf8, 0xec, 0x73, 0x47, 0xfd,
	0x89, 0x71, 0xa6, 0x45, 0x21, 0x6d, 0x25, 0x1c, 0x0b, 0x81, 0x16, 0x1d, 0x05, 0xfa, 0x3a, 0xa5,
	0x45, 0x92, 0x2e, 0x13, 0x4e, 0x5d, 0xc8, 0x85, 0x1c, 0x56, 0xf1, 0x86, 0x0e, 0x2b, 0xc4, 0x05,
	0x55, 0x79, 0xf2, 0xae, 0xd0, 0xea, 0x6f, 0x6b, 0x11, 0x75, 0x9c, 0x4a, 0xe3, 0x67, 0x7a, 0x9f,
	0xe5, 0x1b, 0x39, 0xe6, 0xa9, 0xc8, 0x83, 0xe6, 0x46, 0x9e, 0x3b, 0xb4, 0xe7, 0xae, 0xb3, 0x14,
	0x7d, 0x45, 0xf2, 0x46, 0x69, 0x02, 0xa6, 0x59, 0xfa, 0x3a, 0xc9, 0xd2, 0xc9, 0x8c, 0x66, 0x69,
	0x55, 0xf2, 0x35, 0x02, 0x48, 0x22, 0x8d, 0xe1, 0xee, 0x8d, 0xad, 0x7e, 0xe9, 0xd6, 0x66, 0x6c,
	0x2b, 0xad, 0xf2, 0x2f, 0xb4, 0x0e, 0x60, 0xb8, 0x2a, 0xd6, 0x4c, 0x3a, 0x76, 0x9b, 0x8e, 0x49,
	0x10, 0xb4, 0x0f, 0x79, 0x6c, 0xf5, 0x6d, 0xdd, 0xb0, 0x06, 0xac, 0x11, 0xff, 0x4a, 0x90, 0x72,
	0xbd, 0x78, 0xb6, 0xf1, 0xda, 0x84, 0xc4, 0x1a, 0x1c, 0x97, 0x76, 0xca, 0x73, 0x58, 0xfa, 0x22,
	0x15, 0x90, 0x6e, 0xb8, 0x24, 0x9b, 0xd1, 0x4b, 0x25, 0xb9, 0x02, 0x12, 0xd0, 0xf2, 0x3a, 0x64,
	0x7c, 0x73, 0x47, 0x29, 0x88, 0x55, 0x8e, 0x6a, 0xac, 0x6f, 0x54, 0x6f, 0x1c, 0xd5, 0x94, 0x48,
	0xf9, 0x0e, 0xc4, 0x29, 0xa7, 0x2c, 0xa4, 0xf6, 0x3a, 0xea, 0xa7, 0x15, 0xb5, 0xce, 0x7a, 0x55,
	0xcd, 0xf6, 0x49, 0x43, 0xed, 0x36, 0xea, 0x4a, 0xa4, 0xfc, 0xcb, 0x18, 0xa0, 0xa0, 0x5f, 0xd1,
	0xb5, 0x79, 0xe5, 0xaf, 0x43, 0xb1, 0xef, 0x43, 0xc5, 0x55, 0x49, 0x74, 0xab, 0xb0, 0xfb, 0xe1,
	0xf5, 0x0d, 0x0f, 0xc1, 0x40, 0x06, 0x05, 0x2a, 0x51, 0xe8, 0x87, 0xa0, 0x7e, 0xbc, 0x88, 0x6e,
	0x46, 0x27, 0xe2, 0x45, 0x07, 0x12, 0xfd, 0x73, 0xdc, 0xff, 0x9c, 0xc7, 0xf0, 0x0f, 0x66, 0xcd,
	0x4a, 0xf3, 0x3e, 0x49, 0xf7, 0x6a, 0x84, 0x20, 0x98, 0x57, 0xa4, 0x2d, 0x94, 0x0f, 0xea, 0x84,
	0x7d, 0x61, 0x7c, 0xbe, 0xa3, 0x99, 0xd5, 0x4f, 0x9b, 0xe1, 0x0c, 0x3f, 0x82, 0xa2, 0x65, 0x7b,
	0x3d, 0x52, 0x8d, 0x72, 0xfb, 0xa5, 0x35, 0x66, 0xbe, 0xaa, 0xf0, 0x93, 0x0e, 0xac, 0x35, 0x6f,
	0xd9, 0x5e, 0x7b, 0x6c, 0x9a, 0x0c, 0x50, 0xfe, 0x18, 0x0a, 0x61, 0xe9, 0xa0, 0x0c, 0x24, 0x6a,
	0xfb, 0x8d, 0xda, 0x23, 0x65, 0x09, 0x15, 0x21, 0xbb, 0xd7, 0x51, 0x1b, 0xcd, 0x07, 0xed, 0xde,
	0xa3, 0xc6, 0x63, 0xd6, 0x4c, 0x6c, 0x77, 0x44, 0x33, 0x91, 0xc5, 0xde, 0x87, 0xf1, 0x74, 0x42,
	0x49, 0x96, 0xff, 0x2e, 0x0a, 0x85, 0x43, 0xc7, 0x18, 0x6a, 0xce, 0xd5, 0x23, 0x7c, 0x75, 0xf4,
	0x54, 0x1b, 0xa1, 0x4f, 0x60, 0xd5, 0xc2, 0x4f, 0x7b, 0x23, 0x06, 0xed, 0xf9, 0xf9, 0x6f, 0x64,
	0x4e, 0x9b, 0xc5, 0xc2, 0x4f, 0x39, 0x87, 0x26, 0x4f, 0x7f, 0xdf, 0x85, 0xac, 0x6d, 0xf2, 0xc6,
	0x0a, 0x16, 0xdd, 0xbe, 0xac, 0x4c, 0x04, 0xb6, 0xc9, 0x3a, 0x29, 0x34, 0xde, 0x66, 0xc9, 0x7c,
	0x02, 0x3b, 0x36, 0x03, 0xdb, 0xc2, 0x4f, 0x05, 0xf6, 0x27, 0xb0, 0x4a, 0x78, 0x4f, 0xad, 0x2e,
	0x3e, 0x67, 0x75, 0xb6, 0xa9, 0x4f, 0xac, 0xee, 0xdb, 0x70, 0x7b, 0x7a, 0x7f, 0x53, 0xcd, 0xba,
	0x95, 0x89, 0x6d, 0x05, 0xb9, 0x4b, 0xf9, 0xbf, 0x22, 0xf0, 0xca, 0x81, 0xe6, 0x61, 0xc7, 0xd0,
	0x4c, 0xe3, 0xc7, 0x58, 0x27, 0x75, 0xa3, 0x8a, 0xcf, 0x1c, 0xec, 0x9e, 0xa3, 0x63, 0x58, 0x9e,
	0x62, 0x4e, 0x25, 0x97, 0xdd, 0xbd, 0xbb, 0x80, 0xef, 0x13, 0x39, 0xdf, 0xc4, 0xe4, 0xe8, 0x61,
	0x58, 0x46, 0x2c, 0xa1, 0x7f, 0x09, 0x86, 0xb2, 0x04, 0x3f, 0x84, 0x84, 0xe6, 0xf6, 0xec, 0x33,
	0x6e, 0x16, 0x6b, 0x82, 0xcb, 0xd8, 0x33, 0xcc, 0xed, 0x73, 0xb3, 0xbf, 0xdd, 0x15, 0xed, 0x00,
	0x61, 0x4d, 0x9a, 0xdb, 0x39, 0x2b, 0xff, 0x75, 0x12, 0x50, 0xc0, 0xf7, 0x60, 0xec, 0x51, 0x4f,
	0x89, 0xbe, 0x07, 0x49, 0xae, 0xb9, 0x6c, 0x97, 0x6f, 0xcc, 0x6f, 0xcf, 0x04, 0xd4, 0xfb, 0x4b,
	0x2a, 0xa7, 0x42, 0xdf, 0x91, 0x2f, 0x2f, 0x16, 0xdb, 0xd3, 0xfe, 0x92, 0xb8, 0xd2, 0xd8, 0x87,
	0x84, 0xeb, 0x69, 0x1e, 0xcb, 0xf4, 0x0a, 0xbb, 0xef, 0xce, 0x22, 0x9e, 0x5e, 0xf3, 0xf6, 0x11,
	0xa1, 0x11, 0xa6, 0x4d, 0x19, 0xa0, 0x2e, 0x64, 0xfc, 0xdc, 0x89, 0xdf, 0x81, 0xdc, 0x5f, 0x90,
	0x9b, 0xef, 0x3d, 0x45, 0xf5, 0xe9, 0x33, 0x42, 0x15, 0xc8, 0x0e, 0x39, 0x5a, 0x50, 0x38, 0x6f,
	0xf2, 0xd4, 0x15, 0x04, 0x07, 0x9a, 0xc2, 0x4a, 0x5f, 0x2a, 0x08, 0xa2, 0xa6, 0x4e, 0x1c, 0xb8,
	0x63, 0x9b, 0xe6, 0xa9, 0xd6, 0xff, 0x9c, 0xf6, 0x78, 0x7d, 0x07, 0x2e, 0xa0, 0x68, 0x9f, 0x64,
	0xa0, 0xc2, 0x15, 0xd0, 0xa6, 0x6d, 0xf6, 0x0f, 0xb5, 0x94, 0x85, 0x87, 0xdd, 0x5f, 0x52, 0x25,
	0x5a, 0xd4, 0x82, 0xc2, 0x28, 0xe4, 0x0b, 0x78, 0xba, 0x57, 0x9e, 0xd3, 0xb7, 0x91, 0x30, 0xf7,
	0x97, 0xd4, 0x09, 0x5a, 0x34, 0x80, 0x57, 0x86, 0xb3, 0xad, 0x84, 0x76, 0x6c, 0xb3, 0xb3, 0x2f,
	0x80, 0xe7, 0x18, 0xd6, 0xfe, 0x92, 0x3a, 0x8f, 0x5b, 0xf9, 0x13, 0x48, 0xd0, 0x13, 0x25, 0x21,
	0xea, 0xb8, 0xfd, 0xa8, 0xdd, 0xf9, 0xb4, 0xcd, 0x9c, 0x60, 0xbd, 0xd1, 0x6a, 0x74, 0x1b, 0xbd,
	0x4e, 0xbb, 0x45, 0x9c, 0xe0, 0xab, 0x70, 0x8b, 0x03, 0x2a, 0xed, 0x7a, 0xef, 0x53, 0xb5, 0x29,
	0x86, 0xa2, 0xe5, 0x2d, 0x39, 0x06, 0x06, 0x77, 0x84, 0x24, 0x1a, 0xd6, 0xeb, 0x4a, 0x84, 0x46,
	0x43, 0xb5, 0x73, 0xa8, 0x44, 0xab, 0x39, 0x00, 0xdd, 0x57, 0x81, 0x87, 0xf1, 0x74, 0x52, 0x49,
	0x95, 0x5f, 0xbc, 0x09, 0xc5, 0x89, 0x38, 0x72, 0x4d, 0x15, 0xb3, 0x49, 0xab, 0x98, 0x58, 0xe0,
	0xe6, 0xfd, 0x2a, 0x26, 0xca, 0x0b, 0x98, 0x50, 0xc7, 0x2b, 0xbe, 0x60, 0xc7, 0xeb, 0x03, 0x48,
	0x5d, 0x60, 0xc7, 0x15, 0xf5, 0x71, 0xbe, 0xfa, 0x2a, 0x77, 0x85, 0xcb, 0xc1, 0xaa, 0x4e, 0x18,
	0x82, 0x2a, 0x30, 0xd1, 0xfb, 0xb0, 0xec, 0xe0, 0x91, 0x69, 0xf0, 0x84, 0x88, 0xdd, 0x33, 0xca,
	0x5d, 0x4e, 0x45, 0x1a, 0xa6, 0x5b, 0x44, 0x07, 0xb0, 0x3c, 0xb4, 0x75, 0xe3, 0xcc, 0xa7, 0x31,
	0x86, 0xec, 0xf2, 0x61, 0x11, 0x4f, 0xa2, 0xc8, 0xa4, 0x64, 0x10, 0xd5, 0x21, 0x25, 0xba, 0x18,
	0xec, 0x06, 0x7f, 0x21, 0xff, 0x21, 0xf2, 0x2c, 0x4e, 0x8a, 0xf6, 0xa0, 0x60, 0xe1, 0x4b, 0xb9,
	0x47, 0x95, 0x09, 0x99, 0x5a, 0xae, 0x8d, 0x2f, 0x67, 0x37, 0xa8, 0x72, 0x56, 0x30, 0xa2, 0xa3,
	0x36, 0xe4, 0xc3, 0x9e, 0x1b, 0x5e, 0xd6, 0x73, 0xe7, 0x46, 0xb2, 0xdb, 0xae, 0x41, 0x4a, 0xb8,
	0xec, 0xec, 0xcb, 0xba, 0x6c, 0x41, 0x89, 0xaa, 0x90, 0xa7, 0x9b, 0xf3, 0x43, 0x5d, 0x8e, 0xee,
	0x6d, 0x9d, 0xef, 0x2d, 0x4b, 0xf6, 0x36, 0xa3, 0x19, 0x95, 0xb5, 0x7c, 0xb8, 0x3e, 0xd1, 0x8d,
	0xcd, 0xdf, 0xbc, 0x1b, 0xfb, 0x10, 0x32, 0xc2, 0x39, 0xb1, 0x3a, 0x63, 0x8e, 0xaf, 0x99, 0xf6,
	0x93, 0xc2, 0x3b, 0xfa, 0xe4, 0x24, 0x3f, 0x33, 0xb1, 0xe6, 0x62, 0x5e, 0x69, 0x7c, 0xb8, 0x48,
	0x7e, 0x76, 0xd4, 0x3f, 0xc7, 0x43, 0xad, 0x76, 0xae, 0x59, 0x03, 0xdc, 0x22, 0xc4, 0xd5, 0x68,
	0x29, 0xa2, 0x32, 0x3e, 0xa8, 0x0d, 0x0a, 0x95, 0x94, 0xec, 0x73, 0x15, 0x2a, 0xac, 0x37, 0xb8,
	0xb0, 0x0a, 0x44, 0x58, 0x73, 0xfd, 0x2e, 0x55, 0xa2, 0x83, 0xc0, 0xf7, 0x7e, 0x17, 0x0a, 0x67,
	0xb6, 0x33, 0xd4, 0xbc, 0x9e, 0x30, 0xad, 0xe5, 0xa0, 0xf9, 0xf0, 0xe2, 0xd9, 0x46, 0x7e, 0x8f,
	0x8e, 0x0a, 0xb3, 0xca, 0x9f, 0xc9, 0x9f, 0xb3, 0xab, 0x16, 0x74, 0xa3, 0xaa, 0xa5, 0x21, 0xe2,
	0xdc, 0x0a, 0x8d, 0x4c, 0x6f, 0x2f, 0x24, 0xa9, 0xe9, 0x20, 0xf7, 0x08, 0x92, 0x34, 0x91, 0x75,
	0x4b, 0xab, 0xf4, 0xe4, 0x6e, 0x92, 0x11, 0xab, 0x9c, 0x05, 0x7a, 0x0c, 0x05, 0x9d, 0x40, 0x48,
	0x8d, 0xc2, 0x5a, 0x24, 0xb7, 0x28, 0xd3, 0x77, 0x17, 0x61, 0x4a, 0x76, 0xd5, 0xb4, 0xce, 0x6c,
	0x51, 0x29, 0x0b, 0x4e, 0xac, 0xa7, 0xd2, 0x82, 0xf4, 0x99, 0x36, 0x34, 0x4c, 0x03, 0xbb, 0xb4,
	0x38, 0xca, 0x5e, 0xf7, 0x04, 0x69, 0xb2, 0xa5, 0x2e, 0xe2, 0xa3, 0xe0, 0xe0, 0x3b, 0x07, 0x0a,
	0xb8, 0x22, 0x3a, 0xf1, 0xca, 0xb4, 0x73, 0x10, 0x2d, 0xf5, 0x50, 0x7b, 0x9d, 0x3a, 0x07, 0xfe,
	0xa5, 0xa3, 0xbb, 0x00, 0x17, 0x06, 0x7e, 0xda, 0x7b, 0x32, 0xc6, 0xce, 0x15, 0x2d, 0xa6, 0x84,
	0x63, 0xcf, 0x10, 0xf8, 0x0f, 0x08, 0x18, 0xbd, 0x0f, 0x19, 0x9d, 0x5d, 0x21, 0x74, 0xac, 0xd2,
	0xab, 0x34, 0x95, 0x5d, 0x79, 0xfe, 0x6c, 0x23, 0x53, 0x17, 0x40, 0xee, 0xb8, 0x03, 0x2c, 0x34,
	0x80, 0x1c, 0xfb, 0xc0, 0x7a, 0xc7, 0xaa, 0x5e, 0x95, 0xd6, 0xe8, 0x8e, 0xdf, 0x5b, 0x44, 0x8c,
	0x41, 0xc7, 0x61, 0x55, 0x6c, 0xa6, 0x2e, 0xb1, 0x52, 0x43, 0x8c, 0xd1, 0x63, 0xc8, 0x09, 0xcb,
	0x78, 0x68, 0x9f, 0xba, 0xa5, 0xd7, 0xe6, 0xb7, 0x85, 0x27, 0x27, 0x3a, 0x08, 0xe8, 0x84, 0xa3,
	0x93, 0x59, 0xa1, 0x63, 0xc8, 0xfb, 0x57, 0x24, 0xf6, 0xc8, 0x73, 0x4b, 0xaf, 0x53, 0x3d, 0xbf,
	0xbf, 0x90, 0xa2, 0x72, 0xc2, 0xce, 0xc8, 0x73, 0xd5, 0x9c, 0x2b, 0x7d, 0x91, 0x12, 0x5c, 0x77,
	0xec, 0x11, 0x0b, 0x32, 0xdf, 0xd8, 0x8c, 0x6c, 0xc5, 0xfc, 0xf2, 0xd5, 0xb1, 0x47, 0x34, 0x80,
	0xfc, 0x10, 0x0a, 0x24, 0x46, 0x69, 0x7d, 0x3c, 0x24, 0x11, 0xd3, 0x3e, 0x2b, 0xad, 0xd3, 0xa9,
	0x77, 0x16, 0x93, 0x9f, 0x4f, 0x29, 0x34, 0x51, 0x62, 0xd6, 0x39, 0x43, 0x2a, 0x80, 0x36, 0xd6,
	0x0d, 0xaf, 0x37, 0xb4, 0x75, 0x5c, 0xda, 0x98, 0x7f, 0x83, 0x3d, 0xc9, 0xb9, 0x42, 0xa8, 0x0e,
	0x6c, 0x1d, 0xfb, 0x57, 0x12, 0x02, 0x80, 0xde, 0x87, 0x2c, 0xdd, 0xd4, 0x8f, 0xec, 0x53, 0xa2,
	0x8c, 0x9b, 0x74, 0x5b, 0xcb, 0xfc, 0xfc, 0x32, 0x75, 0xc7, 0x1e, 0x3d, 0xb4, 0x4f, 0xa9, 0x8a,
	0xf0, 0x9f, 0x3a, 0x1a, 0x41, 0x6e, 0xd0, 0xef, 0x05, 0x8e, 0xf7, 0x0e, 0x3d, 0xb9, 0x8f, 0x16,
	0x59, 0xc8, 0x83, 0xda, 0x0c, 0x57, 0xbc, 0x22, 0x62, 0xc7, 0x83, 0x9a, 0x80, 0xb9, 0x6a, 0x76,
	0xd0, 0xf7, 0x3f, 0xa6, 0xfb, 0x24, 0xe5, 0x97, 0xe9, 0xd0, 0xdf, 0xbd, 0xa6, 0x43, 0x8f, 0xca,
	0x90, 0x39, 0xe7, 0x00, 0xb7, 0xf4, 0x86, 0xfc, 0x96, 0xd1, 0x07, 0x0b, 0x9c, 0x3d, 0x03, 0x9b,
	0x7a, 0xe9, 0x9e, 0x6c, 0x6a, 0x3e, 0x18, 0x9d, 0xc3, 0x0a, 0xb6, 0x06, 0x86, 0xc5, 0xde, 0x2a,
	0xf6, 0x5c, 0xec, 0xf5, 0x86, 0xda, 0xa8, 0xf4, 0x26, 0x95, 0xcd, 0xb7, 0x17, 0x91, 0x4d, 0x83,
	0x92, 0x93, 0xea, 0xf9, 0x08, 0x7b, 0x07, 0xda, 0xa8, 0x61, 0x79, 0xce, 0x95, 0xaa, 0xe0, 0x09,
	0x30, 0xda, 0x86, 0xb4, 0x7f, 0xdf, 0xf9, 0x16, 0xb5, 0x69, 0x44, 0x72, 0x31, 0x71, 0xd7, 0x29,
	0x72, 0x31, 0x81, 0x83, 0xbe, 0x05, 0x20, 0x7e, 0x9f, 0x5e, 0x95, 0xb6, 0x28, 0xc5, 0x2a, 0xc9,
	0xf8, 0x05, 0x45, 0xf5, 0x8a, 0xd3, 0x48, 0x78, 0x64, 0xcf, 0x1e, 0x1e, 0x8e, 0x6c, 0x47, 0x73,
	0xae, 0x4a, 0x6f, 0x4b, 0x12, 0x0c, 0xc0, 0xe8, 0x1d, 0xc8, 0xf7, 0x1d, 0x4c, 0x1c, 0xfb, 0x15,
	0xdd, 0x4c, 0xe9, 0x1d, 0x09, 0x2f, 0x3c, 0x84, 0xde, 0x84, 0xec, 0x50, 0xbb, 0x14, 0x99, 0x4e,
	0xe9, 0x9b, 0x92, 0xa4, 0xe5, 0x01, 0xc2, 0x93, 0xf8, 0xaf, 0x63, 0x71, 0x0d, 0x5a, 0x7a, 0x57,
	0xe6, 0x19, 0x1a, 0x12, 0xb8, 0xbe, 0x37, 0x2b, 0xbd, 0x27, 0x5d, 0x3d, 0x85, 0x87, 0x48, 0xe5,
	0xd2, 0xb7, 0x87, 0x43, 0xfa, 0xb4, 0x71, 0x5b, 0x6e, 0x9f, 0x09, 0x28, 0xfa, 0x13, 0x58, 0x35,
	0xdc, 0x9e, 0x9c, 0xd6, 0xf7, 0x08, 0x8b, 0xd2, 0x8e, 0xb4, 0x00, 0x64, 0xb8, 0x93, 0x25, 0x01,
	0x7a, 0x0b, 0x72, 0x6c, 0xab, 0xdc, 0x17, 0xdf, 0x97, 0xb8, 0x67, 0xd9, 0x08, 0xf3, 0xc6, 0x8f,
	0x60, 0x99, 0x23, 0xd2, 0x8a, 0x97, 0xf9, 0x91, 0xf7, 0x17, 0x4c, 0x56, 0x0b, 0x8c, 0xb4, 0xe2,
	0x76, 0xce, 0xc8, 0xd0, 0xda, 0xdf, 0x44, 0x60, 0x79, 0x2a, 0xfd, 0x40, 0x7f, 0x0a, 0x29, 0xcb,
	0xd6, 0xa5, 0x2b, 0xc5, 0xef, 0x73, 0xdb, 0x4a, 0xb6, 0x6d, 0x9d, 0xdd, 0x28, 0xbe, 0x37, 0x30,
	0xbc, 0xf3, 0xf1, 0xe9, 0x76, 0xdf, 0x1e, 0xee, 0xb0, 0x49, 0xf5, 0x53, 0xfe, 0x63, 0x67, 0xf4,
	0xf9, 0x60, 0x47, 0x24, 0x01, 0x8c, 0x40, 0x4d, 0x12, 0x7e, 0x4d, 0x1d, 0xbd, 0x07, 0x45, 0x7c,
	0x39, 0x32, 0x1c, 0x29, 0xcf, 0x8e, 0x4a, 0x2e, 0xb0, 0x10, 0x0c, 0xd2, 0xe5, 0xfd, 0x7d, 0x14,
	0x8a, 0x13, 0xb1, 0x9a, 0x54, 0x21, 0xb4, 0x7b, 0x19, 0xaa, 0x42, 0x08, 0x44, 0xea, 0x9a, 0x5d,
	0xf7, 0x3e, 0x29, 0xf6, 0x95, 0xde, 0x27, 0x85, 0xaf, 0x46, 0x12, 0x2f, 0x71, 0x35, 0x52, 0x82,
	0xf8, 0x54, 0x29, 0x12, 0xe7, 0x6f, 0x1d, 0x43, 0xaf, 0x0f, 0x52, 0x73, 0x5e, 0x1f, 0x84, 0xde,
	0x31, 0xa4, 0x67, 0xbd, 0x63, 0xf0, 0xbb, 0x60, 0x71, 0x25, 0xb1, 0xf6, 0x18, 0xd2, 0x22, 0x23,
	0x09, 0x57, 0x5f, 0x91, 0x05, 0xab, 0xaf, 0xb9, 0xe2, 0x5c, 0xfb, 0x69, 0x04, 0x32, 0xf2, 0x63,
	0xce, 0xa8, 0xcf, 0x75, 0x76, 0xf1, 0x77, 0xc3, 0x1b, 0xe7, 0xb0, 0xac, 0x63, 0x8b, 0xcb, 0x7a,
	0xed, 0x02, 0xb2, 0x52, 0x74, 0x9f, 0x6c, 0x59, 0x44, 0x6e, 0xd0, 0xb2, 0x78, 0x03, 0x92, 0x3c,
	0xb6, 0x31, 0x7d, 0xcd, 0x73, 0xea, 0x04, 0x8b, 0x6b, 0x89, 0x1f, 0x91, 0x98, 0xb6, 0xf6, 0x8f,
	0x71, 0xc8, 0xc9, 0xa1, 0x9f, 0xf8, 0x3f, 0xc3, 0xea, 0x3b, 0x34, 0xf4, 0xd2, 0x79, 0x85, 0xa6,
	0x07, 0x60, 0x72, 0xae, 0x43, 0xc3, 0xea, 0xd1, 0x0b, 0xdb, 0x90, 0x35, 0xa4, 0x87, 0x06, 0x4b,
	0x9e, 0x29, 0x8a, 0x76, 0xc9, 0x51, 0x62, 0x21, 0x14, 0xed, 0x92, 0xa1, 0xac, 0xd1, 0x74, 0xda,
	0xf1, 0x68, 0x71, 0x1d, 0x93, 0x72, 0x64, 0xc7, 0x43, 0xeb, 0x90, 0xba, 0x30, 0x1c, 0x6f, 0xac,
	0x99, 0xa1, 0x7b, 0x66, 0x01, 0x24, 0xb4, 0x7d, 0xad, 0x7f, 0xce, 0x74, 0xd3, 0xa7, 0xa5, 0x20,
	0x3a, 0x76, 0xd5, 0x37, 0x71, 0x48, 0x2d, 0x19, 0x88, 0x2c, 0x0b, 0x5f, 0x60, 0xa7, 0x67, 0x5f,
	0x60, 0x87, 0x6a, 0xa4, 0xdf, 0xc8, 0x21, 0xe0, 0xce, 0x05, 0x76, 0xd0, 0x37, 0xe8, 0x9b, 0x9f,
	0xbe, 0x66, 0x9a, 0xb4, 0x7c, 0xf5, 0x6f, 0x2e, 0x0d, 0xb7, 0xa6, 0x99, 0x26, 0xfa, 0x1c, 0x0a,
	0x41, 0x8e, 0xf5, 0xd4, 0xc2, 0x0e, 0xaf, 0x4e, 0xbf, 0xf7, 0xb2, 0x49, 0x56, 0xf0, 0x41, 0xb8,
	0x08, 0xe7, 0xed, 0xca, 0xc0, 0xb5, 0x9f, 0x47, 0x20, 0x1f, 0x42, 0x43, 0x4d, 0x28, 0xd2, 0x59,
	0xa5, 0x22, 0x9b, 0x29, 0xc7, 0x1d, 0xff, 0x35, 0x28, 0x19, 0x9e, 0x59, 0x65, 0xe7, 0x6d, 0x69,
	0x48, 0x47, 0x9f, 0x40, 0x81, 0xb1, 0xf2, 0x5f, 0x63, 0x84, 0x35, 0x3d, 0x47, 0x39, 0x85, 0x9f,
	0x64, 0xe4, 0xec, 0x00, 0xa6, 0xf3, 0x3b, 0x70, 0x0c, 0x59, 0x29, 0x83, 0x5b, 0xc0, 0xb8, 0xbe,
	0x05, 0x71, 0xdf, 0x8f, 0x2e, 0xd4, 0xf9, 0x24, 0xd8, 0x6b, 0x3f, 0x8b, 0xc0, 0xea, 0xac, 0x34,
	0x2a, 0x64, 0xab, 0x4c, 0x61, 0x17, 0xb2, 0xd5, 0xbb, 0x72, 0x56, 0xcb, 0x94, 0x58, 0x3c, 0xb7,
	0x0b, 0xf2, 0xda, 0x37, 0x7d, 0x23, 0x62, 0x3a, 0x5c, 0x0c, 0x19, 0x11, 0xa9, 0x79, 0xa9, 0x19,
	0x71, 0x49, 0x3c, 0x81, 0x5b, 0x33, 0x93, 0x19, 0xa4, 0x40, 0xec, 0x73, 0x7c, 0xc5, 0x84, 0xa2,
	0x92, 0x9f, 0xa8, 0x0a, 0x89, 0xc0, 0x7c, 0x16, 0x2c, 0xd7, 0x0e, 0xb4, 0x11, 0xab, 0x4c, 0x19,
	0xe9, 0xc7, 0xd1, 0x8f, 0x22, 0x6b, 0x9b, 0x90, 0x16, 0x60, 0xb4, 0x2a, 0x78, 0x46, 0xe8, 0x2d,
	0x39, 0xfb, 0x28, 0x7f, 0x20, 0xfa, 0x72, 0x00, 0xc9, 0xc3, 0xe3, 0x6a, 0xab, 0x59, 0x9b, 0xd9,
	0x53, 0x43, 0x59, 0x48, 0x75, 0xf6, 0xf6, 0x5a, 0xcd, 0x76, 0x43, 0x89, 0x95, 0xb7, 0x20, 0xe3,
	0xe7, 0xce, 0x28, 0x07, 0xe9, 0x7a, 0xf3, 0xa8, 0x52, 0x6d, 0x35, 0xea, 0xca, 0x12, 0xca, 0x43,
	0x46, 0x6d, 0x54, 0xea, 0xb4, 0x73, 0xa7, 0x44, 0x3e, 0x8e, 0xff, 0xe4, 0x67, 0x1b, 0x91, 0xf2,
	0xef, 0x22, 0x80, 0xea, 0x24, 0x3b, 0xd1, 0xdc, 0x97, 0xe9, 0xbf, 0x45, 0xaf, 0xd1, 0x92, 0x70,
	0xb3, 0x24, 0x76, 0xf3, 0x66, 0x49, 0x1d, 0x52, 0x2e, 0x4d, 0x18, 0xd8, 0x3b, 0x83, 0x39, 0xcd,
	0x2d, 0x96, 0x53, 0x4c, 0xf7, 0x7f, 0x38, 0x29, 0xdf, 0xe7, 0x4f, 0xa3, 0x00, 0xd2, 0xfe, 0xbe,
	0x23, 0xff, 0x2b, 0x60, 0x4e, 0x5f, 0x69, 0xe2, 0x14, 0xf7, 0x97, 0xc4, 0x1f, 0x06, 0xea, 0x90,
	0xd6, 0xb9, 0xc8, 0xb8, 0x16, 0xcc, 0xee, 0xe1, 0x4c, 0x89, 0x75, 0x9f, 0x54, 0x5e, 0x1c, 0x8a,
	0xbe, 0x07, 0x49, 0xb6, 0x44, 0x2e, 0xa2, 0x85, 0x36, 0xb7, 0xbf, 0xa4, 0x72, 0x2a, 0xb2, 0x8a,
	0xb3, 0xb1, 0x15, 0x74, 0xdc, 0xe7, 0xac, 0x62, 0x8f, 0xe3, 0x84, 0x57, 0x21, 0x28, 0xab, 0x29,
	0x48, 0x8c, 0x2d, 0xc3, 0xb6, 0xca, 0xff, 0x1e, 0x01, 0x65, 0x72, 0xb6, 0x3f, 0x0e, 0x35, 0xb8,
	0x49, 0x3f, 0x97, 0x9f, 0xfa, 0x11, 0xac, 0x88, 0xfd, 0x77, 0x1d, 0x63, 0x30, 0xc0, 0x0e, 0x31,
	0xf0, 0xf2, 0x77, 0xc5, 0x53, 0xff, 0x22, 0x64, 0xeb, 0x07, 0xad, 0x5e, 0x57, 0x6d, 0x3e, 0x78,
	0xd0, 0x50, 0x95, 0x25, 0xb4, 0x0c, 0xf9, 0xc6, 0x49, 0xa3, 0xdd, 0xf5, 0x41, 0x11, 0x82, 0xd3,
	0xee, 0x04, 0x80, 0x68, 0xf9, 0xf7, 0x51, 0x58, 0x26, 0x5c, 0x2b, 0xce, 0xe0, 0x8f, 0xe4, 0x9d,
	0xee, 0x7d, 0xe0, 0x0f, 0x4f, 0xa8, 0xfb, 0xf2, 0x1c, 0xf1, 0x5e, 0x4a, 0xac, 0x63, 0x6a, 0x34,
	0xf4, 0xb2, 0x37, 0x31, 0xf3, 0x65, 0xef, 0x5b, 0x13, 0x8f, 0x6c, 0x93, 0xa1, 0x22, 0x41, 0x7a,
	0x6a, 0x4b, 0xf3, 0x8e, 0xce, 0x98, 0x7a, 0x1c, 0x1a, 0xb9, 0x33, 0x41, 0xde, 0xc1, 0xc1, 0xe8,
	0x63, 0x88, 0xd9, 0x86, 0xce, 0x33, 0xc9, 0x2d, 0x2e, 0x83, 0x58, 0xc7, 0xd0, 0x5f, 0x3c, 0xdb,
	0x78, 0x55, 0x4a, 0xef, 0x4d, 0xe3, 0x74, 0x67, 0xf4, 0x64, 0xc7, 0x36, 0xf4, 0xed, 0x8e, 0xa1,
	0xab, 0x84, 0xa8, 0xfc, 0xd3, 0x02, 0xa0, 0x69, 0x25, 0xfe, 0xff, 0xab, 0x9a, 0xe8, 0xdb, 0x90,
	0xf7, 0x1c, 0xcd, 0x72, 0xb5, 0x3e, 0x4b, 0xf8, 0xf8, 0x85, 0x83, 0x68, 0x2a, 0x24, 0xba, 0x97,
	0x56, 0xf0, 0x6f, 0x90, 0x10, 0xa6, 0x7c, 0x4b, 0x91, 0x5c, 0xf8, 0x96, 0xe2, 0xfb, 0x10, 0xd7,
	0x9c, 0x01, 0x7b, 0x1c, 0x95, 0xdd, 0xbd, 0x37, 0xcf, 0x49, 0x84, 0xd4, 0xd9, 0x2f, 0x1a, 0x9c,
	0x81, 0x8b, 0x5e, 0x87, 0xa4, 0xe6, 0x0c, 0xda, 0xe3, 0x61, 0xa8, 0x14, 0xe0, 0x30, 0x52, 0x27,
	0x1b, 0xee, 0xa1, 0x63, 0xf7, 0xb1, 0x3e, 0x76, 0x70, 0x28, 0xf5, 0x92, 0x07, 0x50, 0x07, 0xb2,
	0x5e, 0x60, 0x83, 0x3c, 0xf9, 0x7a, 0xeb, 0x3a, 0x97, 0x25, 0x99, 0xac, 0x60, 0x28, 0x71, 0x40,
	0x6f, 0x00, 0x38, 0xd8, 0x1b, 0x3b, 0x54, 0xaf, 0xd9, 0x23, 0x70, 0x51, 0xca, 0x04, 0x70, 0x54,
	0x83, 0xa4, 0x83, 0xbd, 0x8e, 0xdf, 0xf7, 0xff, 0xa6, 0xa8, 0x2f, 0x55, 0x0a, 0xbd, 0x5e, 0x01,
	0x39, 0x29, 0x31, 0x17, 0x53, 0xb3, 0x06, 0x63, 0x6d, 0xc0, 0xfe, 0x09, 0xe0, 0xd7, 0xe2, 0x02,
	0x1a, 0x5c, 0xa5, 0x16, 0xe7, 0x5f, 0xa5, 0x4e, 0x6b, 0xf1, 0xac, 0x2e, 0xf3, 0x3a, 0xa4, 0x88,
	0x77, 0xae, 0xe3, 0x33, 0xda, 0x7c, 0x17, 0x53, 0x09, 0x20, 0xfa, 0xe1, 0x54, 0xe3, 0x78, 0x79,
	0x7e, 0x23, 0x72, 0xc6, 0x94, 0xd7, 0xf7, 0x8e, 0x43, 0x2d, 0x43, 0x34, 0xb3, 0x65, 0xb8, 0x05,
	0xb9, 0xb3, 0xb1, 0x49, 0x5f, 0xda, 0xd0, 0xd7, 0xe0, 0xf2, 0xdb, 0x9e, 0xd0, 0xc8, 0x64, 0xab,
	0x6e, 0x75, 0x81, 0x56, 0xdd, 0x0f, 0x27, 0x9a, 0xac, 0xac, 0x29, 0xbe, 0xbb, 0xe0, 0xde, 0xfe,
	0x50, 0x9f, 0xd5, 0x9d, 0x68, 0x04, 0xb2, 0xee, 0xf8, 0x77, 0x16, 0xe4, 0x7e, 0xc3, 0x5e, 0xe0,
	0x3a, 0xa4, 0xce, 0x35, 0xf7, 0xdc, 0x7d, 0x62, 0xd2, 0xce, 0xb9, 0x7f, 0xa0, 0x1c, 0x48, 0x44,
	0x7e, 0x66, 0x98, 0xb8, 0x37, 0xd2, 0xbc, 0xf3, 0x50, 0x5f, 0x3c, 0x4d, 0xc0, 0x87, 0x9a, 0x77,
	0xee, 0xa3, 0x50, 0x8f, 0xf7, 0xea, 0x24, 0x0a, 0x95, 0x75, 0x0b, 0x94, 0x83, 0x89, 0xdb, 0xc1,
	0xd2, 0xda, 0xa2, 0xf7, 0x8a, 0x93, 0x94, 0xff, 0x9b, 0x15, 0xfd, 0xff, 0x55, 0xc1, 0xfc, 0x57,
	0x5f, 0x73, 0x19, 0x72, 0x67, 0xba, 0x0c, 0x99, 0xb4, 0x94, 0x37, 0x26, 0x8a, 0x90, 0x99, 0x0b,
	0x2b, 0xef, 0x2e, 0x98, 0xe7, 0x03, 0x24, 0x0f, 0x3a, 0xf5, 0xe6, 0xde, 0x63, 0x25, 0xc6, 0xd2,
	0x9b, 0x87, 0xf1, 0x74, 0x41, 0x29, 0x96, 0x7f, 0x1f, 0x03, 0xa5, 0x36, 0x76, 0x5c, 0xdb, 0xf9,
	0x9a, 0xc2, 0xe3, 0x5b, 0x90, 0xa3, 0x8d, 0xc1, 0x9e, 0xcb, 0x52, 0x09, 0xf9, 0x1f, 0xaf, 0x59,
	0x3a, 0x12, 0x64, 0x11, 0xf4, 0x3d, 0xa5, 0x48, 0x41, 0x7d, 0x09, 0x08, 0x28, 0xba, 0x0b, 0x30,
	0xd4, 0x2e, 0x7b, 0x8e, 0xfd, 0xd4, 0x1a, 0x0f, 0x69, 0xa0, 0xf3, 0xbb, 0x12, 0x43, 0xed, 0x52,
	0xa5, 0x60, 0xf9, 0x12, 0x3b, 0x79, 0xf3, 0x4b, 0xec, 0x35, 0xe1, 0x81, 0x53, 0x52, 0x90, 0xe2,
	0x3e, 0xf5, 0x33, 0x58, 0xee, 0x8f, 0x9d, 0x13, 0x4d, 0x92, 0x90, 0xb8, 0x30, 0x9f, 0x99, 0x34,
	0x9f, 0x68, 0x8e, 0x11, 0xce, 0xfe, 0x39, 0xbf, 0x69, 0x36, 0xa8, 0x0c, 0xa1, 0x4b, 0x6b, 0xfe,
	0xf7, 0xf7, 0xf0, 0x45, 0x76, 0x19, 0x32, 0xb4, 0x74, 0x98, 0xfa, 0xe7, 0x7b, 0x00, 0x26, 0xc2,
	0xf4, 0x2e, 0x2d, 0xaa, 0x09, 0xa1, 0x60, 0xe6, 0x43, 0x79, 0x4e, 0xfb, 0xab, 0x08, 0xa0, 0xe9,
	0xf5, 0x7d, 0xa5, 0x03, 0xaf, 0xfa, 0x8f, 0x90, 0x62, 0x8b, 0x3f, 0x42, 0x12, 0x69, 0x00, 0x7f,
	0x88, 0x24, 0x2f, 0x3f, 0x3e, 0x7f, 0xf9, 0xef, 0xa8, 0xf2, 0x5b, 0x47, 0xd1, 0xfb, 0x24, 0xb5,
	0x29, 0xfd, 0xad, 0x79, 0x58, 0x67, 0x8f, 0x4f, 0x8e, 0xad, 0x0b, 0x1f, 0x10, 0x41, 0x05, 0x00,
	0x3e, 0x6e, 0x58, 0x03, 0x25, 0x4a, 0x2b, 0x5b, 0xc7, 0x1e, 0x8d, 0xc8, 0x57, 0xac, 0xfa, 0xf6,
	0x17, 0xff, 0xb1, 0xbe, 0xf4, 0xc5, 0xf3, 0xf5, 0xc8, 0xaf, 0x9f, 0xaf, 0x47, 0x7e, 0xf3, 0x7c,
	0x3d, 0xf2, 0xdb, 0xe7, 0xeb, 0x91, 0xbf, 0xf8, 0x72, 0x7d, 0xe9, 0xd7, 0x5f, 0xae, 0x2f, 0xfd,
	0xe6, 0xcb, 0xf5, 0xa5, 0xcf, 0x52, 0x7c, 0x17, 0xff, 0x13, 0x00, 0x00, 0xff, 0xff, 0x35, 0x6a,
	0x88, 0x6a, 0x24, 0x43, 0x00, 0x00,
}
