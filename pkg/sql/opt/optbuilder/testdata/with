exec-ddl
CREATE TABLE x(a INT, b INT)
----
TABLE x
 ├── a int
 ├── b int
 ├── rowid int not null (hidden)
 └── INDEX primary
      └── rowid int not null (hidden)

exec-ddl
CREATE TABLE y(a INT)
----
TABLE y
 ├── a int
 ├── rowid int not null (hidden)
 └── INDEX primary
      └── rowid int not null (hidden)

build
WITH t AS (SELECT a FROM y WHERE a < 3)
  SELECT * FROM x NATURAL JOIN t
----
with &1 (t)
 ├── columns: a:3(int!null) b:4(int)
 ├── project
 │    ├── columns: y.a:1(int!null)
 │    └── select
 │         ├── columns: y.a:1(int!null) y.rowid:2(int!null)
 │         ├── scan y
 │         │    └── columns: y.a:1(int) y.rowid:2(int!null)
 │         └── filters
 │              └── lt [type=bool]
 │                   ├── variable: y.a [type=int]
 │                   └── const: 3 [type=int]
 └── project
      ├── columns: x.a:3(int!null) b:4(int)
      └── inner-join
           ├── columns: x.a:3(int!null) b:4(int) x.rowid:5(int!null) a:6(int!null)
           ├── can parallel: true
           ├── scan x
           │    └── columns: x.a:3(int) b:4(int) x.rowid:5(int!null)
           ├── with-scan &1 (t)
           │    ├── columns: a:6(int!null)
           │    └── mapping:
           │         └──  y.a:1(int) => a:6(int)
           └── filters
                └── eq [type=bool]
                     ├── variable: x.a [type=int]
                     └── variable: a [type=int]

build
WITH t AS (SELECT a FROM y WHERE a < 3)
  SELECT * FROM t
----
with &1 (t)
 ├── columns: a:3(int!null)
 ├── project
 │    ├── columns: y.a:1(int!null)
 │    └── select
 │         ├── columns: y.a:1(int!null) rowid:2(int!null)
 │         ├── scan y
 │         │    └── columns: y.a:1(int) rowid:2(int!null)
 │         └── filters
 │              └── lt [type=bool]
 │                   ├── variable: y.a [type=int]
 │                   └── const: 3 [type=int]
 └── with-scan &1 (t)
      ├── columns: a:3(int!null)
      └── mapping:
           └──  y.a:1(int) => a:3(int)

# Chaining multiple CTEs.
build
WITH
    t1 AS (SELECT a FROM y WHERE a < 3),
    t2 AS (SELECT * FROM t1 WHERE a > 1)
SELECT * FROM t2
----
with &1 (t1)
 ├── columns: a:4(int!null)
 ├── project
 │    ├── columns: y.a:1(int!null)
 │    └── select
 │         ├── columns: y.a:1(int!null) rowid:2(int!null)
 │         ├── scan y
 │         │    └── columns: y.a:1(int) rowid:2(int!null)
 │         └── filters
 │              └── lt [type=bool]
 │                   ├── variable: y.a [type=int]
 │                   └── const: 3 [type=int]
 └── with &2 (t2)
      ├── columns: a:4(int!null)
      ├── select
      │    ├── columns: a:3(int!null)
      │    ├── with-scan &1 (t1)
      │    │    ├── columns: a:3(int!null)
      │    │    └── mapping:
      │    │         └──  y.a:1(int) => a:3(int)
      │    └── filters
      │         └── gt [type=bool]
      │              ├── variable: a [type=int]
      │              └── const: 1 [type=int]
      └── with-scan &2 (t2)
           ├── columns: a:4(int!null)
           └── mapping:
                └──  a:3(int) => a:4(int)

build
WITH
    t1 AS (SELECT a FROM y WHERE a < 3),
    t2 AS (SELECT * FROM t1 WHERE a > 1),
    t3 AS (SELECT * FROM t2 WHERE a = 2)
SELECT * FROM t3
----
with &1 (t1)
 ├── columns: a:5(int!null)
 ├── project
 │    ├── columns: y.a:1(int!null)
 │    └── select
 │         ├── columns: y.a:1(int!null) rowid:2(int!null)
 │         ├── scan y
 │         │    └── columns: y.a:1(int) rowid:2(int!null)
 │         └── filters
 │              └── lt [type=bool]
 │                   ├── variable: y.a [type=int]
 │                   └── const: 3 [type=int]
 └── with &2 (t2)
      ├── columns: a:5(int!null)
      ├── select
      │    ├── columns: a:3(int!null)
      │    ├── with-scan &1 (t1)
      │    │    ├── columns: a:3(int!null)
      │    │    └── mapping:
      │    │         └──  y.a:1(int) => a:3(int)
      │    └── filters
      │         └── gt [type=bool]
      │              ├── variable: a [type=int]
      │              └── const: 1 [type=int]
      └── with &3 (t3)
           ├── columns: a:5(int!null)
           ├── select
           │    ├── columns: a:4(int!null)
           │    ├── with-scan &2 (t2)
           │    │    ├── columns: a:4(int!null)
           │    │    └── mapping:
           │    │         └──  a:3(int) => a:4(int)
           │    └── filters
           │         └── eq [type=bool]
           │              ├── variable: a [type=int]
           │              └── const: 2 [type=int]
           └── with-scan &3 (t3)
                ├── columns: a:5(int!null)
                └── mapping:
                     └──  a:4(int) => a:5(int)

build
WITH
    t1 AS (SELECT * FROM y WHERE a < 3),
    t2 AS (SELECT * FROM y WHERE a > 1),
    t3 AS (SELECT * FROM t1 WHERE a < 4),
    t4 AS (SELECT * FROM t2 WHERE a > 3)
SELECT * FROM t3 NATURAL JOIN t4
----
with &1 (t1)
 ├── columns: a:7(int!null)
 ├── project
 │    ├── columns: y.a:1(int!null)
 │    └── select
 │         ├── columns: y.a:1(int!null) rowid:2(int!null)
 │         ├── scan y
 │         │    └── columns: y.a:1(int) rowid:2(int!null)
 │         └── filters
 │              └── lt [type=bool]
 │                   ├── variable: y.a [type=int]
 │                   └── const: 3 [type=int]
 └── with &2 (t2)
      ├── columns: a:7(int!null)
      ├── project
      │    ├── columns: y.a:3(int!null)
      │    └── select
      │         ├── columns: y.a:3(int!null) rowid:4(int!null)
      │         ├── scan y
      │         │    └── columns: y.a:3(int) rowid:4(int!null)
      │         └── filters
      │              └── gt [type=bool]
      │                   ├── variable: y.a [type=int]
      │                   └── const: 1 [type=int]
      └── with &3 (t3)
           ├── columns: a:7(int!null)
           ├── select
           │    ├── columns: a:5(int!null)
           │    ├── with-scan &1 (t1)
           │    │    ├── columns: a:5(int!null)
           │    │    └── mapping:
           │    │         └──  y.a:1(int) => a:5(int)
           │    └── filters
           │         └── lt [type=bool]
           │              ├── variable: a [type=int]
           │              └── const: 4 [type=int]
           └── with &4 (t4)
                ├── columns: a:7(int!null)
                ├── select
                │    ├── columns: a:6(int!null)
                │    ├── with-scan &2 (t2)
                │    │    ├── columns: a:6(int!null)
                │    │    └── mapping:
                │    │         └──  y.a:3(int) => a:6(int)
                │    └── filters
                │         └── gt [type=bool]
                │              ├── variable: a [type=int]
                │              └── const: 3 [type=int]
                └── project
                     ├── columns: a:7(int!null)
                     └── inner-join
                          ├── columns: a:7(int!null) a:8(int!null)
                          ├── can parallel: true
                          ├── with-scan &3 (t3)
                          │    ├── columns: a:7(int!null)
                          │    └── mapping:
                          │         └──  a:5(int) => a:7(int)
                          ├── with-scan &4 (t4)
                          │    ├── columns: a:8(int!null)
                          │    └── mapping:
                          │         └──  a:6(int) => a:8(int)
                          └── filters
                               └── eq [type=bool]
                                    ├── variable: a [type=int]
                                    └── variable: a [type=int]

# Make sure they scope properly.
build
WITH t AS (SELECT true) SELECT * FROM (WITH t AS (SELECT false) SELECT * FROM t)
----
with &1 (t)
 ├── columns: bool:3(bool!null)
 ├── project
 │    ├── columns: bool:1(bool!null)
 │    ├── values
 │    │    └── tuple [type=tuple]
 │    └── projections
 │         └── true [type=bool]
 └── with &2 (t)
      ├── columns: bool:3(bool!null)
      ├── project
      │    ├── columns: bool:2(bool!null)
      │    ├── values
      │    │    └── tuple [type=tuple]
      │    └── projections
      │         └── false [type=bool]
      └── with-scan &2 (t)
           ├── columns: bool:3(bool!null)
           └── mapping:
                └──  bool:2(bool) => bool:3(bool)

build
WITH
    t AS (SELECT true),
    t AS (SELECT false)
SELECT * FROM t
----
error (42712): WITH query name "t" specified more than once

# Using a CTE once in another CTE and once otherwise.
build
WITH
    t1 AS (SELECT true),
    t2 AS (SELECT * FROM t1)
SELECT * FROM t1 NATURAL JOIN t2
----
with &1 (t1)
 ├── columns: bool:3(bool!null)
 ├── project
 │    ├── columns: bool:1(bool!null)
 │    ├── values
 │    │    └── tuple [type=tuple]
 │    └── projections
 │         └── true [type=bool]
 └── with &2 (t2)
      ├── columns: bool:3(bool!null)
      ├── with-scan &1 (t1)
      │    ├── columns: bool:2(bool!null)
      │    └── mapping:
      │         └──  bool:1(bool) => bool:2(bool)
      └── project
           ├── columns: bool:3(bool!null)
           └── inner-join
                ├── columns: bool:3(bool!null) bool:4(bool!null)
                ├── can parallel: true
                ├── with-scan &1 (t1)
                │    ├── columns: bool:3(bool!null)
                │    └── mapping:
                │         └──  bool:1(bool) => bool:3(bool)
                ├── with-scan &2 (t2)
                │    ├── columns: bool:4(bool!null)
                │    └── mapping:
                │         └──  bool:2(bool) => bool:4(bool)
                └── filters
                     └── eq [type=bool]
                          ├── variable: bool [type=bool]
                          └── variable: bool [type=bool]

build
WITH
    t1 AS (SELECT * FROM x),
    t2 AS (SELECT * FROM x NATURAL JOIN t1)
SELECT * FROM t2 NATURAL JOIN x
----
with &1 (t1)
 ├── columns: a:9(int!null) b:10(int!null)
 ├── project
 │    ├── columns: x.a:1(int) x.b:2(int)
 │    └── scan x
 │         └── columns: x.a:1(int) x.b:2(int) rowid:3(int!null)
 └── with &2 (t2)
      ├── columns: a:9(int!null) b:10(int!null)
      ├── project
      │    ├── columns: x.a:4(int!null) x.b:5(int!null)
      │    └── inner-join
      │         ├── columns: x.a:4(int!null) x.b:5(int!null) rowid:6(int!null) a:7(int!null) b:8(int!null)
      │         ├── can parallel: true
      │         ├── scan x
      │         │    └── columns: x.a:4(int) x.b:5(int) rowid:6(int!null)
      │         ├── with-scan &1 (t1)
      │         │    ├── columns: a:7(int) b:8(int)
      │         │    └── mapping:
      │         │         ├──  x.a:1(int) => a:7(int)
      │         │         └──  x.b:2(int) => b:8(int)
      │         └── filters
      │              ├── eq [type=bool]
      │              │    ├── variable: x.a [type=int]
      │              │    └── variable: a [type=int]
      │              └── eq [type=bool]
      │                   ├── variable: x.b [type=int]
      │                   └── variable: b [type=int]
      └── project
           ├── columns: a:9(int!null) b:10(int!null)
           └── inner-join
                ├── columns: a:9(int!null) b:10(int!null) x.a:11(int!null) x.b:12(int!null) rowid:13(int!null)
                ├── can parallel: true
                ├── with-scan &2 (t2)
                │    ├── columns: a:9(int!null) b:10(int!null)
                │    └── mapping:
                │         ├──  x.a:4(int) => a:9(int)
                │         └──  x.b:5(int) => b:10(int)
                ├── scan x
                │    └── columns: x.a:11(int) x.b:12(int) rowid:13(int!null)
                └── filters
                     ├── eq [type=bool]
                     │    ├── variable: a [type=int]
                     │    └── variable: x.a [type=int]
                     └── eq [type=bool]
                          ├── variable: b [type=int]
                          └── variable: x.b [type=int]

build
WITH t AS (SELECT a FROM y WHERE a < 3)
  SELECT * FROM t NATURAL JOIN t
----
error (42712): source name "t" specified more than once (missing AS clause)

build
WITH t(x) AS (SELECT a FROM x)
  SELECT x FROM (SELECT x FROM t)
----
with &1 (t)
 ├── columns: x:4(int)
 ├── project
 │    ├── columns: a:1(int)
 │    └── scan x
 │         └── columns: a:1(int) b:2(int) rowid:3(int!null)
 └── with-scan &1 (t)
      ├── columns: x:4(int)
      └── mapping:
           └──  a:1(int) => x:4(int)

build
WITH t(a, b) AS (SELECT true a, false b)
  SELECT a, b FROM t
----
with &1 (t)
 ├── columns: a:3(bool!null) b:4(bool!null)
 ├── project
 │    ├── columns: a:1(bool!null) b:2(bool!null)
 │    ├── values
 │    │    └── tuple [type=tuple]
 │    └── projections
 │         ├── true [type=bool]
 │         └── false [type=bool]
 └── with-scan &1 (t)
      ├── columns: a:3(bool!null) b:4(bool!null)
      └── mapping:
           ├──  a:1(bool) => a:3(bool)
           └──  b:2(bool) => b:4(bool)

build
WITH t(b, a) AS (SELECT true a, false b)
  SELECT a, b FROM t
----
with &1 (t)
 ├── columns: a:4(bool!null) b:3(bool!null)
 ├── project
 │    ├── columns: a:1(bool!null) b:2(bool!null)
 │    ├── values
 │    │    └── tuple [type=tuple]
 │    └── projections
 │         ├── true [type=bool]
 │         └── false [type=bool]
 └── with-scan &1 (t)
      ├── columns: b:3(bool!null) a:4(bool!null)
      └── mapping:
           ├──  a:1(bool) => b:3(bool)
           └──  b:2(bool) => a:4(bool)

build
WITH t AS (SELECT a FROM x)
    SELECT * FROM y WHERE a IN (SELECT * FROM t)
----
with &1 (t)
 ├── columns: a:4(int)
 ├── project
 │    ├── columns: x.a:1(int)
 │    └── scan x
 │         └── columns: x.a:1(int) b:2(int) x.rowid:3(int!null)
 └── project
      ├── columns: y.a:4(int)
      └── select
           ├── columns: y.a:4(int) y.rowid:5(int!null)
           ├── scan y
           │    └── columns: y.a:4(int) y.rowid:5(int!null)
           └── filters
                └── any: eq [type=bool]
                     ├── with-scan &1 (t)
                     │    ├── columns: a:6(int)
                     │    └── mapping:
                     │         └──  x.a:1(int) => a:6(int)
                     └── variable: y.a [type=int]

build
WITH t(x) AS (SELECT a FROM x)
    SELECT * FROM y WHERE a IN (SELECT x FROM t)
----
with &1 (t)
 ├── columns: a:4(int)
 ├── project
 │    ├── columns: x.a:1(int)
 │    └── scan x
 │         └── columns: x.a:1(int) b:2(int) x.rowid:3(int!null)
 └── project
      ├── columns: y.a:4(int)
      └── select
           ├── columns: y.a:4(int) y.rowid:5(int!null)
           ├── scan y
           │    └── columns: y.a:4(int) y.rowid:5(int!null)
           └── filters
                └── any: eq [type=bool]
                     ├── with-scan &1 (t)
                     │    ├── columns: x:6(int)
                     │    └── mapping:
                     │         └──  x.a:1(int) => x:6(int)
                     └── variable: y.a [type=int]

# Using a subquery inside a CTE
build
SELECT * FROM x WHERE a IN
  (WITH t AS (SELECT * FROM y WHERE a < 3) SELECT * FROM t)
----
project
 ├── columns: a:1(int) b:2(int)
 └── select
      ├── columns: x.a:1(int) b:2(int) x.rowid:3(int!null)
      ├── scan x
      │    └── columns: x.a:1(int) b:2(int) x.rowid:3(int!null)
      └── filters
           └── any: eq [type=bool]
                ├── with &1 (t)
                │    ├── columns: a:6(int!null)
                │    ├── project
                │    │    ├── columns: y.a:4(int!null)
                │    │    └── select
                │    │         ├── columns: y.a:4(int!null) y.rowid:5(int!null)
                │    │         ├── scan y
                │    │         │    └── columns: y.a:4(int) y.rowid:5(int!null)
                │    │         └── filters
                │    │              └── lt [type=bool]
                │    │                   ├── variable: y.a [type=int]
                │    │                   └── const: 3 [type=int]
                │    └── with-scan &1 (t)
                │         ├── columns: a:6(int!null)
                │         └── mapping:
                │              └──  y.a:4(int) => a:6(int)
                └── variable: x.a [type=int]

# Using a correlated subquery inside a CTE
build
SELECT (WITH t AS (SELECT * FROM y WHERE x.a = y.a) SELECT * FROM t LIMIT 1) FROM x
----
error (0A000): CTEs may not be correlated

# Rename columns
build
WITH t(b) AS (SELECT a FROM x) SELECT b, t.b FROM t
----
with &1 (t)
 ├── columns: b:4(int) b:4(int)
 ├── project
 │    ├── columns: a:1(int)
 │    └── scan x
 │         └── columns: a:1(int) x.b:2(int) rowid:3(int!null)
 └── with-scan &1 (t)
      ├── columns: b:4(int)
      └── mapping:
           └──  a:1(int) => b:4(int)

build
WITH t(b, c) AS (SELECT a FROM x) SELECT b, t.b FROM t
----
error (42P10): source "t" has 1 columns available but 2 columns specified

# Ensure you can't reference the original table name
build
WITH t AS (SELECT a FROM x) SELECT a, x.t FROM t
----
error (42P01): no data source matches prefix: x

# Nested WITH, name shadowing
build
WITH t(x) AS (WITH t(x) AS (SELECT 1) SELECT x * 10 FROM t) SELECT x + 2 FROM t
----
with &2 (t)
 ├── columns: "?column?":5(int)
 ├── with &1 (t)
 │    ├── columns: "?column?":3(int)
 │    ├── project
 │    │    ├── columns: "?column?":1(int!null)
 │    │    ├── values
 │    │    │    └── tuple [type=tuple]
 │    │    └── projections
 │    │         └── const: 1 [type=int]
 │    └── project
 │         ├── columns: "?column?":3(int)
 │         ├── with-scan &1 (t)
 │         │    ├── columns: x:2(int!null)
 │         │    └── mapping:
 │         │         └──  "?column?":1(int) => x:2(int)
 │         └── projections
 │              └── mult [type=int]
 │                   ├── variable: x [type=int]
 │                   └── const: 10 [type=int]
 └── project
      ├── columns: "?column?":5(int)
      ├── with-scan &2 (t)
      │    ├── columns: x:4(int)
      │    └── mapping:
      │         └──  "?column?":3(int) => x:4(int)
      └── projections
           └── plus [type=int]
                ├── variable: x [type=int]
                └── const: 2 [type=int]

build
WITH one AS (SELECT a AS u FROM x),
     two AS (SELECT a AS v FROM (SELECT a FROM y UNION ALL SELECT u FROM one))
  SELECT * FROM one JOIN two ON u = v
----
with &1 (one)
 ├── columns: u:8(int!null) v:9(int!null)
 ├── project
 │    ├── columns: x.a:1(int)
 │    └── scan x
 │         └── columns: x.a:1(int) b:2(int) x.rowid:3(int!null)
 └── with &2 (two)
      ├── columns: u:8(int!null) v:9(int!null)
      ├── union-all
      │    ├── columns: a:7(int)
      │    ├── left columns: y.a:4(int)
      │    ├── right columns: u:6(int)
      │    ├── project
      │    │    ├── columns: y.a:4(int)
      │    │    └── scan y
      │    │         └── columns: y.a:4(int) y.rowid:5(int!null)
      │    └── with-scan &1 (one)
      │         ├── columns: u:6(int)
      │         └── mapping:
      │              └──  x.a:1(int) => u:6(int)
      └── inner-join
           ├── columns: u:8(int!null) v:9(int!null)
           ├── can parallel: true
           ├── with-scan &1 (one)
           │    ├── columns: u:8(int)
           │    └── mapping:
           │         └──  x.a:1(int) => u:8(int)
           ├── with-scan &2 (two)
           │    ├── columns: v:9(int)
           │    └── mapping:
           │         └──  a:7(int) => v:9(int)
           └── filters
                └── eq [type=bool]
                     ├── variable: u [type=int]
                     └── variable: v [type=int]

build
WITH foo AS (SELECT x.a FROM x ORDER by x.a) SELECT * FROM foo
----
with &1 (foo)
 ├── columns: a:4(int)
 ├── project
 │    ├── columns: x.a:1(int)
 │    └── scan x
 │         └── columns: x.a:1(int) b:2(int) rowid:3(int!null)
 └── with-scan &1 (foo)
      ├── columns: a:4(int)
      └── mapping:
           └──  x.a:1(int) => a:4(int)

# Mutations.
build
WITH t AS (SELECT a FROM x) INSERT INTO x SELECT a + 20 FROM t RETURNING *
----
with &1 (t)
 ├── columns: a:4(int) b:5(int)
 ├── project
 │    ├── columns: x.a:1(int)
 │    └── scan x
 │         └── columns: x.a:1(int) b:2(int) rowid:3(int!null)
 └── project
      ├── columns: x.a:4(int) b:5(int)
      └── insert x
           ├── columns: x.a:4(int) b:5(int) rowid:6(int!null)
           ├── insert-mapping:
           │    ├──  int8:8 => x.a:4
           │    ├──  column9:9 => b:5
           │    └──  column10:10 => rowid:6
           └── project
                ├── columns: column9:9(int) column10:10(int) int8:8(int)
                ├── project
                │    ├── columns: int8:8(int)
                │    ├── with-scan &1 (t)
                │    │    ├── columns: a:7(int)
                │    │    └── mapping:
                │    │         └──  x.a:1(int) => a:7(int)
                │    └── projections
                │         └── cast: INT8 [type=int]
                │              └── plus [type=int]
                │                   ├── variable: a [type=int]
                │                   └── const: 20 [type=int]
                └── projections
                     ├── cast: INT8 [type=int]
                     │    └── null [type=unknown]
                     └── function: unique_rowid [type=int]

build
WITH t AS (SELECT a FROM x) UPDATE x SET a = (SELECT * FROM t) RETURNING *
----
with &1 (t)
 ├── columns: a:4(int) b:5(int)
 ├── project
 │    ├── columns: x.a:1(int)
 │    └── scan x
 │         └── columns: x.a:1(int) b:2(int) rowid:3(int!null)
 └── project
      ├── columns: x.a:4(int) b:5(int)
      └── update x
           ├── columns: x.a:4(int) b:5(int) rowid:6(int!null)
           ├── fetch columns: x.a:7(int) b:8(int) rowid:9(int)
           ├── update-mapping:
           │    └──  column11:11 => x.a:4
           └── project
                ├── columns: column11:11(int) x.a:7(int) b:8(int) rowid:9(int!null)
                ├── scan x
                │    └── columns: x.a:7(int) b:8(int) rowid:9(int!null)
                └── projections
                     └── subquery [type=int]
                          └── max1-row
                               ├── columns: a:10(int)
                               └── with-scan &1 (t)
                                    ├── columns: a:10(int)
                                    └── mapping:
                                         └──  x.a:1(int) => a:10(int)

build
WITH t AS (SELECT a FROM x) DELETE FROM x WHERE a = (SELECT * FROM t) RETURNING *
----
with &1 (t)
 ├── columns: a:4(int!null) b:5(int)
 ├── project
 │    ├── columns: x.a:1(int)
 │    └── scan x
 │         └── columns: x.a:1(int) b:2(int) rowid:3(int!null)
 └── project
      ├── columns: x.a:4(int!null) b:5(int)
      └── delete x
           ├── columns: x.a:4(int!null) b:5(int) rowid:6(int!null)
           ├── fetch columns: x.a:7(int) b:8(int) rowid:9(int)
           └── select
                ├── columns: x.a:7(int!null) b:8(int) rowid:9(int!null)
                ├── scan x
                │    └── columns: x.a:7(int) b:8(int) rowid:9(int!null)
                └── filters
                     └── eq [type=bool]
                          ├── variable: x.a [type=int]
                          └── subquery [type=int]
                               └── max1-row
                                    ├── columns: a:10(int)
                                    └── with-scan &1 (t)
                                         ├── columns: a:10(int)
                                         └── mapping:
                                              └──  x.a:1(int) => a:10(int)

# Correlated WITH is not allowed.

build
SELECT (WITH foo AS (SELECT x.a FROM x WHERE x.a = y.a) SELECT a FROM foo) FROM y
----
error (0A000): CTEs may not be correlated

build
SELECT (WITH foo AS (SELECT (SELECT y.a) FROM x) SELECT a FROM foo) FROM y
----
error (0A000): CTEs may not be correlated

# Regression test for #40407.
exec-ddl
CREATE TABLE xy (x INT, y INT, z TIMESTAMP);
----
TABLE xy
 ├── x int
 ├── y int
 ├── z timestamp
 ├── rowid int not null (hidden)
 └── INDEX primary
      └── rowid int not null (hidden)

exec-ddl
CREATE TABLE uv (u INT, v INT);
----
TABLE uv
 ├── u int
 ├── v int
 ├── rowid int not null (hidden)
 └── INDEX primary
      └── rowid int not null (hidden)

build
WITH
    t AS (SELECT xy.x FROM xy INNER JOIN uv ON xy.x = uv.u ORDER BY uv.v DESC LIMIT 5)
DELETE FROM
    xy
WHERE
    x = ANY (SELECT * FROM t);
----
with &1 (t)
 ├── project
 │    ├── columns: xy.x:1(int!null)
 │    └── limit
 │         ├── columns: xy.x:1(int!null) v:6(int)
 │         ├── internal-ordering: -6
 │         ├── sort
 │         │    ├── columns: xy.x:1(int!null) v:6(int)
 │         │    ├── ordering: -6
 │         │    └── project
 │         │         ├── columns: xy.x:1(int!null) v:6(int)
 │         │         └── inner-join
 │         │              ├── columns: xy.x:1(int!null) y:2(int) z:3(timestamp) xy.rowid:4(int!null) u:5(int!null) v:6(int) uv.rowid:7(int!null)
 │         │              ├── can parallel: true
 │         │              ├── scan xy
 │         │              │    └── columns: xy.x:1(int) y:2(int) z:3(timestamp) xy.rowid:4(int!null)
 │         │              ├── scan uv
 │         │              │    └── columns: u:5(int) v:6(int) uv.rowid:7(int!null)
 │         │              └── filters
 │         │                   └── eq [type=bool]
 │         │                        ├── variable: xy.x [type=int]
 │         │                        └── variable: u [type=int]
 │         └── const: 5 [type=int]
 └── delete xy
      ├── columns: <none>
      ├── fetch columns: xy.x:12(int) y:13(int) z:14(timestamp) xy.rowid:15(int)
      └── select
           ├── columns: xy.x:12(int) y:13(int) z:14(timestamp) xy.rowid:15(int!null)
           ├── scan xy
           │    └── columns: xy.x:12(int) y:13(int) z:14(timestamp) xy.rowid:15(int!null)
           └── filters
                └── any: eq [type=bool]
                     ├── with-scan &1 (t)
                     │    ├── columns: x:16(int!null)
                     │    └── mapping:
                     │         └──  xy.x:1(int) => x:16(int)
                     └── variable: xy.x [type=int]

# WITH RECURSIVE examples from postgres docs.

build
WITH RECURSIVE t(n) AS (
    VALUES (1)
  UNION ALL
    SELECT n+1 FROM t WHERE n < 100
)
SELECT sum(n) FROM t
----
with &2 (t)
 ├── columns: sum:6(decimal)
 ├── recursive-c-t-e
 │    ├── columns: n:2(int)
 │    ├── working table binding: &1
 │    ├── initial columns: column1:1(int)
 │    ├── recursive columns: int8:4(int)
 │    ├── values
 │    │    ├── columns: column1:1(int)
 │    │    └── tuple [type=tuple{int}]
 │    │         └── const: 1 [type=int]
 │    └── project
 │         ├── columns: int8:4(int)
 │         ├── select
 │         │    ├── columns: n:3(int!null)
 │         │    ├── with-scan &1 (t)
 │         │    │    ├── columns: n:3(int)
 │         │    │    └── mapping:
 │         │    │         └──  n:2(int) => n:3(int)
 │         │    └── filters
 │         │         └── lt [type=bool]
 │         │              ├── variable: n [type=int]
 │         │              └── const: 100 [type=int]
 │         └── projections
 │              └── cast: INT8 [type=int]
 │                   └── plus [type=int]
 │                        ├── variable: n [type=int]
 │                        └── const: 1 [type=int]
 └── scalar-group-by
      ├── columns: sum:6(decimal)
      ├── with-scan &2 (t)
      │    ├── columns: n:5(int)
      │    └── mapping:
      │         └──  n:2(int) => n:5(int)
      └── aggregations
           └── sum [type=decimal]
                └── variable: n [type=int]

exec-ddl
CREATE TABLE parts (part STRING, sub_part STRING, quantity INT)
----
TABLE parts
 ├── part string
 ├── sub_part string
 ├── quantity int
 ├── rowid int not null (hidden)
 └── INDEX primary
      └── rowid int not null (hidden)

build
WITH RECURSIVE included_parts(sub_part, part, quantity) AS (
    SELECT sub_part, part, quantity FROM parts WHERE part = 'our_product'
  UNION ALL
    SELECT p.sub_part, p.part, p.quantity
    FROM included_parts AS pr, parts AS p
    WHERE p.part = pr.sub_part
)
SELECT sub_part, sum(quantity) as total_quantity
FROM included_parts
GROUP BY sub_part
----
with &2 (included_parts)
 ├── columns: sub_part:18(string) total_quantity:21(decimal)
 ├── recursive-c-t-e
 │    ├── columns: sub_part:5(string) part:6(string) quantity:7(int)
 │    ├── working table binding: &1
 │    ├── initial columns: parts.sub_part:2(string) parts.part:1(string) parts.quantity:3(int)
 │    ├── recursive columns: sub_part:15(string) part:16(string) quantity:17(int)
 │    ├── project
 │    │    ├── columns: parts.part:1(string!null) parts.sub_part:2(string) parts.quantity:3(int)
 │    │    └── select
 │    │         ├── columns: parts.part:1(string!null) parts.sub_part:2(string) parts.quantity:3(int) parts.rowid:4(int!null)
 │    │         ├── scan parts
 │    │         │    └── columns: parts.part:1(string) parts.sub_part:2(string) parts.quantity:3(int) parts.rowid:4(int!null)
 │    │         └── filters
 │    │              └── eq [type=bool]
 │    │                   ├── variable: parts.part [type=string]
 │    │                   └── const: 'our_product' [type=string]
 │    └── project
 │         ├── columns: sub_part:15(string) part:16(string!null) quantity:17(int)
 │         ├── select
 │         │    ├── columns: sub_part:8(string!null) part:9(string) quantity:10(int) p.part:11(string!null) p.sub_part:12(string) p.quantity:13(int) p.rowid:14(int!null)
 │         │    ├── inner-join
 │         │    │    ├── columns: sub_part:8(string) part:9(string) quantity:10(int) p.part:11(string) p.sub_part:12(string) p.quantity:13(int) p.rowid:14(int!null)
 │         │    │    ├── can parallel: true
 │         │    │    ├── with-scan &1 (included_parts)
 │         │    │    │    ├── columns: sub_part:8(string) part:9(string) quantity:10(int)
 │         │    │    │    └── mapping:
 │         │    │    │         ├──  sub_part:5(string) => sub_part:8(string)
 │         │    │    │         ├──  part:6(string) => part:9(string)
 │         │    │    │         └──  quantity:7(int) => quantity:10(int)
 │         │    │    ├── scan p
 │         │    │    │    └── columns: p.part:11(string) p.sub_part:12(string) p.quantity:13(int) p.rowid:14(int!null)
 │         │    │    └── filters (true)
 │         │    └── filters
 │         │         └── eq [type=bool]
 │         │              ├── variable: p.part [type=string]
 │         │              └── variable: sub_part [type=string]
 │         └── projections
 │              ├── cast: STRING [type=string]
 │              │    └── variable: p.sub_part [type=string]
 │              ├── cast: STRING [type=string]
 │              │    └── variable: p.part [type=string]
 │              └── cast: INT8 [type=int]
 │                   └── variable: p.quantity [type=int]
 └── group-by
      ├── columns: sub_part:18(string) sum:21(decimal)
      ├── grouping columns: sub_part:18(string)
      ├── project
      │    ├── columns: sub_part:18(string) quantity:20(int)
      │    └── with-scan &2 (included_parts)
      │         ├── columns: sub_part:18(string) part:19(string) quantity:20(int)
      │         └── mapping:
      │              ├──  sub_part:5(string) => sub_part:18(string)
      │              ├──  part:6(string) => part:19(string)
      │              └──  quantity:7(int) => quantity:20(int)
      └── aggregations
           └── sum [type=decimal]
                └── variable: quantity [type=int]

exec-ddl
CREATE TABLE graph (id INT PRIMARY KEY, link INT, data STRING)
----
TABLE graph
 ├── id int not null
 ├── link int
 ├── data string
 └── INDEX primary
      └── id int not null

build
WITH RECURSIVE search_graph(id, link, data, depth, path, cycle) AS (
    SELECT g.id, g.link, g.data, 1,
      ARRAY[g.id],
      false
    FROM graph g
  UNION ALL
    SELECT g.id, g.link, g.data, sg.depth + 1,
      path || g.id,
      g.id = ANY(path)
    FROM graph g, search_graph sg
    WHERE g.id = sg.link AND NOT cycle
)
SELECT * FROM search_graph
----
with &2 (search_graph)
 ├── columns: id:28(int) link:29(int) data:30(string) depth:31(int) path:32(int[]) cycle:33(bool)
 ├── recursive-c-t-e
 │    ├── columns: id:7(int) link:8(int) data:9(string) depth:10(int) path:11(int[]) cycle:12(bool)
 │    ├── working table binding: &1
 │    ├── initial columns: g.id:1(int) g.link:2(int) g.data:3(string) "?column?":4(int) array:5(int[]) bool:6(bool)
 │    ├── recursive columns: id:22(int) link:23(int) data:24(string) int8:25(int) "int8[]":26(int[]) bool:27(bool)
 │    ├── project
 │    │    ├── columns: "?column?":4(int!null) array:5(int[]) bool:6(bool!null) g.id:1(int!null) g.link:2(int) g.data:3(string)
 │    │    ├── scan g
 │    │    │    └── columns: g.id:1(int!null) g.link:2(int) g.data:3(string)
 │    │    └── projections
 │    │         ├── const: 1 [type=int]
 │    │         ├── array: [type=int[]]
 │    │         │    └── variable: g.id [type=int]
 │    │         └── false [type=bool]
 │    └── project
 │         ├── columns: id:22(int!null) link:23(int) data:24(string) int8:25(int) "int8[]":26(int[]) bool:27(bool)
 │         ├── select
 │         │    ├── columns: g.id:13(int!null) g.link:14(int) g.data:15(string) id:16(int) link:17(int!null) data:18(string) depth:19(int) path:20(int[]) cycle:21(bool!null)
 │         │    ├── inner-join
 │         │    │    ├── columns: g.id:13(int!null) g.link:14(int) g.data:15(string) id:16(int) link:17(int) data:18(string) depth:19(int) path:20(int[]) cycle:21(bool)
 │         │    │    ├── can parallel: true
 │         │    │    ├── scan g
 │         │    │    │    └── columns: g.id:13(int!null) g.link:14(int) g.data:15(string)
 │         │    │    ├── with-scan &1 (search_graph)
 │         │    │    │    ├── columns: id:16(int) link:17(int) data:18(string) depth:19(int) path:20(int[]) cycle:21(bool)
 │         │    │    │    └── mapping:
 │         │    │    │         ├──  id:7(int) => id:16(int)
 │         │    │    │         ├──  link:8(int) => link:17(int)
 │         │    │    │         ├──  data:9(string) => data:18(string)
 │         │    │    │         ├──  depth:10(int) => depth:19(int)
 │         │    │    │         ├──  path:11(int[]) => path:20(int[])
 │         │    │    │         └──  cycle:12(bool) => cycle:21(bool)
 │         │    │    └── filters (true)
 │         │    └── filters
 │         │         └── and [type=bool]
 │         │              ├── eq [type=bool]
 │         │              │    ├── variable: g.id [type=int]
 │         │              │    └── variable: link [type=int]
 │         │              └── not [type=bool]
 │         │                   └── variable: cycle [type=bool]
 │         └── projections
 │              ├── cast: INT8 [type=int]
 │              │    └── variable: g.id [type=int]
 │              ├── cast: INT8 [type=int]
 │              │    └── variable: g.link [type=int]
 │              ├── cast: STRING [type=string]
 │              │    └── variable: g.data [type=string]
 │              ├── cast: INT8 [type=int]
 │              │    └── plus [type=int]
 │              │         ├── variable: depth [type=int]
 │              │         └── const: 1 [type=int]
 │              ├── cast: INT8[] [type=int[]]
 │              │    └── concat [type=int[]]
 │              │         ├── variable: path [type=int[]]
 │              │         └── variable: g.id [type=int]
 │              └── cast: BOOL [type=bool]
 │                   └── any-scalar: eq [type=bool]
 │                        ├── variable: g.id [type=int]
 │                        └── variable: path [type=int[]]
 └── with-scan &2 (search_graph)
      ├── columns: id:28(int) link:29(int) data:30(string) depth:31(int) path:32(int[]) cycle:33(bool)
      └── mapping:
           ├──  id:7(int) => id:28(int)
           ├──  link:8(int) => link:29(int)
           ├──  data:9(string) => data:30(string)
           ├──  depth:10(int) => depth:31(int)
           ├──  path:11(int[]) => path:32(int[])
           └──  cycle:12(bool) => cycle:33(bool)

# Test where initial query has duplicate columns.
build
WITH RECURSIVE cte(a, b) AS (
    SELECT 0, 0
  UNION ALL
    SELECT a+1, b+10 FROM cte WHERE a < 5
) SELECT * FROM cte;
----
with &2 (cte)
 ├── columns: a:8(int) b:9(int)
 ├── recursive-c-t-e
 │    ├── columns: a:2(int) b:3(int)
 │    ├── working table binding: &1
 │    ├── initial columns: "?column?":1(int) "?column?":1(int)
 │    ├── recursive columns: int8:6(int) int8:7(int)
 │    ├── project
 │    │    ├── columns: "?column?":1(int!null)
 │    │    ├── values
 │    │    │    └── tuple [type=tuple]
 │    │    └── projections
 │    │         └── const: 0 [type=int]
 │    └── project
 │         ├── columns: int8:6(int) int8:7(int)
 │         ├── select
 │         │    ├── columns: a:4(int!null) b:5(int)
 │         │    ├── with-scan &1 (cte)
 │         │    │    ├── columns: a:4(int) b:5(int)
 │         │    │    └── mapping:
 │         │    │         ├──  a:2(int) => a:4(int)
 │         │    │         └──  b:3(int) => b:5(int)
 │         │    └── filters
 │         │         └── lt [type=bool]
 │         │              ├── variable: a [type=int]
 │         │              └── const: 5 [type=int]
 │         └── projections
 │              ├── cast: INT8 [type=int]
 │              │    └── plus [type=int]
 │              │         ├── variable: a [type=int]
 │              │         └── const: 1 [type=int]
 │              └── cast: INT8 [type=int]
 │                   └── plus [type=int]
 │                        ├── variable: b [type=int]
 │                        └── const: 10 [type=int]
 └── with-scan &2 (cte)
      ├── columns: a:8(int) b:9(int)
      └── mapping:
           ├──  a:2(int) => a:8(int)
           └──  b:3(int) => b:9(int)

# Test where recursive query has duplicate columns.
build
WITH RECURSIVE cte(a, b) AS (
    SELECT 0, 1
  UNION ALL
    SELECT a+1, a+1 FROM cte WHERE a < 5
) SELECT * FROM cte;
----
with &2 (cte)
 ├── columns: a:8(int) b:9(int)
 ├── recursive-c-t-e
 │    ├── columns: a:3(int) b:4(int)
 │    ├── working table binding: &1
 │    ├── initial columns: "?column?":1(int) "?column?":2(int)
 │    ├── recursive columns: int8:7(int) int8:7(int)
 │    ├── project
 │    │    ├── columns: "?column?":1(int!null) "?column?":2(int!null)
 │    │    ├── values
 │    │    │    └── tuple [type=tuple]
 │    │    └── projections
 │    │         ├── const: 0 [type=int]
 │    │         └── const: 1 [type=int]
 │    └── project
 │         ├── columns: int8:7(int)
 │         ├── select
 │         │    ├── columns: a:5(int!null) b:6(int)
 │         │    ├── with-scan &1 (cte)
 │         │    │    ├── columns: a:5(int) b:6(int)
 │         │    │    └── mapping:
 │         │    │         ├──  a:3(int) => a:5(int)
 │         │    │         └──  b:4(int) => b:6(int)
 │         │    └── filters
 │         │         └── lt [type=bool]
 │         │              ├── variable: a [type=int]
 │         │              └── const: 5 [type=int]
 │         └── projections
 │              └── cast: INT8 [type=int]
 │                   └── plus [type=int]
 │                        ├── variable: a [type=int]
 │                        └── const: 1 [type=int]
 └── with-scan &2 (cte)
      ├── columns: a:8(int) b:9(int)
      └── mapping:
           ├──  a:3(int) => a:8(int)
           └──  b:4(int) => b:9(int)

# Allow non-recursive CTE when RECURSIVE is used.
build
WITH RECURSIVE cte(a, b) AS (
  SELECT 1, 2
) SELECT * FROM cte;
----
with &2 (cte)
 ├── columns: a:3(int!null) b:4(int!null)
 ├── project
 │    ├── columns: "?column?":1(int!null) "?column?":2(int!null)
 │    ├── values
 │    │    └── tuple [type=tuple]
 │    └── projections
 │         ├── const: 1 [type=int]
 │         └── const: 2 [type=int]
 └── with-scan &2 (cte)
      ├── columns: a:3(int!null) b:4(int!null)
      └── mapping:
           ├──  "?column?":1(int) => a:3(int)
           └──  "?column?":2(int) => b:4(int)

# Allow non-recursive CTE even when it has UNION ALL.
build
WITH RECURSIVE cte(a, b) AS (
    SELECT 1, 2
  UNION ALL
    SELECT 3, 4
) SELECT * FROM cte;
----
with &2 (cte)
 ├── columns: a:9(int) b:10(int)
 ├── union
 │    ├── columns: "?column?":7(int) "?column?":8(int)
 │    ├── left columns: "?column?":1(int) "?column?":2(int)
 │    ├── right columns: int8:5(int) int8:6(int)
 │    ├── project
 │    │    ├── columns: "?column?":1(int!null) "?column?":2(int!null)
 │    │    ├── values
 │    │    │    └── tuple [type=tuple]
 │    │    └── projections
 │    │         ├── const: 1 [type=int]
 │    │         └── const: 2 [type=int]
 │    └── project
 │         ├── columns: int8:5(int) int8:6(int)
 │         ├── values
 │         │    └── tuple [type=tuple]
 │         └── projections
 │              ├── cast: INT8 [type=int]
 │              │    └── const: 3 [type=int]
 │              └── cast: INT8 [type=int]
 │                   └── const: 4 [type=int]
 └── with-scan &2 (cte)
      ├── columns: a:9(int) b:10(int)
      └── mapping:
           ├──  "?column?":7(int) => a:9(int)
           └──  "?column?":8(int) => b:10(int)

# Error cases.
build
WITH RECURSIVE cte(a, b) AS (
  SELECT 1+a, 1+b FROM cte
) SELECT * FROM cte;
----
error (42601): recursive query "cte" does not have the form non-recursive-term UNION ALL recursive-term

build
WITH RECURSIVE cte(a, b) AS (
    SELECT 1, 2
  UNION
    SELECT 1+a, 1+b FROM cte
) SELECT * FROM cte;
----
with &2 (cte)
 ├── columns: a:9(int) b:10(int)
 ├── recursive-c-t-e
 │    ├── columns: a:3(int) b:4(int)
 │    ├── working table binding: &1
 │    ├── initial columns: "?column?":1(int) "?column?":2(int)
 │    ├── recursive columns: int8:7(int) int8:8(int)
 │    ├── project
 │    │    ├── columns: "?column?":1(int!null) "?column?":2(int!null)
 │    │    ├── values
 │    │    │    └── tuple [type=tuple]
 │    │    └── projections
 │    │         ├── const: 1 [type=int]
 │    │         └── const: 2 [type=int]
 │    └── project
 │         ├── columns: int8:7(int) int8:8(int)
 │         ├── with-scan &1 (cte)
 │         │    ├── columns: a:5(int) b:6(int)
 │         │    └── mapping:
 │         │         ├──  a:3(int) => a:5(int)
 │         │         └──  b:4(int) => b:6(int)
 │         └── projections
 │              ├── cast: INT8 [type=int]
 │              │    └── plus [type=int]
 │              │         ├── const: 1 [type=int]
 │              │         └── variable: a [type=int]
 │              └── cast: INT8 [type=int]
 │                   └── plus [type=int]
 │                        ├── const: 1 [type=int]
 │                        └── variable: b [type=int]
 └── with-scan &2 (cte)
      ├── columns: a:9(int) b:10(int)
      └── mapping:
           ├──  a:3(int) => a:9(int)
           └──  b:4(int) => b:10(int)

build
WITH RECURSIVE cte(a, b) AS (
    SELECT 1+a, 1+b FROM cte
  UNION ALL
    SELECT 3, 4
) SELECT * FROM cte;
----
error (42601): recursive reference to query "cte" must not appear within its non-recursive term

build
WITH RECURSIVE cte(a, b) AS (
    SELECT 1, 2
  UNION ALL
    SELECT c1.a+c2.a, c1.b+c2.b FROM cte AS c1, cte AS c2
) SELECT * FROM cte;
----
error (42601): WITH query name "cte" specified more than once

# If we really need to reference the working table multiple times, we can use
# an inner WITH.
build
WITH RECURSIVE cte(a, b) AS (
    SELECT 1, 2
  UNION ALL
    (WITH foo AS (SELECT * FROM cte) SELECT c1.a+c2.a, c1.b+c2.b FROM foo AS c1, foo AS c2)
) SELECT * FROM cte;
----
with &3 (cte)
 ├── columns: a:13(int) b:14(int)
 ├── recursive-c-t-e
 │    ├── columns: a:3(int) b:4(int)
 │    ├── working table binding: &1
 │    ├── initial columns: "?column?":1(int) "?column?":2(int)
 │    ├── recursive columns: int8:11(int) int8:12(int)
 │    ├── project
 │    │    ├── columns: "?column?":1(int!null) "?column?":2(int!null)
 │    │    ├── values
 │    │    │    └── tuple [type=tuple]
 │    │    └── projections
 │    │         ├── const: 1 [type=int]
 │    │         └── const: 2 [type=int]
 │    └── with &2 (foo)
 │         ├── columns: int8:11(int) int8:12(int)
 │         ├── with-scan &1 (cte)
 │         │    ├── columns: a:5(int) b:6(int)
 │         │    └── mapping:
 │         │         ├──  a:3(int) => a:5(int)
 │         │         └──  b:4(int) => b:6(int)
 │         └── project
 │              ├── columns: int8:11(int) int8:12(int)
 │              ├── inner-join
 │              │    ├── columns: a:7(int) b:8(int) a:9(int) b:10(int)
 │              │    ├── can parallel: true
 │              │    ├── with-scan &2 (foo)
 │              │    │    ├── columns: a:7(int) b:8(int)
 │              │    │    └── mapping:
 │              │    │         ├──  a:5(int) => a:7(int)
 │              │    │         └──  b:6(int) => b:8(int)
 │              │    ├── with-scan &2 (foo)
 │              │    │    ├── columns: a:9(int) b:10(int)
 │              │    │    └── mapping:
 │              │    │         ├──  a:5(int) => a:9(int)
 │              │    │         └──  b:6(int) => b:10(int)
 │              │    └── filters (true)
 │              └── projections
 │                   ├── cast: INT8 [type=int]
 │                   │    └── plus [type=int]
 │                   │         ├── variable: a [type=int]
 │                   │         └── variable: a [type=int]
 │                   └── cast: INT8 [type=int]
 │                        └── plus [type=int]
 │                             ├── variable: b [type=int]
 │                             └── variable: b [type=int]
 └── with-scan &3 (cte)
      ├── columns: a:13(int) b:14(int)
      └── mapping:
           ├──  a:3(int) => a:13(int)
           └──  b:4(int) => b:14(int)
