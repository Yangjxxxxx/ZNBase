// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: roachpb/pushdown.proto

#ifndef PROTOBUF_INCLUDED_roachpb_2fpushdown_2eproto
#define PROTOBUF_INCLUDED_roachpb_2fpushdown_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_roachpb_2fpushdown_2eproto 

namespace protobuf_roachpb_2fpushdown_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[7];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
}  // namespace protobuf_roachpb_2fpushdown_2eproto
namespace znbase {
namespace roachpb {
class AggregatorPush;
class AggregatorPushDefaultTypeInternal;
extern AggregatorPushDefaultTypeInternal _AggregatorPush_default_instance_;
class AggregatorPush_Aggregation;
class AggregatorPush_AggregationDefaultTypeInternal;
extern AggregatorPush_AggregationDefaultTypeInternal _AggregatorPush_Aggregation_default_instance_;
class BaseFilter;
class BaseFilterDefaultTypeInternal;
extern BaseFilterDefaultTypeInternal _BaseFilter_default_instance_;
class ColumnMeta;
class ColumnMetaDefaultTypeInternal;
extern ColumnMetaDefaultTypeInternal _ColumnMeta_default_instance_;
class FilterUnion;
class FilterUnionDefaultTypeInternal;
extern FilterUnionDefaultTypeInternal _FilterUnion_default_instance_;
class LogicalFilter;
class LogicalFilterDefaultTypeInternal;
extern LogicalFilterDefaultTypeInternal _LogicalFilter_default_instance_;
class PushDownExpr;
class PushDownExprDefaultTypeInternal;
extern PushDownExprDefaultTypeInternal _PushDownExpr_default_instance_;
}  // namespace roachpb
}  // namespace znbase
namespace google {
namespace protobuf {
template<> ::znbase::roachpb::AggregatorPush* Arena::CreateMaybeMessage<::znbase::roachpb::AggregatorPush>(Arena*);
template<> ::znbase::roachpb::AggregatorPush_Aggregation* Arena::CreateMaybeMessage<::znbase::roachpb::AggregatorPush_Aggregation>(Arena*);
template<> ::znbase::roachpb::BaseFilter* Arena::CreateMaybeMessage<::znbase::roachpb::BaseFilter>(Arena*);
template<> ::znbase::roachpb::ColumnMeta* Arena::CreateMaybeMessage<::znbase::roachpb::ColumnMeta>(Arena*);
template<> ::znbase::roachpb::FilterUnion* Arena::CreateMaybeMessage<::znbase::roachpb::FilterUnion>(Arena*);
template<> ::znbase::roachpb::LogicalFilter* Arena::CreateMaybeMessage<::znbase::roachpb::LogicalFilter>(Arena*);
template<> ::znbase::roachpb::PushDownExpr* Arena::CreateMaybeMessage<::znbase::roachpb::PushDownExpr>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace znbase {
namespace roachpb {

enum ColumnMeta_Type {
  ColumnMeta_Type_BOOL = 0,
  ColumnMeta_Type_INT = 1,
  ColumnMeta_Type_FLOAT = 2,
  ColumnMeta_Type_DECIMAL = 3,
  ColumnMeta_Type_DATE = 4,
  ColumnMeta_Type_TIMESTAMP = 5,
  ColumnMeta_Type_INTERVAL = 6,
  ColumnMeta_Type_STRING = 7,
  ColumnMeta_Type_BYTES = 8,
  ColumnMeta_Type_TIMESTAMPTZ = 9,
  ColumnMeta_Type_COLLATEDSTRING = 10,
  ColumnMeta_Type_NAME = 11,
  ColumnMeta_Type_OID = 12,
  ColumnMeta_Type_NULL_T = 13,
  ColumnMeta_Type_UUID = 14,
  ColumnMeta_Type_ARRAY = 15,
  ColumnMeta_Type_INET = 16,
  ColumnMeta_Type_TIME = 17,
  ColumnMeta_Type_JSONB = 18,
  ColumnMeta_Type_TIMETZ = 19,
  ColumnMeta_Type_TUPLE = 20,
  ColumnMeta_Type_BIT = 21,
  ColumnMeta_Type_INT2VECTOR = 200,
  ColumnMeta_Type_OIDVECTOR = 201
};
bool ColumnMeta_Type_IsValid(int value);
const ColumnMeta_Type ColumnMeta_Type_Type_MIN = ColumnMeta_Type_BOOL;
const ColumnMeta_Type ColumnMeta_Type_Type_MAX = ColumnMeta_Type_OIDVECTOR;
const int ColumnMeta_Type_Type_ARRAYSIZE = ColumnMeta_Type_Type_MAX + 1;

enum AggregatorPush_Func {
  AggregatorPush_Func_ANY_NOT_NULL = 0,
  AggregatorPush_Func_AVG = 1,
  AggregatorPush_Func_BOOL_AND = 2,
  AggregatorPush_Func_BOOL_OR = 3,
  AggregatorPush_Func_CONCAT_AGG = 4,
  AggregatorPush_Func_COUNT = 5,
  AggregatorPush_Func_MAX = 7,
  AggregatorPush_Func_MIN = 8,
  AggregatorPush_Func_STDDEV = 9,
  AggregatorPush_Func_SUM = 10,
  AggregatorPush_Func_SUM_INT = 11,
  AggregatorPush_Func_VARIANCE = 12,
  AggregatorPush_Func_XOR_AGG = 13,
  AggregatorPush_Func_COUNT_ROWS = 14,
  AggregatorPush_Func_SQRDIFF = 15,
  AggregatorPush_Func_FINAL_VARIANCE = 16,
  AggregatorPush_Func_FINAL_STDDEV = 17,
  AggregatorPush_Func_ARRAY_AGG = 18,
  AggregatorPush_Func_JSON_AGG = 19,
  AggregatorPush_Func_JSONB_AGG = 20,
  AggregatorPush_Func_STRING_AGG = 21,
  AggregatorPush_Func_MEDIAN = 22,
  AggregatorPush_Func_GROUP_CONCAT = 23,
  AggregatorPush_Func_LISTAGG = 24,
  AggregatorPush_Func_COUNT_PD = 25
};
bool AggregatorPush_Func_IsValid(int value);
const AggregatorPush_Func AggregatorPush_Func_Func_MIN = AggregatorPush_Func_ANY_NOT_NULL;
const AggregatorPush_Func AggregatorPush_Func_Func_MAX = AggregatorPush_Func_COUNT_PD;
const int AggregatorPush_Func_Func_ARRAYSIZE = AggregatorPush_Func_Func_MAX + 1;

enum AggregatorPush_Type {
  AggregatorPush_Type_AUTO = 0,
  AggregatorPush_Type_SCALAR = 1,
  AggregatorPush_Type_NON_SCALAR = 2
};
bool AggregatorPush_Type_IsValid(int value);
const AggregatorPush_Type AggregatorPush_Type_Type_MIN = AggregatorPush_Type_AUTO;
const AggregatorPush_Type AggregatorPush_Type_Type_MAX = AggregatorPush_Type_NON_SCALAR;
const int AggregatorPush_Type_Type_ARRAYSIZE = AggregatorPush_Type_Type_MAX + 1;

enum FilterType {
  AlwaysTrue = 0,
  AlwaysFalse = 1,
  IsNotNull = 2,
  IsNull = 3,
  Equal = 4,
  EqualNullSafe = 5,
  Greater = 6,
  GreaterOrEqual = 7,
  Less = 8,
  LessOrEqual = 9,
  In = 10,
  StringContains = 11,
  StringEnds = 12,
  StringStarts = 13,
  Not = 14,
  Or = 15,
  And = 16,
  Expression = 20
};
bool FilterType_IsValid(int value);
const FilterType FilterType_MIN = AlwaysTrue;
const FilterType FilterType_MAX = Expression;
const int FilterType_ARRAYSIZE = FilterType_MAX + 1;

// ===================================================================

class ColumnMeta : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.ColumnMeta) */ {
 public:
  ColumnMeta();
  virtual ~ColumnMeta();

  ColumnMeta(const ColumnMeta& from);

  inline ColumnMeta& operator=(const ColumnMeta& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ColumnMeta(ColumnMeta&& from) noexcept
    : ColumnMeta() {
    *this = ::std::move(from);
  }

  inline ColumnMeta& operator=(ColumnMeta&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ColumnMeta& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ColumnMeta* internal_default_instance() {
    return reinterpret_cast<const ColumnMeta*>(
               &_ColumnMeta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ColumnMeta* other);
  friend void swap(ColumnMeta& a, ColumnMeta& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ColumnMeta* New() const final {
    return CreateMaybeMessage<ColumnMeta>(NULL);
  }

  ColumnMeta* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ColumnMeta>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ColumnMeta& from);
  void MergeFrom(const ColumnMeta& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ColumnMeta* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ColumnMeta_Type Type;
  static const Type BOOL =
    ColumnMeta_Type_BOOL;
  static const Type INT =
    ColumnMeta_Type_INT;
  static const Type FLOAT =
    ColumnMeta_Type_FLOAT;
  static const Type DECIMAL =
    ColumnMeta_Type_DECIMAL;
  static const Type DATE =
    ColumnMeta_Type_DATE;
  static const Type TIMESTAMP =
    ColumnMeta_Type_TIMESTAMP;
  static const Type INTERVAL =
    ColumnMeta_Type_INTERVAL;
  static const Type STRING =
    ColumnMeta_Type_STRING;
  static const Type BYTES =
    ColumnMeta_Type_BYTES;
  static const Type TIMESTAMPTZ =
    ColumnMeta_Type_TIMESTAMPTZ;
  static const Type COLLATEDSTRING =
    ColumnMeta_Type_COLLATEDSTRING;
  static const Type NAME =
    ColumnMeta_Type_NAME;
  static const Type OID =
    ColumnMeta_Type_OID;
  static const Type NULL_T =
    ColumnMeta_Type_NULL_T;
  static const Type UUID =
    ColumnMeta_Type_UUID;
  static const Type ARRAY =
    ColumnMeta_Type_ARRAY;
  static const Type INET =
    ColumnMeta_Type_INET;
  static const Type TIME =
    ColumnMeta_Type_TIME;
  static const Type JSONB =
    ColumnMeta_Type_JSONB;
  static const Type TIMETZ =
    ColumnMeta_Type_TIMETZ;
  static const Type TUPLE =
    ColumnMeta_Type_TUPLE;
  static const Type BIT =
    ColumnMeta_Type_BIT;
  static const Type INT2VECTOR =
    ColumnMeta_Type_INT2VECTOR;
  static const Type OIDVECTOR =
    ColumnMeta_Type_OIDVECTOR;
  static inline bool Type_IsValid(int value) {
    return ColumnMeta_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ColumnMeta_Type_Type_MIN;
  static const Type Type_MAX =
    ColumnMeta_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ColumnMeta_Type_Type_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:znbase.roachpb.ColumnMeta)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fpushdown_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BaseFilter : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.BaseFilter) */ {
 public:
  BaseFilter();
  virtual ~BaseFilter();

  BaseFilter(const BaseFilter& from);

  inline BaseFilter& operator=(const BaseFilter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BaseFilter(BaseFilter&& from) noexcept
    : BaseFilter() {
    *this = ::std::move(from);
  }

  inline BaseFilter& operator=(BaseFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const BaseFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BaseFilter* internal_default_instance() {
    return reinterpret_cast<const BaseFilter*>(
               &_BaseFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(BaseFilter* other);
  friend void swap(BaseFilter& a, BaseFilter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BaseFilter* New() const final {
    return CreateMaybeMessage<BaseFilter>(NULL);
  }

  BaseFilter* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BaseFilter>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const BaseFilter& from);
  void MergeFrom(const BaseFilter& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BaseFilter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 4;
  const ::std::string& values(int index) const;
  ::std::string* mutable_values(int index);
  void set_values(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_values(int index, ::std::string&& value);
  #endif
  void set_values(int index, const char* value);
  void set_values(int index, const char* value, size_t size);
  ::std::string* add_values();
  void add_values(const ::std::string& value);
  #if LANG_CXX11
  void add_values(::std::string&& value);
  #endif
  void add_values(const char* value);
  void add_values(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& values() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_values();

  bool has_attribute() const;
  void clear_attribute();
  static const int kAttributeFieldNumber = 2;
  const ::std::string& attribute() const;
  void set_attribute(const ::std::string& value);
  #if LANG_CXX11
  void set_attribute(::std::string&& value);
  #endif
  void set_attribute(const char* value);
  void set_attribute(const char* value, size_t size);
  ::std::string* mutable_attribute();
  ::std::string* release_attribute();
  void set_allocated_attribute(::std::string* attribute);

  // optional string value = 3;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.BaseFilter)
 private:
  void set_has_attribute();
  void clear_has_attribute();
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> values_;
  ::google::protobuf::internal::ArenaStringPtr attribute_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend struct ::protobuf_roachpb_2fpushdown_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LogicalFilter : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.LogicalFilter) */ {
 public:
  LogicalFilter();
  virtual ~LogicalFilter();

  LogicalFilter(const LogicalFilter& from);

  inline LogicalFilter& operator=(const LogicalFilter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LogicalFilter(LogicalFilter&& from) noexcept
    : LogicalFilter() {
    *this = ::std::move(from);
  }

  inline LogicalFilter& operator=(LogicalFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const LogicalFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogicalFilter* internal_default_instance() {
    return reinterpret_cast<const LogicalFilter*>(
               &_LogicalFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(LogicalFilter* other);
  friend void swap(LogicalFilter& a, LogicalFilter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LogicalFilter* New() const final {
    return CreateMaybeMessage<LogicalFilter>(NULL);
  }

  LogicalFilter* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LogicalFilter>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const LogicalFilter& from);
  void MergeFrom(const LogicalFilter& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LogicalFilter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_left() const;
  void clear_left();
  static const int kLeftFieldNumber = 2;
  private:
  const ::znbase::roachpb::FilterUnion& _internal_left() const;
  public:
  const ::znbase::roachpb::FilterUnion& left() const;
  ::znbase::roachpb::FilterUnion* release_left();
  ::znbase::roachpb::FilterUnion* mutable_left();
  void set_allocated_left(::znbase::roachpb::FilterUnion* left);

  // optional .znbase.roachpb.FilterUnion right = 3;
  bool has_right() const;
  void clear_right();
  static const int kRightFieldNumber = 3;
  private:
  const ::znbase::roachpb::FilterUnion& _internal_right() const;
  public:
  const ::znbase::roachpb::FilterUnion& right() const;
  ::znbase::roachpb::FilterUnion* release_right();
  ::znbase::roachpb::FilterUnion* mutable_right();
  void set_allocated_right(::znbase::roachpb::FilterUnion* right);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.LogicalFilter)
 private:
  void set_has_left();
  void clear_has_left();
  void set_has_right();
  void clear_has_right();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::znbase::roachpb::FilterUnion* left_;
  ::znbase::roachpb::FilterUnion* right_;
  friend struct ::protobuf_roachpb_2fpushdown_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FilterUnion : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.FilterUnion) */ {
 public:
  FilterUnion();
  virtual ~FilterUnion();

  FilterUnion(const FilterUnion& from);

  inline FilterUnion& operator=(const FilterUnion& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FilterUnion(FilterUnion&& from) noexcept
    : FilterUnion() {
    *this = ::std::move(from);
  }

  inline FilterUnion& operator=(FilterUnion&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const FilterUnion& default_instance();

  enum ValueCase {
    kBase = 2,
    kLogical = 3,
    kExpression = 4,
    VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FilterUnion* internal_default_instance() {
    return reinterpret_cast<const FilterUnion*>(
               &_FilterUnion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(FilterUnion* other);
  friend void swap(FilterUnion& a, FilterUnion& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FilterUnion* New() const final {
    return CreateMaybeMessage<FilterUnion>(NULL);
  }

  FilterUnion* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FilterUnion>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const FilterUnion& from);
  void MergeFrom(const FilterUnion& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FilterUnion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::znbase::roachpb::FilterType type() const;
  void set_type(::znbase::roachpb::FilterType value);

  // optional .znbase.roachpb.BaseFilter base = 2;
  bool has_base() const;
  void clear_base();
  static const int kBaseFieldNumber = 2;
  private:
  const ::znbase::roachpb::BaseFilter& _internal_base() const;
  public:
  const ::znbase::roachpb::BaseFilter& base() const;
  ::znbase::roachpb::BaseFilter* release_base();
  ::znbase::roachpb::BaseFilter* mutable_base();
  void set_allocated_base(::znbase::roachpb::BaseFilter* base);

  // optional .znbase.roachpb.LogicalFilter logical = 3;
  bool has_logical() const;
  void clear_logical();
  static const int kLogicalFieldNumber = 3;
  private:
  const ::znbase::roachpb::LogicalFilter& _internal_logical() const;
  public:
  const ::znbase::roachpb::LogicalFilter& logical() const;
  ::znbase::roachpb::LogicalFilter* release_logical();
  ::znbase::roachpb::LogicalFilter* mutable_logical();
  void set_allocated_logical(::znbase::roachpb::LogicalFilter* logical);

  // optional string expression = 4;
  bool has_expression() const;
  void clear_expression();
  static const int kExpressionFieldNumber = 4;
  const ::std::string& expression() const;
  void set_expression(const ::std::string& value);
  #if LANG_CXX11
  void set_expression(::std::string&& value);
  #endif
  void set_expression(const char* value);
  void set_expression(const char* value, size_t size);
  ::std::string* mutable_expression();
  ::std::string* release_expression();
  void set_allocated_expression(::std::string* expression);

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:znbase.roachpb.FilterUnion)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_base();
  void set_has_logical();
  void set_has_expression();

  inline bool has_value() const;
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int type_;
  union ValueUnion {
    ValueUnion() {}
    ::znbase::roachpb::BaseFilter* base_;
    ::znbase::roachpb::LogicalFilter* logical_;
    ::google::protobuf::internal::ArenaStringPtr expression_;
  } value_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_roachpb_2fpushdown_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AggregatorPush_Aggregation : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.AggregatorPush.Aggregation) */ {
 public:
  AggregatorPush_Aggregation();
  virtual ~AggregatorPush_Aggregation();

  AggregatorPush_Aggregation(const AggregatorPush_Aggregation& from);

  inline AggregatorPush_Aggregation& operator=(const AggregatorPush_Aggregation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AggregatorPush_Aggregation(AggregatorPush_Aggregation&& from) noexcept
    : AggregatorPush_Aggregation() {
    *this = ::std::move(from);
  }

  inline AggregatorPush_Aggregation& operator=(AggregatorPush_Aggregation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const AggregatorPush_Aggregation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AggregatorPush_Aggregation* internal_default_instance() {
    return reinterpret_cast<const AggregatorPush_Aggregation*>(
               &_AggregatorPush_Aggregation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(AggregatorPush_Aggregation* other);
  friend void swap(AggregatorPush_Aggregation& a, AggregatorPush_Aggregation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AggregatorPush_Aggregation* New() const final {
    return CreateMaybeMessage<AggregatorPush_Aggregation>(NULL);
  }

  AggregatorPush_Aggregation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AggregatorPush_Aggregation>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const AggregatorPush_Aggregation& from);
  void MergeFrom(const AggregatorPush_Aggregation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AggregatorPush_Aggregation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 col_idx = 5;
  int col_idx_size() const;
  void clear_col_idx();
  static const int kColIdxFieldNumber = 5;
  ::google::protobuf::uint32 col_idx(int index) const;
  void set_col_idx(int index, ::google::protobuf::uint32 value);
  void add_col_idx(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      col_idx() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_col_idx();

  // repeated string arguments = 6;
  int arguments_size() const;
  void clear_arguments();
  static const int kArgumentsFieldNumber = 6;
  const ::std::string& arguments(int index) const;
  ::std::string* mutable_arguments(int index);
  void set_arguments(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_arguments(int index, ::std::string&& value);
  #endif
  void set_arguments(int index, const char* value);
  void set_arguments(int index, const char* value, size_t size);
  ::std::string* add_arguments();
  void add_arguments(const ::std::string& value);
  #if LANG_CXX11
  void add_arguments(::std::string&& value);
  #endif
  void add_arguments(const char* value);
  void add_arguments(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& arguments() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_arguments();

  // optional string render_expr = 9;
  bool has_render_expr() const;
  void clear_render_expr();
  static const int kRenderExprFieldNumber = 9;
  const ::std::string& render_expr() const;
  void set_render_expr(const ::std::string& value);
  #if LANG_CXX11
  void set_render_expr(::std::string&& value);
  #endif
  void set_render_expr(const char* value);
  void set_render_expr(const char* value, size_t size);
  ::std::string* mutable_render_expr();
  ::std::string* release_render_expr();
  void set_allocated_render_expr(::std::string* render_expr);

  bool has_func() const;
  void clear_func();
  static const int kFuncFieldNumber = 1;
  ::znbase::roachpb::AggregatorPush_Func func() const;
  void set_func(::znbase::roachpb::AggregatorPush_Func value);

  // optional uint32 filter_col_idx = 4;
  bool has_filter_col_idx() const;
  void clear_filter_col_idx();
  static const int kFilterColIdxFieldNumber = 4;
  ::google::protobuf::uint32 filter_col_idx() const;
  void set_filter_col_idx(::google::protobuf::uint32 value);

  bool has_distinct() const;
  void clear_distinct();
  static const int kDistinctFieldNumber = 2;
  bool distinct() const;
  void set_distinct(bool value);

  // required bool push_down_to_store = 7;
  bool has_push_down_to_store() const;
  void clear_push_down_to_store();
  static const int kPushDownToStoreFieldNumber = 7;
  bool push_down_to_store() const;
  void set_push_down_to_store(bool value);

  // required .znbase.roachpb.ColumnMeta.Type result_type = 8;
  bool has_result_type() const;
  void clear_result_type();
  static const int kResultTypeFieldNumber = 8;
  ::znbase::roachpb::ColumnMeta_Type result_type() const;
  void set_result_type(::znbase::roachpb::ColumnMeta_Type value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.AggregatorPush.Aggregation)
 private:
  void set_has_func();
  void clear_has_func();
  void set_has_distinct();
  void clear_has_distinct();
  void set_has_filter_col_idx();
  void clear_has_filter_col_idx();
  void set_has_push_down_to_store();
  void clear_has_push_down_to_store();
  void set_has_result_type();
  void clear_has_result_type();
  void set_has_render_expr();
  void clear_has_render_expr();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > col_idx_;
  ::google::protobuf::RepeatedPtrField< ::std::string> arguments_;
  ::google::protobuf::internal::ArenaStringPtr render_expr_;
  int func_;
  ::google::protobuf::uint32 filter_col_idx_;
  bool distinct_;
  bool push_down_to_store_;
  int result_type_;
  friend struct ::protobuf_roachpb_2fpushdown_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AggregatorPush : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.AggregatorPush) */ {
 public:
  AggregatorPush();
  virtual ~AggregatorPush();

  AggregatorPush(const AggregatorPush& from);

  inline AggregatorPush& operator=(const AggregatorPush& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AggregatorPush(AggregatorPush&& from) noexcept
    : AggregatorPush() {
    *this = ::std::move(from);
  }

  inline AggregatorPush& operator=(AggregatorPush&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const AggregatorPush& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AggregatorPush* internal_default_instance() {
    return reinterpret_cast<const AggregatorPush*>(
               &_AggregatorPush_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(AggregatorPush* other);
  friend void swap(AggregatorPush& a, AggregatorPush& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AggregatorPush* New() const final {
    return CreateMaybeMessage<AggregatorPush>(NULL);
  }

  AggregatorPush* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AggregatorPush>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const AggregatorPush& from);
  void MergeFrom(const AggregatorPush& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AggregatorPush* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AggregatorPush_Aggregation Aggregation;

  typedef AggregatorPush_Func Func;
  static const Func ANY_NOT_NULL =
    AggregatorPush_Func_ANY_NOT_NULL;
  static const Func AVG =
    AggregatorPush_Func_AVG;
  static const Func BOOL_AND =
    AggregatorPush_Func_BOOL_AND;
  static const Func BOOL_OR =
    AggregatorPush_Func_BOOL_OR;
  static const Func CONCAT_AGG =
    AggregatorPush_Func_CONCAT_AGG;
  static const Func COUNT =
    AggregatorPush_Func_COUNT;
  static const Func MAX =
    AggregatorPush_Func_MAX;
  static const Func MIN =
    AggregatorPush_Func_MIN;
  static const Func STDDEV =
    AggregatorPush_Func_STDDEV;
  static const Func SUM =
    AggregatorPush_Func_SUM;
  static const Func SUM_INT =
    AggregatorPush_Func_SUM_INT;
  static const Func VARIANCE =
    AggregatorPush_Func_VARIANCE;
  static const Func XOR_AGG =
    AggregatorPush_Func_XOR_AGG;
  static const Func COUNT_ROWS =
    AggregatorPush_Func_COUNT_ROWS;
  static const Func SQRDIFF =
    AggregatorPush_Func_SQRDIFF;
  static const Func FINAL_VARIANCE =
    AggregatorPush_Func_FINAL_VARIANCE;
  static const Func FINAL_STDDEV =
    AggregatorPush_Func_FINAL_STDDEV;
  static const Func ARRAY_AGG =
    AggregatorPush_Func_ARRAY_AGG;
  static const Func JSON_AGG =
    AggregatorPush_Func_JSON_AGG;
  static const Func JSONB_AGG =
    AggregatorPush_Func_JSONB_AGG;
  static const Func STRING_AGG =
    AggregatorPush_Func_STRING_AGG;
  static const Func MEDIAN =
    AggregatorPush_Func_MEDIAN;
  static const Func GROUP_CONCAT =
    AggregatorPush_Func_GROUP_CONCAT;
  static const Func LISTAGG =
    AggregatorPush_Func_LISTAGG;
  static const Func COUNT_PD =
    AggregatorPush_Func_COUNT_PD;
  static inline bool Func_IsValid(int value) {
    return AggregatorPush_Func_IsValid(value);
  }
  static const Func Func_MIN =
    AggregatorPush_Func_Func_MIN;
  static const Func Func_MAX =
    AggregatorPush_Func_Func_MAX;
  static const int Func_ARRAYSIZE =
    AggregatorPush_Func_Func_ARRAYSIZE;

  typedef AggregatorPush_Type Type;
  static const Type AUTO =
    AggregatorPush_Type_AUTO;
  static const Type SCALAR =
    AggregatorPush_Type_SCALAR;
  static const Type NON_SCALAR =
    AggregatorPush_Type_NON_SCALAR;
  static inline bool Type_IsValid(int value) {
    return AggregatorPush_Type_IsValid(value);
  }
  static const Type Type_MIN =
    AggregatorPush_Type_Type_MIN;
  static const Type Type_MAX =
    AggregatorPush_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    AggregatorPush_Type_Type_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated uint32 group_cols = 2 [packed = true];
  int group_cols_size() const;
  void clear_group_cols();
  static const int kGroupColsFieldNumber = 2;
  ::google::protobuf::uint32 group_cols(int index) const;
  void set_group_cols(int index, ::google::protobuf::uint32 value);
  void add_group_cols(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      group_cols() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_group_cols();

  int aggregations_size() const;
  void clear_aggregations();
  static const int kAggregationsFieldNumber = 3;
  ::znbase::roachpb::AggregatorPush_Aggregation* mutable_aggregations(int index);
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::AggregatorPush_Aggregation >*
      mutable_aggregations();
  const ::znbase::roachpb::AggregatorPush_Aggregation& aggregations(int index) const;
  ::znbase::roachpb::AggregatorPush_Aggregation* add_aggregations();
  const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::AggregatorPush_Aggregation >&
      aggregations() const;

  // repeated uint32 ordered_group_cols = 4 [packed = true];
  int ordered_group_cols_size() const;
  void clear_ordered_group_cols();
  static const int kOrderedGroupColsFieldNumber = 4;
  ::google::protobuf::uint32 ordered_group_cols(int index) const;
  void set_ordered_group_cols(int index, ::google::protobuf::uint32 value);
  void add_ordered_group_cols(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      ordered_group_cols() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_ordered_group_cols();

  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 5;
  ::znbase::roachpb::AggregatorPush_Type type() const;
  void set_type(::znbase::roachpb::AggregatorPush_Type value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.AggregatorPush)
 private:
  void set_has_type();
  void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > group_cols_;
  mutable int _group_cols_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::AggregatorPush_Aggregation > aggregations_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > ordered_group_cols_;
  mutable int _ordered_group_cols_cached_byte_size_;
  int type_;
  friend struct ::protobuf_roachpb_2fpushdown_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PushDownExpr : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.PushDownExpr) */ {
 public:
  PushDownExpr();
  virtual ~PushDownExpr();

  PushDownExpr(const PushDownExpr& from);

  inline PushDownExpr& operator=(const PushDownExpr& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PushDownExpr(PushDownExpr&& from) noexcept
    : PushDownExpr() {
    *this = ::std::move(from);
  }

  inline PushDownExpr& operator=(PushDownExpr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const PushDownExpr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PushDownExpr* internal_default_instance() {
    return reinterpret_cast<const PushDownExpr*>(
               &_PushDownExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(PushDownExpr* other);
  friend void swap(PushDownExpr& a, PushDownExpr& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PushDownExpr* New() const final {
    return CreateMaybeMessage<PushDownExpr>(NULL);
  }

  PushDownExpr* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PushDownExpr>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const PushDownExpr& from);
  void MergeFrom(const PushDownExpr& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PushDownExpr* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 col_ids = 1;
  int col_ids_size() const;
  void clear_col_ids();
  static const int kColIdsFieldNumber = 1;
  ::google::protobuf::int32 col_ids(int index) const;
  void set_col_ids(int index, ::google::protobuf::int32 value);
  void add_col_ids(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      col_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_col_ids();

  // repeated .znbase.roachpb.ColumnMeta.Type col_types = 2;
  int col_types_size() const;
  void clear_col_types();
  static const int kColTypesFieldNumber = 2;
  ::znbase::roachpb::ColumnMeta_Type col_types(int index) const;
  void set_col_types(int index, ::znbase::roachpb::ColumnMeta_Type value);
  void add_col_types(::znbase::roachpb::ColumnMeta_Type value);
  const ::google::protobuf::RepeatedField<int>& col_types() const;
  ::google::protobuf::RepeatedField<int>* mutable_col_types();

  // repeated int32 primary_cols = 3;
  int primary_cols_size() const;
  void clear_primary_cols();
  static const int kPrimaryColsFieldNumber = 3;
  ::google::protobuf::int32 primary_cols(int index) const;
  void set_primary_cols(int index, ::google::protobuf::int32 value);
  void add_primary_cols(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      primary_cols() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_primary_cols();

  // repeated int32 primary_cols_direct = 4;
  int primary_cols_direct_size() const;
  void clear_primary_cols_direct();
  static const int kPrimaryColsDirectFieldNumber = 4;
  ::google::protobuf::int32 primary_cols_direct(int index) const;
  void set_primary_cols_direct(int index, ::google::protobuf::int32 value);
  void add_primary_cols_direct(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      primary_cols_direct() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_primary_cols_direct();

  // repeated int32 secondary_cols = 5;
  int secondary_cols_size() const;
  void clear_secondary_cols();
  static const int kSecondaryColsFieldNumber = 5;
  ::google::protobuf::int32 secondary_cols(int index) const;
  void set_secondary_cols(int index, ::google::protobuf::int32 value);
  void add_secondary_cols(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      secondary_cols() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_secondary_cols();

  // repeated int32 orderby_cols = 6 [packed = true];
  int orderby_cols_size() const;
  void clear_orderby_cols();
  static const int kOrderbyColsFieldNumber = 6;
  ::google::protobuf::int32 orderby_cols(int index) const;
  void set_orderby_cols(int index, ::google::protobuf::int32 value);
  void add_orderby_cols(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      orderby_cols() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_orderby_cols();

  // repeated int32 order_directions = 7 [packed = true];
  int order_directions_size() const;
  void clear_order_directions();
  static const int kOrderDirectionsFieldNumber = 7;
  ::google::protobuf::int32 order_directions(int index) const;
  void set_order_directions(int index, ::google::protobuf::int32 value);
  void add_order_directions(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      order_directions() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_order_directions();

  // repeated int32 required_cols = 8;
  int required_cols_size() const;
  void clear_required_cols();
  static const int kRequiredColsFieldNumber = 8;
  ::google::protobuf::int32 required_cols(int index) const;
  void set_required_cols(int index, ::google::protobuf::int32 value);
  void add_required_cols(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      required_cols() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_required_cols();

  // repeated .znbase.roachpb.FilterUnion filters = 9;
  int filters_size() const;
  void clear_filters();
  static const int kFiltersFieldNumber = 9;
  ::znbase::roachpb::FilterUnion* mutable_filters(int index);
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::FilterUnion >*
      mutable_filters();
  const ::znbase::roachpb::FilterUnion& filters(int index) const;
  ::znbase::roachpb::FilterUnion* add_filters();
  const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::FilterUnion >&
      filters() const;

  // optional .znbase.roachpb.AggregatorPush aggregator = 10;
  bool has_aggregator() const;
  void clear_aggregator();
  static const int kAggregatorFieldNumber = 10;
  private:
  const ::znbase::roachpb::AggregatorPush& _internal_aggregator() const;
  public:
  const ::znbase::roachpb::AggregatorPush& aggregator() const;
  ::znbase::roachpb::AggregatorPush* release_aggregator();
  ::znbase::roachpb::AggregatorPush* mutable_aggregator();
  void set_allocated_aggregator(::znbase::roachpb::AggregatorPush* aggregator);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.PushDownExpr)
 private:
  void set_has_aggregator();
  void clear_has_aggregator();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > col_ids_;
  ::google::protobuf::RepeatedField<int> col_types_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > primary_cols_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > primary_cols_direct_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > secondary_cols_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > orderby_cols_;
  mutable int _orderby_cols_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > order_directions_;
  mutable int _order_directions_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > required_cols_;
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::FilterUnion > filters_;
  ::znbase::roachpb::AggregatorPush* aggregator_;
  friend struct ::protobuf_roachpb_2fpushdown_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ColumnMeta

// -------------------------------------------------------------------

// BaseFilter

inline bool BaseFilter::has_attribute() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BaseFilter::set_has_attribute() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BaseFilter::clear_has_attribute() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BaseFilter::clear_attribute() {
  attribute_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_attribute();
}
inline const ::std::string& BaseFilter::attribute() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.BaseFilter.attribute)
  return attribute_.GetNoArena();
}
inline void BaseFilter::set_attribute(const ::std::string& value) {
  set_has_attribute();
  attribute_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.BaseFilter.attribute)
}
#if LANG_CXX11
inline void BaseFilter::set_attribute(::std::string&& value) {
  set_has_attribute();
  attribute_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.BaseFilter.attribute)
}
#endif
inline void BaseFilter::set_attribute(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_attribute();
  attribute_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.BaseFilter.attribute)
}
inline void BaseFilter::set_attribute(const char* value, size_t size) {
  set_has_attribute();
  attribute_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.BaseFilter.attribute)
}
inline ::std::string* BaseFilter::mutable_attribute() {
  set_has_attribute();
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.BaseFilter.attribute)
  return attribute_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BaseFilter::release_attribute() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.BaseFilter.attribute)
  if (!has_attribute()) {
    return NULL;
  }
  clear_has_attribute();
  return attribute_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BaseFilter::set_allocated_attribute(::std::string* attribute) {
  if (attribute != NULL) {
    set_has_attribute();
  } else {
    clear_has_attribute();
  }
  attribute_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), attribute);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.BaseFilter.attribute)
}

// optional string value = 3;
inline bool BaseFilter::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BaseFilter::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BaseFilter::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BaseFilter::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& BaseFilter::value() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.BaseFilter.value)
  return value_.GetNoArena();
}
inline void BaseFilter::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.BaseFilter.value)
}
#if LANG_CXX11
inline void BaseFilter::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.BaseFilter.value)
}
#endif
inline void BaseFilter::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.BaseFilter.value)
}
inline void BaseFilter::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.BaseFilter.value)
}
inline ::std::string* BaseFilter::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.BaseFilter.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BaseFilter::release_value() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.BaseFilter.value)
  if (!has_value()) {
    return NULL;
  }
  clear_has_value();
  return value_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BaseFilter::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.BaseFilter.value)
}

inline int BaseFilter::values_size() const {
  return values_.size();
}
inline void BaseFilter::clear_values() {
  values_.Clear();
}
inline const ::std::string& BaseFilter::values(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.BaseFilter.values)
  return values_.Get(index);
}
inline ::std::string* BaseFilter::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.BaseFilter.values)
  return values_.Mutable(index);
}
inline void BaseFilter::set_values(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:znbase.roachpb.BaseFilter.values)
  values_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void BaseFilter::set_values(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:znbase.roachpb.BaseFilter.values)
  values_.Mutable(index)->assign(std::move(value));
}
#endif
inline void BaseFilter::set_values(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.BaseFilter.values)
}
inline void BaseFilter::set_values(int index, const char* value, size_t size) {
  values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.BaseFilter.values)
}
inline ::std::string* BaseFilter::add_values() {
  // @@protoc_insertion_point(field_add_mutable:znbase.roachpb.BaseFilter.values)
  return values_.Add();
}
inline void BaseFilter::add_values(const ::std::string& value) {
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:znbase.roachpb.BaseFilter.values)
}
#if LANG_CXX11
inline void BaseFilter::add_values(::std::string&& value) {
  values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:znbase.roachpb.BaseFilter.values)
}
#endif
inline void BaseFilter::add_values(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:znbase.roachpb.BaseFilter.values)
}
inline void BaseFilter::add_values(const char* value, size_t size) {
  values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:znbase.roachpb.BaseFilter.values)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BaseFilter::values() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.BaseFilter.values)
  return values_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BaseFilter::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.BaseFilter.values)
  return &values_;
}

// -------------------------------------------------------------------

// LogicalFilter

inline bool LogicalFilter::has_left() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogicalFilter::set_has_left() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogicalFilter::clear_has_left() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogicalFilter::clear_left() {
  if (left_ != NULL) left_->Clear();
  clear_has_left();
}
inline const ::znbase::roachpb::FilterUnion& LogicalFilter::_internal_left() const {
  return *left_;
}
inline const ::znbase::roachpb::FilterUnion& LogicalFilter::left() const {
  const ::znbase::roachpb::FilterUnion* p = left_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.LogicalFilter.left)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::FilterUnion*>(
      &::znbase::roachpb::_FilterUnion_default_instance_);
}
inline ::znbase::roachpb::FilterUnion* LogicalFilter::release_left() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.LogicalFilter.left)
  clear_has_left();
  ::znbase::roachpb::FilterUnion* temp = left_;
  left_ = NULL;
  return temp;
}
inline ::znbase::roachpb::FilterUnion* LogicalFilter::mutable_left() {
  set_has_left();
  if (left_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::FilterUnion>(GetArenaNoVirtual());
    left_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.LogicalFilter.left)
  return left_;
}
inline void LogicalFilter::set_allocated_left(::znbase::roachpb::FilterUnion* left) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete left_;
  }
  if (left) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      left = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, left, submessage_arena);
    }
    set_has_left();
  } else {
    clear_has_left();
  }
  left_ = left;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.LogicalFilter.left)
}

// optional .znbase.roachpb.FilterUnion right = 3;
inline bool LogicalFilter::has_right() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogicalFilter::set_has_right() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogicalFilter::clear_has_right() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogicalFilter::clear_right() {
  if (right_ != NULL) right_->Clear();
  clear_has_right();
}
inline const ::znbase::roachpb::FilterUnion& LogicalFilter::_internal_right() const {
  return *right_;
}
inline const ::znbase::roachpb::FilterUnion& LogicalFilter::right() const {
  const ::znbase::roachpb::FilterUnion* p = right_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.LogicalFilter.right)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::FilterUnion*>(
      &::znbase::roachpb::_FilterUnion_default_instance_);
}
inline ::znbase::roachpb::FilterUnion* LogicalFilter::release_right() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.LogicalFilter.right)
  clear_has_right();
  ::znbase::roachpb::FilterUnion* temp = right_;
  right_ = NULL;
  return temp;
}
inline ::znbase::roachpb::FilterUnion* LogicalFilter::mutable_right() {
  set_has_right();
  if (right_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::FilterUnion>(GetArenaNoVirtual());
    right_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.LogicalFilter.right)
  return right_;
}
inline void LogicalFilter::set_allocated_right(::znbase::roachpb::FilterUnion* right) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete right_;
  }
  if (right) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      right = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, right, submessage_arena);
    }
    set_has_right();
  } else {
    clear_has_right();
  }
  right_ = right;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.LogicalFilter.right)
}

// -------------------------------------------------------------------

// FilterUnion

inline bool FilterUnion::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FilterUnion::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FilterUnion::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FilterUnion::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::znbase::roachpb::FilterType FilterUnion::type() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.FilterUnion.type)
  return static_cast< ::znbase::roachpb::FilterType >(type_);
}
inline void FilterUnion::set_type(::znbase::roachpb::FilterType value) {
  assert(::znbase::roachpb::FilterType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.FilterUnion.type)
}

// optional .znbase.roachpb.BaseFilter base = 2;
inline bool FilterUnion::has_base() const {
  return value_case() == kBase;
}
inline void FilterUnion::set_has_base() {
  _oneof_case_[0] = kBase;
}
inline void FilterUnion::clear_base() {
  if (has_base()) {
    delete value_.base_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::BaseFilter& FilterUnion::_internal_base() const {
  return *value_.base_;
}
inline ::znbase::roachpb::BaseFilter* FilterUnion::release_base() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.FilterUnion.base)
  if (has_base()) {
    clear_has_value();
      ::znbase::roachpb::BaseFilter* temp = value_.base_;
    value_.base_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::BaseFilter& FilterUnion::base() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.FilterUnion.base)
  return has_base()
      ? *value_.base_
      : *reinterpret_cast< ::znbase::roachpb::BaseFilter*>(&::znbase::roachpb::_BaseFilter_default_instance_);
}
inline ::znbase::roachpb::BaseFilter* FilterUnion::mutable_base() {
  if (!has_base()) {
    clear_value();
    set_has_base();
    value_.base_ = CreateMaybeMessage< ::znbase::roachpb::BaseFilter >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.FilterUnion.base)
  return value_.base_;
}

// optional .znbase.roachpb.LogicalFilter logical = 3;
inline bool FilterUnion::has_logical() const {
  return value_case() == kLogical;
}
inline void FilterUnion::set_has_logical() {
  _oneof_case_[0] = kLogical;
}
inline void FilterUnion::clear_logical() {
  if (has_logical()) {
    delete value_.logical_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::LogicalFilter& FilterUnion::_internal_logical() const {
  return *value_.logical_;
}
inline ::znbase::roachpb::LogicalFilter* FilterUnion::release_logical() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.FilterUnion.logical)
  if (has_logical()) {
    clear_has_value();
      ::znbase::roachpb::LogicalFilter* temp = value_.logical_;
    value_.logical_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::LogicalFilter& FilterUnion::logical() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.FilterUnion.logical)
  return has_logical()
      ? *value_.logical_
      : *reinterpret_cast< ::znbase::roachpb::LogicalFilter*>(&::znbase::roachpb::_LogicalFilter_default_instance_);
}
inline ::znbase::roachpb::LogicalFilter* FilterUnion::mutable_logical() {
  if (!has_logical()) {
    clear_value();
    set_has_logical();
    value_.logical_ = CreateMaybeMessage< ::znbase::roachpb::LogicalFilter >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.FilterUnion.logical)
  return value_.logical_;
}

// optional string expression = 4;
inline bool FilterUnion::has_expression() const {
  return value_case() == kExpression;
}
inline void FilterUnion::set_has_expression() {
  _oneof_case_[0] = kExpression;
}
inline void FilterUnion::clear_expression() {
  if (has_expression()) {
    value_.expression_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_value();
  }
}
inline const ::std::string& FilterUnion::expression() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.FilterUnion.expression)
  if (has_expression()) {
    return value_.expression_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void FilterUnion::set_expression(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:znbase.roachpb.FilterUnion.expression)
  if (!has_expression()) {
    clear_value();
    set_has_expression();
    value_.expression_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.expression_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.FilterUnion.expression)
}
#if LANG_CXX11
inline void FilterUnion::set_expression(::std::string&& value) {
  // @@protoc_insertion_point(field_set:znbase.roachpb.FilterUnion.expression)
  if (!has_expression()) {
    clear_value();
    set_has_expression();
    value_.expression_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.expression_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.FilterUnion.expression)
}
#endif
inline void FilterUnion::set_expression(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_expression()) {
    clear_value();
    set_has_expression();
    value_.expression_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.expression_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.FilterUnion.expression)
}
inline void FilterUnion::set_expression(const char* value, size_t size) {
  if (!has_expression()) {
    clear_value();
    set_has_expression();
    value_.expression_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.expression_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.FilterUnion.expression)
}
inline ::std::string* FilterUnion::mutable_expression() {
  if (!has_expression()) {
    clear_value();
    set_has_expression();
    value_.expression_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.FilterUnion.expression)
  return value_.expression_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FilterUnion::release_expression() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.FilterUnion.expression)
  if (has_expression()) {
    clear_has_value();
    return value_.expression_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void FilterUnion::set_allocated_expression(::std::string* expression) {
  if (!has_expression()) {
    value_.expression_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_value();
  if (expression != NULL) {
    set_has_expression();
    value_.expression_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), expression);
  }
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.FilterUnion.expression)
}

inline bool FilterUnion::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void FilterUnion::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline FilterUnion::ValueCase FilterUnion::value_case() const {
  return FilterUnion::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AggregatorPush_Aggregation

inline bool AggregatorPush_Aggregation::has_func() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AggregatorPush_Aggregation::set_has_func() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AggregatorPush_Aggregation::clear_has_func() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AggregatorPush_Aggregation::clear_func() {
  func_ = 0;
  clear_has_func();
}
inline ::znbase::roachpb::AggregatorPush_Func AggregatorPush_Aggregation::func() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.AggregatorPush.Aggregation.func)
  return static_cast< ::znbase::roachpb::AggregatorPush_Func >(func_);
}
inline void AggregatorPush_Aggregation::set_func(::znbase::roachpb::AggregatorPush_Func value) {
  assert(::znbase::roachpb::AggregatorPush_Func_IsValid(value));
  set_has_func();
  func_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.AggregatorPush.Aggregation.func)
}

inline bool AggregatorPush_Aggregation::has_distinct() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AggregatorPush_Aggregation::set_has_distinct() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AggregatorPush_Aggregation::clear_has_distinct() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AggregatorPush_Aggregation::clear_distinct() {
  distinct_ = false;
  clear_has_distinct();
}
inline bool AggregatorPush_Aggregation::distinct() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.AggregatorPush.Aggregation.distinct)
  return distinct_;
}
inline void AggregatorPush_Aggregation::set_distinct(bool value) {
  set_has_distinct();
  distinct_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.AggregatorPush.Aggregation.distinct)
}

// repeated uint32 col_idx = 5;
inline int AggregatorPush_Aggregation::col_idx_size() const {
  return col_idx_.size();
}
inline void AggregatorPush_Aggregation::clear_col_idx() {
  col_idx_.Clear();
}
inline ::google::protobuf::uint32 AggregatorPush_Aggregation::col_idx(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.AggregatorPush.Aggregation.col_idx)
  return col_idx_.Get(index);
}
inline void AggregatorPush_Aggregation::set_col_idx(int index, ::google::protobuf::uint32 value) {
  col_idx_.Set(index, value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.AggregatorPush.Aggregation.col_idx)
}
inline void AggregatorPush_Aggregation::add_col_idx(::google::protobuf::uint32 value) {
  col_idx_.Add(value);
  // @@protoc_insertion_point(field_add:znbase.roachpb.AggregatorPush.Aggregation.col_idx)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
AggregatorPush_Aggregation::col_idx() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.AggregatorPush.Aggregation.col_idx)
  return col_idx_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
AggregatorPush_Aggregation::mutable_col_idx() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.AggregatorPush.Aggregation.col_idx)
  return &col_idx_;
}

// optional uint32 filter_col_idx = 4;
inline bool AggregatorPush_Aggregation::has_filter_col_idx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AggregatorPush_Aggregation::set_has_filter_col_idx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AggregatorPush_Aggregation::clear_has_filter_col_idx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AggregatorPush_Aggregation::clear_filter_col_idx() {
  filter_col_idx_ = 0u;
  clear_has_filter_col_idx();
}
inline ::google::protobuf::uint32 AggregatorPush_Aggregation::filter_col_idx() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.AggregatorPush.Aggregation.filter_col_idx)
  return filter_col_idx_;
}
inline void AggregatorPush_Aggregation::set_filter_col_idx(::google::protobuf::uint32 value) {
  set_has_filter_col_idx();
  filter_col_idx_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.AggregatorPush.Aggregation.filter_col_idx)
}

// repeated string arguments = 6;
inline int AggregatorPush_Aggregation::arguments_size() const {
  return arguments_.size();
}
inline void AggregatorPush_Aggregation::clear_arguments() {
  arguments_.Clear();
}
inline const ::std::string& AggregatorPush_Aggregation::arguments(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.AggregatorPush.Aggregation.arguments)
  return arguments_.Get(index);
}
inline ::std::string* AggregatorPush_Aggregation::mutable_arguments(int index) {
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.AggregatorPush.Aggregation.arguments)
  return arguments_.Mutable(index);
}
inline void AggregatorPush_Aggregation::set_arguments(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:znbase.roachpb.AggregatorPush.Aggregation.arguments)
  arguments_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void AggregatorPush_Aggregation::set_arguments(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:znbase.roachpb.AggregatorPush.Aggregation.arguments)
  arguments_.Mutable(index)->assign(std::move(value));
}
#endif
inline void AggregatorPush_Aggregation::set_arguments(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  arguments_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.AggregatorPush.Aggregation.arguments)
}
inline void AggregatorPush_Aggregation::set_arguments(int index, const char* value, size_t size) {
  arguments_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.AggregatorPush.Aggregation.arguments)
}
inline ::std::string* AggregatorPush_Aggregation::add_arguments() {
  // @@protoc_insertion_point(field_add_mutable:znbase.roachpb.AggregatorPush.Aggregation.arguments)
  return arguments_.Add();
}
inline void AggregatorPush_Aggregation::add_arguments(const ::std::string& value) {
  arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:znbase.roachpb.AggregatorPush.Aggregation.arguments)
}
#if LANG_CXX11
inline void AggregatorPush_Aggregation::add_arguments(::std::string&& value) {
  arguments_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:znbase.roachpb.AggregatorPush.Aggregation.arguments)
}
#endif
inline void AggregatorPush_Aggregation::add_arguments(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:znbase.roachpb.AggregatorPush.Aggregation.arguments)
}
inline void AggregatorPush_Aggregation::add_arguments(const char* value, size_t size) {
  arguments_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:znbase.roachpb.AggregatorPush.Aggregation.arguments)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AggregatorPush_Aggregation::arguments() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.AggregatorPush.Aggregation.arguments)
  return arguments_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AggregatorPush_Aggregation::mutable_arguments() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.AggregatorPush.Aggregation.arguments)
  return &arguments_;
}

// required bool push_down_to_store = 7;
inline bool AggregatorPush_Aggregation::has_push_down_to_store() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AggregatorPush_Aggregation::set_has_push_down_to_store() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AggregatorPush_Aggregation::clear_has_push_down_to_store() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AggregatorPush_Aggregation::clear_push_down_to_store() {
  push_down_to_store_ = false;
  clear_has_push_down_to_store();
}
inline bool AggregatorPush_Aggregation::push_down_to_store() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.AggregatorPush.Aggregation.push_down_to_store)
  return push_down_to_store_;
}
inline void AggregatorPush_Aggregation::set_push_down_to_store(bool value) {
  set_has_push_down_to_store();
  push_down_to_store_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.AggregatorPush.Aggregation.push_down_to_store)
}

// required .znbase.roachpb.ColumnMeta.Type result_type = 8;
inline bool AggregatorPush_Aggregation::has_result_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AggregatorPush_Aggregation::set_has_result_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AggregatorPush_Aggregation::clear_has_result_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AggregatorPush_Aggregation::clear_result_type() {
  result_type_ = 0;
  clear_has_result_type();
}
inline ::znbase::roachpb::ColumnMeta_Type AggregatorPush_Aggregation::result_type() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.AggregatorPush.Aggregation.result_type)
  return static_cast< ::znbase::roachpb::ColumnMeta_Type >(result_type_);
}
inline void AggregatorPush_Aggregation::set_result_type(::znbase::roachpb::ColumnMeta_Type value) {
  assert(::znbase::roachpb::ColumnMeta_Type_IsValid(value));
  set_has_result_type();
  result_type_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.AggregatorPush.Aggregation.result_type)
}

// optional string render_expr = 9;
inline bool AggregatorPush_Aggregation::has_render_expr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AggregatorPush_Aggregation::set_has_render_expr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AggregatorPush_Aggregation::clear_has_render_expr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AggregatorPush_Aggregation::clear_render_expr() {
  render_expr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_render_expr();
}
inline const ::std::string& AggregatorPush_Aggregation::render_expr() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.AggregatorPush.Aggregation.render_expr)
  return render_expr_.GetNoArena();
}
inline void AggregatorPush_Aggregation::set_render_expr(const ::std::string& value) {
  set_has_render_expr();
  render_expr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.AggregatorPush.Aggregation.render_expr)
}
#if LANG_CXX11
inline void AggregatorPush_Aggregation::set_render_expr(::std::string&& value) {
  set_has_render_expr();
  render_expr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.AggregatorPush.Aggregation.render_expr)
}
#endif
inline void AggregatorPush_Aggregation::set_render_expr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_render_expr();
  render_expr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.AggregatorPush.Aggregation.render_expr)
}
inline void AggregatorPush_Aggregation::set_render_expr(const char* value, size_t size) {
  set_has_render_expr();
  render_expr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.AggregatorPush.Aggregation.render_expr)
}
inline ::std::string* AggregatorPush_Aggregation::mutable_render_expr() {
  set_has_render_expr();
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.AggregatorPush.Aggregation.render_expr)
  return render_expr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AggregatorPush_Aggregation::release_render_expr() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.AggregatorPush.Aggregation.render_expr)
  if (!has_render_expr()) {
    return NULL;
  }
  clear_has_render_expr();
  return render_expr_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AggregatorPush_Aggregation::set_allocated_render_expr(::std::string* render_expr) {
  if (render_expr != NULL) {
    set_has_render_expr();
  } else {
    clear_has_render_expr();
  }
  render_expr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), render_expr);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.AggregatorPush.Aggregation.render_expr)
}

// -------------------------------------------------------------------

// AggregatorPush

inline bool AggregatorPush::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AggregatorPush::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AggregatorPush::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AggregatorPush::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::znbase::roachpb::AggregatorPush_Type AggregatorPush::type() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.AggregatorPush.type)
  return static_cast< ::znbase::roachpb::AggregatorPush_Type >(type_);
}
inline void AggregatorPush::set_type(::znbase::roachpb::AggregatorPush_Type value) {
  assert(::znbase::roachpb::AggregatorPush_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.AggregatorPush.type)
}

// repeated uint32 group_cols = 2 [packed = true];
inline int AggregatorPush::group_cols_size() const {
  return group_cols_.size();
}
inline void AggregatorPush::clear_group_cols() {
  group_cols_.Clear();
}
inline ::google::protobuf::uint32 AggregatorPush::group_cols(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.AggregatorPush.group_cols)
  return group_cols_.Get(index);
}
inline void AggregatorPush::set_group_cols(int index, ::google::protobuf::uint32 value) {
  group_cols_.Set(index, value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.AggregatorPush.group_cols)
}
inline void AggregatorPush::add_group_cols(::google::protobuf::uint32 value) {
  group_cols_.Add(value);
  // @@protoc_insertion_point(field_add:znbase.roachpb.AggregatorPush.group_cols)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
AggregatorPush::group_cols() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.AggregatorPush.group_cols)
  return group_cols_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
AggregatorPush::mutable_group_cols() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.AggregatorPush.group_cols)
  return &group_cols_;
}

inline int AggregatorPush::aggregations_size() const {
  return aggregations_.size();
}
inline void AggregatorPush::clear_aggregations() {
  aggregations_.Clear();
}
inline ::znbase::roachpb::AggregatorPush_Aggregation* AggregatorPush::mutable_aggregations(int index) {
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.AggregatorPush.aggregations)
  return aggregations_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::AggregatorPush_Aggregation >*
AggregatorPush::mutable_aggregations() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.AggregatorPush.aggregations)
  return &aggregations_;
}
inline const ::znbase::roachpb::AggregatorPush_Aggregation& AggregatorPush::aggregations(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.AggregatorPush.aggregations)
  return aggregations_.Get(index);
}
inline ::znbase::roachpb::AggregatorPush_Aggregation* AggregatorPush::add_aggregations() {
  // @@protoc_insertion_point(field_add:znbase.roachpb.AggregatorPush.aggregations)
  return aggregations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::AggregatorPush_Aggregation >&
AggregatorPush::aggregations() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.AggregatorPush.aggregations)
  return aggregations_;
}

// repeated uint32 ordered_group_cols = 4 [packed = true];
inline int AggregatorPush::ordered_group_cols_size() const {
  return ordered_group_cols_.size();
}
inline void AggregatorPush::clear_ordered_group_cols() {
  ordered_group_cols_.Clear();
}
inline ::google::protobuf::uint32 AggregatorPush::ordered_group_cols(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.AggregatorPush.ordered_group_cols)
  return ordered_group_cols_.Get(index);
}
inline void AggregatorPush::set_ordered_group_cols(int index, ::google::protobuf::uint32 value) {
  ordered_group_cols_.Set(index, value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.AggregatorPush.ordered_group_cols)
}
inline void AggregatorPush::add_ordered_group_cols(::google::protobuf::uint32 value) {
  ordered_group_cols_.Add(value);
  // @@protoc_insertion_point(field_add:znbase.roachpb.AggregatorPush.ordered_group_cols)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
AggregatorPush::ordered_group_cols() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.AggregatorPush.ordered_group_cols)
  return ordered_group_cols_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
AggregatorPush::mutable_ordered_group_cols() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.AggregatorPush.ordered_group_cols)
  return &ordered_group_cols_;
}

// -------------------------------------------------------------------

// PushDownExpr

// repeated int32 col_ids = 1;
inline int PushDownExpr::col_ids_size() const {
  return col_ids_.size();
}
inline void PushDownExpr::clear_col_ids() {
  col_ids_.Clear();
}
inline ::google::protobuf::int32 PushDownExpr::col_ids(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.PushDownExpr.col_ids)
  return col_ids_.Get(index);
}
inline void PushDownExpr::set_col_ids(int index, ::google::protobuf::int32 value) {
  col_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.PushDownExpr.col_ids)
}
inline void PushDownExpr::add_col_ids(::google::protobuf::int32 value) {
  col_ids_.Add(value);
  // @@protoc_insertion_point(field_add:znbase.roachpb.PushDownExpr.col_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PushDownExpr::col_ids() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.PushDownExpr.col_ids)
  return col_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PushDownExpr::mutable_col_ids() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.PushDownExpr.col_ids)
  return &col_ids_;
}

// repeated .znbase.roachpb.ColumnMeta.Type col_types = 2;
inline int PushDownExpr::col_types_size() const {
  return col_types_.size();
}
inline void PushDownExpr::clear_col_types() {
  col_types_.Clear();
}
inline ::znbase::roachpb::ColumnMeta_Type PushDownExpr::col_types(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.PushDownExpr.col_types)
  return static_cast< ::znbase::roachpb::ColumnMeta_Type >(col_types_.Get(index));
}
inline void PushDownExpr::set_col_types(int index, ::znbase::roachpb::ColumnMeta_Type value) {
  assert(::znbase::roachpb::ColumnMeta_Type_IsValid(value));
  col_types_.Set(index, value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.PushDownExpr.col_types)
}
inline void PushDownExpr::add_col_types(::znbase::roachpb::ColumnMeta_Type value) {
  assert(::znbase::roachpb::ColumnMeta_Type_IsValid(value));
  col_types_.Add(value);
  // @@protoc_insertion_point(field_add:znbase.roachpb.PushDownExpr.col_types)
}
inline const ::google::protobuf::RepeatedField<int>&
PushDownExpr::col_types() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.PushDownExpr.col_types)
  return col_types_;
}
inline ::google::protobuf::RepeatedField<int>*
PushDownExpr::mutable_col_types() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.PushDownExpr.col_types)
  return &col_types_;
}

// repeated int32 primary_cols = 3;
inline int PushDownExpr::primary_cols_size() const {
  return primary_cols_.size();
}
inline void PushDownExpr::clear_primary_cols() {
  primary_cols_.Clear();
}
inline ::google::protobuf::int32 PushDownExpr::primary_cols(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.PushDownExpr.primary_cols)
  return primary_cols_.Get(index);
}
inline void PushDownExpr::set_primary_cols(int index, ::google::protobuf::int32 value) {
  primary_cols_.Set(index, value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.PushDownExpr.primary_cols)
}
inline void PushDownExpr::add_primary_cols(::google::protobuf::int32 value) {
  primary_cols_.Add(value);
  // @@protoc_insertion_point(field_add:znbase.roachpb.PushDownExpr.primary_cols)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PushDownExpr::primary_cols() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.PushDownExpr.primary_cols)
  return primary_cols_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PushDownExpr::mutable_primary_cols() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.PushDownExpr.primary_cols)
  return &primary_cols_;
}

// repeated int32 primary_cols_direct = 4;
inline int PushDownExpr::primary_cols_direct_size() const {
  return primary_cols_direct_.size();
}
inline void PushDownExpr::clear_primary_cols_direct() {
  primary_cols_direct_.Clear();
}
inline ::google::protobuf::int32 PushDownExpr::primary_cols_direct(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.PushDownExpr.primary_cols_direct)
  return primary_cols_direct_.Get(index);
}
inline void PushDownExpr::set_primary_cols_direct(int index, ::google::protobuf::int32 value) {
  primary_cols_direct_.Set(index, value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.PushDownExpr.primary_cols_direct)
}
inline void PushDownExpr::add_primary_cols_direct(::google::protobuf::int32 value) {
  primary_cols_direct_.Add(value);
  // @@protoc_insertion_point(field_add:znbase.roachpb.PushDownExpr.primary_cols_direct)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PushDownExpr::primary_cols_direct() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.PushDownExpr.primary_cols_direct)
  return primary_cols_direct_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PushDownExpr::mutable_primary_cols_direct() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.PushDownExpr.primary_cols_direct)
  return &primary_cols_direct_;
}

// repeated int32 secondary_cols = 5;
inline int PushDownExpr::secondary_cols_size() const {
  return secondary_cols_.size();
}
inline void PushDownExpr::clear_secondary_cols() {
  secondary_cols_.Clear();
}
inline ::google::protobuf::int32 PushDownExpr::secondary_cols(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.PushDownExpr.secondary_cols)
  return secondary_cols_.Get(index);
}
inline void PushDownExpr::set_secondary_cols(int index, ::google::protobuf::int32 value) {
  secondary_cols_.Set(index, value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.PushDownExpr.secondary_cols)
}
inline void PushDownExpr::add_secondary_cols(::google::protobuf::int32 value) {
  secondary_cols_.Add(value);
  // @@protoc_insertion_point(field_add:znbase.roachpb.PushDownExpr.secondary_cols)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PushDownExpr::secondary_cols() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.PushDownExpr.secondary_cols)
  return secondary_cols_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PushDownExpr::mutable_secondary_cols() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.PushDownExpr.secondary_cols)
  return &secondary_cols_;
}

// repeated int32 orderby_cols = 6 [packed = true];
inline int PushDownExpr::orderby_cols_size() const {
  return orderby_cols_.size();
}
inline void PushDownExpr::clear_orderby_cols() {
  orderby_cols_.Clear();
}
inline ::google::protobuf::int32 PushDownExpr::orderby_cols(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.PushDownExpr.orderby_cols)
  return orderby_cols_.Get(index);
}
inline void PushDownExpr::set_orderby_cols(int index, ::google::protobuf::int32 value) {
  orderby_cols_.Set(index, value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.PushDownExpr.orderby_cols)
}
inline void PushDownExpr::add_orderby_cols(::google::protobuf::int32 value) {
  orderby_cols_.Add(value);
  // @@protoc_insertion_point(field_add:znbase.roachpb.PushDownExpr.orderby_cols)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PushDownExpr::orderby_cols() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.PushDownExpr.orderby_cols)
  return orderby_cols_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PushDownExpr::mutable_orderby_cols() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.PushDownExpr.orderby_cols)
  return &orderby_cols_;
}

// repeated int32 order_directions = 7 [packed = true];
inline int PushDownExpr::order_directions_size() const {
  return order_directions_.size();
}
inline void PushDownExpr::clear_order_directions() {
  order_directions_.Clear();
}
inline ::google::protobuf::int32 PushDownExpr::order_directions(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.PushDownExpr.order_directions)
  return order_directions_.Get(index);
}
inline void PushDownExpr::set_order_directions(int index, ::google::protobuf::int32 value) {
  order_directions_.Set(index, value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.PushDownExpr.order_directions)
}
inline void PushDownExpr::add_order_directions(::google::protobuf::int32 value) {
  order_directions_.Add(value);
  // @@protoc_insertion_point(field_add:znbase.roachpb.PushDownExpr.order_directions)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PushDownExpr::order_directions() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.PushDownExpr.order_directions)
  return order_directions_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PushDownExpr::mutable_order_directions() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.PushDownExpr.order_directions)
  return &order_directions_;
}

// repeated int32 required_cols = 8;
inline int PushDownExpr::required_cols_size() const {
  return required_cols_.size();
}
inline void PushDownExpr::clear_required_cols() {
  required_cols_.Clear();
}
inline ::google::protobuf::int32 PushDownExpr::required_cols(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.PushDownExpr.required_cols)
  return required_cols_.Get(index);
}
inline void PushDownExpr::set_required_cols(int index, ::google::protobuf::int32 value) {
  required_cols_.Set(index, value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.PushDownExpr.required_cols)
}
inline void PushDownExpr::add_required_cols(::google::protobuf::int32 value) {
  required_cols_.Add(value);
  // @@protoc_insertion_point(field_add:znbase.roachpb.PushDownExpr.required_cols)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PushDownExpr::required_cols() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.PushDownExpr.required_cols)
  return required_cols_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PushDownExpr::mutable_required_cols() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.PushDownExpr.required_cols)
  return &required_cols_;
}

// repeated .znbase.roachpb.FilterUnion filters = 9;
inline int PushDownExpr::filters_size() const {
  return filters_.size();
}
inline void PushDownExpr::clear_filters() {
  filters_.Clear();
}
inline ::znbase::roachpb::FilterUnion* PushDownExpr::mutable_filters(int index) {
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.PushDownExpr.filters)
  return filters_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::FilterUnion >*
PushDownExpr::mutable_filters() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.PushDownExpr.filters)
  return &filters_;
}
inline const ::znbase::roachpb::FilterUnion& PushDownExpr::filters(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.PushDownExpr.filters)
  return filters_.Get(index);
}
inline ::znbase::roachpb::FilterUnion* PushDownExpr::add_filters() {
  // @@protoc_insertion_point(field_add:znbase.roachpb.PushDownExpr.filters)
  return filters_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::FilterUnion >&
PushDownExpr::filters() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.PushDownExpr.filters)
  return filters_;
}

// optional .znbase.roachpb.AggregatorPush aggregator = 10;
inline bool PushDownExpr::has_aggregator() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PushDownExpr::set_has_aggregator() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PushDownExpr::clear_has_aggregator() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PushDownExpr::clear_aggregator() {
  if (aggregator_ != NULL) aggregator_->Clear();
  clear_has_aggregator();
}
inline const ::znbase::roachpb::AggregatorPush& PushDownExpr::_internal_aggregator() const {
  return *aggregator_;
}
inline const ::znbase::roachpb::AggregatorPush& PushDownExpr::aggregator() const {
  const ::znbase::roachpb::AggregatorPush* p = aggregator_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.PushDownExpr.aggregator)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::AggregatorPush*>(
      &::znbase::roachpb::_AggregatorPush_default_instance_);
}
inline ::znbase::roachpb::AggregatorPush* PushDownExpr::release_aggregator() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.PushDownExpr.aggregator)
  clear_has_aggregator();
  ::znbase::roachpb::AggregatorPush* temp = aggregator_;
  aggregator_ = NULL;
  return temp;
}
inline ::znbase::roachpb::AggregatorPush* PushDownExpr::mutable_aggregator() {
  set_has_aggregator();
  if (aggregator_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::AggregatorPush>(GetArenaNoVirtual());
    aggregator_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.PushDownExpr.aggregator)
  return aggregator_;
}
inline void PushDownExpr::set_allocated_aggregator(::znbase::roachpb::AggregatorPush* aggregator) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete aggregator_;
  }
  if (aggregator) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      aggregator = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, aggregator, submessage_arena);
    }
    set_has_aggregator();
  } else {
    clear_has_aggregator();
  }
  aggregator_ = aggregator;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.PushDownExpr.aggregator)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace roachpb
}  // namespace znbase

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::znbase::roachpb::ColumnMeta_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::znbase::roachpb::AggregatorPush_Func> : ::std::true_type {};
template <> struct is_proto_enum< ::znbase::roachpb::AggregatorPush_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::znbase::roachpb::FilterType> : ::std::true_type {};

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_roachpb_2fpushdown_2eproto
