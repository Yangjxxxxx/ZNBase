// Copyright 2019 The Cockroach Authors.
//
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package span

import (
	"github.com/znbasedb/znbase/pkg/roachpb"
	"github.com/znbasedb/znbase/pkg/sql/sqlbase"
	"github.com/znbasedb/znbase/pkg/util"
	"github.com/znbasedb/znbase/pkg/util/encoding"
)

// Builder is a single struct for generating key spans from Constraints, Datums and encDatums.
type Builder struct {
	table         sqlbase.TableDescriptor
	index         *sqlbase.IndexDescriptor
	indexColTypes []sqlbase.ColumnType
	indexColDirs  []sqlbase.IndexDescriptor_Direction

	// KeyPrefix is the prefix of keys generated by the builder.
	KeyPrefix []byte
	alloc     sqlbase.DatumAlloc

	// TODO (rohany): The interstices are used to convert opt constraints into spans. In future work,
	//  we should unify the codepaths and use the allocation free method used on datums.
	//  This work is tracked in #42738.
	interstices [][]byte

	neededFamilies []sqlbase.FamilyID
}

// Use some functions that aren't needed right now to make the linter happy.
var _ = (*Builder).UnsetNeededColumns
var _ = (*Builder).SetNeededFamilies
var _ = (*Builder).UnsetNeededFamilies

// MakeBuilder creates a Builder for a table and index.
func MakeBuilder(table sqlbase.TableDescriptor, index *sqlbase.IndexDescriptor) *Builder {
	s := &Builder{
		table:          table,
		index:          index,
		KeyPrefix:      sqlbase.MakeIndexKeyPrefix(&table, index.ID),
		interstices:    make([][]byte, len(index.ColumnDirections)+len(index.ExtraColumnIDs)+1),
		neededFamilies: nil,
	}

	var columnIDs sqlbase.ColumnIDs
	columnIDs, s.indexColDirs = index.FullColumnIDs()
	s.indexColTypes = make([]sqlbase.ColumnType, len(columnIDs))
	for i, colID := range columnIDs {
		// TODO (rohany): do I need to look at table columns with mutations here as well?
		for _, col := range table.Columns {
			if col.ID == colID {
				s.indexColTypes[i] = col.Type
				break
			}
		}
	}

	// Set up the interstices for encoding interleaved tables later.
	s.interstices[0] = s.KeyPrefix
	if len(index.Interleave.Ancestors) > 0 {
		// TODO(rohany): too much of this code is copied from EncodePartialIndexKey.
		sharedPrefixLen := 0
		for i, ancestor := range index.Interleave.Ancestors {
			// The first ancestor is already encoded in interstices[0].
			if i != 0 {
				s.interstices[sharedPrefixLen] = sqlbase.EncodePartialTableIDIndexID(
					s.interstices[sharedPrefixLen], ancestor.TableID, ancestor.IndexID)
			}
			sharedPrefixLen += int(ancestor.SharedPrefixLen)
			s.interstices[sharedPrefixLen] = encoding.EncodeInterleavedSentinel(
				s.interstices[sharedPrefixLen])
		}
		s.interstices[sharedPrefixLen] = sqlbase.EncodePartialTableIDIndexID(
			s.interstices[sharedPrefixLen], table.ID, index.ID)
	}

	return s
}

// N.B. [Un]SetNeeded{Columns,Families} interact / overwrite each other.

// SetNeededColumns sets the needed columns on the Builder. This information
// is used by MaybeSplitSpanIntoSeparateFamilies.
func (s *Builder) SetNeededColumns(neededCols util.FastIntSet) {
	s.neededFamilies = sqlbase.NeededColumnFamilyIDs(neededCols, s.table, s.index)
}

// UnsetNeededColumns resets the needed columns for column family specific optimizations
// that the Builder performs.
func (s *Builder) UnsetNeededColumns() {
	s.neededFamilies = nil
}

// SetNeededFamilies sets the needed families of the span builder directly. This information
// is used by MaybeSplitSpanIntoSeparateFamilies.
func (s *Builder) SetNeededFamilies(neededFamilies []sqlbase.FamilyID) {
	s.neededFamilies = neededFamilies
}

// UnsetNeededFamilies resets the needed families for column family specific optimizations
// that the Builder performs.
func (s *Builder) UnsetNeededFamilies() {
	s.neededFamilies = nil
}

// SpanFromEncDatums encodes a span with prefixLen constraint columns from the index.
// SpanFromEncDatums assumes that the EncDatums in values are in the order of the index columns.
// It also returns whether or not the input values contain a null value or not, which can be
// used as input for CanSplitSpanIntoSeparateFamilies.
func (s *Builder) SpanFromEncDatums(
	values sqlbase.EncDatumRow, prefixLen int,
) (_ roachpb.Span, containsNull bool, _ error) {
	return sqlbase.MakeSpanFromEncDatumsForSpan(
		values[:prefixLen], s.indexColTypes[:prefixLen], s.indexColDirs[:prefixLen], s.table, s.index, &s.alloc, s.KeyPrefix)
}

// MaybeSplitSpanIntoSeparateFamilies uses the needed columns configured by
// SetNeededColumns to conditionally split the input span into multiple family
// specific spans. prefixLen is the number of index columns encoded in the span.
//
// The function accepts a slice of spans to append to.
func (s *Builder) MaybeSplitSpanIntoSeparateFamilies(
	appendTo roachpb.Spans, span roachpb.Span, prefixLen int, containsNull bool,
) roachpb.Spans {
	if s.neededFamilies != nil && s.CanSplitSpanIntoSeparateFamilies(len(s.neededFamilies), prefixLen, containsNull) {
		return sqlbase.SplitSpanIntoSeparateFamilies(appendTo, span, s.neededFamilies)
	}
	return append(appendTo, span)
}

// CanSplitSpanIntoSeparateFamilies returns whether a span encoded with prefixLen keys and numNeededFamilies
// needed families can be safely split into multiple family specific spans.
func (s *Builder) CanSplitSpanIntoSeparateFamilies(
	numNeededFamilies, prefixLen int, containsNull bool,
) bool {
	// We can only split a span into separate family specific point lookups if:
	// * We have a unique index.
	// * The index we are generating spans for actually has multiple families:
	//   - In the case of the primary index, that means the table itself has
	//     multiple families.
	//   - In the case of a secondary index, the table must have multiple families
	//     and the index must store some columns.
	// * If we have a secondary index, then containsNull must be false
	//   and it cannot be an inverted index.
	// * We have all of the lookup columns of the index.
	// * We don't need all of the families.
	return s.index.Unique && len(s.table.Families) > 1 &&
		(s.index.ID == s.table.PrimaryIndex.ID ||
			// Secondary index specific checks.
			(!containsNull &&
				len(s.index.StoreColumnIDs) > 0 &&
				s.index.Type == sqlbase.IndexDescriptor_FORWARD)) &&
		prefixLen == len(s.index.ColumnIDs) &&
		numNeededFamilies < len(s.table.Families)
}
