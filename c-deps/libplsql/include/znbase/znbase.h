// 文件名: znbase.h
// 描述: 该文件定义了关于plsql 和znbase 进行交互的相关接口
//
// 1. 函数、存储过程源数据获取的相关接口。
// 2. 参数类型源数据的定义和相关接口。
// 3. 执行状态等相关接口。
// 4. 游标相关接口和定义。
// 5. BEPI 相关接口。
#ifndef ZNBASE_H
#define ZNBASE_H

#include "nodes/nodes.h"
typedef uintptr_t Datum;

#include <unistd.h>
#ifndef addRoach
#include "../../../libroach/include/libroach.h"
#define addRoach 1
#endif

#include <sys/syscall.h>

#ifndef __NR_gettid
#define __NR_gettid 224
#endif

#ifdef SYS_gettid
#define gettid() syscall(SYS_gettid)
#else
#define gettid() syscall(__NR_gettid)
#endif

#define PROC_CATCH_ID 43
#define ERRSIZE 1024
#define MAX_ERROR_MSG_LEN 8192

// core pointer UDRRumParam from znbase
typedef struct
{
    //the return rc
    int rc;
    int callOrSelectCount ;
    // the error msg of ret
    char *ErrMsg;
    //the engine to get params
    // DBEngine *tempEngine;
    //save znbase funcDesc 's addr
    unsigned long  Pointer_func_desc;
    // save znbase UDRRunParam's address
    unsigned long pointer;
    // cursor temp engine (rocksDB)
    unsigned long cursorEngine;
    // save a magic code generated by random in caseof UDRRumParam is corrupted by golang
    int magicCode;
} Handler_t;

typedef struct
{
    unsigned long engine;
    unsigned long pointer;
    unsigned long cursorEngine;
    // unsigned long tempEngine;
}Pointer_vec;


// 全局变量类
typedef struct PLSQLData
{
    char *KeyName;
    // 标记本次operation 发生了oom？
    bool error_oom_happen;
    // 保存错误信息
    ErrorData *errData;
    MemoryContext ThreadMemoryContext;
    // 查找变量时所需的环境变量PLpgSQL_expr
    void *var_arg_env;
    // 回指handler
    Handler_t handler;
    int index;
    sigjmp_buf *plsql_sigjum_buf[31];
} PLSQLData;

typedef enum
{
    PLSQL_CALL_FUNCTION = 1,
    PLSQL_VALIDATOR = 2,
} PLSQLACTION;

#define ERR_MSG_MAXLEN 1024

typedef struct VarDesc {
	int placeIdx;
    int parts;
    char *part0;
    char *part1;
    char *part2;
    char *part3;
} VarDesc;

typedef struct VarRes {
	char *varName;
    uint typ;
    int  len;
    bool state;
    char *data;
} VarRes;

typedef struct UDRVarFind {
    unsigned long paramAddr;
    char *err;
} UDRVarFind;

typedef struct UDRVarDatumFind {
    char paramDatumStr;
    char *err;
} UDRVarDatumFind;
// 信号处理
void SignalDFLAll();
void SignalHandler(int sigNum);
void SignalAll();

// 对ZNBase 的唯一接口
extern bool PLSQL_external_for_znbase(Handler_t handler, PLSQLACTION action_type,   char *error_message,Pointer_vec vec, char *log_path,FunctionCallInfoBaseDataForGO fcinfo);

// 辅助接口
extern bool PLSQL_init_resource(Handler_t handler);
extern void PLSQL_cleanup_resource();
extern PLSQLData *PLSQL_GetCurrentThread_Data();
extern UDRVarFind PLSQL_GetCurrentUdrRunParamAddr(char *varName, int placeIdx);
extern DBEngine *GetRocksDBEngine();
extern DBKey GetRocksDBKey();
extern int BEPI_TXN_commit(Handler_t handler);
extern int  BEPI_TXN_rollback(Handler_t handler);


void __attribute__((weak)) ConvertCGoBackCaller(Handler_t);

// Part.1 Function Meta
// FucntionAttribute's interface, need request from znbase's function meta data
#define PROARGMODE_IN 'i'
#define PROARGMODE_OUT 'o'
#define PROARGMODE_INOUT 'b'
#define PROARGMODE_VARIADIC 'v'
#define PROARGMODE_TABLE 't'

typedef struct procdesc
{

} PROCDESC;

typedef enum TypeFuncClass
{
    TYPEFUNC_SCALAR,           /* scalar result type */
    TYPEFUNC_COMPOSITE,        /* determinable rowtype result */
    TYPEFUNC_COMPOSITE_DOMAIN, /* domain over determinable rowtype result */
    TYPEFUNC_RECORD,           /* indeterminate rowtype result */
    TYPEFUNC_OTHER             /* bogus type, eg pseudotype */
} TypeFuncClass;

FormData_pg_proc __attribute__((weak)) SearchFunctionMetaCache(Handler_t handler, int catchId);
TypeFuncClass get_call_result_type(FunctionCallInfo fcinfo,
                                   Oid *resultTypeId,
                                   TupleDesc *resultTupleDesc);

// Part.2 Type Meta
typedef struct typedesc
{
    Oid oid;
    NameData typname;
    int16 typlen;
    int32 typmod;
    bool typbyval;
    bool typisdefined;
    Oid typrelid;
    Oid typbasetype;
    Oid typcollation;
    Oid typelem;
    char typtype;
    char typstorage;
} TYPEDESC;

typedef TYPEDESC FormData_pg_type;
typedef TYPEDESC *Form_pg_type;

// BEPIPlanIndex 即为ZNBase UDR运行参数中关于该表达式的计划缓存的索引。
typedef uint BEPIPlanIndex;

TYPEDESC __attribute__((weak)) SearchTypeMetaCache(Handler_t handler, Oid typeID);
Oid __attribute__((weak)) SearchTypeOidByName(Handler_t handler, char *name);
extern char * __attribute__((weak)) CheckStmtParse(char *query);

ExpandedRecordHeader *
make_expanded_record_from_typeid(Oid type_id, int32 typmod,
                                 MemoryContext parentcontext);

// Part.3 Execute State
// znbase ExecuteState struct
// Used for znbase Expr eval related struct and interface
typedef enum
{
    BackwardScanDirection = -1,
    NoMovementScanDirection = 0,
    ForwardScanDirection = 1
} ScanDirection;

typedef struct ExecuteState
{
    NodeTag type;
    // Basic state for all query types
    ScanDirection es_direction; /* current scan direction */
    // TODO: snapshot
    void *es_snapshot;
    void *es_crosscheck_snapshot;
} EState;

// cursor related strcut
typedef struct
{
    int32 vl_len_;    /* varlena header (do not touch directly!) */
    int ndim;         /* # of dimensions */
    int32 dataoffset; /* offset to data, or 0 if no bitmap */
    Oid elemtype;     /* element type OID */
} ArrayType;

// cursor Desc
typedef struct CursorDesc
{
	char *name;     /* varlena header (do not touch directly!) */
	uint32 id;      /* cursor id */
	char *queryStr; /* cursor's source query string */
	int64 position; /* cursor position */
	void *columnDescs; /* cursor's columnDescs */
	void *plan;		/* # cursor plan store with type void* */
} CursorDesc, *CursorDescPtr;

// struct for cursor fetch
typedef struct CursorFetchPre {
    DBKey startKey, endKey;
	DBEngine *cursorEngine;
    int colTypes[100];
    int colNum;
} CursorFetchPre;

typedef struct _Portal
{
    char *name;
    TupleDesc tupDesc;
} _Portal;
typedef struct _Portal *Portal;

// Part.5
// bepi interface and struct
typedef struct CachedPlan
{
    int magic;             /* should equal CACHEDPLAN_MAGIC */
    List *stmt_list;       /* list of PlannedStmts */
    bool is_oneshot;       /* is it a "oneshot" plan? */
    bool is_saved;         /* is CachedPlan in a long-lived context? */
    bool is_valid;         /* is the stmt_list currently valid? */
    Oid planRoleId;        /* Role ID the plan was created for */
    bool dependsOnRole;    /* is plan specific to that role? */
    int generation;        /* parent's generation number for this plan */
    int refcount;          /* count of live references to this struct */
    MemoryContext context; /* context containing this CachedPlan */
} CachedPlan;

typedef struct cursorArg_name_type {
    char *name;
    char *type_name;
    Oid  typoid;
} cursorArg_name_type;

// bepi CGO Interface Begin
typedef int *  BEPI_BOOL_PTR;
typedef int *   BEPI_INT_PTR;
typedef float*  BEPI_FLOAT_PTR;
typedef char *  BEPI_STRING_PTR;
//typedef int *   BEPI_ARRAY_INT_PTR;
//typedef float * BEPI_ARRAY_FLOAT_PTR;
//typedef char ** BEPI_ARRAY_STRING_PTR;
typedef struct BEPI_ARRAY_INT
{
    int* vals;
    int num;
}BEPI_ARRAY_INT, *BEPI_ARRAY_INT_PTR;
typedef struct BEPI_ARRAY_FLOAT
{
    float* vals;
    int num;
}BEPI_ARRAY_FLOAT, *BEPI_ARRAY_FLOAT_PTR;
typedef struct BEPI_ARRAY_STRING
{
    char** vals;
    int num;
}BEPI_ARRAY_STRING, *BEPI_ARRAY_STRING_PTR;
typedef struct BEPI_BIT
{
    unsigned int vals:1;
}BEPI_BIT, *BEPI_BIT_PTR;
typedef struct BEPI_VARBIT
{
    int num;
    unsigned int* vals;
}BEPI_VARBIT, *BEPI_VARBIT_PTR;

extern char *__attribute__((weak)) BepiExecPlan(Handler_t , BEPIPlanIndex, bool *);
extern char *__attribute__((weak)) BepiPreparePlan(Handler_t handle,char *, int, uint *);
extern char *__attribute__((weak)) BepiExecEvalExpr(Handler_t, BEPIPlanIndex, VarRes *);
extern char *__attribute__((weak)) BepiExecReturnAndSet(Handler_t, char*, int);
extern char *__attribute__((weak)) BepiExecEvalExprAndStoreInResult(Handler_t, BEPIPlanIndex,VarRes*, bool *);
extern bool __attribute__((weak))  BepiExecBoolExpr(Handler_t, BEPIPlanIndex, char**);
extern char *__attribute__((weak)) FindParamsName(Handler_t,int);
extern char * __attribute__((weak)) GetNthParam(Handler_t, int, bool*);
extern char * __attribute__((weak)) GetNthBytesParam(Handler_t, int, int*, bool*);
extern int  __attribute__((weak)) GetNthParamListLength(Handler_t, int);
extern char * __attribute__((weak)) GetNthParamListI(Handler_t, int, int, bool*);
extern bool __attribute__((weak)) SetupFound(Handler_t);
extern char *__attribute__((weak)) BepiAssignResultToReturn(Handler_t);
extern char *__attribute__((weak)) BepiAssignStrToReturn(Handler_t, char *, Oid, char *);
extern char *__attribute__((weak)) BepiAssignBytesToReturn(Handler_t,char*, Oid, int);
extern char *__attribute__((weak)) BepiAssignArrayToReturn(Handler_t,char**,  Oid, int, int*) ;
extern bool __attribute__((weak)) DeclareVarible(Handler_t, char *, char *, bool);
extern int __attribute__((weak)) BepiCursorDeclare(Handler_t, char *, char *, char *, char **);
extern unsigned long __attribute__((weak)) BepiCursorFind(Handler_t,char *, char **);
extern char *__attribute__((weak)) BepiAssignCursorOpen(Handler_t,char *);
extern void __attribute__((weak)) BepiCursorClose(Handler_t, char *, char **);
extern bool __attribute__((weak)) BepiCursorFetch(Handler_t, char*, int, long, char **);
extern bool __attribute__((weak)) BepiCursorFetchPython(Handler_t, char*, int, long, char **);
extern bool __attribute__((weak)) BepiCursorMove(Handler_t, char*, int, long, char **);
extern char * __attribute__((weak)) BepiFetchIntoValue(Handler_t, char*);

extern void __attribute__((weak)) BepiResetCursorAssign();
extern char *__attribute__((weak)) BepiTryToCloseAllUnClosedCursor(Handler_t);

extern char *__attribute__((weak)) BepiCastValueToType(Handler_t, char *, char **, int, int);

extern unsigned long __attribute__((weak)) BepiFindVarByName(Handler_t, char *, int, bool *);
extern char **__attribute__((weak)) BepiGetReturn(Handler_t, Oid **, long *, char ***, int *,int **);

extern int __attribute__((weak)) BepiGetArgCount(Handler_t);
extern uint32 __attribute__((weak)) BepiGetArgTypeID(Handler_t, int);
extern char **__attribute__((weak)) BepiGetCursorFetchRow(Handler_t, Oid **, int *, char ***, int *,int **, char **);
extern char *__attribute__((weak)) BepiFindVarDatumByNameToString(Handler_t, char *, int, bool*);
extern char * __attribute__((weak)) GetTypeNameFromOid(Oid, char **);
extern int __attribute__((weak)) GetReturnColNum(Handler_t);
extern int __attribute__((weak)) GetIntFromResult(Handler_t, char**);
extern unsigned long long int __attribute__((weak)) BepiGetGoroutineID();
extern char *__attribute__((weak)) AssignTheRecord(Handler_t, int);
extern void __attribute__((weak)) BepiSetFound(Handler_t);
// bepi CGO Interface End

#define BEPI_NOCACHED_PLAN (-1)
#define BEPI_EXEC_OK 5

#define SPI_ERROR_CONNECT (-1)
#define SPI_ERROR_COPY (-2)
#define SPI_ERROR_OPUNKNOWN (-3)
#define SPI_ERROR_UNCONNECTED (-4)
#define SPI_ERROR_CURSOR (-5) /* not used anymore */
#define SPI_ERROR_ARGUMENT (-6)
#define SPI_ERROR_PARAM (-7)
#define SPI_ERROR_TRANSACTION (-8)
#define SPI_ERROR_NOATTRIBUTE (-9)
#define SPI_ERROR_NOOUTFUNC (-10)
#define SPI_ERROR_TYPUNKNOWN (-11)
#define SPI_ERROR_REL_DUPLICATE (-12)
#define SPI_ERROR_REL_NOT_FOUND (-13)

#define SPI_OK_CONNECT 1
#define SPI_OK_FINISH 2
#define SPI_OK_FETCH 3
#define SPI_OK_UTILITY 4
#define SPI_OK_SELECT 5
#define SPI_OK_SELINTO 6
#define SPI_OK_INSERT 7
#define SPI_OK_DELETE 8
#define SPI_OK_UPDATE 9
#define SPI_OK_CURSOR 10
#define SPI_OK_INSERT_RETURNING 11
#define SPI_OK_DELETE_RETURNING 12
#define SPI_OK_UPDATE_RETURNING 13
#define SPI_OK_REWRITTEN 14
#define SPI_OK_REL_REGISTER 15
#define SPI_OK_REL_UNREGISTER 16
#define SPI_OK_TD_REGISTER 17

// interface
// 首先将所有的SPI 接口定义为伪接口
typedef struct SPIPlan
{

} SPIPlan;

typedef struct SPIPlan *SPIPlanPtr;
// 垃圾定义，将来会移除
typedef struct Snapshot
{

} Snapshot;

typedef struct ParserSetupHook
{

} ParserSetupHook;

typedef struct EphemeralNamedRelation
{

} EphemeralNamedRelation;

typedef struct SPITupleTable
{
    /* Public members */
    TupleDesc tupdesc; /* tuple descriptor */
    HeapTuple *vals;   /* array of tuples */
    uint64 numvals;    /* number of valid tuples */
    bool rocksDB_get;
    /* Private members, not intended for external callers */
    uint64 alloced;          /* allocated length of vals array */
    MemoryContext tuptabcxt; /* memory context of result table */
    SubTransactionId subid;  /* subxact in which tuptable was created */
} SPITupleTable;

typedef struct SPI_result
{

} SPI_result;

typedef struct _SPI_connection
{

} _SPI_connection;

int SPI_connect(void);
int SPI_connect_ext(int options);
int SPI_finish(void);
int SPI_execute(const char *src, bool read_only, long tcount);
int SPI_execute_plan(SPIPlanPtr plan, Datum *Values, const char *Nulls,
                 bool read_only, long tcount);

bool
BEPI_exec_eval_expr(Handler_t handler, BEPIPlanIndex planIndex, char *varName, int dno, Datum *result, Oid *retType,
                    bool in_using, bool *isNull);
int BEPI_execute_plan_with_paramlist(Handler_t handler, BEPIPlanIndex planIndex,
                                     ParamListInfo params,
                                     bool read_only, long tcount, bool *is_query_or_hasReturning);
char **BEPI_execute_plan_with_returnrows(Handler_t handler, BEPIPlanIndex planIndex,
                                        ParamListInfo params, Oid *oid,
                                        bool read_only, long tcount);
int SPI_exec(const char *src, long tcount);
int SPI_execp(SPIPlanPtr plan, Datum *Values, const char *Nulls,
              long tcount);
int SPI_execute_snapshot(SPIPlanPtr plan,
                         Datum *Values, const char *Nulls,
                         Snapshot snapshot,
                         Snapshot crosscheck_snapshot,
                         bool read_only, bool fire_triggers, long tcount);
int SPI_execute_with_args(const char *src,
                          int nargs, Oid *argtypes,
                          Datum *Values, const char *Nulls,
                          bool read_only, long tcount);
SPIPlanPtr SPI_prepare(const char *src, int nargs, Oid *argtypes);
SPIPlanPtr SPI_prepare_cursor(const char *src, int nargs, Oid *argtypes,
                              int cursorOptions);
BEPIPlanIndex BEPI_prepare_params(Handler_t handler, const char *src, int cursorOptions);
bool __attribute__((weak))BepiExecBoolExpr(Handler_t handler,BEPIPlanIndex BEPIPlanIndex,char **);
char* __attribute__((weak))FindParamsName(Handler_t,int);
int SPI_keepplan(SPIPlanPtr plan);
SPIPlanPtr SPI_saveplan(SPIPlanPtr plan);
int SPI_freeplan(SPIPlanPtr plan);

Oid SPI_getargtypeid(SPIPlanPtr plan, int argIndex);
int SPI_getargcount(SPIPlanPtr plan);

int BEPI_getargcount(Handler_t handler);

bool SPI_is_cursor_plan(SPIPlanPtr plan);
bool SPI_plan_is_valid(SPIPlanPtr plan);
const char *SPI_result_code_string(int code);

List *SPI_plan_get_plan_sources(SPIPlanPtr plan);
CachedPlan *SPI_plan_get_cached_plan(SPIPlanPtr plan);

HeapTuple SPI_copytuple(HeapTuple tuple);
HeapTupleHeader SPI_returntuple(HeapTuple tuple, TupleDesc tupdesc);
HeapTuple SPI_modifytuple(Relation rel, HeapTuple tuple, int natts,
                          int *attnum, Datum *Values, const char *Nulls);
int SPI_fnumber(TupleDesc tupdesc, const char *fname);
char *SPI_fname(TupleDesc tupdesc, int fnumber);
char *SPI_getvalue(HeapTuple tuple, TupleDesc tupdesc, int fnumber);
Datum SPI_getbinval(HeapTuple tuple, TupleDesc tupdesc, int fnumber, bool *isnull);
char *SPI_gettype(TupleDesc tupdesc, int fnumber);
Oid SPI_gettypeid(TupleDesc tupdesc, int fnumber);

uint32 BEPI_getargtypeid(Handler_t handler, int argIndex);

char *SPI_getrelname(Relation rel);
char *SPI_getnspname(Relation rel);
void *SPI_palloc(Size size);
void *BEPI_palloc(Size size);
void *SPI_repalloc(void *pointer, Size size);
void BEPI_pfree(void *pointer);
Datum SPI_datumTransfer(Datum value, bool typByVal, int typLen);
void SPI_freetuple(HeapTuple pointer);
void SPI_freetuptable(SPITupleTable *tuptable);

Portal SPI_cursor_open(const char *name, SPIPlanPtr plan,
                       Datum *Values, const char *Nulls, bool read_only);
Portal SPI_cursor_open_with_args(const char *name,
                                 const char *src,
                                 int nargs, Oid *argtypes,
                                 Datum *Values, const char *Nulls,
                                 bool read_only, int cursorOptions);
Portal SPI_cursor_open_with_paramlist(const char *name, SPIPlanPtr plan,
                                      ParamListInfo params, bool read_only);

int BEPI_cursor_declare(Handler_t handler, const char *cursorName, char *query, cursorArg_name_type *curArg, int arg_num);

int BEPI_cursor_open_with_paramlist(Handler_t handler, const char *name,
                                        ParamListInfo params, char *arg_str, bool read_only);
Portal SPI_cursor_find(const char *name);
CursorDesc BEPI_cursor_find(Handler_t handler, const char *name, char **errmsg);
void SPI_cursor_fetch(Portal portal, bool forward, long count);
void SPI_cursor_move(Portal portal, bool forward, long count);
/*void BEPI_cursor_move(Handler_t handler, char *name, bool forward, long count);*/
void SPI_scroll_cursor_fetch(Portal, FetchDirection direction, long count);
CursorFetchPre BEPI_cursor_fetch_prepare(Handler_t handler, char *name, bool forward, int colTypes[], long count);
/*bool BEPI_cursor_fetch(Handler_t handler, char *name, bool forward, long count);*/
void SPI_scroll_cursor_move(Portal, FetchDirection direction, long count);
void SPI_cursor_close(Portal portal);
void BEPI_cursor_close(Handler_t handler, char *name, char *errmsg);
char *BEPI_castValue_toType(Handler_t handler, char *valStr, char **resStr, int srcOid, int castOid);

int SPI_register_relation(EphemeralNamedRelation enr);
int SPI_unregister_relation(const char *name);
int SPI_register_trigger_data(TriggerData *tdata);

void SPI_start_transaction(void);
void SPI_commit(void);
void SPI_commit_and_chain(void);
void SPI_rollback(void);
void SPI_rollback_and_chain(void);

void SPICleanup(void);
void AtEOXact_SPI(bool isCommit);
void AtEOSubXact_SPI(bool isCommit, SubTransactionId mySubid);
bool SPI_inside_nonatomic_context(void);

int BEPI_execute(Handler_t handler, const char *src);
int BEPI_exec(Handler_t handler, const char *src);
int BEPI_execute_plan(Handler_t handler, BEPIPlanIndex planIndex);
int BEPI_execp(Handler_t handler, BEPIPlanIndex planIndex);
BEPIPlanIndex BEPI_prepare(Handler_t handler, const char *src);
void BEPI_cursor_move(Handler_t handler, char *name, FetchDirection direction, long count);
bool BEPI_cursor_fetch(Handler_t handler, char *name, FetchDirection direction, long count);
#endif
