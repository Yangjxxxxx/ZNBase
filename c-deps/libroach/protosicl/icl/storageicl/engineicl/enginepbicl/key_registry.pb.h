// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: icl/storageicl/engineicl/enginepbicl/key_registry.proto

#ifndef PROTOBUF_INCLUDED_icl_2fstorageicl_2fengineicl_2fenginepbicl_2fkey_5fregistry_2eproto
#define PROTOBUF_INCLUDED_icl_2fstorageicl_2fengineicl_2fenginepbicl_2fkey_5fregistry_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry_lite.h>
#include <google/protobuf/map_field_lite.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_icl_2fstorageicl_2fengineicl_2fenginepbicl_2fkey_5fregistry_2eproto 

namespace protobuf_icl_2fstorageicl_2fengineicl_2fenginepbicl_2fkey_5fregistry_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[6];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
}  // namespace protobuf_icl_2fstorageicl_2fengineicl_2fenginepbicl_2fkey_5fregistry_2eproto
namespace znbase {
namespace icl {
namespace storageicl {
namespace engineicl {
namespace enginepbicl {
class DataKeysRegistry;
class DataKeysRegistryDefaultTypeInternal;
extern DataKeysRegistryDefaultTypeInternal _DataKeysRegistry_default_instance_;
class DataKeysRegistry_DataKeysEntry_DoNotUse;
class DataKeysRegistry_DataKeysEntry_DoNotUseDefaultTypeInternal;
extern DataKeysRegistry_DataKeysEntry_DoNotUseDefaultTypeInternal _DataKeysRegistry_DataKeysEntry_DoNotUse_default_instance_;
class DataKeysRegistry_StoreKeysEntry_DoNotUse;
class DataKeysRegistry_StoreKeysEntry_DoNotUseDefaultTypeInternal;
extern DataKeysRegistry_StoreKeysEntry_DoNotUseDefaultTypeInternal _DataKeysRegistry_StoreKeysEntry_DoNotUse_default_instance_;
class EncryptionSettings;
class EncryptionSettingsDefaultTypeInternal;
extern EncryptionSettingsDefaultTypeInternal _EncryptionSettings_default_instance_;
class KeyInfo;
class KeyInfoDefaultTypeInternal;
extern KeyInfoDefaultTypeInternal _KeyInfo_default_instance_;
class SecretKey;
class SecretKeyDefaultTypeInternal;
extern SecretKeyDefaultTypeInternal _SecretKey_default_instance_;
}  // namespace enginepbicl
}  // namespace engineicl
}  // namespace storageicl
}  // namespace icl
}  // namespace znbase
namespace google {
namespace protobuf {
template<> ::znbase::icl::storageicl::engineicl::enginepbicl::DataKeysRegistry* Arena::CreateMaybeMessage<::znbase::icl::storageicl::engineicl::enginepbicl::DataKeysRegistry>(Arena*);
template<> ::znbase::icl::storageicl::engineicl::enginepbicl::DataKeysRegistry_DataKeysEntry_DoNotUse* Arena::CreateMaybeMessage<::znbase::icl::storageicl::engineicl::enginepbicl::DataKeysRegistry_DataKeysEntry_DoNotUse>(Arena*);
template<> ::znbase::icl::storageicl::engineicl::enginepbicl::DataKeysRegistry_StoreKeysEntry_DoNotUse* Arena::CreateMaybeMessage<::znbase::icl::storageicl::engineicl::enginepbicl::DataKeysRegistry_StoreKeysEntry_DoNotUse>(Arena*);
template<> ::znbase::icl::storageicl::engineicl::enginepbicl::EncryptionSettings* Arena::CreateMaybeMessage<::znbase::icl::storageicl::engineicl::enginepbicl::EncryptionSettings>(Arena*);
template<> ::znbase::icl::storageicl::engineicl::enginepbicl::KeyInfo* Arena::CreateMaybeMessage<::znbase::icl::storageicl::engineicl::enginepbicl::KeyInfo>(Arena*);
template<> ::znbase::icl::storageicl::engineicl::enginepbicl::SecretKey* Arena::CreateMaybeMessage<::znbase::icl::storageicl::engineicl::enginepbicl::SecretKey>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace znbase {
namespace icl {
namespace storageicl {
namespace engineicl {
namespace enginepbicl {

enum EncryptionType {
  Plaintext = 0,
  AES128_CTR = 1,
  AES192_CTR = 2,
  AES256_CTR = 3,
  EncryptionType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EncryptionType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EncryptionType_IsValid(int value);
const EncryptionType EncryptionType_MIN = Plaintext;
const EncryptionType EncryptionType_MAX = AES256_CTR;
const int EncryptionType_ARRAYSIZE = EncryptionType_MAX + 1;

// ===================================================================

class DataKeysRegistry_StoreKeysEntry_DoNotUse : public ::google::protobuf::internal::MapEntryLite<DataKeysRegistry_StoreKeysEntry_DoNotUse, 
    ::std::string, ::znbase::icl::storageicl::engineicl::enginepbicl::KeyInfo,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntryLite<DataKeysRegistry_StoreKeysEntry_DoNotUse, 
    ::std::string, ::znbase::icl::storageicl::engineicl::enginepbicl::KeyInfo,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  DataKeysRegistry_StoreKeysEntry_DoNotUse();
  DataKeysRegistry_StoreKeysEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const DataKeysRegistry_StoreKeysEntry_DoNotUse& other);
  static const DataKeysRegistry_StoreKeysEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const DataKeysRegistry_StoreKeysEntry_DoNotUse*>(&_DataKeysRegistry_StoreKeysEntry_DoNotUse_default_instance_); }
};

// -------------------------------------------------------------------

class DataKeysRegistry_DataKeysEntry_DoNotUse : public ::google::protobuf::internal::MapEntryLite<DataKeysRegistry_DataKeysEntry_DoNotUse, 
    ::std::string, ::znbase::icl::storageicl::engineicl::enginepbicl::SecretKey,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntryLite<DataKeysRegistry_DataKeysEntry_DoNotUse, 
    ::std::string, ::znbase::icl::storageicl::engineicl::enginepbicl::SecretKey,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  DataKeysRegistry_DataKeysEntry_DoNotUse();
  DataKeysRegistry_DataKeysEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const DataKeysRegistry_DataKeysEntry_DoNotUse& other);
  static const DataKeysRegistry_DataKeysEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const DataKeysRegistry_DataKeysEntry_DoNotUse*>(&_DataKeysRegistry_DataKeysEntry_DoNotUse_default_instance_); }
};

// -------------------------------------------------------------------

class DataKeysRegistry : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.icl.storageicl.engineicl.enginepbicl.DataKeysRegistry) */ {
 public:
  DataKeysRegistry();
  virtual ~DataKeysRegistry();

  DataKeysRegistry(const DataKeysRegistry& from);

  inline DataKeysRegistry& operator=(const DataKeysRegistry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DataKeysRegistry(DataKeysRegistry&& from) noexcept
    : DataKeysRegistry() {
    *this = ::std::move(from);
  }

  inline DataKeysRegistry& operator=(DataKeysRegistry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DataKeysRegistry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DataKeysRegistry* internal_default_instance() {
    return reinterpret_cast<const DataKeysRegistry*>(
               &_DataKeysRegistry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(DataKeysRegistry* other);
  friend void swap(DataKeysRegistry& a, DataKeysRegistry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DataKeysRegistry* New() const final {
    return CreateMaybeMessage<DataKeysRegistry>(NULL);
  }

  DataKeysRegistry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DataKeysRegistry>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const DataKeysRegistry& from);
  void MergeFrom(const DataKeysRegistry& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DataKeysRegistry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .znbase.icl.storageicl.engineicl.enginepbicl.KeyInfo> store_keys = 1;
  int store_keys_size() const;
  void clear_store_keys();
  static const int kStoreKeysFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::znbase::icl::storageicl::engineicl::enginepbicl::KeyInfo >&
      store_keys() const;
  ::google::protobuf::Map< ::std::string, ::znbase::icl::storageicl::engineicl::enginepbicl::KeyInfo >*
      mutable_store_keys();

  // map<string, .znbase.icl.storageicl.engineicl.enginepbicl.SecretKey> data_keys = 2;
  int data_keys_size() const;
  void clear_data_keys();
  static const int kDataKeysFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, ::znbase::icl::storageicl::engineicl::enginepbicl::SecretKey >&
      data_keys() const;
  ::google::protobuf::Map< ::std::string, ::znbase::icl::storageicl::engineicl::enginepbicl::SecretKey >*
      mutable_data_keys();

  // string active_store_key_id = 3;
  void clear_active_store_key_id();
  static const int kActiveStoreKeyIdFieldNumber = 3;
  const ::std::string& active_store_key_id() const;
  void set_active_store_key_id(const ::std::string& value);
  #if LANG_CXX11
  void set_active_store_key_id(::std::string&& value);
  #endif
  void set_active_store_key_id(const char* value);
  void set_active_store_key_id(const char* value, size_t size);
  ::std::string* mutable_active_store_key_id();
  ::std::string* release_active_store_key_id();
  void set_allocated_active_store_key_id(::std::string* active_store_key_id);

  // string active_data_key_id = 4;
  void clear_active_data_key_id();
  static const int kActiveDataKeyIdFieldNumber = 4;
  const ::std::string& active_data_key_id() const;
  void set_active_data_key_id(const ::std::string& value);
  #if LANG_CXX11
  void set_active_data_key_id(::std::string&& value);
  #endif
  void set_active_data_key_id(const char* value);
  void set_active_data_key_id(const char* value, size_t size);
  ::std::string* mutable_active_data_key_id();
  ::std::string* release_active_data_key_id();
  void set_allocated_active_data_key_id(::std::string* active_data_key_id);

  // @@protoc_insertion_point(class_scope:znbase.icl.storageicl.engineicl.enginepbicl.DataKeysRegistry)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::MapFieldLite<
      DataKeysRegistry_StoreKeysEntry_DoNotUse,
      ::std::string, ::znbase::icl::storageicl::engineicl::enginepbicl::KeyInfo,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > store_keys_;
  ::google::protobuf::internal::MapFieldLite<
      DataKeysRegistry_DataKeysEntry_DoNotUse,
      ::std::string, ::znbase::icl::storageicl::engineicl::enginepbicl::SecretKey,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > data_keys_;
  ::google::protobuf::internal::ArenaStringPtr active_store_key_id_;
  ::google::protobuf::internal::ArenaStringPtr active_data_key_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_icl_2fstorageicl_2fengineicl_2fenginepbicl_2fkey_5fregistry_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KeyInfo : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.icl.storageicl.engineicl.enginepbicl.KeyInfo) */ {
 public:
  KeyInfo();
  virtual ~KeyInfo();

  KeyInfo(const KeyInfo& from);

  inline KeyInfo& operator=(const KeyInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KeyInfo(KeyInfo&& from) noexcept
    : KeyInfo() {
    *this = ::std::move(from);
  }

  inline KeyInfo& operator=(KeyInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const KeyInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KeyInfo* internal_default_instance() {
    return reinterpret_cast<const KeyInfo*>(
               &_KeyInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(KeyInfo* other);
  friend void swap(KeyInfo& a, KeyInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeyInfo* New() const final {
    return CreateMaybeMessage<KeyInfo>(NULL);
  }

  KeyInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KeyInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const KeyInfo& from);
  void MergeFrom(const KeyInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KeyInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key_id = 2;
  void clear_key_id();
  static const int kKeyIdFieldNumber = 2;
  const ::std::string& key_id() const;
  void set_key_id(const ::std::string& value);
  #if LANG_CXX11
  void set_key_id(::std::string&& value);
  #endif
  void set_key_id(const char* value);
  void set_key_id(const char* value, size_t size);
  ::std::string* mutable_key_id();
  ::std::string* release_key_id();
  void set_allocated_key_id(::std::string* key_id);

  // string source = 4;
  void clear_source();
  static const int kSourceFieldNumber = 4;
  const ::std::string& source() const;
  void set_source(const ::std::string& value);
  #if LANG_CXX11
  void set_source(::std::string&& value);
  #endif
  void set_source(const char* value);
  void set_source(const char* value, size_t size);
  ::std::string* mutable_source();
  ::std::string* release_source();
  void set_allocated_source(::std::string* source);

  // string parent_key_id = 6;
  void clear_parent_key_id();
  static const int kParentKeyIdFieldNumber = 6;
  const ::std::string& parent_key_id() const;
  void set_parent_key_id(const ::std::string& value);
  #if LANG_CXX11
  void set_parent_key_id(::std::string&& value);
  #endif
  void set_parent_key_id(const char* value);
  void set_parent_key_id(const char* value, size_t size);
  ::std::string* mutable_parent_key_id();
  ::std::string* release_parent_key_id();
  void set_allocated_parent_key_id(::std::string* parent_key_id);

  // int64 creation_time = 3;
  void clear_creation_time();
  static const int kCreationTimeFieldNumber = 3;
  ::google::protobuf::int64 creation_time() const;
  void set_creation_time(::google::protobuf::int64 value);

  // .znbase.icl.storageicl.engineicl.enginepbicl.EncryptionType encryption_type = 1;
  void clear_encryption_type();
  static const int kEncryptionTypeFieldNumber = 1;
  ::znbase::icl::storageicl::engineicl::enginepbicl::EncryptionType encryption_type() const;
  void set_encryption_type(::znbase::icl::storageicl::engineicl::enginepbicl::EncryptionType value);

  // bool was_exposed = 5;
  void clear_was_exposed();
  static const int kWasExposedFieldNumber = 5;
  bool was_exposed() const;
  void set_was_exposed(bool value);

  // @@protoc_insertion_point(class_scope:znbase.icl.storageicl.engineicl.enginepbicl.KeyInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_id_;
  ::google::protobuf::internal::ArenaStringPtr source_;
  ::google::protobuf::internal::ArenaStringPtr parent_key_id_;
  ::google::protobuf::int64 creation_time_;
  int encryption_type_;
  bool was_exposed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_icl_2fstorageicl_2fengineicl_2fenginepbicl_2fkey_5fregistry_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SecretKey : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.icl.storageicl.engineicl.enginepbicl.SecretKey) */ {
 public:
  SecretKey();
  virtual ~SecretKey();

  SecretKey(const SecretKey& from);

  inline SecretKey& operator=(const SecretKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SecretKey(SecretKey&& from) noexcept
    : SecretKey() {
    *this = ::std::move(from);
  }

  inline SecretKey& operator=(SecretKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const SecretKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SecretKey* internal_default_instance() {
    return reinterpret_cast<const SecretKey*>(
               &_SecretKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(SecretKey* other);
  friend void swap(SecretKey& a, SecretKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SecretKey* New() const final {
    return CreateMaybeMessage<SecretKey>(NULL);
  }

  SecretKey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SecretKey>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const SecretKey& from);
  void MergeFrom(const SecretKey& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SecretKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 2;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // .znbase.icl.storageicl.engineicl.enginepbicl.KeyInfo info = 1;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 1;
  private:
  const ::znbase::icl::storageicl::engineicl::enginepbicl::KeyInfo& _internal_info() const;
  public:
  const ::znbase::icl::storageicl::engineicl::enginepbicl::KeyInfo& info() const;
  ::znbase::icl::storageicl::engineicl::enginepbicl::KeyInfo* release_info();
  ::znbase::icl::storageicl::engineicl::enginepbicl::KeyInfo* mutable_info();
  void set_allocated_info(::znbase::icl::storageicl::engineicl::enginepbicl::KeyInfo* info);

  // @@protoc_insertion_point(class_scope:znbase.icl.storageicl.engineicl.enginepbicl.SecretKey)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::znbase::icl::storageicl::engineicl::enginepbicl::KeyInfo* info_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_icl_2fstorageicl_2fengineicl_2fenginepbicl_2fkey_5fregistry_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EncryptionSettings : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.icl.storageicl.engineicl.enginepbicl.EncryptionSettings) */ {
 public:
  EncryptionSettings();
  virtual ~EncryptionSettings();

  EncryptionSettings(const EncryptionSettings& from);

  inline EncryptionSettings& operator=(const EncryptionSettings& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EncryptionSettings(EncryptionSettings&& from) noexcept
    : EncryptionSettings() {
    *this = ::std::move(from);
  }

  inline EncryptionSettings& operator=(EncryptionSettings&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const EncryptionSettings& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EncryptionSettings* internal_default_instance() {
    return reinterpret_cast<const EncryptionSettings*>(
               &_EncryptionSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(EncryptionSettings* other);
  friend void swap(EncryptionSettings& a, EncryptionSettings& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EncryptionSettings* New() const final {
    return CreateMaybeMessage<EncryptionSettings>(NULL);
  }

  EncryptionSettings* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EncryptionSettings>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const EncryptionSettings& from);
  void MergeFrom(const EncryptionSettings& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EncryptionSettings* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key_id = 2;
  void clear_key_id();
  static const int kKeyIdFieldNumber = 2;
  const ::std::string& key_id() const;
  void set_key_id(const ::std::string& value);
  #if LANG_CXX11
  void set_key_id(::std::string&& value);
  #endif
  void set_key_id(const char* value);
  void set_key_id(const char* value, size_t size);
  ::std::string* mutable_key_id();
  ::std::string* release_key_id();
  void set_allocated_key_id(::std::string* key_id);

  // bytes nonce = 3;
  void clear_nonce();
  static const int kNonceFieldNumber = 3;
  const ::std::string& nonce() const;
  void set_nonce(const ::std::string& value);
  #if LANG_CXX11
  void set_nonce(::std::string&& value);
  #endif
  void set_nonce(const char* value);
  void set_nonce(const void* value, size_t size);
  ::std::string* mutable_nonce();
  ::std::string* release_nonce();
  void set_allocated_nonce(::std::string* nonce);

  // .znbase.icl.storageicl.engineicl.enginepbicl.EncryptionType encryption_type = 1;
  void clear_encryption_type();
  static const int kEncryptionTypeFieldNumber = 1;
  ::znbase::icl::storageicl::engineicl::enginepbicl::EncryptionType encryption_type() const;
  void set_encryption_type(::znbase::icl::storageicl::engineicl::enginepbicl::EncryptionType value);

  // uint32 counter = 4;
  void clear_counter();
  static const int kCounterFieldNumber = 4;
  ::google::protobuf::uint32 counter() const;
  void set_counter(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:znbase.icl.storageicl.engineicl.enginepbicl.EncryptionSettings)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_id_;
  ::google::protobuf::internal::ArenaStringPtr nonce_;
  int encryption_type_;
  ::google::protobuf::uint32 counter_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_icl_2fstorageicl_2fengineicl_2fenginepbicl_2fkey_5fregistry_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// DataKeysRegistry

// map<string, .znbase.icl.storageicl.engineicl.enginepbicl.KeyInfo> store_keys = 1;
inline int DataKeysRegistry::store_keys_size() const {
  return store_keys_.size();
}
inline void DataKeysRegistry::clear_store_keys() {
  store_keys_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::znbase::icl::storageicl::engineicl::enginepbicl::KeyInfo >&
DataKeysRegistry::store_keys() const {
  // @@protoc_insertion_point(field_map:znbase.icl.storageicl.engineicl.enginepbicl.DataKeysRegistry.store_keys)
  return store_keys_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::znbase::icl::storageicl::engineicl::enginepbicl::KeyInfo >*
DataKeysRegistry::mutable_store_keys() {
  // @@protoc_insertion_point(field_mutable_map:znbase.icl.storageicl.engineicl.enginepbicl.DataKeysRegistry.store_keys)
  return store_keys_.MutableMap();
}

// map<string, .znbase.icl.storageicl.engineicl.enginepbicl.SecretKey> data_keys = 2;
inline int DataKeysRegistry::data_keys_size() const {
  return data_keys_.size();
}
inline void DataKeysRegistry::clear_data_keys() {
  data_keys_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::znbase::icl::storageicl::engineicl::enginepbicl::SecretKey >&
DataKeysRegistry::data_keys() const {
  // @@protoc_insertion_point(field_map:znbase.icl.storageicl.engineicl.enginepbicl.DataKeysRegistry.data_keys)
  return data_keys_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::znbase::icl::storageicl::engineicl::enginepbicl::SecretKey >*
DataKeysRegistry::mutable_data_keys() {
  // @@protoc_insertion_point(field_mutable_map:znbase.icl.storageicl.engineicl.enginepbicl.DataKeysRegistry.data_keys)
  return data_keys_.MutableMap();
}

// string active_store_key_id = 3;
inline void DataKeysRegistry::clear_active_store_key_id() {
  active_store_key_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DataKeysRegistry::active_store_key_id() const {
  // @@protoc_insertion_point(field_get:znbase.icl.storageicl.engineicl.enginepbicl.DataKeysRegistry.active_store_key_id)
  return active_store_key_id_.GetNoArena();
}
inline void DataKeysRegistry::set_active_store_key_id(const ::std::string& value) {
  
  active_store_key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.icl.storageicl.engineicl.enginepbicl.DataKeysRegistry.active_store_key_id)
}
#if LANG_CXX11
inline void DataKeysRegistry::set_active_store_key_id(::std::string&& value) {
  
  active_store_key_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.icl.storageicl.engineicl.enginepbicl.DataKeysRegistry.active_store_key_id)
}
#endif
inline void DataKeysRegistry::set_active_store_key_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  active_store_key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.icl.storageicl.engineicl.enginepbicl.DataKeysRegistry.active_store_key_id)
}
inline void DataKeysRegistry::set_active_store_key_id(const char* value, size_t size) {
  
  active_store_key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.icl.storageicl.engineicl.enginepbicl.DataKeysRegistry.active_store_key_id)
}
inline ::std::string* DataKeysRegistry::mutable_active_store_key_id() {
  
  // @@protoc_insertion_point(field_mutable:znbase.icl.storageicl.engineicl.enginepbicl.DataKeysRegistry.active_store_key_id)
  return active_store_key_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DataKeysRegistry::release_active_store_key_id() {
  // @@protoc_insertion_point(field_release:znbase.icl.storageicl.engineicl.enginepbicl.DataKeysRegistry.active_store_key_id)
  
  return active_store_key_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataKeysRegistry::set_allocated_active_store_key_id(::std::string* active_store_key_id) {
  if (active_store_key_id != NULL) {
    
  } else {
    
  }
  active_store_key_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), active_store_key_id);
  // @@protoc_insertion_point(field_set_allocated:znbase.icl.storageicl.engineicl.enginepbicl.DataKeysRegistry.active_store_key_id)
}

// string active_data_key_id = 4;
inline void DataKeysRegistry::clear_active_data_key_id() {
  active_data_key_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DataKeysRegistry::active_data_key_id() const {
  // @@protoc_insertion_point(field_get:znbase.icl.storageicl.engineicl.enginepbicl.DataKeysRegistry.active_data_key_id)
  return active_data_key_id_.GetNoArena();
}
inline void DataKeysRegistry::set_active_data_key_id(const ::std::string& value) {
  
  active_data_key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.icl.storageicl.engineicl.enginepbicl.DataKeysRegistry.active_data_key_id)
}
#if LANG_CXX11
inline void DataKeysRegistry::set_active_data_key_id(::std::string&& value) {
  
  active_data_key_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.icl.storageicl.engineicl.enginepbicl.DataKeysRegistry.active_data_key_id)
}
#endif
inline void DataKeysRegistry::set_active_data_key_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  active_data_key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.icl.storageicl.engineicl.enginepbicl.DataKeysRegistry.active_data_key_id)
}
inline void DataKeysRegistry::set_active_data_key_id(const char* value, size_t size) {
  
  active_data_key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.icl.storageicl.engineicl.enginepbicl.DataKeysRegistry.active_data_key_id)
}
inline ::std::string* DataKeysRegistry::mutable_active_data_key_id() {
  
  // @@protoc_insertion_point(field_mutable:znbase.icl.storageicl.engineicl.enginepbicl.DataKeysRegistry.active_data_key_id)
  return active_data_key_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DataKeysRegistry::release_active_data_key_id() {
  // @@protoc_insertion_point(field_release:znbase.icl.storageicl.engineicl.enginepbicl.DataKeysRegistry.active_data_key_id)
  
  return active_data_key_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataKeysRegistry::set_allocated_active_data_key_id(::std::string* active_data_key_id) {
  if (active_data_key_id != NULL) {
    
  } else {
    
  }
  active_data_key_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), active_data_key_id);
  // @@protoc_insertion_point(field_set_allocated:znbase.icl.storageicl.engineicl.enginepbicl.DataKeysRegistry.active_data_key_id)
}

// -------------------------------------------------------------------

// KeyInfo

// .znbase.icl.storageicl.engineicl.enginepbicl.EncryptionType encryption_type = 1;
inline void KeyInfo::clear_encryption_type() {
  encryption_type_ = 0;
}
inline ::znbase::icl::storageicl::engineicl::enginepbicl::EncryptionType KeyInfo::encryption_type() const {
  // @@protoc_insertion_point(field_get:znbase.icl.storageicl.engineicl.enginepbicl.KeyInfo.encryption_type)
  return static_cast< ::znbase::icl::storageicl::engineicl::enginepbicl::EncryptionType >(encryption_type_);
}
inline void KeyInfo::set_encryption_type(::znbase::icl::storageicl::engineicl::enginepbicl::EncryptionType value) {
  
  encryption_type_ = value;
  // @@protoc_insertion_point(field_set:znbase.icl.storageicl.engineicl.enginepbicl.KeyInfo.encryption_type)
}

// string key_id = 2;
inline void KeyInfo::clear_key_id() {
  key_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyInfo::key_id() const {
  // @@protoc_insertion_point(field_get:znbase.icl.storageicl.engineicl.enginepbicl.KeyInfo.key_id)
  return key_id_.GetNoArena();
}
inline void KeyInfo::set_key_id(const ::std::string& value) {
  
  key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.icl.storageicl.engineicl.enginepbicl.KeyInfo.key_id)
}
#if LANG_CXX11
inline void KeyInfo::set_key_id(::std::string&& value) {
  
  key_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.icl.storageicl.engineicl.enginepbicl.KeyInfo.key_id)
}
#endif
inline void KeyInfo::set_key_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.icl.storageicl.engineicl.enginepbicl.KeyInfo.key_id)
}
inline void KeyInfo::set_key_id(const char* value, size_t size) {
  
  key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.icl.storageicl.engineicl.enginepbicl.KeyInfo.key_id)
}
inline ::std::string* KeyInfo::mutable_key_id() {
  
  // @@protoc_insertion_point(field_mutable:znbase.icl.storageicl.engineicl.enginepbicl.KeyInfo.key_id)
  return key_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyInfo::release_key_id() {
  // @@protoc_insertion_point(field_release:znbase.icl.storageicl.engineicl.enginepbicl.KeyInfo.key_id)
  
  return key_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyInfo::set_allocated_key_id(::std::string* key_id) {
  if (key_id != NULL) {
    
  } else {
    
  }
  key_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key_id);
  // @@protoc_insertion_point(field_set_allocated:znbase.icl.storageicl.engineicl.enginepbicl.KeyInfo.key_id)
}

// int64 creation_time = 3;
inline void KeyInfo::clear_creation_time() {
  creation_time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 KeyInfo::creation_time() const {
  // @@protoc_insertion_point(field_get:znbase.icl.storageicl.engineicl.enginepbicl.KeyInfo.creation_time)
  return creation_time_;
}
inline void KeyInfo::set_creation_time(::google::protobuf::int64 value) {
  
  creation_time_ = value;
  // @@protoc_insertion_point(field_set:znbase.icl.storageicl.engineicl.enginepbicl.KeyInfo.creation_time)
}

// string source = 4;
inline void KeyInfo::clear_source() {
  source_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyInfo::source() const {
  // @@protoc_insertion_point(field_get:znbase.icl.storageicl.engineicl.enginepbicl.KeyInfo.source)
  return source_.GetNoArena();
}
inline void KeyInfo::set_source(const ::std::string& value) {
  
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.icl.storageicl.engineicl.enginepbicl.KeyInfo.source)
}
#if LANG_CXX11
inline void KeyInfo::set_source(::std::string&& value) {
  
  source_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.icl.storageicl.engineicl.enginepbicl.KeyInfo.source)
}
#endif
inline void KeyInfo::set_source(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.icl.storageicl.engineicl.enginepbicl.KeyInfo.source)
}
inline void KeyInfo::set_source(const char* value, size_t size) {
  
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.icl.storageicl.engineicl.enginepbicl.KeyInfo.source)
}
inline ::std::string* KeyInfo::mutable_source() {
  
  // @@protoc_insertion_point(field_mutable:znbase.icl.storageicl.engineicl.enginepbicl.KeyInfo.source)
  return source_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyInfo::release_source() {
  // @@protoc_insertion_point(field_release:znbase.icl.storageicl.engineicl.enginepbicl.KeyInfo.source)
  
  return source_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyInfo::set_allocated_source(::std::string* source) {
  if (source != NULL) {
    
  } else {
    
  }
  source_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source);
  // @@protoc_insertion_point(field_set_allocated:znbase.icl.storageicl.engineicl.enginepbicl.KeyInfo.source)
}

// bool was_exposed = 5;
inline void KeyInfo::clear_was_exposed() {
  was_exposed_ = false;
}
inline bool KeyInfo::was_exposed() const {
  // @@protoc_insertion_point(field_get:znbase.icl.storageicl.engineicl.enginepbicl.KeyInfo.was_exposed)
  return was_exposed_;
}
inline void KeyInfo::set_was_exposed(bool value) {
  
  was_exposed_ = value;
  // @@protoc_insertion_point(field_set:znbase.icl.storageicl.engineicl.enginepbicl.KeyInfo.was_exposed)
}

// string parent_key_id = 6;
inline void KeyInfo::clear_parent_key_id() {
  parent_key_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyInfo::parent_key_id() const {
  // @@protoc_insertion_point(field_get:znbase.icl.storageicl.engineicl.enginepbicl.KeyInfo.parent_key_id)
  return parent_key_id_.GetNoArena();
}
inline void KeyInfo::set_parent_key_id(const ::std::string& value) {
  
  parent_key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.icl.storageicl.engineicl.enginepbicl.KeyInfo.parent_key_id)
}
#if LANG_CXX11
inline void KeyInfo::set_parent_key_id(::std::string&& value) {
  
  parent_key_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.icl.storageicl.engineicl.enginepbicl.KeyInfo.parent_key_id)
}
#endif
inline void KeyInfo::set_parent_key_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  parent_key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.icl.storageicl.engineicl.enginepbicl.KeyInfo.parent_key_id)
}
inline void KeyInfo::set_parent_key_id(const char* value, size_t size) {
  
  parent_key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.icl.storageicl.engineicl.enginepbicl.KeyInfo.parent_key_id)
}
inline ::std::string* KeyInfo::mutable_parent_key_id() {
  
  // @@protoc_insertion_point(field_mutable:znbase.icl.storageicl.engineicl.enginepbicl.KeyInfo.parent_key_id)
  return parent_key_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyInfo::release_parent_key_id() {
  // @@protoc_insertion_point(field_release:znbase.icl.storageicl.engineicl.enginepbicl.KeyInfo.parent_key_id)
  
  return parent_key_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyInfo::set_allocated_parent_key_id(::std::string* parent_key_id) {
  if (parent_key_id != NULL) {
    
  } else {
    
  }
  parent_key_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), parent_key_id);
  // @@protoc_insertion_point(field_set_allocated:znbase.icl.storageicl.engineicl.enginepbicl.KeyInfo.parent_key_id)
}

// -------------------------------------------------------------------

// SecretKey

// .znbase.icl.storageicl.engineicl.enginepbicl.KeyInfo info = 1;
inline bool SecretKey::has_info() const {
  return this != internal_default_instance() && info_ != NULL;
}
inline void SecretKey::clear_info() {
  if (GetArenaNoVirtual() == NULL && info_ != NULL) {
    delete info_;
  }
  info_ = NULL;
}
inline const ::znbase::icl::storageicl::engineicl::enginepbicl::KeyInfo& SecretKey::_internal_info() const {
  return *info_;
}
inline const ::znbase::icl::storageicl::engineicl::enginepbicl::KeyInfo& SecretKey::info() const {
  const ::znbase::icl::storageicl::engineicl::enginepbicl::KeyInfo* p = info_;
  // @@protoc_insertion_point(field_get:znbase.icl.storageicl.engineicl.enginepbicl.SecretKey.info)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::icl::storageicl::engineicl::enginepbicl::KeyInfo*>(
      &::znbase::icl::storageicl::engineicl::enginepbicl::_KeyInfo_default_instance_);
}
inline ::znbase::icl::storageicl::engineicl::enginepbicl::KeyInfo* SecretKey::release_info() {
  // @@protoc_insertion_point(field_release:znbase.icl.storageicl.engineicl.enginepbicl.SecretKey.info)
  
  ::znbase::icl::storageicl::engineicl::enginepbicl::KeyInfo* temp = info_;
  info_ = NULL;
  return temp;
}
inline ::znbase::icl::storageicl::engineicl::enginepbicl::KeyInfo* SecretKey::mutable_info() {
  
  if (info_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::icl::storageicl::engineicl::enginepbicl::KeyInfo>(GetArenaNoVirtual());
    info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.icl.storageicl.engineicl.enginepbicl.SecretKey.info)
  return info_;
}
inline void SecretKey::set_allocated_info(::znbase::icl::storageicl::engineicl::enginepbicl::KeyInfo* info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete info_;
  }
  if (info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:znbase.icl.storageicl.engineicl.enginepbicl.SecretKey.info)
}

// bytes key = 2;
inline void SecretKey::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SecretKey::key() const {
  // @@protoc_insertion_point(field_get:znbase.icl.storageicl.engineicl.enginepbicl.SecretKey.key)
  return key_.GetNoArena();
}
inline void SecretKey::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.icl.storageicl.engineicl.enginepbicl.SecretKey.key)
}
#if LANG_CXX11
inline void SecretKey::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.icl.storageicl.engineicl.enginepbicl.SecretKey.key)
}
#endif
inline void SecretKey::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.icl.storageicl.engineicl.enginepbicl.SecretKey.key)
}
inline void SecretKey::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.icl.storageicl.engineicl.enginepbicl.SecretKey.key)
}
inline ::std::string* SecretKey::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:znbase.icl.storageicl.engineicl.enginepbicl.SecretKey.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SecretKey::release_key() {
  // @@protoc_insertion_point(field_release:znbase.icl.storageicl.engineicl.enginepbicl.SecretKey.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SecretKey::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:znbase.icl.storageicl.engineicl.enginepbicl.SecretKey.key)
}

// -------------------------------------------------------------------

// EncryptionSettings

// .znbase.icl.storageicl.engineicl.enginepbicl.EncryptionType encryption_type = 1;
inline void EncryptionSettings::clear_encryption_type() {
  encryption_type_ = 0;
}
inline ::znbase::icl::storageicl::engineicl::enginepbicl::EncryptionType EncryptionSettings::encryption_type() const {
  // @@protoc_insertion_point(field_get:znbase.icl.storageicl.engineicl.enginepbicl.EncryptionSettings.encryption_type)
  return static_cast< ::znbase::icl::storageicl::engineicl::enginepbicl::EncryptionType >(encryption_type_);
}
inline void EncryptionSettings::set_encryption_type(::znbase::icl::storageicl::engineicl::enginepbicl::EncryptionType value) {
  
  encryption_type_ = value;
  // @@protoc_insertion_point(field_set:znbase.icl.storageicl.engineicl.enginepbicl.EncryptionSettings.encryption_type)
}

// string key_id = 2;
inline void EncryptionSettings::clear_key_id() {
  key_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EncryptionSettings::key_id() const {
  // @@protoc_insertion_point(field_get:znbase.icl.storageicl.engineicl.enginepbicl.EncryptionSettings.key_id)
  return key_id_.GetNoArena();
}
inline void EncryptionSettings::set_key_id(const ::std::string& value) {
  
  key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.icl.storageicl.engineicl.enginepbicl.EncryptionSettings.key_id)
}
#if LANG_CXX11
inline void EncryptionSettings::set_key_id(::std::string&& value) {
  
  key_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.icl.storageicl.engineicl.enginepbicl.EncryptionSettings.key_id)
}
#endif
inline void EncryptionSettings::set_key_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.icl.storageicl.engineicl.enginepbicl.EncryptionSettings.key_id)
}
inline void EncryptionSettings::set_key_id(const char* value, size_t size) {
  
  key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.icl.storageicl.engineicl.enginepbicl.EncryptionSettings.key_id)
}
inline ::std::string* EncryptionSettings::mutable_key_id() {
  
  // @@protoc_insertion_point(field_mutable:znbase.icl.storageicl.engineicl.enginepbicl.EncryptionSettings.key_id)
  return key_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EncryptionSettings::release_key_id() {
  // @@protoc_insertion_point(field_release:znbase.icl.storageicl.engineicl.enginepbicl.EncryptionSettings.key_id)
  
  return key_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EncryptionSettings::set_allocated_key_id(::std::string* key_id) {
  if (key_id != NULL) {
    
  } else {
    
  }
  key_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key_id);
  // @@protoc_insertion_point(field_set_allocated:znbase.icl.storageicl.engineicl.enginepbicl.EncryptionSettings.key_id)
}

// bytes nonce = 3;
inline void EncryptionSettings::clear_nonce() {
  nonce_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EncryptionSettings::nonce() const {
  // @@protoc_insertion_point(field_get:znbase.icl.storageicl.engineicl.enginepbicl.EncryptionSettings.nonce)
  return nonce_.GetNoArena();
}
inline void EncryptionSettings::set_nonce(const ::std::string& value) {
  
  nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.icl.storageicl.engineicl.enginepbicl.EncryptionSettings.nonce)
}
#if LANG_CXX11
inline void EncryptionSettings::set_nonce(::std::string&& value) {
  
  nonce_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.icl.storageicl.engineicl.enginepbicl.EncryptionSettings.nonce)
}
#endif
inline void EncryptionSettings::set_nonce(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.icl.storageicl.engineicl.enginepbicl.EncryptionSettings.nonce)
}
inline void EncryptionSettings::set_nonce(const void* value, size_t size) {
  
  nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.icl.storageicl.engineicl.enginepbicl.EncryptionSettings.nonce)
}
inline ::std::string* EncryptionSettings::mutable_nonce() {
  
  // @@protoc_insertion_point(field_mutable:znbase.icl.storageicl.engineicl.enginepbicl.EncryptionSettings.nonce)
  return nonce_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EncryptionSettings::release_nonce() {
  // @@protoc_insertion_point(field_release:znbase.icl.storageicl.engineicl.enginepbicl.EncryptionSettings.nonce)
  
  return nonce_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EncryptionSettings::set_allocated_nonce(::std::string* nonce) {
  if (nonce != NULL) {
    
  } else {
    
  }
  nonce_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nonce);
  // @@protoc_insertion_point(field_set_allocated:znbase.icl.storageicl.engineicl.enginepbicl.EncryptionSettings.nonce)
}

// uint32 counter = 4;
inline void EncryptionSettings::clear_counter() {
  counter_ = 0u;
}
inline ::google::protobuf::uint32 EncryptionSettings::counter() const {
  // @@protoc_insertion_point(field_get:znbase.icl.storageicl.engineicl.enginepbicl.EncryptionSettings.counter)
  return counter_;
}
inline void EncryptionSettings::set_counter(::google::protobuf::uint32 value) {
  
  counter_ = value;
  // @@protoc_insertion_point(field_set:znbase.icl.storageicl.engineicl.enginepbicl.EncryptionSettings.counter)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace enginepbicl
}  // namespace engineicl
}  // namespace storageicl
}  // namespace icl
}  // namespace znbase

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::znbase::icl::storageicl::engineicl::enginepbicl::EncryptionType> : ::std::true_type {};

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_icl_2fstorageicl_2fengineicl_2fenginepbicl_2fkey_5fregistry_2eproto
