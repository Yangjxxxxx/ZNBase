// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: roachpb/api.proto

#ifndef PROTOBUF_INCLUDED_roachpb_2fapi_2eproto
#define PROTOBUF_INCLUDED_roachpb_2fapi_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "roachpb/data.pb.h"
#include "roachpb/pushdown.pb.h"
#include "roachpb/errors.pb.h"
#include "roachpb/metadata.pb.h"
#include "storage/concurrency/lock/locking.pb.h"
#include "storage/engine/enginepb/mvcc.pb.h"
#include "storage/engine/enginepb/mvcc3.pb.h"
#include "util/hlc/timestamp.pb.h"
#include "util/tracing/recorded_span.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_roachpb_2fapi_2eproto 

namespace protobuf_roachpb_2fapi_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[142];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
}  // namespace protobuf_roachpb_2fapi_2eproto
namespace znbase {
namespace roachpb {
class AddSSTableRequest;
class AddSSTableRequestDefaultTypeInternal;
extern AddSSTableRequestDefaultTypeInternal _AddSSTableRequest_default_instance_;
class AddSSTableResponse;
class AddSSTableResponseDefaultTypeInternal;
extern AddSSTableResponseDefaultTypeInternal _AddSSTableResponse_default_instance_;
class AdminChangeReplicasRequest;
class AdminChangeReplicasRequestDefaultTypeInternal;
extern AdminChangeReplicasRequestDefaultTypeInternal _AdminChangeReplicasRequest_default_instance_;
class AdminChangeReplicasResponse;
class AdminChangeReplicasResponseDefaultTypeInternal;
extern AdminChangeReplicasResponseDefaultTypeInternal _AdminChangeReplicasResponse_default_instance_;
class AdminMergeRequest;
class AdminMergeRequestDefaultTypeInternal;
extern AdminMergeRequestDefaultTypeInternal _AdminMergeRequest_default_instance_;
class AdminMergeResponse;
class AdminMergeResponseDefaultTypeInternal;
extern AdminMergeResponseDefaultTypeInternal _AdminMergeResponse_default_instance_;
class AdminRelocateRangeRequest;
class AdminRelocateRangeRequestDefaultTypeInternal;
extern AdminRelocateRangeRequestDefaultTypeInternal _AdminRelocateRangeRequest_default_instance_;
class AdminRelocateRangeResponse;
class AdminRelocateRangeResponseDefaultTypeInternal;
extern AdminRelocateRangeResponseDefaultTypeInternal _AdminRelocateRangeResponse_default_instance_;
class AdminScatterRequest;
class AdminScatterRequestDefaultTypeInternal;
extern AdminScatterRequestDefaultTypeInternal _AdminScatterRequest_default_instance_;
class AdminScatterResponse;
class AdminScatterResponseDefaultTypeInternal;
extern AdminScatterResponseDefaultTypeInternal _AdminScatterResponse_default_instance_;
class AdminScatterResponse_Range;
class AdminScatterResponse_RangeDefaultTypeInternal;
extern AdminScatterResponse_RangeDefaultTypeInternal _AdminScatterResponse_Range_default_instance_;
class AdminSplitRequest;
class AdminSplitRequestDefaultTypeInternal;
extern AdminSplitRequestDefaultTypeInternal _AdminSplitRequest_default_instance_;
class AdminSplitResponse;
class AdminSplitResponseDefaultTypeInternal;
extern AdminSplitResponseDefaultTypeInternal _AdminSplitResponse_default_instance_;
class AdminTransferLeaseRequest;
class AdminTransferLeaseRequestDefaultTypeInternal;
extern AdminTransferLeaseRequestDefaultTypeInternal _AdminTransferLeaseRequest_default_instance_;
class AdminTransferLeaseResponse;
class AdminTransferLeaseResponseDefaultTypeInternal;
extern AdminTransferLeaseResponseDefaultTypeInternal _AdminTransferLeaseResponse_default_instance_;
class BatchRequest;
class BatchRequestDefaultTypeInternal;
extern BatchRequestDefaultTypeInternal _BatchRequest_default_instance_;
class BatchResponse;
class BatchResponseDefaultTypeInternal;
extern BatchResponseDefaultTypeInternal _BatchResponse_default_instance_;
class BatchResponse_Header;
class BatchResponse_HeaderDefaultTypeInternal;
extern BatchResponse_HeaderDefaultTypeInternal _BatchResponse_Header_default_instance_;
class BulkOpSummary;
class BulkOpSummaryDefaultTypeInternal;
extern BulkOpSummaryDefaultTypeInternal _BulkOpSummary_default_instance_;
class CheckConsistencyRequest;
class CheckConsistencyRequestDefaultTypeInternal;
extern CheckConsistencyRequestDefaultTypeInternal _CheckConsistencyRequest_default_instance_;
class CheckConsistencyResponse;
class CheckConsistencyResponseDefaultTypeInternal;
extern CheckConsistencyResponseDefaultTypeInternal _CheckConsistencyResponse_default_instance_;
class CheckConsistencyResponse_Result;
class CheckConsistencyResponse_ResultDefaultTypeInternal;
extern CheckConsistencyResponse_ResultDefaultTypeInternal _CheckConsistencyResponse_Result_default_instance_;
class ClearIntentRequest;
class ClearIntentRequestDefaultTypeInternal;
extern ClearIntentRequestDefaultTypeInternal _ClearIntentRequest_default_instance_;
class ClearIntentResponse;
class ClearIntentResponseDefaultTypeInternal;
extern ClearIntentResponseDefaultTypeInternal _ClearIntentResponse_default_instance_;
class ClearRangeRequest;
class ClearRangeRequestDefaultTypeInternal;
extern ClearRangeRequestDefaultTypeInternal _ClearRangeRequest_default_instance_;
class ClearRangeResponse;
class ClearRangeResponseDefaultTypeInternal;
extern ClearRangeResponseDefaultTypeInternal _ClearRangeResponse_default_instance_;
class ComputeChecksumRequest;
class ComputeChecksumRequestDefaultTypeInternal;
extern ComputeChecksumRequestDefaultTypeInternal _ComputeChecksumRequest_default_instance_;
class ComputeChecksumResponse;
class ComputeChecksumResponseDefaultTypeInternal;
extern ComputeChecksumResponseDefaultTypeInternal _ComputeChecksumResponse_default_instance_;
class ConditionalPutRequest;
class ConditionalPutRequestDefaultTypeInternal;
extern ConditionalPutRequestDefaultTypeInternal _ConditionalPutRequest_default_instance_;
class ConditionalPutResponse;
class ConditionalPutResponseDefaultTypeInternal;
extern ConditionalPutResponseDefaultTypeInternal _ConditionalPutResponse_default_instance_;
class DeleteRangeRequest;
class DeleteRangeRequestDefaultTypeInternal;
extern DeleteRangeRequestDefaultTypeInternal _DeleteRangeRequest_default_instance_;
class DeleteRangeResponse;
class DeleteRangeResponseDefaultTypeInternal;
extern DeleteRangeResponseDefaultTypeInternal _DeleteRangeResponse_default_instance_;
class DeleteRequest;
class DeleteRequestDefaultTypeInternal;
extern DeleteRequestDefaultTypeInternal _DeleteRequest_default_instance_;
class DeleteResponse;
class DeleteResponseDefaultTypeInternal;
extern DeleteResponseDefaultTypeInternal _DeleteResponse_default_instance_;
class DumpOnlineRequest;
class DumpOnlineRequestDefaultTypeInternal;
extern DumpOnlineRequestDefaultTypeInternal _DumpOnlineRequest_default_instance_;
class DumpOnlineResponse;
class DumpOnlineResponseDefaultTypeInternal;
extern DumpOnlineResponseDefaultTypeInternal _DumpOnlineResponse_default_instance_;
class DumpOnlineResponse_File;
class DumpOnlineResponse_FileDefaultTypeInternal;
extern DumpOnlineResponse_FileDefaultTypeInternal _DumpOnlineResponse_File_default_instance_;
class DumpOnlineResponse_Files;
class DumpOnlineResponse_FilesDefaultTypeInternal;
extern DumpOnlineResponse_FilesDefaultTypeInternal _DumpOnlineResponse_Files_default_instance_;
class DumpRequest;
class DumpRequestDefaultTypeInternal;
extern DumpRequestDefaultTypeInternal _DumpRequest_default_instance_;
class DumpResponse;
class DumpResponseDefaultTypeInternal;
extern DumpResponseDefaultTypeInternal _DumpResponse_default_instance_;
class DumpResponse_File;
class DumpResponse_FileDefaultTypeInternal;
extern DumpResponse_FileDefaultTypeInternal _DumpResponse_File_default_instance_;
class DumpSink;
class DumpSinkDefaultTypeInternal;
extern DumpSinkDefaultTypeInternal _DumpSink_default_instance_;
class DumpSink_Azure;
class DumpSink_AzureDefaultTypeInternal;
extern DumpSink_AzureDefaultTypeInternal _DumpSink_Azure_default_instance_;
class DumpSink_GCS;
class DumpSink_GCSDefaultTypeInternal;
extern DumpSink_GCSDefaultTypeInternal _DumpSink_GCS_default_instance_;
class DumpSink_HDFS;
class DumpSink_HDFSDefaultTypeInternal;
extern DumpSink_HDFSDefaultTypeInternal _DumpSink_HDFS_default_instance_;
class DumpSink_Http;
class DumpSink_HttpDefaultTypeInternal;
extern DumpSink_HttpDefaultTypeInternal _DumpSink_Http_default_instance_;
class DumpSink_KAFKA;
class DumpSink_KAFKADefaultTypeInternal;
extern DumpSink_KAFKADefaultTypeInternal _DumpSink_KAFKA_default_instance_;
class DumpSink_LocalFilePath;
class DumpSink_LocalFilePathDefaultTypeInternal;
extern DumpSink_LocalFilePathDefaultTypeInternal _DumpSink_LocalFilePath_default_instance_;
class DumpSink_S3;
class DumpSink_S3DefaultTypeInternal;
extern DumpSink_S3DefaultTypeInternal _DumpSink_S3_default_instance_;
class DumpSink_Workload;
class DumpSink_WorkloadDefaultTypeInternal;
extern DumpSink_WorkloadDefaultTypeInternal _DumpSink_Workload_default_instance_;
class EndTransactionRequest;
class EndTransactionRequestDefaultTypeInternal;
extern EndTransactionRequestDefaultTypeInternal _EndTransactionRequest_default_instance_;
class EndTransactionResponse;
class EndTransactionResponseDefaultTypeInternal;
extern EndTransactionResponseDefaultTypeInternal _EndTransactionResponse_default_instance_;
class ExportRequest;
class ExportRequestDefaultTypeInternal;
extern ExportRequestDefaultTypeInternal _ExportRequest_default_instance_;
class ExportResponse;
class ExportResponseDefaultTypeInternal;
extern ExportResponseDefaultTypeInternal _ExportResponse_default_instance_;
class ExportResponse_File;
class ExportResponse_FileDefaultTypeInternal;
extern ExportResponse_FileDefaultTypeInternal _ExportResponse_File_default_instance_;
class ExportStorage;
class ExportStorageDefaultTypeInternal;
extern ExportStorageDefaultTypeInternal _ExportStorage_default_instance_;
class ExportStorage_Azure;
class ExportStorage_AzureDefaultTypeInternal;
extern ExportStorage_AzureDefaultTypeInternal _ExportStorage_Azure_default_instance_;
class ExportStorage_GCS;
class ExportStorage_GCSDefaultTypeInternal;
extern ExportStorage_GCSDefaultTypeInternal _ExportStorage_GCS_default_instance_;
class ExportStorage_Http;
class ExportStorage_HttpDefaultTypeInternal;
extern ExportStorage_HttpDefaultTypeInternal _ExportStorage_Http_default_instance_;
class ExportStorage_LocalFilePath;
class ExportStorage_LocalFilePathDefaultTypeInternal;
extern ExportStorage_LocalFilePathDefaultTypeInternal _ExportStorage_LocalFilePath_default_instance_;
class ExportStorage_S3;
class ExportStorage_S3DefaultTypeInternal;
extern ExportStorage_S3DefaultTypeInternal _ExportStorage_S3_default_instance_;
class ExportStorage_Workload;
class ExportStorage_WorkloadDefaultTypeInternal;
extern ExportStorage_WorkloadDefaultTypeInternal _ExportStorage_Workload_default_instance_;
class FileEncryptionOptions;
class FileEncryptionOptionsDefaultTypeInternal;
extern FileEncryptionOptionsDefaultTypeInternal _FileEncryptionOptions_default_instance_;
class GCRequest;
class GCRequestDefaultTypeInternal;
extern GCRequestDefaultTypeInternal _GCRequest_default_instance_;
class GCRequest_GCKey;
class GCRequest_GCKeyDefaultTypeInternal;
extern GCRequest_GCKeyDefaultTypeInternal _GCRequest_GCKey_default_instance_;
class GCResponse;
class GCResponseDefaultTypeInternal;
extern GCResponseDefaultTypeInternal _GCResponse_default_instance_;
class GetRequest;
class GetRequestDefaultTypeInternal;
extern GetRequestDefaultTypeInternal _GetRequest_default_instance_;
class GetResponse;
class GetResponseDefaultTypeInternal;
extern GetResponseDefaultTypeInternal _GetResponse_default_instance_;
class Header;
class HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class HeartbeatTxnRequest;
class HeartbeatTxnRequestDefaultTypeInternal;
extern HeartbeatTxnRequestDefaultTypeInternal _HeartbeatTxnRequest_default_instance_;
class HeartbeatTxnResponse;
class HeartbeatTxnResponseDefaultTypeInternal;
extern HeartbeatTxnResponseDefaultTypeInternal _HeartbeatTxnResponse_default_instance_;
class ImportRequest;
class ImportRequestDefaultTypeInternal;
extern ImportRequestDefaultTypeInternal _ImportRequest_default_instance_;
class ImportRequest_File;
class ImportRequest_FileDefaultTypeInternal;
extern ImportRequest_FileDefaultTypeInternal _ImportRequest_File_default_instance_;
class ImportRequest_TableRekey;
class ImportRequest_TableRekeyDefaultTypeInternal;
extern ImportRequest_TableRekeyDefaultTypeInternal _ImportRequest_TableRekey_default_instance_;
class ImportResponse;
class ImportResponseDefaultTypeInternal;
extern ImportResponseDefaultTypeInternal _ImportResponse_default_instance_;
class IncrementRequest;
class IncrementRequestDefaultTypeInternal;
extern IncrementRequestDefaultTypeInternal _IncrementRequest_default_instance_;
class IncrementResponse;
class IncrementResponseDefaultTypeInternal;
extern IncrementResponseDefaultTypeInternal _IncrementResponse_default_instance_;
class InitPutRequest;
class InitPutRequestDefaultTypeInternal;
extern InitPutRequestDefaultTypeInternal _InitPutRequest_default_instance_;
class InitPutResponse;
class InitPutResponseDefaultTypeInternal;
extern InitPutResponseDefaultTypeInternal _InitPutResponse_default_instance_;
class LeaseInfoRequest;
class LeaseInfoRequestDefaultTypeInternal;
extern LeaseInfoRequestDefaultTypeInternal _LeaseInfoRequest_default_instance_;
class LeaseInfoResponse;
class LeaseInfoResponseDefaultTypeInternal;
extern LeaseInfoResponseDefaultTypeInternal _LeaseInfoResponse_default_instance_;
class LoadRequest;
class LoadRequestDefaultTypeInternal;
extern LoadRequestDefaultTypeInternal _LoadRequest_default_instance_;
class LoadRequest_File;
class LoadRequest_FileDefaultTypeInternal;
extern LoadRequest_FileDefaultTypeInternal _LoadRequest_File_default_instance_;
class LoadRequest_TableRekey;
class LoadRequest_TableRekeyDefaultTypeInternal;
extern LoadRequest_TableRekeyDefaultTypeInternal _LoadRequest_TableRekey_default_instance_;
class LoadResponse;
class LoadResponseDefaultTypeInternal;
extern LoadResponseDefaultTypeInternal _LoadResponse_default_instance_;
class MergeRequest;
class MergeRequestDefaultTypeInternal;
extern MergeRequestDefaultTypeInternal _MergeRequest_default_instance_;
class MergeResponse;
class MergeResponseDefaultTypeInternal;
extern MergeResponseDefaultTypeInternal _MergeResponse_default_instance_;
class PushTxnRequest;
class PushTxnRequestDefaultTypeInternal;
extern PushTxnRequestDefaultTypeInternal _PushTxnRequest_default_instance_;
class PushTxnResponse;
class PushTxnResponseDefaultTypeInternal;
extern PushTxnResponseDefaultTypeInternal _PushTxnResponse_default_instance_;
class PutRequest;
class PutRequestDefaultTypeInternal;
extern PutRequestDefaultTypeInternal _PutRequest_default_instance_;
class PutResponse;
class PutResponseDefaultTypeInternal;
extern PutResponseDefaultTypeInternal _PutResponse_default_instance_;
class QueryIntentRequest;
class QueryIntentRequestDefaultTypeInternal;
extern QueryIntentRequestDefaultTypeInternal _QueryIntentRequest_default_instance_;
class QueryIntentResponse;
class QueryIntentResponseDefaultTypeInternal;
extern QueryIntentResponseDefaultTypeInternal _QueryIntentResponse_default_instance_;
class QueryLockRequest;
class QueryLockRequestDefaultTypeInternal;
extern QueryLockRequestDefaultTypeInternal _QueryLockRequest_default_instance_;
class QueryLockResponse;
class QueryLockResponseDefaultTypeInternal;
extern QueryLockResponseDefaultTypeInternal _QueryLockResponse_default_instance_;
class QueryTxnRequest;
class QueryTxnRequestDefaultTypeInternal;
extern QueryTxnRequestDefaultTypeInternal _QueryTxnRequest_default_instance_;
class QueryTxnResponse;
class QueryTxnResponseDefaultTypeInternal;
extern QueryTxnResponseDefaultTypeInternal _QueryTxnResponse_default_instance_;
class RangeFeedCheckpoint;
class RangeFeedCheckpointDefaultTypeInternal;
extern RangeFeedCheckpointDefaultTypeInternal _RangeFeedCheckpoint_default_instance_;
class RangeFeedError;
class RangeFeedErrorDefaultTypeInternal;
extern RangeFeedErrorDefaultTypeInternal _RangeFeedError_default_instance_;
class RangeFeedEvent;
class RangeFeedEventDefaultTypeInternal;
extern RangeFeedEventDefaultTypeInternal _RangeFeedEvent_default_instance_;
class RangeFeedRequest;
class RangeFeedRequestDefaultTypeInternal;
extern RangeFeedRequestDefaultTypeInternal _RangeFeedRequest_default_instance_;
class RangeFeedValue;
class RangeFeedValueDefaultTypeInternal;
extern RangeFeedValueDefaultTypeInternal _RangeFeedValue_default_instance_;
class RangeInfo;
class RangeInfoDefaultTypeInternal;
extern RangeInfoDefaultTypeInternal _RangeInfo_default_instance_;
class RangeStatsRequest;
class RangeStatsRequestDefaultTypeInternal;
extern RangeStatsRequestDefaultTypeInternal _RangeStatsRequest_default_instance_;
class RangeStatsResponse;
class RangeStatsResponseDefaultTypeInternal;
extern RangeStatsResponseDefaultTypeInternal _RangeStatsResponse_default_instance_;
class RecomputeStatsRequest;
class RecomputeStatsRequestDefaultTypeInternal;
extern RecomputeStatsRequestDefaultTypeInternal _RecomputeStatsRequest_default_instance_;
class RecomputeStatsResponse;
class RecomputeStatsResponseDefaultTypeInternal;
extern RecomputeStatsResponseDefaultTypeInternal _RecomputeStatsResponse_default_instance_;
class RecoverTxnRequest;
class RecoverTxnRequestDefaultTypeInternal;
extern RecoverTxnRequestDefaultTypeInternal _RecoverTxnRequest_default_instance_;
class RecoverTxnResponse;
class RecoverTxnResponseDefaultTypeInternal;
extern RecoverTxnResponseDefaultTypeInternal _RecoverTxnResponse_default_instance_;
class RefreshRangeRequest;
class RefreshRangeRequestDefaultTypeInternal;
extern RefreshRangeRequestDefaultTypeInternal _RefreshRangeRequest_default_instance_;
class RefreshRangeResponse;
class RefreshRangeResponseDefaultTypeInternal;
extern RefreshRangeResponseDefaultTypeInternal _RefreshRangeResponse_default_instance_;
class RefreshRequest;
class RefreshRequestDefaultTypeInternal;
extern RefreshRequestDefaultTypeInternal _RefreshRequest_default_instance_;
class RefreshResponse;
class RefreshResponseDefaultTypeInternal;
extern RefreshResponseDefaultTypeInternal _RefreshResponse_default_instance_;
class RequestHeader;
class RequestHeaderDefaultTypeInternal;
extern RequestHeaderDefaultTypeInternal _RequestHeader_default_instance_;
class RequestLeaseRequest;
class RequestLeaseRequestDefaultTypeInternal;
extern RequestLeaseRequestDefaultTypeInternal _RequestLeaseRequest_default_instance_;
class RequestLeaseResponse;
class RequestLeaseResponseDefaultTypeInternal;
extern RequestLeaseResponseDefaultTypeInternal _RequestLeaseResponse_default_instance_;
class RequestUnion;
class RequestUnionDefaultTypeInternal;
extern RequestUnionDefaultTypeInternal _RequestUnion_default_instance_;
class ResolveIntentRangeRequest;
class ResolveIntentRangeRequestDefaultTypeInternal;
extern ResolveIntentRangeRequestDefaultTypeInternal _ResolveIntentRangeRequest_default_instance_;
class ResolveIntentRangeResponse;
class ResolveIntentRangeResponseDefaultTypeInternal;
extern ResolveIntentRangeResponseDefaultTypeInternal _ResolveIntentRangeResponse_default_instance_;
class ResolveIntentRequest;
class ResolveIntentRequestDefaultTypeInternal;
extern ResolveIntentRequestDefaultTypeInternal _ResolveIntentRequest_default_instance_;
class ResolveIntentResponse;
class ResolveIntentResponseDefaultTypeInternal;
extern ResolveIntentResponseDefaultTypeInternal _ResolveIntentResponse_default_instance_;
class ResponseHeader;
class ResponseHeaderDefaultTypeInternal;
extern ResponseHeaderDefaultTypeInternal _ResponseHeader_default_instance_;
class ResponseUnion;
class ResponseUnionDefaultTypeInternal;
extern ResponseUnionDefaultTypeInternal _ResponseUnion_default_instance_;
class Result;
class ResultDefaultTypeInternal;
extern ResultDefaultTypeInternal _Result_default_instance_;
class ReverseScanRequest;
class ReverseScanRequestDefaultTypeInternal;
extern ReverseScanRequestDefaultTypeInternal _ReverseScanRequest_default_instance_;
class ReverseScanResponse;
class ReverseScanResponseDefaultTypeInternal;
extern ReverseScanResponseDefaultTypeInternal _ReverseScanResponse_default_instance_;
class RevertRangeRequest;
class RevertRangeRequestDefaultTypeInternal;
extern RevertRangeRequestDefaultTypeInternal _RevertRangeRequest_default_instance_;
class RevertRangeResponse;
class RevertRangeResponseDefaultTypeInternal;
extern RevertRangeResponseDefaultTypeInternal _RevertRangeResponse_default_instance_;
class RevertRequest;
class RevertRequestDefaultTypeInternal;
extern RevertRequestDefaultTypeInternal _RevertRequest_default_instance_;
class RevertResponse;
class RevertResponseDefaultTypeInternal;
extern RevertResponseDefaultTypeInternal _RevertResponse_default_instance_;
class ScanOptions;
class ScanOptionsDefaultTypeInternal;
extern ScanOptionsDefaultTypeInternal _ScanOptions_default_instance_;
class ScanRequest;
class ScanRequestDefaultTypeInternal;
extern ScanRequestDefaultTypeInternal _ScanRequest_default_instance_;
class ScanResponse;
class ScanResponseDefaultTypeInternal;
extern ScanResponseDefaultTypeInternal _ScanResponse_default_instance_;
class SubsumeRequest;
class SubsumeRequestDefaultTypeInternal;
extern SubsumeRequestDefaultTypeInternal _SubsumeRequest_default_instance_;
class SubsumeResponse;
class SubsumeResponseDefaultTypeInternal;
extern SubsumeResponseDefaultTypeInternal _SubsumeResponse_default_instance_;
class TransferLeaseRequest;
class TransferLeaseRequestDefaultTypeInternal;
extern TransferLeaseRequestDefaultTypeInternal _TransferLeaseRequest_default_instance_;
class TruncateLogRequest;
class TruncateLogRequestDefaultTypeInternal;
extern TruncateLogRequestDefaultTypeInternal _TruncateLogRequest_default_instance_;
class TruncateLogResponse;
class TruncateLogResponseDefaultTypeInternal;
extern TruncateLogResponseDefaultTypeInternal _TruncateLogResponse_default_instance_;
class VecScanRequest;
class VecScanRequestDefaultTypeInternal;
extern VecScanRequestDefaultTypeInternal _VecScanRequest_default_instance_;
class VecScanResponse;
class VecScanResponseDefaultTypeInternal;
extern VecScanResponseDefaultTypeInternal _VecScanResponse_default_instance_;
class WriteBatchRequest;
class WriteBatchRequestDefaultTypeInternal;
extern WriteBatchRequestDefaultTypeInternal _WriteBatchRequest_default_instance_;
class WriteBatchResponse;
class WriteBatchResponseDefaultTypeInternal;
extern WriteBatchResponseDefaultTypeInternal _WriteBatchResponse_default_instance_;
}  // namespace roachpb
}  // namespace znbase
namespace google {
namespace protobuf {
template<> ::znbase::roachpb::AddSSTableRequest* Arena::CreateMaybeMessage<::znbase::roachpb::AddSSTableRequest>(Arena*);
template<> ::znbase::roachpb::AddSSTableResponse* Arena::CreateMaybeMessage<::znbase::roachpb::AddSSTableResponse>(Arena*);
template<> ::znbase::roachpb::AdminChangeReplicasRequest* Arena::CreateMaybeMessage<::znbase::roachpb::AdminChangeReplicasRequest>(Arena*);
template<> ::znbase::roachpb::AdminChangeReplicasResponse* Arena::CreateMaybeMessage<::znbase::roachpb::AdminChangeReplicasResponse>(Arena*);
template<> ::znbase::roachpb::AdminMergeRequest* Arena::CreateMaybeMessage<::znbase::roachpb::AdminMergeRequest>(Arena*);
template<> ::znbase::roachpb::AdminMergeResponse* Arena::CreateMaybeMessage<::znbase::roachpb::AdminMergeResponse>(Arena*);
template<> ::znbase::roachpb::AdminRelocateRangeRequest* Arena::CreateMaybeMessage<::znbase::roachpb::AdminRelocateRangeRequest>(Arena*);
template<> ::znbase::roachpb::AdminRelocateRangeResponse* Arena::CreateMaybeMessage<::znbase::roachpb::AdminRelocateRangeResponse>(Arena*);
template<> ::znbase::roachpb::AdminScatterRequest* Arena::CreateMaybeMessage<::znbase::roachpb::AdminScatterRequest>(Arena*);
template<> ::znbase::roachpb::AdminScatterResponse* Arena::CreateMaybeMessage<::znbase::roachpb::AdminScatterResponse>(Arena*);
template<> ::znbase::roachpb::AdminScatterResponse_Range* Arena::CreateMaybeMessage<::znbase::roachpb::AdminScatterResponse_Range>(Arena*);
template<> ::znbase::roachpb::AdminSplitRequest* Arena::CreateMaybeMessage<::znbase::roachpb::AdminSplitRequest>(Arena*);
template<> ::znbase::roachpb::AdminSplitResponse* Arena::CreateMaybeMessage<::znbase::roachpb::AdminSplitResponse>(Arena*);
template<> ::znbase::roachpb::AdminTransferLeaseRequest* Arena::CreateMaybeMessage<::znbase::roachpb::AdminTransferLeaseRequest>(Arena*);
template<> ::znbase::roachpb::AdminTransferLeaseResponse* Arena::CreateMaybeMessage<::znbase::roachpb::AdminTransferLeaseResponse>(Arena*);
template<> ::znbase::roachpb::BatchRequest* Arena::CreateMaybeMessage<::znbase::roachpb::BatchRequest>(Arena*);
template<> ::znbase::roachpb::BatchResponse* Arena::CreateMaybeMessage<::znbase::roachpb::BatchResponse>(Arena*);
template<> ::znbase::roachpb::BatchResponse_Header* Arena::CreateMaybeMessage<::znbase::roachpb::BatchResponse_Header>(Arena*);
template<> ::znbase::roachpb::BulkOpSummary* Arena::CreateMaybeMessage<::znbase::roachpb::BulkOpSummary>(Arena*);
template<> ::znbase::roachpb::CheckConsistencyRequest* Arena::CreateMaybeMessage<::znbase::roachpb::CheckConsistencyRequest>(Arena*);
template<> ::znbase::roachpb::CheckConsistencyResponse* Arena::CreateMaybeMessage<::znbase::roachpb::CheckConsistencyResponse>(Arena*);
template<> ::znbase::roachpb::CheckConsistencyResponse_Result* Arena::CreateMaybeMessage<::znbase::roachpb::CheckConsistencyResponse_Result>(Arena*);
template<> ::znbase::roachpb::ClearIntentRequest* Arena::CreateMaybeMessage<::znbase::roachpb::ClearIntentRequest>(Arena*);
template<> ::znbase::roachpb::ClearIntentResponse* Arena::CreateMaybeMessage<::znbase::roachpb::ClearIntentResponse>(Arena*);
template<> ::znbase::roachpb::ClearRangeRequest* Arena::CreateMaybeMessage<::znbase::roachpb::ClearRangeRequest>(Arena*);
template<> ::znbase::roachpb::ClearRangeResponse* Arena::CreateMaybeMessage<::znbase::roachpb::ClearRangeResponse>(Arena*);
template<> ::znbase::roachpb::ComputeChecksumRequest* Arena::CreateMaybeMessage<::znbase::roachpb::ComputeChecksumRequest>(Arena*);
template<> ::znbase::roachpb::ComputeChecksumResponse* Arena::CreateMaybeMessage<::znbase::roachpb::ComputeChecksumResponse>(Arena*);
template<> ::znbase::roachpb::ConditionalPutRequest* Arena::CreateMaybeMessage<::znbase::roachpb::ConditionalPutRequest>(Arena*);
template<> ::znbase::roachpb::ConditionalPutResponse* Arena::CreateMaybeMessage<::znbase::roachpb::ConditionalPutResponse>(Arena*);
template<> ::znbase::roachpb::DeleteRangeRequest* Arena::CreateMaybeMessage<::znbase::roachpb::DeleteRangeRequest>(Arena*);
template<> ::znbase::roachpb::DeleteRangeResponse* Arena::CreateMaybeMessage<::znbase::roachpb::DeleteRangeResponse>(Arena*);
template<> ::znbase::roachpb::DeleteRequest* Arena::CreateMaybeMessage<::znbase::roachpb::DeleteRequest>(Arena*);
template<> ::znbase::roachpb::DeleteResponse* Arena::CreateMaybeMessage<::znbase::roachpb::DeleteResponse>(Arena*);
template<> ::znbase::roachpb::DumpOnlineRequest* Arena::CreateMaybeMessage<::znbase::roachpb::DumpOnlineRequest>(Arena*);
template<> ::znbase::roachpb::DumpOnlineResponse* Arena::CreateMaybeMessage<::znbase::roachpb::DumpOnlineResponse>(Arena*);
template<> ::znbase::roachpb::DumpOnlineResponse_File* Arena::CreateMaybeMessage<::znbase::roachpb::DumpOnlineResponse_File>(Arena*);
template<> ::znbase::roachpb::DumpOnlineResponse_Files* Arena::CreateMaybeMessage<::znbase::roachpb::DumpOnlineResponse_Files>(Arena*);
template<> ::znbase::roachpb::DumpRequest* Arena::CreateMaybeMessage<::znbase::roachpb::DumpRequest>(Arena*);
template<> ::znbase::roachpb::DumpResponse* Arena::CreateMaybeMessage<::znbase::roachpb::DumpResponse>(Arena*);
template<> ::znbase::roachpb::DumpResponse_File* Arena::CreateMaybeMessage<::znbase::roachpb::DumpResponse_File>(Arena*);
template<> ::znbase::roachpb::DumpSink* Arena::CreateMaybeMessage<::znbase::roachpb::DumpSink>(Arena*);
template<> ::znbase::roachpb::DumpSink_Azure* Arena::CreateMaybeMessage<::znbase::roachpb::DumpSink_Azure>(Arena*);
template<> ::znbase::roachpb::DumpSink_GCS* Arena::CreateMaybeMessage<::znbase::roachpb::DumpSink_GCS>(Arena*);
template<> ::znbase::roachpb::DumpSink_HDFS* Arena::CreateMaybeMessage<::znbase::roachpb::DumpSink_HDFS>(Arena*);
template<> ::znbase::roachpb::DumpSink_Http* Arena::CreateMaybeMessage<::znbase::roachpb::DumpSink_Http>(Arena*);
template<> ::znbase::roachpb::DumpSink_KAFKA* Arena::CreateMaybeMessage<::znbase::roachpb::DumpSink_KAFKA>(Arena*);
template<> ::znbase::roachpb::DumpSink_LocalFilePath* Arena::CreateMaybeMessage<::znbase::roachpb::DumpSink_LocalFilePath>(Arena*);
template<> ::znbase::roachpb::DumpSink_S3* Arena::CreateMaybeMessage<::znbase::roachpb::DumpSink_S3>(Arena*);
template<> ::znbase::roachpb::DumpSink_Workload* Arena::CreateMaybeMessage<::znbase::roachpb::DumpSink_Workload>(Arena*);
template<> ::znbase::roachpb::EndTransactionRequest* Arena::CreateMaybeMessage<::znbase::roachpb::EndTransactionRequest>(Arena*);
template<> ::znbase::roachpb::EndTransactionResponse* Arena::CreateMaybeMessage<::znbase::roachpb::EndTransactionResponse>(Arena*);
template<> ::znbase::roachpb::ExportRequest* Arena::CreateMaybeMessage<::znbase::roachpb::ExportRequest>(Arena*);
template<> ::znbase::roachpb::ExportResponse* Arena::CreateMaybeMessage<::znbase::roachpb::ExportResponse>(Arena*);
template<> ::znbase::roachpb::ExportResponse_File* Arena::CreateMaybeMessage<::znbase::roachpb::ExportResponse_File>(Arena*);
template<> ::znbase::roachpb::ExportStorage* Arena::CreateMaybeMessage<::znbase::roachpb::ExportStorage>(Arena*);
template<> ::znbase::roachpb::ExportStorage_Azure* Arena::CreateMaybeMessage<::znbase::roachpb::ExportStorage_Azure>(Arena*);
template<> ::znbase::roachpb::ExportStorage_GCS* Arena::CreateMaybeMessage<::znbase::roachpb::ExportStorage_GCS>(Arena*);
template<> ::znbase::roachpb::ExportStorage_Http* Arena::CreateMaybeMessage<::znbase::roachpb::ExportStorage_Http>(Arena*);
template<> ::znbase::roachpb::ExportStorage_LocalFilePath* Arena::CreateMaybeMessage<::znbase::roachpb::ExportStorage_LocalFilePath>(Arena*);
template<> ::znbase::roachpb::ExportStorage_S3* Arena::CreateMaybeMessage<::znbase::roachpb::ExportStorage_S3>(Arena*);
template<> ::znbase::roachpb::ExportStorage_Workload* Arena::CreateMaybeMessage<::znbase::roachpb::ExportStorage_Workload>(Arena*);
template<> ::znbase::roachpb::FileEncryptionOptions* Arena::CreateMaybeMessage<::znbase::roachpb::FileEncryptionOptions>(Arena*);
template<> ::znbase::roachpb::GCRequest* Arena::CreateMaybeMessage<::znbase::roachpb::GCRequest>(Arena*);
template<> ::znbase::roachpb::GCRequest_GCKey* Arena::CreateMaybeMessage<::znbase::roachpb::GCRequest_GCKey>(Arena*);
template<> ::znbase::roachpb::GCResponse* Arena::CreateMaybeMessage<::znbase::roachpb::GCResponse>(Arena*);
template<> ::znbase::roachpb::GetRequest* Arena::CreateMaybeMessage<::znbase::roachpb::GetRequest>(Arena*);
template<> ::znbase::roachpb::GetResponse* Arena::CreateMaybeMessage<::znbase::roachpb::GetResponse>(Arena*);
template<> ::znbase::roachpb::Header* Arena::CreateMaybeMessage<::znbase::roachpb::Header>(Arena*);
template<> ::znbase::roachpb::HeartbeatTxnRequest* Arena::CreateMaybeMessage<::znbase::roachpb::HeartbeatTxnRequest>(Arena*);
template<> ::znbase::roachpb::HeartbeatTxnResponse* Arena::CreateMaybeMessage<::znbase::roachpb::HeartbeatTxnResponse>(Arena*);
template<> ::znbase::roachpb::ImportRequest* Arena::CreateMaybeMessage<::znbase::roachpb::ImportRequest>(Arena*);
template<> ::znbase::roachpb::ImportRequest_File* Arena::CreateMaybeMessage<::znbase::roachpb::ImportRequest_File>(Arena*);
template<> ::znbase::roachpb::ImportRequest_TableRekey* Arena::CreateMaybeMessage<::znbase::roachpb::ImportRequest_TableRekey>(Arena*);
template<> ::znbase::roachpb::ImportResponse* Arena::CreateMaybeMessage<::znbase::roachpb::ImportResponse>(Arena*);
template<> ::znbase::roachpb::IncrementRequest* Arena::CreateMaybeMessage<::znbase::roachpb::IncrementRequest>(Arena*);
template<> ::znbase::roachpb::IncrementResponse* Arena::CreateMaybeMessage<::znbase::roachpb::IncrementResponse>(Arena*);
template<> ::znbase::roachpb::InitPutRequest* Arena::CreateMaybeMessage<::znbase::roachpb::InitPutRequest>(Arena*);
template<> ::znbase::roachpb::InitPutResponse* Arena::CreateMaybeMessage<::znbase::roachpb::InitPutResponse>(Arena*);
template<> ::znbase::roachpb::LeaseInfoRequest* Arena::CreateMaybeMessage<::znbase::roachpb::LeaseInfoRequest>(Arena*);
template<> ::znbase::roachpb::LeaseInfoResponse* Arena::CreateMaybeMessage<::znbase::roachpb::LeaseInfoResponse>(Arena*);
template<> ::znbase::roachpb::LoadRequest* Arena::CreateMaybeMessage<::znbase::roachpb::LoadRequest>(Arena*);
template<> ::znbase::roachpb::LoadRequest_File* Arena::CreateMaybeMessage<::znbase::roachpb::LoadRequest_File>(Arena*);
template<> ::znbase::roachpb::LoadRequest_TableRekey* Arena::CreateMaybeMessage<::znbase::roachpb::LoadRequest_TableRekey>(Arena*);
template<> ::znbase::roachpb::LoadResponse* Arena::CreateMaybeMessage<::znbase::roachpb::LoadResponse>(Arena*);
template<> ::znbase::roachpb::MergeRequest* Arena::CreateMaybeMessage<::znbase::roachpb::MergeRequest>(Arena*);
template<> ::znbase::roachpb::MergeResponse* Arena::CreateMaybeMessage<::znbase::roachpb::MergeResponse>(Arena*);
template<> ::znbase::roachpb::PushTxnRequest* Arena::CreateMaybeMessage<::znbase::roachpb::PushTxnRequest>(Arena*);
template<> ::znbase::roachpb::PushTxnResponse* Arena::CreateMaybeMessage<::znbase::roachpb::PushTxnResponse>(Arena*);
template<> ::znbase::roachpb::PutRequest* Arena::CreateMaybeMessage<::znbase::roachpb::PutRequest>(Arena*);
template<> ::znbase::roachpb::PutResponse* Arena::CreateMaybeMessage<::znbase::roachpb::PutResponse>(Arena*);
template<> ::znbase::roachpb::QueryIntentRequest* Arena::CreateMaybeMessage<::znbase::roachpb::QueryIntentRequest>(Arena*);
template<> ::znbase::roachpb::QueryIntentResponse* Arena::CreateMaybeMessage<::znbase::roachpb::QueryIntentResponse>(Arena*);
template<> ::znbase::roachpb::QueryLockRequest* Arena::CreateMaybeMessage<::znbase::roachpb::QueryLockRequest>(Arena*);
template<> ::znbase::roachpb::QueryLockResponse* Arena::CreateMaybeMessage<::znbase::roachpb::QueryLockResponse>(Arena*);
template<> ::znbase::roachpb::QueryTxnRequest* Arena::CreateMaybeMessage<::znbase::roachpb::QueryTxnRequest>(Arena*);
template<> ::znbase::roachpb::QueryTxnResponse* Arena::CreateMaybeMessage<::znbase::roachpb::QueryTxnResponse>(Arena*);
template<> ::znbase::roachpb::RangeFeedCheckpoint* Arena::CreateMaybeMessage<::znbase::roachpb::RangeFeedCheckpoint>(Arena*);
template<> ::znbase::roachpb::RangeFeedError* Arena::CreateMaybeMessage<::znbase::roachpb::RangeFeedError>(Arena*);
template<> ::znbase::roachpb::RangeFeedEvent* Arena::CreateMaybeMessage<::znbase::roachpb::RangeFeedEvent>(Arena*);
template<> ::znbase::roachpb::RangeFeedRequest* Arena::CreateMaybeMessage<::znbase::roachpb::RangeFeedRequest>(Arena*);
template<> ::znbase::roachpb::RangeFeedValue* Arena::CreateMaybeMessage<::znbase::roachpb::RangeFeedValue>(Arena*);
template<> ::znbase::roachpb::RangeInfo* Arena::CreateMaybeMessage<::znbase::roachpb::RangeInfo>(Arena*);
template<> ::znbase::roachpb::RangeStatsRequest* Arena::CreateMaybeMessage<::znbase::roachpb::RangeStatsRequest>(Arena*);
template<> ::znbase::roachpb::RangeStatsResponse* Arena::CreateMaybeMessage<::znbase::roachpb::RangeStatsResponse>(Arena*);
template<> ::znbase::roachpb::RecomputeStatsRequest* Arena::CreateMaybeMessage<::znbase::roachpb::RecomputeStatsRequest>(Arena*);
template<> ::znbase::roachpb::RecomputeStatsResponse* Arena::CreateMaybeMessage<::znbase::roachpb::RecomputeStatsResponse>(Arena*);
template<> ::znbase::roachpb::RecoverTxnRequest* Arena::CreateMaybeMessage<::znbase::roachpb::RecoverTxnRequest>(Arena*);
template<> ::znbase::roachpb::RecoverTxnResponse* Arena::CreateMaybeMessage<::znbase::roachpb::RecoverTxnResponse>(Arena*);
template<> ::znbase::roachpb::RefreshRangeRequest* Arena::CreateMaybeMessage<::znbase::roachpb::RefreshRangeRequest>(Arena*);
template<> ::znbase::roachpb::RefreshRangeResponse* Arena::CreateMaybeMessage<::znbase::roachpb::RefreshRangeResponse>(Arena*);
template<> ::znbase::roachpb::RefreshRequest* Arena::CreateMaybeMessage<::znbase::roachpb::RefreshRequest>(Arena*);
template<> ::znbase::roachpb::RefreshResponse* Arena::CreateMaybeMessage<::znbase::roachpb::RefreshResponse>(Arena*);
template<> ::znbase::roachpb::RequestHeader* Arena::CreateMaybeMessage<::znbase::roachpb::RequestHeader>(Arena*);
template<> ::znbase::roachpb::RequestLeaseRequest* Arena::CreateMaybeMessage<::znbase::roachpb::RequestLeaseRequest>(Arena*);
template<> ::znbase::roachpb::RequestLeaseResponse* Arena::CreateMaybeMessage<::znbase::roachpb::RequestLeaseResponse>(Arena*);
template<> ::znbase::roachpb::RequestUnion* Arena::CreateMaybeMessage<::znbase::roachpb::RequestUnion>(Arena*);
template<> ::znbase::roachpb::ResolveIntentRangeRequest* Arena::CreateMaybeMessage<::znbase::roachpb::ResolveIntentRangeRequest>(Arena*);
template<> ::znbase::roachpb::ResolveIntentRangeResponse* Arena::CreateMaybeMessage<::znbase::roachpb::ResolveIntentRangeResponse>(Arena*);
template<> ::znbase::roachpb::ResolveIntentRequest* Arena::CreateMaybeMessage<::znbase::roachpb::ResolveIntentRequest>(Arena*);
template<> ::znbase::roachpb::ResolveIntentResponse* Arena::CreateMaybeMessage<::znbase::roachpb::ResolveIntentResponse>(Arena*);
template<> ::znbase::roachpb::ResponseHeader* Arena::CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(Arena*);
template<> ::znbase::roachpb::ResponseUnion* Arena::CreateMaybeMessage<::znbase::roachpb::ResponseUnion>(Arena*);
template<> ::znbase::roachpb::Result* Arena::CreateMaybeMessage<::znbase::roachpb::Result>(Arena*);
template<> ::znbase::roachpb::ReverseScanRequest* Arena::CreateMaybeMessage<::znbase::roachpb::ReverseScanRequest>(Arena*);
template<> ::znbase::roachpb::ReverseScanResponse* Arena::CreateMaybeMessage<::znbase::roachpb::ReverseScanResponse>(Arena*);
template<> ::znbase::roachpb::RevertRangeRequest* Arena::CreateMaybeMessage<::znbase::roachpb::RevertRangeRequest>(Arena*);
template<> ::znbase::roachpb::RevertRangeResponse* Arena::CreateMaybeMessage<::znbase::roachpb::RevertRangeResponse>(Arena*);
template<> ::znbase::roachpb::RevertRequest* Arena::CreateMaybeMessage<::znbase::roachpb::RevertRequest>(Arena*);
template<> ::znbase::roachpb::RevertResponse* Arena::CreateMaybeMessage<::znbase::roachpb::RevertResponse>(Arena*);
template<> ::znbase::roachpb::ScanOptions* Arena::CreateMaybeMessage<::znbase::roachpb::ScanOptions>(Arena*);
template<> ::znbase::roachpb::ScanRequest* Arena::CreateMaybeMessage<::znbase::roachpb::ScanRequest>(Arena*);
template<> ::znbase::roachpb::ScanResponse* Arena::CreateMaybeMessage<::znbase::roachpb::ScanResponse>(Arena*);
template<> ::znbase::roachpb::SubsumeRequest* Arena::CreateMaybeMessage<::znbase::roachpb::SubsumeRequest>(Arena*);
template<> ::znbase::roachpb::SubsumeResponse* Arena::CreateMaybeMessage<::znbase::roachpb::SubsumeResponse>(Arena*);
template<> ::znbase::roachpb::TransferLeaseRequest* Arena::CreateMaybeMessage<::znbase::roachpb::TransferLeaseRequest>(Arena*);
template<> ::znbase::roachpb::TruncateLogRequest* Arena::CreateMaybeMessage<::znbase::roachpb::TruncateLogRequest>(Arena*);
template<> ::znbase::roachpb::TruncateLogResponse* Arena::CreateMaybeMessage<::znbase::roachpb::TruncateLogResponse>(Arena*);
template<> ::znbase::roachpb::VecScanRequest* Arena::CreateMaybeMessage<::znbase::roachpb::VecScanRequest>(Arena*);
template<> ::znbase::roachpb::VecScanResponse* Arena::CreateMaybeMessage<::znbase::roachpb::VecScanResponse>(Arena*);
template<> ::znbase::roachpb::WriteBatchRequest* Arena::CreateMaybeMessage<::znbase::roachpb::WriteBatchRequest>(Arena*);
template<> ::znbase::roachpb::WriteBatchResponse* Arena::CreateMaybeMessage<::znbase::roachpb::WriteBatchResponse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace znbase {
namespace roachpb {

enum ResponseHeader_ResumeReason {
  ResponseHeader_ResumeReason_RESUME_UNKNOWN = 0,
  ResponseHeader_ResumeReason_RESUME_KEY_LIMIT = 1,
  ResponseHeader_ResumeReason_RESUME_RANGE_BOUNDARY = 2,
  ResponseHeader_ResumeReason_ResponseHeader_ResumeReason_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ResponseHeader_ResumeReason_ResponseHeader_ResumeReason_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ResponseHeader_ResumeReason_IsValid(int value);
const ResponseHeader_ResumeReason ResponseHeader_ResumeReason_ResumeReason_MIN = ResponseHeader_ResumeReason_RESUME_UNKNOWN;
const ResponseHeader_ResumeReason ResponseHeader_ResumeReason_ResumeReason_MAX = ResponseHeader_ResumeReason_RESUME_RANGE_BOUNDARY;
const int ResponseHeader_ResumeReason_ResumeReason_ARRAYSIZE = ResponseHeader_ResumeReason_ResumeReason_MAX + 1;

enum CheckConsistencyResponse_Status {
  CheckConsistencyResponse_Status_RANGE_INDETERMINATE = 0,
  CheckConsistencyResponse_Status_RANGE_INCONSISTENT = 1,
  CheckConsistencyResponse_Status_RANGE_CONSISTENT = 2,
  CheckConsistencyResponse_Status_RANGE_CONSISTENT_STATS_ESTIMATED = 3,
  CheckConsistencyResponse_Status_RANGE_CONSISTENT_STATS_INCORRECT = 4,
  CheckConsistencyResponse_Status_CheckConsistencyResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CheckConsistencyResponse_Status_CheckConsistencyResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CheckConsistencyResponse_Status_IsValid(int value);
const CheckConsistencyResponse_Status CheckConsistencyResponse_Status_Status_MIN = CheckConsistencyResponse_Status_RANGE_INDETERMINATE;
const CheckConsistencyResponse_Status CheckConsistencyResponse_Status_Status_MAX = CheckConsistencyResponse_Status_RANGE_CONSISTENT_STATS_INCORRECT;
const int CheckConsistencyResponse_Status_Status_ARRAYSIZE = CheckConsistencyResponse_Status_Status_MAX + 1;

enum ReadConsistencyType {
  CONSISTENT = 0,
  READ_UNCOMMITTED = 1,
  INCONSISTENT = 2,
  ReadConsistencyType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ReadConsistencyType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ReadConsistencyType_IsValid(int value);
const ReadConsistencyType ReadConsistencyType_MIN = CONSISTENT;
const ReadConsistencyType ReadConsistencyType_MAX = INCONSISTENT;
const int ReadConsistencyType_ARRAYSIZE = ReadConsistencyType_MAX + 1;

enum ScanFormat {
  KEY_VALUES = 0,
  BATCH_RESPONSE = 1,
  COUNT_ONLY = 2,
  ScanFormat_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ScanFormat_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ScanFormat_IsValid(int value);
const ScanFormat ScanFormat_MIN = KEY_VALUES;
const ScanFormat ScanFormat_MAX = COUNT_ONLY;
const int ScanFormat_ARRAYSIZE = ScanFormat_MAX + 1;

enum ChecksumMode {
  CHECK_VIA_QUEUE = 0,
  CHECK_FULL = 1,
  CHECK_STATS = 2,
  ChecksumMode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ChecksumMode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ChecksumMode_IsValid(int value);
const ChecksumMode ChecksumMode_MIN = CHECK_VIA_QUEUE;
const ChecksumMode ChecksumMode_MAX = CHECK_STATS;
const int ChecksumMode_ARRAYSIZE = ChecksumMode_MAX + 1;

enum PushTxnType {
  PUSH_TIMESTAMP = 0,
  PUSH_ABORT = 1,
  PUSH_TOUCH = 2,
  PushTxnType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PushTxnType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PushTxnType_IsValid(int value);
const PushTxnType PushTxnType_MIN = PUSH_TIMESTAMP;
const PushTxnType PushTxnType_MAX = PUSH_TOUCH;
const int PushTxnType_ARRAYSIZE = PushTxnType_MAX + 1;

enum ExportStorageProvider {
  Unknown = 0,
  LocalFile = 1,
  Http = 2,
  S3 = 3,
  GoogleCloud = 4,
  Azure = 5,
  Workload = 6,
  HDFS = 7,
  KAFKA = 8,
  ExportStorageProvider_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ExportStorageProvider_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ExportStorageProvider_IsValid(int value);
const ExportStorageProvider ExportStorageProvider_MIN = Unknown;
const ExportStorageProvider ExportStorageProvider_MAX = KAFKA;
const int ExportStorageProvider_ARRAYSIZE = ExportStorageProvider_MAX + 1;

enum MVCCFilter {
  Latest = 0,
  All = 1,
  MVCCFilter_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MVCCFilter_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MVCCFilter_IsValid(int value);
const MVCCFilter MVCCFilter_MIN = Latest;
const MVCCFilter MVCCFilter_MAX = All;
const int MVCCFilter_ARRAYSIZE = MVCCFilter_MAX + 1;

enum FileCompression {
  None = 0,
  Gzip = 1,
  FileCompression_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  FileCompression_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool FileCompression_IsValid(int value);
const FileCompression FileCompression_MIN = None;
const FileCompression FileCompression_MAX = Gzip;
const int FileCompression_ARRAYSIZE = FileCompression_MAX + 1;

// ===================================================================

class RangeInfo : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.RangeInfo) */ {
 public:
  RangeInfo();
  virtual ~RangeInfo();

  RangeInfo(const RangeInfo& from);

  inline RangeInfo& operator=(const RangeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RangeInfo(RangeInfo&& from) noexcept
    : RangeInfo() {
    *this = ::std::move(from);
  }

  inline RangeInfo& operator=(RangeInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const RangeInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RangeInfo* internal_default_instance() {
    return reinterpret_cast<const RangeInfo*>(
               &_RangeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(RangeInfo* other);
  friend void swap(RangeInfo& a, RangeInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RangeInfo* New() const final {
    return CreateMaybeMessage<RangeInfo>(NULL);
  }

  RangeInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RangeInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const RangeInfo& from);
  void MergeFrom(const RangeInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RangeInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_desc() const;
  void clear_desc();
  static const int kDescFieldNumber = 1;
  private:
  const ::znbase::roachpb::RangeDescriptor& _internal_desc() const;
  public:
  const ::znbase::roachpb::RangeDescriptor& desc() const;
  ::znbase::roachpb::RangeDescriptor* release_desc();
  ::znbase::roachpb::RangeDescriptor* mutable_desc();
  void set_allocated_desc(::znbase::roachpb::RangeDescriptor* desc);

  bool has_lease() const;
  void clear_lease();
  static const int kLeaseFieldNumber = 2;
  private:
  const ::znbase::roachpb::Lease& _internal_lease() const;
  public:
  const ::znbase::roachpb::Lease& lease() const;
  ::znbase::roachpb::Lease* release_lease();
  ::znbase::roachpb::Lease* mutable_lease();
  void set_allocated_lease(::znbase::roachpb::Lease* lease);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.RangeInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::RangeDescriptor* desc_;
  ::znbase::roachpb::Lease* lease_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestHeader : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.RequestHeader) */ {
 public:
  RequestHeader();
  virtual ~RequestHeader();

  RequestHeader(const RequestHeader& from);

  inline RequestHeader& operator=(const RequestHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestHeader(RequestHeader&& from) noexcept
    : RequestHeader() {
    *this = ::std::move(from);
  }

  inline RequestHeader& operator=(RequestHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const RequestHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestHeader* internal_default_instance() {
    return reinterpret_cast<const RequestHeader*>(
               &_RequestHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(RequestHeader* other);
  friend void swap(RequestHeader& a, RequestHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestHeader* New() const final {
    return CreateMaybeMessage<RequestHeader>(NULL);
  }

  RequestHeader* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestHeader>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const RequestHeader& from);
  void MergeFrom(const RequestHeader& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  void clear_key();
  static const int kKeyFieldNumber = 3;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  void clear_end_key();
  static const int kEndKeyFieldNumber = 4;
  const ::std::string& end_key() const;
  void set_end_key(const ::std::string& value);
  #if LANG_CXX11
  void set_end_key(::std::string&& value);
  #endif
  void set_end_key(const char* value);
  void set_end_key(const void* value, size_t size);
  ::std::string* mutable_end_key();
  ::std::string* release_end_key();
  void set_allocated_end_key(::std::string* end_key);

  void clear_sequence();
  static const int kSequenceFieldNumber = 5;
  ::google::protobuf::int32 sequence() const;
  void set_sequence(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.RequestHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr end_key_;
  ::google::protobuf::int32 sequence_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseHeader : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.ResponseHeader) */ {
 public:
  ResponseHeader();
  virtual ~ResponseHeader();

  ResponseHeader(const ResponseHeader& from);

  inline ResponseHeader& operator=(const ResponseHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseHeader(ResponseHeader&& from) noexcept
    : ResponseHeader() {
    *this = ::std::move(from);
  }

  inline ResponseHeader& operator=(ResponseHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ResponseHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseHeader* internal_default_instance() {
    return reinterpret_cast<const ResponseHeader*>(
               &_ResponseHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ResponseHeader* other);
  friend void swap(ResponseHeader& a, ResponseHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseHeader* New() const final {
    return CreateMaybeMessage<ResponseHeader>(NULL);
  }

  ResponseHeader* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseHeader>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ResponseHeader& from);
  void MergeFrom(const ResponseHeader& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResponseHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ResponseHeader_ResumeReason ResumeReason;
  static const ResumeReason RESUME_UNKNOWN =
    ResponseHeader_ResumeReason_RESUME_UNKNOWN;
  static const ResumeReason RESUME_KEY_LIMIT =
    ResponseHeader_ResumeReason_RESUME_KEY_LIMIT;
  static const ResumeReason RESUME_RANGE_BOUNDARY =
    ResponseHeader_ResumeReason_RESUME_RANGE_BOUNDARY;
  static inline bool ResumeReason_IsValid(int value) {
    return ResponseHeader_ResumeReason_IsValid(value);
  }
  static const ResumeReason ResumeReason_MIN =
    ResponseHeader_ResumeReason_ResumeReason_MIN;
  static const ResumeReason ResumeReason_MAX =
    ResponseHeader_ResumeReason_ResumeReason_MAX;
  static const int ResumeReason_ARRAYSIZE =
    ResponseHeader_ResumeReason_ResumeReason_ARRAYSIZE;

  // accessors -------------------------------------------------------

  int range_infos_size() const;
  void clear_range_infos();
  static const int kRangeInfosFieldNumber = 6;
  ::znbase::roachpb::RangeInfo* mutable_range_infos(int index);
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::RangeInfo >*
      mutable_range_infos();
  const ::znbase::roachpb::RangeInfo& range_infos(int index) const;
  ::znbase::roachpb::RangeInfo* add_range_infos();
  const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::RangeInfo >&
      range_infos() const;

  // .znbase.roachpb.Transaction txn = 3;
  bool has_txn() const;
  void clear_txn();
  static const int kTxnFieldNumber = 3;
  private:
  const ::znbase::roachpb::Transaction& _internal_txn() const;
  public:
  const ::znbase::roachpb::Transaction& txn() const;
  ::znbase::roachpb::Transaction* release_txn();
  ::znbase::roachpb::Transaction* mutable_txn();
  void set_allocated_txn(::znbase::roachpb::Transaction* txn);

  // .znbase.roachpb.Span resume_span = 4;
  bool has_resume_span() const;
  void clear_resume_span();
  static const int kResumeSpanFieldNumber = 4;
  private:
  const ::znbase::roachpb::Span& _internal_resume_span() const;
  public:
  const ::znbase::roachpb::Span& resume_span() const;
  ::znbase::roachpb::Span* release_resume_span();
  ::znbase::roachpb::Span* mutable_resume_span();
  void set_allocated_resume_span(::znbase::roachpb::Span* resume_span);

  // int64 num_keys = 5;
  void clear_num_keys();
  static const int kNumKeysFieldNumber = 5;
  ::google::protobuf::int64 num_keys() const;
  void set_num_keys(::google::protobuf::int64 value);

  // .znbase.roachpb.ResponseHeader.ResumeReason resume_reason = 7;
  void clear_resume_reason();
  static const int kResumeReasonFieldNumber = 7;
  ::znbase::roachpb::ResponseHeader_ResumeReason resume_reason() const;
  void set_resume_reason(::znbase::roachpb::ResponseHeader_ResumeReason value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.ResponseHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::RangeInfo > range_infos_;
  ::znbase::roachpb::Transaction* txn_;
  ::znbase::roachpb::Span* resume_span_;
  ::google::protobuf::int64 num_keys_;
  int resume_reason_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.GetRequest) */ {
 public:
  GetRequest();
  virtual ~GetRequest();

  GetRequest(const GetRequest& from);

  inline GetRequest& operator=(const GetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetRequest(GetRequest&& from) noexcept
    : GetRequest() {
    *this = ::std::move(from);
  }

  inline GetRequest& operator=(GetRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const GetRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetRequest* internal_default_instance() {
    return reinterpret_cast<const GetRequest*>(
               &_GetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(GetRequest* other);
  friend void swap(GetRequest& a, GetRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetRequest* New() const final {
    return CreateMaybeMessage<GetRequest>(NULL);
  }

  GetRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const GetRequest& from);
  void MergeFrom(const GetRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.GetRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::RequestHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.GetResponse) */ {
 public:
  GetResponse();
  virtual ~GetResponse();

  GetResponse(const GetResponse& from);

  inline GetResponse& operator=(const GetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetResponse(GetResponse&& from) noexcept
    : GetResponse() {
    *this = ::std::move(from);
  }

  inline GetResponse& operator=(GetResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const GetResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetResponse* internal_default_instance() {
    return reinterpret_cast<const GetResponse*>(
               &_GetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(GetResponse* other);
  friend void swap(GetResponse& a, GetResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetResponse* New() const final {
    return CreateMaybeMessage<GetResponse>(NULL);
  }

  GetResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const GetResponse& from);
  void MergeFrom(const GetResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  // .znbase.roachpb.Value value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  private:
  const ::znbase::roachpb::Value& _internal_value() const;
  public:
  const ::znbase::roachpb::Value& value() const;
  ::znbase::roachpb::Value* release_value();
  ::znbase::roachpb::Value* mutable_value();
  void set_allocated_value(::znbase::roachpb::Value* value);

  // .znbase.roachpb.Value intent_value = 3;
  bool has_intent_value() const;
  void clear_intent_value();
  static const int kIntentValueFieldNumber = 3;
  private:
  const ::znbase::roachpb::Value& _internal_intent_value() const;
  public:
  const ::znbase::roachpb::Value& intent_value() const;
  ::znbase::roachpb::Value* release_intent_value();
  ::znbase::roachpb::Value* mutable_intent_value();
  void set_allocated_intent_value(::znbase::roachpb::Value* intent_value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.GetResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::ResponseHeader* header_;
  ::znbase::roachpb::Value* value_;
  ::znbase::roachpb::Value* intent_value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PutRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.PutRequest) */ {
 public:
  PutRequest();
  virtual ~PutRequest();

  PutRequest(const PutRequest& from);

  inline PutRequest& operator=(const PutRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PutRequest(PutRequest&& from) noexcept
    : PutRequest() {
    *this = ::std::move(from);
  }

  inline PutRequest& operator=(PutRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const PutRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PutRequest* internal_default_instance() {
    return reinterpret_cast<const PutRequest*>(
               &_PutRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(PutRequest* other);
  friend void swap(PutRequest& a, PutRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PutRequest* New() const final {
    return CreateMaybeMessage<PutRequest>(NULL);
  }

  PutRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PutRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const PutRequest& from);
  void MergeFrom(const PutRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PutRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  private:
  const ::znbase::roachpb::Value& _internal_value() const;
  public:
  const ::znbase::roachpb::Value& value() const;
  ::znbase::roachpb::Value* release_value();
  ::znbase::roachpb::Value* mutable_value();
  void set_allocated_value(::znbase::roachpb::Value* value);

  // .znbase.util.hlc.Timestamp key_timestamp = 6;
  bool has_key_timestamp() const;
  void clear_key_timestamp();
  static const int kKeyTimestampFieldNumber = 6;
  private:
  const ::znbase::util::hlc::Timestamp& _internal_key_timestamp() const;
  public:
  const ::znbase::util::hlc::Timestamp& key_timestamp() const;
  ::znbase::util::hlc::Timestamp* release_key_timestamp();
  ::znbase::util::hlc::Timestamp* mutable_key_timestamp();
  void set_allocated_key_timestamp(::znbase::util::hlc::Timestamp* key_timestamp);

  // bool inline = 3;
  void clear_inline_();
  static const int kInlineFieldNumber = 3;
  bool inline_() const;
  void set_inline_(bool value);

  // bool blind = 4;
  void clear_blind();
  static const int kBlindFieldNumber = 4;
  bool blind() const;
  void set_blind(bool value);

  // bool original = 5;
  void clear_original();
  static const int kOriginalFieldNumber = 5;
  bool original() const;
  void set_original(bool value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.PutRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::RequestHeader* header_;
  ::znbase::roachpb::Value* value_;
  ::znbase::util::hlc::Timestamp* key_timestamp_;
  bool inline__;
  bool blind_;
  bool original_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PutResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.PutResponse) */ {
 public:
  PutResponse();
  virtual ~PutResponse();

  PutResponse(const PutResponse& from);

  inline PutResponse& operator=(const PutResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PutResponse(PutResponse&& from) noexcept
    : PutResponse() {
    *this = ::std::move(from);
  }

  inline PutResponse& operator=(PutResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const PutResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PutResponse* internal_default_instance() {
    return reinterpret_cast<const PutResponse*>(
               &_PutResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(PutResponse* other);
  friend void swap(PutResponse& a, PutResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PutResponse* New() const final {
    return CreateMaybeMessage<PutResponse>(NULL);
  }

  PutResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PutResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const PutResponse& from);
  void MergeFrom(const PutResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PutResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.PutResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::ResponseHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ConditionalPutRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.ConditionalPutRequest) */ {
 public:
  ConditionalPutRequest();
  virtual ~ConditionalPutRequest();

  ConditionalPutRequest(const ConditionalPutRequest& from);

  inline ConditionalPutRequest& operator=(const ConditionalPutRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConditionalPutRequest(ConditionalPutRequest&& from) noexcept
    : ConditionalPutRequest() {
    *this = ::std::move(from);
  }

  inline ConditionalPutRequest& operator=(ConditionalPutRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ConditionalPutRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConditionalPutRequest* internal_default_instance() {
    return reinterpret_cast<const ConditionalPutRequest*>(
               &_ConditionalPutRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ConditionalPutRequest* other);
  friend void swap(ConditionalPutRequest& a, ConditionalPutRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConditionalPutRequest* New() const final {
    return CreateMaybeMessage<ConditionalPutRequest>(NULL);
  }

  ConditionalPutRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConditionalPutRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ConditionalPutRequest& from);
  void MergeFrom(const ConditionalPutRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConditionalPutRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  private:
  const ::znbase::roachpb::Value& _internal_value() const;
  public:
  const ::znbase::roachpb::Value& value() const;
  ::znbase::roachpb::Value* release_value();
  ::znbase::roachpb::Value* mutable_value();
  void set_allocated_value(::znbase::roachpb::Value* value);

  // .znbase.roachpb.Value exp_value = 3;
  bool has_exp_value() const;
  void clear_exp_value();
  static const int kExpValueFieldNumber = 3;
  private:
  const ::znbase::roachpb::Value& _internal_exp_value() const;
  public:
  const ::znbase::roachpb::Value& exp_value() const;
  ::znbase::roachpb::Value* release_exp_value();
  ::znbase::roachpb::Value* mutable_exp_value();
  void set_allocated_exp_value(::znbase::roachpb::Value* exp_value);

  // bool blind = 4;
  void clear_blind();
  static const int kBlindFieldNumber = 4;
  bool blind() const;
  void set_blind(bool value);

  // bool allow_if_does_not_exist = 5;
  void clear_allow_if_does_not_exist();
  static const int kAllowIfDoesNotExistFieldNumber = 5;
  bool allow_if_does_not_exist() const;
  void set_allow_if_does_not_exist(bool value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.ConditionalPutRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::RequestHeader* header_;
  ::znbase::roachpb::Value* value_;
  ::znbase::roachpb::Value* exp_value_;
  bool blind_;
  bool allow_if_does_not_exist_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ConditionalPutResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.ConditionalPutResponse) */ {
 public:
  ConditionalPutResponse();
  virtual ~ConditionalPutResponse();

  ConditionalPutResponse(const ConditionalPutResponse& from);

  inline ConditionalPutResponse& operator=(const ConditionalPutResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConditionalPutResponse(ConditionalPutResponse&& from) noexcept
    : ConditionalPutResponse() {
    *this = ::std::move(from);
  }

  inline ConditionalPutResponse& operator=(ConditionalPutResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ConditionalPutResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConditionalPutResponse* internal_default_instance() {
    return reinterpret_cast<const ConditionalPutResponse*>(
               &_ConditionalPutResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ConditionalPutResponse* other);
  friend void swap(ConditionalPutResponse& a, ConditionalPutResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConditionalPutResponse* New() const final {
    return CreateMaybeMessage<ConditionalPutResponse>(NULL);
  }

  ConditionalPutResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConditionalPutResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ConditionalPutResponse& from);
  void MergeFrom(const ConditionalPutResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConditionalPutResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.ConditionalPutResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::ResponseHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InitPutRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.InitPutRequest) */ {
 public:
  InitPutRequest();
  virtual ~InitPutRequest();

  InitPutRequest(const InitPutRequest& from);

  inline InitPutRequest& operator=(const InitPutRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InitPutRequest(InitPutRequest&& from) noexcept
    : InitPutRequest() {
    *this = ::std::move(from);
  }

  inline InitPutRequest& operator=(InitPutRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const InitPutRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InitPutRequest* internal_default_instance() {
    return reinterpret_cast<const InitPutRequest*>(
               &_InitPutRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(InitPutRequest* other);
  friend void swap(InitPutRequest& a, InitPutRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InitPutRequest* New() const final {
    return CreateMaybeMessage<InitPutRequest>(NULL);
  }

  InitPutRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InitPutRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const InitPutRequest& from);
  void MergeFrom(const InitPutRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InitPutRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  private:
  const ::znbase::roachpb::Value& _internal_value() const;
  public:
  const ::znbase::roachpb::Value& value() const;
  ::znbase::roachpb::Value* release_value();
  ::znbase::roachpb::Value* mutable_value();
  void set_allocated_value(::znbase::roachpb::Value* value);

  // bool blind = 3;
  void clear_blind();
  static const int kBlindFieldNumber = 3;
  bool blind() const;
  void set_blind(bool value);

  // bool failOnTombstones = 4;
  void clear_failontombstones();
  static const int kFailOnTombstonesFieldNumber = 4;
  bool failontombstones() const;
  void set_failontombstones(bool value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.InitPutRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::RequestHeader* header_;
  ::znbase::roachpb::Value* value_;
  bool blind_;
  bool failontombstones_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InitPutResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.InitPutResponse) */ {
 public:
  InitPutResponse();
  virtual ~InitPutResponse();

  InitPutResponse(const InitPutResponse& from);

  inline InitPutResponse& operator=(const InitPutResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InitPutResponse(InitPutResponse&& from) noexcept
    : InitPutResponse() {
    *this = ::std::move(from);
  }

  inline InitPutResponse& operator=(InitPutResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const InitPutResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InitPutResponse* internal_default_instance() {
    return reinterpret_cast<const InitPutResponse*>(
               &_InitPutResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(InitPutResponse* other);
  friend void swap(InitPutResponse& a, InitPutResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InitPutResponse* New() const final {
    return CreateMaybeMessage<InitPutResponse>(NULL);
  }

  InitPutResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InitPutResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const InitPutResponse& from);
  void MergeFrom(const InitPutResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InitPutResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.InitPutResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::ResponseHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IncrementRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.IncrementRequest) */ {
 public:
  IncrementRequest();
  virtual ~IncrementRequest();

  IncrementRequest(const IncrementRequest& from);

  inline IncrementRequest& operator=(const IncrementRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IncrementRequest(IncrementRequest&& from) noexcept
    : IncrementRequest() {
    *this = ::std::move(from);
  }

  inline IncrementRequest& operator=(IncrementRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const IncrementRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IncrementRequest* internal_default_instance() {
    return reinterpret_cast<const IncrementRequest*>(
               &_IncrementRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(IncrementRequest* other);
  friend void swap(IncrementRequest& a, IncrementRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IncrementRequest* New() const final {
    return CreateMaybeMessage<IncrementRequest>(NULL);
  }

  IncrementRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IncrementRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const IncrementRequest& from);
  void MergeFrom(const IncrementRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IncrementRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  // int64 increment = 2;
  void clear_increment();
  static const int kIncrementFieldNumber = 2;
  ::google::protobuf::int64 increment() const;
  void set_increment(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.IncrementRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::RequestHeader* header_;
  ::google::protobuf::int64 increment_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IncrementResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.IncrementResponse) */ {
 public:
  IncrementResponse();
  virtual ~IncrementResponse();

  IncrementResponse(const IncrementResponse& from);

  inline IncrementResponse& operator=(const IncrementResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IncrementResponse(IncrementResponse&& from) noexcept
    : IncrementResponse() {
    *this = ::std::move(from);
  }

  inline IncrementResponse& operator=(IncrementResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const IncrementResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IncrementResponse* internal_default_instance() {
    return reinterpret_cast<const IncrementResponse*>(
               &_IncrementResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(IncrementResponse* other);
  friend void swap(IncrementResponse& a, IncrementResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IncrementResponse* New() const final {
    return CreateMaybeMessage<IncrementResponse>(NULL);
  }

  IncrementResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IncrementResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const IncrementResponse& from);
  void MergeFrom(const IncrementResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IncrementResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  // int64 new_value = 2;
  void clear_new_value();
  static const int kNewValueFieldNumber = 2;
  ::google::protobuf::int64 new_value() const;
  void set_new_value(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.IncrementResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::ResponseHeader* header_;
  ::google::protobuf::int64 new_value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeleteRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.DeleteRequest) */ {
 public:
  DeleteRequest();
  virtual ~DeleteRequest();

  DeleteRequest(const DeleteRequest& from);

  inline DeleteRequest& operator=(const DeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteRequest(DeleteRequest&& from) noexcept
    : DeleteRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRequest& operator=(DeleteRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DeleteRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRequest*>(
               &_DeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(DeleteRequest* other);
  friend void swap(DeleteRequest& a, DeleteRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteRequest* New() const final {
    return CreateMaybeMessage<DeleteRequest>(NULL);
  }

  DeleteRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeleteRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const DeleteRequest& from);
  void MergeFrom(const DeleteRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeleteRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.DeleteRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::RequestHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeleteResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.DeleteResponse) */ {
 public:
  DeleteResponse();
  virtual ~DeleteResponse();

  DeleteResponse(const DeleteResponse& from);

  inline DeleteResponse& operator=(const DeleteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteResponse(DeleteResponse&& from) noexcept
    : DeleteResponse() {
    *this = ::std::move(from);
  }

  inline DeleteResponse& operator=(DeleteResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DeleteResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteResponse*>(
               &_DeleteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(DeleteResponse* other);
  friend void swap(DeleteResponse& a, DeleteResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteResponse* New() const final {
    return CreateMaybeMessage<DeleteResponse>(NULL);
  }

  DeleteResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeleteResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const DeleteResponse& from);
  void MergeFrom(const DeleteResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeleteResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.DeleteResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::ResponseHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeleteRangeRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.DeleteRangeRequest) */ {
 public:
  DeleteRangeRequest();
  virtual ~DeleteRangeRequest();

  DeleteRangeRequest(const DeleteRangeRequest& from);

  inline DeleteRangeRequest& operator=(const DeleteRangeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteRangeRequest(DeleteRangeRequest&& from) noexcept
    : DeleteRangeRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRangeRequest& operator=(DeleteRangeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DeleteRangeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteRangeRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRangeRequest*>(
               &_DeleteRangeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(DeleteRangeRequest* other);
  friend void swap(DeleteRangeRequest& a, DeleteRangeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteRangeRequest* New() const final {
    return CreateMaybeMessage<DeleteRangeRequest>(NULL);
  }

  DeleteRangeRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeleteRangeRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const DeleteRangeRequest& from);
  void MergeFrom(const DeleteRangeRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeleteRangeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  // bool return_keys = 3;
  void clear_return_keys();
  static const int kReturnKeysFieldNumber = 3;
  bool return_keys() const;
  void set_return_keys(bool value);

  // bool inline = 4;
  void clear_inline_();
  static const int kInlineFieldNumber = 4;
  bool inline_() const;
  void set_inline_(bool value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.DeleteRangeRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::RequestHeader* header_;
  bool return_keys_;
  bool inline__;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeleteRangeResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.DeleteRangeResponse) */ {
 public:
  DeleteRangeResponse();
  virtual ~DeleteRangeResponse();

  DeleteRangeResponse(const DeleteRangeResponse& from);

  inline DeleteRangeResponse& operator=(const DeleteRangeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteRangeResponse(DeleteRangeResponse&& from) noexcept
    : DeleteRangeResponse() {
    *this = ::std::move(from);
  }

  inline DeleteRangeResponse& operator=(DeleteRangeResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DeleteRangeResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteRangeResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteRangeResponse*>(
               &_DeleteRangeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(DeleteRangeResponse* other);
  friend void swap(DeleteRangeResponse& a, DeleteRangeResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteRangeResponse* New() const final {
    return CreateMaybeMessage<DeleteRangeResponse>(NULL);
  }

  DeleteRangeResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeleteRangeResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const DeleteRangeResponse& from);
  void MergeFrom(const DeleteRangeResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeleteRangeResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 2;
  const ::std::string& keys(int index) const;
  ::std::string* mutable_keys(int index);
  void set_keys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_keys(int index, ::std::string&& value);
  #endif
  void set_keys(int index, const char* value);
  void set_keys(int index, const void* value, size_t size);
  ::std::string* add_keys();
  void add_keys(const ::std::string& value);
  #if LANG_CXX11
  void add_keys(::std::string&& value);
  #endif
  void add_keys(const char* value);
  void add_keys(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.DeleteRangeResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  ::znbase::roachpb::ResponseHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClearRangeRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.ClearRangeRequest) */ {
 public:
  ClearRangeRequest();
  virtual ~ClearRangeRequest();

  ClearRangeRequest(const ClearRangeRequest& from);

  inline ClearRangeRequest& operator=(const ClearRangeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClearRangeRequest(ClearRangeRequest&& from) noexcept
    : ClearRangeRequest() {
    *this = ::std::move(from);
  }

  inline ClearRangeRequest& operator=(ClearRangeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ClearRangeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClearRangeRequest* internal_default_instance() {
    return reinterpret_cast<const ClearRangeRequest*>(
               &_ClearRangeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(ClearRangeRequest* other);
  friend void swap(ClearRangeRequest& a, ClearRangeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClearRangeRequest* New() const final {
    return CreateMaybeMessage<ClearRangeRequest>(NULL);
  }

  ClearRangeRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClearRangeRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ClearRangeRequest& from);
  void MergeFrom(const ClearRangeRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClearRangeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.ClearRangeRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::RequestHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClearRangeResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.ClearRangeResponse) */ {
 public:
  ClearRangeResponse();
  virtual ~ClearRangeResponse();

  ClearRangeResponse(const ClearRangeResponse& from);

  inline ClearRangeResponse& operator=(const ClearRangeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClearRangeResponse(ClearRangeResponse&& from) noexcept
    : ClearRangeResponse() {
    *this = ::std::move(from);
  }

  inline ClearRangeResponse& operator=(ClearRangeResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ClearRangeResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClearRangeResponse* internal_default_instance() {
    return reinterpret_cast<const ClearRangeResponse*>(
               &_ClearRangeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(ClearRangeResponse* other);
  friend void swap(ClearRangeResponse& a, ClearRangeResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClearRangeResponse* New() const final {
    return CreateMaybeMessage<ClearRangeResponse>(NULL);
  }

  ClearRangeResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClearRangeResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ClearRangeResponse& from);
  void MergeFrom(const ClearRangeResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClearRangeResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.ClearRangeResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::ResponseHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RevertRangeRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.RevertRangeRequest) */ {
 public:
  RevertRangeRequest();
  virtual ~RevertRangeRequest();

  RevertRangeRequest(const RevertRangeRequest& from);

  inline RevertRangeRequest& operator=(const RevertRangeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RevertRangeRequest(RevertRangeRequest&& from) noexcept
    : RevertRangeRequest() {
    *this = ::std::move(from);
  }

  inline RevertRangeRequest& operator=(RevertRangeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const RevertRangeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RevertRangeRequest* internal_default_instance() {
    return reinterpret_cast<const RevertRangeRequest*>(
               &_RevertRangeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(RevertRangeRequest* other);
  friend void swap(RevertRangeRequest& a, RevertRangeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RevertRangeRequest* New() const final {
    return CreateMaybeMessage<RevertRangeRequest>(NULL);
  }

  RevertRangeRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RevertRangeRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const RevertRangeRequest& from);
  void MergeFrom(const RevertRangeRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RevertRangeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  bool has_target_time() const;
  void clear_target_time();
  static const int kTargetTimeFieldNumber = 2;
  private:
  const ::znbase::util::hlc::Timestamp& _internal_target_time() const;
  public:
  const ::znbase::util::hlc::Timestamp& target_time() const;
  ::znbase::util::hlc::Timestamp* release_target_time();
  ::znbase::util::hlc::Timestamp* mutable_target_time();
  void set_allocated_target_time(::znbase::util::hlc::Timestamp* target_time);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.RevertRangeRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::RequestHeader* header_;
  ::znbase::util::hlc::Timestamp* target_time_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RevertRangeResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.RevertRangeResponse) */ {
 public:
  RevertRangeResponse();
  virtual ~RevertRangeResponse();

  RevertRangeResponse(const RevertRangeResponse& from);

  inline RevertRangeResponse& operator=(const RevertRangeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RevertRangeResponse(RevertRangeResponse&& from) noexcept
    : RevertRangeResponse() {
    *this = ::std::move(from);
  }

  inline RevertRangeResponse& operator=(RevertRangeResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const RevertRangeResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RevertRangeResponse* internal_default_instance() {
    return reinterpret_cast<const RevertRangeResponse*>(
               &_RevertRangeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(RevertRangeResponse* other);
  friend void swap(RevertRangeResponse& a, RevertRangeResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RevertRangeResponse* New() const final {
    return CreateMaybeMessage<RevertRangeResponse>(NULL);
  }

  RevertRangeResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RevertRangeResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const RevertRangeResponse& from);
  void MergeFrom(const RevertRangeResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RevertRangeResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.RevertRangeResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::ResponseHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class QueryLockRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.QueryLockRequest) */ {
 public:
  QueryLockRequest();
  virtual ~QueryLockRequest();

  QueryLockRequest(const QueryLockRequest& from);

  inline QueryLockRequest& operator=(const QueryLockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  QueryLockRequest(QueryLockRequest&& from) noexcept
    : QueryLockRequest() {
    *this = ::std::move(from);
  }

  inline QueryLockRequest& operator=(QueryLockRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const QueryLockRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const QueryLockRequest* internal_default_instance() {
    return reinterpret_cast<const QueryLockRequest*>(
               &_QueryLockRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(QueryLockRequest* other);
  friend void swap(QueryLockRequest& a, QueryLockRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QueryLockRequest* New() const final {
    return CreateMaybeMessage<QueryLockRequest>(NULL);
  }

  QueryLockRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<QueryLockRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const QueryLockRequest& from);
  void MergeFrom(const QueryLockRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(QueryLockRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string transaction_id = 2;
  void clear_transaction_id();
  static const int kTransactionIdFieldNumber = 2;
  const ::std::string& transaction_id() const;
  void set_transaction_id(const ::std::string& value);
  #if LANG_CXX11
  void set_transaction_id(::std::string&& value);
  #endif
  void set_transaction_id(const char* value);
  void set_transaction_id(const char* value, size_t size);
  ::std::string* mutable_transaction_id();
  ::std::string* release_transaction_id();
  void set_allocated_transaction_id(::std::string* transaction_id);

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  // bool scan_intent = 3;
  void clear_scan_intent();
  static const int kScanIntentFieldNumber = 3;
  bool scan_intent() const;
  void set_scan_intent(bool value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.QueryLockRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr transaction_id_;
  ::znbase::roachpb::RequestHeader* header_;
  bool scan_intent_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class QueryLockResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.QueryLockResponse) */ {
 public:
  QueryLockResponse();
  virtual ~QueryLockResponse();

  QueryLockResponse(const QueryLockResponse& from);

  inline QueryLockResponse& operator=(const QueryLockResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  QueryLockResponse(QueryLockResponse&& from) noexcept
    : QueryLockResponse() {
    *this = ::std::move(from);
  }

  inline QueryLockResponse& operator=(QueryLockResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const QueryLockResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const QueryLockResponse* internal_default_instance() {
    return reinterpret_cast<const QueryLockResponse*>(
               &_QueryLockResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(QueryLockResponse* other);
  friend void swap(QueryLockResponse& a, QueryLockResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QueryLockResponse* New() const final {
    return CreateMaybeMessage<QueryLockResponse>(NULL);
  }

  QueryLockResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<QueryLockResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const QueryLockResponse& from);
  void MergeFrom(const QueryLockResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(QueryLockResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes intent_keys = 5;
  int intent_keys_size() const;
  void clear_intent_keys();
  static const int kIntentKeysFieldNumber = 5;
  const ::std::string& intent_keys(int index) const;
  ::std::string* mutable_intent_keys(int index);
  void set_intent_keys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_intent_keys(int index, ::std::string&& value);
  #endif
  void set_intent_keys(int index, const char* value);
  void set_intent_keys(int index, const void* value, size_t size);
  ::std::string* add_intent_keys();
  void add_intent_keys(const ::std::string& value);
  #if LANG_CXX11
  void add_intent_keys(::std::string&& value);
  #endif
  void add_intent_keys(const char* value);
  void add_intent_keys(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& intent_keys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_intent_keys();

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  // .znbase.roachpb.Span k_vspan = 4;
  bool has_k_vspan() const;
  void clear_k_vspan();
  static const int kKVspanFieldNumber = 4;
  private:
  const ::znbase::roachpb::Span& _internal_k_vspan() const;
  public:
  const ::znbase::roachpb::Span& k_vspan() const;
  ::znbase::roachpb::Span* release_k_vspan();
  ::znbase::roachpb::Span* mutable_k_vspan();
  void set_allocated_k_vspan(::znbase::roachpb::Span* k_vspan);

  // bool durability_replicated = 2;
  void clear_durability_replicated();
  static const int kDurabilityReplicatedFieldNumber = 2;
  bool durability_replicated() const;
  void set_durability_replicated(bool value);

  // bool durability_unreplicated = 3;
  void clear_durability_unreplicated();
  static const int kDurabilityUnreplicatedFieldNumber = 3;
  bool durability_unreplicated() const;
  void set_durability_unreplicated(bool value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.QueryLockResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> intent_keys_;
  ::znbase::roachpb::ResponseHeader* header_;
  ::znbase::roachpb::Span* k_vspan_;
  bool durability_replicated_;
  bool durability_unreplicated_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScanOptions : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.ScanOptions) */ {
 public:
  ScanOptions();
  virtual ~ScanOptions();

  ScanOptions(const ScanOptions& from);

  inline ScanOptions& operator=(const ScanOptions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ScanOptions(ScanOptions&& from) noexcept
    : ScanOptions() {
    *this = ::std::move(from);
  }

  inline ScanOptions& operator=(ScanOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ScanOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScanOptions* internal_default_instance() {
    return reinterpret_cast<const ScanOptions*>(
               &_ScanOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(ScanOptions* other);
  friend void swap(ScanOptions& a, ScanOptions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ScanOptions* New() const final {
    return CreateMaybeMessage<ScanOptions>(NULL);
  }

  ScanOptions* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ScanOptions>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ScanOptions& from);
  void MergeFrom(const ScanOptions& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ScanOptions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 min_results = 2;
  void clear_min_results();
  static const int kMinResultsFieldNumber = 2;
  ::google::protobuf::int64 min_results() const;
  void set_min_results(::google::protobuf::int64 value);

  // bool stop_at_range_boundary = 1;
  void clear_stop_at_range_boundary();
  static const int kStopAtRangeBoundaryFieldNumber = 1;
  bool stop_at_range_boundary() const;
  void set_stop_at_range_boundary(bool value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.ScanOptions)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::int64 min_results_;
  bool stop_at_range_boundary_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScanRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.ScanRequest) */ {
 public:
  ScanRequest();
  virtual ~ScanRequest();

  ScanRequest(const ScanRequest& from);

  inline ScanRequest& operator=(const ScanRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ScanRequest(ScanRequest&& from) noexcept
    : ScanRequest() {
    *this = ::std::move(from);
  }

  inline ScanRequest& operator=(ScanRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ScanRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScanRequest* internal_default_instance() {
    return reinterpret_cast<const ScanRequest*>(
               &_ScanRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(ScanRequest* other);
  friend void swap(ScanRequest& a, ScanRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ScanRequest* New() const final {
    return CreateMaybeMessage<ScanRequest>(NULL);
  }

  ScanRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ScanRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ScanRequest& from);
  void MergeFrom(const ScanRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ScanRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  // .znbase.roachpb.ScanFormat scan_format = 4;
  void clear_scan_format();
  static const int kScanFormatFieldNumber = 4;
  ::znbase::roachpb::ScanFormat scan_format() const;
  void set_scan_format(::znbase::roachpb::ScanFormat value);

  // bool replicationTable = 3;
  void clear_replicationtable();
  static const int kReplicationTableFieldNumber = 3;
  bool replicationtable() const;
  void set_replicationtable(bool value);

  // bool NeedMeta = 5;
  void clear_needmeta();
  static const int kNeedMetaFieldNumber = 5;
  bool needmeta() const;
  void set_needmeta(bool value);

  // .znbase.storage.concurrency.lock.Strength key_locking = 6;
  void clear_key_locking();
  static const int kKeyLockingFieldNumber = 6;
  ::znbase::storage::concurrency::lock::Strength key_locking() const;
  void set_key_locking(::znbase::storage::concurrency::lock::Strength value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.ScanRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::RequestHeader* header_;
  int scan_format_;
  bool replicationtable_;
  bool needmeta_;
  int key_locking_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScanResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.ScanResponse) */ {
 public:
  ScanResponse();
  virtual ~ScanResponse();

  ScanResponse(const ScanResponse& from);

  inline ScanResponse& operator=(const ScanResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ScanResponse(ScanResponse&& from) noexcept
    : ScanResponse() {
    *this = ::std::move(from);
  }

  inline ScanResponse& operator=(ScanResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ScanResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScanResponse* internal_default_instance() {
    return reinterpret_cast<const ScanResponse*>(
               &_ScanResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(ScanResponse* other);
  friend void swap(ScanResponse& a, ScanResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ScanResponse* New() const final {
    return CreateMaybeMessage<ScanResponse>(NULL);
  }

  ScanResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ScanResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ScanResponse& from);
  void MergeFrom(const ScanResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ScanResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  int rows_size() const;
  void clear_rows();
  static const int kRowsFieldNumber = 2;
  ::znbase::roachpb::KeyValue* mutable_rows(int index);
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::KeyValue >*
      mutable_rows();
  const ::znbase::roachpb::KeyValue& rows(int index) const;
  ::znbase::roachpb::KeyValue* add_rows();
  const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::KeyValue >&
      rows() const;

  int intent_rows_size() const;
  void clear_intent_rows();
  static const int kIntentRowsFieldNumber = 3;
  ::znbase::roachpb::KeyValue* mutable_intent_rows(int index);
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::KeyValue >*
      mutable_intent_rows();
  const ::znbase::roachpb::KeyValue& intent_rows(int index) const;
  ::znbase::roachpb::KeyValue* add_intent_rows();
  const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::KeyValue >&
      intent_rows() const;

  // repeated bytes batch_responses = 4;
  int batch_responses_size() const;
  void clear_batch_responses();
  static const int kBatchResponsesFieldNumber = 4;
  const ::std::string& batch_responses(int index) const;
  ::std::string* mutable_batch_responses(int index);
  void set_batch_responses(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_batch_responses(int index, ::std::string&& value);
  #endif
  void set_batch_responses(int index, const char* value);
  void set_batch_responses(int index, const void* value, size_t size);
  ::std::string* add_batch_responses();
  void add_batch_responses(const ::std::string& value);
  #if LANG_CXX11
  void add_batch_responses(::std::string&& value);
  #endif
  void add_batch_responses(const char* value);
  void add_batch_responses(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& batch_responses() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_batch_responses();

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.ScanResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::KeyValue > rows_;
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::KeyValue > intent_rows_;
  ::google::protobuf::RepeatedPtrField< ::std::string> batch_responses_;
  ::znbase::roachpb::ResponseHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReverseScanRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.ReverseScanRequest) */ {
 public:
  ReverseScanRequest();
  virtual ~ReverseScanRequest();

  ReverseScanRequest(const ReverseScanRequest& from);

  inline ReverseScanRequest& operator=(const ReverseScanRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReverseScanRequest(ReverseScanRequest&& from) noexcept
    : ReverseScanRequest() {
    *this = ::std::move(from);
  }

  inline ReverseScanRequest& operator=(ReverseScanRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ReverseScanRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReverseScanRequest* internal_default_instance() {
    return reinterpret_cast<const ReverseScanRequest*>(
               &_ReverseScanRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(ReverseScanRequest* other);
  friend void swap(ReverseScanRequest& a, ReverseScanRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReverseScanRequest* New() const final {
    return CreateMaybeMessage<ReverseScanRequest>(NULL);
  }

  ReverseScanRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReverseScanRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ReverseScanRequest& from);
  void MergeFrom(const ReverseScanRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReverseScanRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  // bool replicationTable = 3;
  void clear_replicationtable();
  static const int kReplicationTableFieldNumber = 3;
  bool replicationtable() const;
  void set_replicationtable(bool value);

  // .znbase.roachpb.ScanFormat scan_format = 4;
  void clear_scan_format();
  static const int kScanFormatFieldNumber = 4;
  ::znbase::roachpb::ScanFormat scan_format() const;
  void set_scan_format(::znbase::roachpb::ScanFormat value);

  // .znbase.storage.concurrency.lock.Strength key_locking = 5;
  void clear_key_locking();
  static const int kKeyLockingFieldNumber = 5;
  ::znbase::storage::concurrency::lock::Strength key_locking() const;
  void set_key_locking(::znbase::storage::concurrency::lock::Strength value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.ReverseScanRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::RequestHeader* header_;
  bool replicationtable_;
  int scan_format_;
  int key_locking_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReverseScanResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.ReverseScanResponse) */ {
 public:
  ReverseScanResponse();
  virtual ~ReverseScanResponse();

  ReverseScanResponse(const ReverseScanResponse& from);

  inline ReverseScanResponse& operator=(const ReverseScanResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReverseScanResponse(ReverseScanResponse&& from) noexcept
    : ReverseScanResponse() {
    *this = ::std::move(from);
  }

  inline ReverseScanResponse& operator=(ReverseScanResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ReverseScanResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReverseScanResponse* internal_default_instance() {
    return reinterpret_cast<const ReverseScanResponse*>(
               &_ReverseScanResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(ReverseScanResponse* other);
  friend void swap(ReverseScanResponse& a, ReverseScanResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReverseScanResponse* New() const final {
    return CreateMaybeMessage<ReverseScanResponse>(NULL);
  }

  ReverseScanResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReverseScanResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ReverseScanResponse& from);
  void MergeFrom(const ReverseScanResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReverseScanResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  int rows_size() const;
  void clear_rows();
  static const int kRowsFieldNumber = 2;
  ::znbase::roachpb::KeyValue* mutable_rows(int index);
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::KeyValue >*
      mutable_rows();
  const ::znbase::roachpb::KeyValue& rows(int index) const;
  ::znbase::roachpb::KeyValue* add_rows();
  const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::KeyValue >&
      rows() const;

  int intent_rows_size() const;
  void clear_intent_rows();
  static const int kIntentRowsFieldNumber = 3;
  ::znbase::roachpb::KeyValue* mutable_intent_rows(int index);
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::KeyValue >*
      mutable_intent_rows();
  const ::znbase::roachpb::KeyValue& intent_rows(int index) const;
  ::znbase::roachpb::KeyValue* add_intent_rows();
  const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::KeyValue >&
      intent_rows() const;

  // repeated bytes batch_responses = 4;
  int batch_responses_size() const;
  void clear_batch_responses();
  static const int kBatchResponsesFieldNumber = 4;
  const ::std::string& batch_responses(int index) const;
  ::std::string* mutable_batch_responses(int index);
  void set_batch_responses(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_batch_responses(int index, ::std::string&& value);
  #endif
  void set_batch_responses(int index, const char* value);
  void set_batch_responses(int index, const void* value, size_t size);
  ::std::string* add_batch_responses();
  void add_batch_responses(const ::std::string& value);
  #if LANG_CXX11
  void add_batch_responses(::std::string&& value);
  #endif
  void add_batch_responses(const char* value);
  void add_batch_responses(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& batch_responses() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_batch_responses();

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.ReverseScanResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::KeyValue > rows_;
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::KeyValue > intent_rows_;
  ::google::protobuf::RepeatedPtrField< ::std::string> batch_responses_;
  ::znbase::roachpb::ResponseHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CheckConsistencyRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.CheckConsistencyRequest) */ {
 public:
  CheckConsistencyRequest();
  virtual ~CheckConsistencyRequest();

  CheckConsistencyRequest(const CheckConsistencyRequest& from);

  inline CheckConsistencyRequest& operator=(const CheckConsistencyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CheckConsistencyRequest(CheckConsistencyRequest&& from) noexcept
    : CheckConsistencyRequest() {
    *this = ::std::move(from);
  }

  inline CheckConsistencyRequest& operator=(CheckConsistencyRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const CheckConsistencyRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CheckConsistencyRequest* internal_default_instance() {
    return reinterpret_cast<const CheckConsistencyRequest*>(
               &_CheckConsistencyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(CheckConsistencyRequest* other);
  friend void swap(CheckConsistencyRequest& a, CheckConsistencyRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CheckConsistencyRequest* New() const final {
    return CreateMaybeMessage<CheckConsistencyRequest>(NULL);
  }

  CheckConsistencyRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CheckConsistencyRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const CheckConsistencyRequest& from);
  void MergeFrom(const CheckConsistencyRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CheckConsistencyRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  // .znbase.roachpb.ChecksumMode mode = 3;
  void clear_mode();
  static const int kModeFieldNumber = 3;
  ::znbase::roachpb::ChecksumMode mode() const;
  void set_mode(::znbase::roachpb::ChecksumMode value);

  // bool with_diff = 2;
  void clear_with_diff();
  static const int kWithDiffFieldNumber = 2;
  bool with_diff() const;
  void set_with_diff(bool value);

  // bool checkpoint = 4;
  void clear_checkpoint();
  static const int kCheckpointFieldNumber = 4;
  bool checkpoint() const;
  void set_checkpoint(bool value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.CheckConsistencyRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::RequestHeader* header_;
  int mode_;
  bool with_diff_;
  bool checkpoint_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CheckConsistencyResponse_Result : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.CheckConsistencyResponse.Result) */ {
 public:
  CheckConsistencyResponse_Result();
  virtual ~CheckConsistencyResponse_Result();

  CheckConsistencyResponse_Result(const CheckConsistencyResponse_Result& from);

  inline CheckConsistencyResponse_Result& operator=(const CheckConsistencyResponse_Result& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CheckConsistencyResponse_Result(CheckConsistencyResponse_Result&& from) noexcept
    : CheckConsistencyResponse_Result() {
    *this = ::std::move(from);
  }

  inline CheckConsistencyResponse_Result& operator=(CheckConsistencyResponse_Result&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const CheckConsistencyResponse_Result& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CheckConsistencyResponse_Result* internal_default_instance() {
    return reinterpret_cast<const CheckConsistencyResponse_Result*>(
               &_CheckConsistencyResponse_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(CheckConsistencyResponse_Result* other);
  friend void swap(CheckConsistencyResponse_Result& a, CheckConsistencyResponse_Result& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CheckConsistencyResponse_Result* New() const final {
    return CreateMaybeMessage<CheckConsistencyResponse_Result>(NULL);
  }

  CheckConsistencyResponse_Result* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CheckConsistencyResponse_Result>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const CheckConsistencyResponse_Result& from);
  void MergeFrom(const CheckConsistencyResponse_Result& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CheckConsistencyResponse_Result* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes start_key = 2;
  void clear_start_key();
  static const int kStartKeyFieldNumber = 2;
  const ::std::string& start_key() const;
  void set_start_key(const ::std::string& value);
  #if LANG_CXX11
  void set_start_key(::std::string&& value);
  #endif
  void set_start_key(const char* value);
  void set_start_key(const void* value, size_t size);
  ::std::string* mutable_start_key();
  ::std::string* release_start_key();
  void set_allocated_start_key(::std::string* start_key);

  // string detail = 4;
  void clear_detail();
  static const int kDetailFieldNumber = 4;
  const ::std::string& detail() const;
  void set_detail(const ::std::string& value);
  #if LANG_CXX11
  void set_detail(::std::string&& value);
  #endif
  void set_detail(const char* value);
  void set_detail(const char* value, size_t size);
  ::std::string* mutable_detail();
  ::std::string* release_detail();
  void set_allocated_detail(::std::string* detail);

  void clear_range_id();
  static const int kRangeIdFieldNumber = 1;
  ::google::protobuf::int64 range_id() const;
  void set_range_id(::google::protobuf::int64 value);

  // .znbase.roachpb.CheckConsistencyResponse.Status status = 3;
  void clear_status();
  static const int kStatusFieldNumber = 3;
  ::znbase::roachpb::CheckConsistencyResponse_Status status() const;
  void set_status(::znbase::roachpb::CheckConsistencyResponse_Status value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.CheckConsistencyResponse.Result)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr start_key_;
  ::google::protobuf::internal::ArenaStringPtr detail_;
  ::google::protobuf::int64 range_id_;
  int status_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CheckConsistencyResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.CheckConsistencyResponse) */ {
 public:
  CheckConsistencyResponse();
  virtual ~CheckConsistencyResponse();

  CheckConsistencyResponse(const CheckConsistencyResponse& from);

  inline CheckConsistencyResponse& operator=(const CheckConsistencyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CheckConsistencyResponse(CheckConsistencyResponse&& from) noexcept
    : CheckConsistencyResponse() {
    *this = ::std::move(from);
  }

  inline CheckConsistencyResponse& operator=(CheckConsistencyResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const CheckConsistencyResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CheckConsistencyResponse* internal_default_instance() {
    return reinterpret_cast<const CheckConsistencyResponse*>(
               &_CheckConsistencyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(CheckConsistencyResponse* other);
  friend void swap(CheckConsistencyResponse& a, CheckConsistencyResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CheckConsistencyResponse* New() const final {
    return CreateMaybeMessage<CheckConsistencyResponse>(NULL);
  }

  CheckConsistencyResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CheckConsistencyResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const CheckConsistencyResponse& from);
  void MergeFrom(const CheckConsistencyResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CheckConsistencyResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef CheckConsistencyResponse_Result Result;

  typedef CheckConsistencyResponse_Status Status;
  static const Status RANGE_INDETERMINATE =
    CheckConsistencyResponse_Status_RANGE_INDETERMINATE;
  static const Status RANGE_INCONSISTENT =
    CheckConsistencyResponse_Status_RANGE_INCONSISTENT;
  static const Status RANGE_CONSISTENT =
    CheckConsistencyResponse_Status_RANGE_CONSISTENT;
  static const Status RANGE_CONSISTENT_STATS_ESTIMATED =
    CheckConsistencyResponse_Status_RANGE_CONSISTENT_STATS_ESTIMATED;
  static const Status RANGE_CONSISTENT_STATS_INCORRECT =
    CheckConsistencyResponse_Status_RANGE_CONSISTENT_STATS_INCORRECT;
  static inline bool Status_IsValid(int value) {
    return CheckConsistencyResponse_Status_IsValid(value);
  }
  static const Status Status_MIN =
    CheckConsistencyResponse_Status_Status_MIN;
  static const Status Status_MAX =
    CheckConsistencyResponse_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    CheckConsistencyResponse_Status_Status_ARRAYSIZE;

  // accessors -------------------------------------------------------

  int result_size() const;
  void clear_result();
  static const int kResultFieldNumber = 2;
  ::znbase::roachpb::CheckConsistencyResponse_Result* mutable_result(int index);
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::CheckConsistencyResponse_Result >*
      mutable_result();
  const ::znbase::roachpb::CheckConsistencyResponse_Result& result(int index) const;
  ::znbase::roachpb::CheckConsistencyResponse_Result* add_result();
  const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::CheckConsistencyResponse_Result >&
      result() const;

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.CheckConsistencyResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::CheckConsistencyResponse_Result > result_;
  ::znbase::roachpb::ResponseHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RecomputeStatsRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.RecomputeStatsRequest) */ {
 public:
  RecomputeStatsRequest();
  virtual ~RecomputeStatsRequest();

  RecomputeStatsRequest(const RecomputeStatsRequest& from);

  inline RecomputeStatsRequest& operator=(const RecomputeStatsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RecomputeStatsRequest(RecomputeStatsRequest&& from) noexcept
    : RecomputeStatsRequest() {
    *this = ::std::move(from);
  }

  inline RecomputeStatsRequest& operator=(RecomputeStatsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const RecomputeStatsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RecomputeStatsRequest* internal_default_instance() {
    return reinterpret_cast<const RecomputeStatsRequest*>(
               &_RecomputeStatsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(RecomputeStatsRequest* other);
  friend void swap(RecomputeStatsRequest& a, RecomputeStatsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RecomputeStatsRequest* New() const final {
    return CreateMaybeMessage<RecomputeStatsRequest>(NULL);
  }

  RecomputeStatsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RecomputeStatsRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const RecomputeStatsRequest& from);
  void MergeFrom(const RecomputeStatsRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RecomputeStatsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  // bool dry_run = 2;
  void clear_dry_run();
  static const int kDryRunFieldNumber = 2;
  bool dry_run() const;
  void set_dry_run(bool value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.RecomputeStatsRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::RequestHeader* header_;
  bool dry_run_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RecomputeStatsResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.RecomputeStatsResponse) */ {
 public:
  RecomputeStatsResponse();
  virtual ~RecomputeStatsResponse();

  RecomputeStatsResponse(const RecomputeStatsResponse& from);

  inline RecomputeStatsResponse& operator=(const RecomputeStatsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RecomputeStatsResponse(RecomputeStatsResponse&& from) noexcept
    : RecomputeStatsResponse() {
    *this = ::std::move(from);
  }

  inline RecomputeStatsResponse& operator=(RecomputeStatsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const RecomputeStatsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RecomputeStatsResponse* internal_default_instance() {
    return reinterpret_cast<const RecomputeStatsResponse*>(
               &_RecomputeStatsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(RecomputeStatsResponse* other);
  friend void swap(RecomputeStatsResponse& a, RecomputeStatsResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RecomputeStatsResponse* New() const final {
    return CreateMaybeMessage<RecomputeStatsResponse>(NULL);
  }

  RecomputeStatsResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RecomputeStatsResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const RecomputeStatsResponse& from);
  void MergeFrom(const RecomputeStatsResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RecomputeStatsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  bool has_added_delta() const;
  void clear_added_delta();
  static const int kAddedDeltaFieldNumber = 2;
  private:
  const ::znbase::storage::engine::enginepb::MVCCStatsDelta& _internal_added_delta() const;
  public:
  const ::znbase::storage::engine::enginepb::MVCCStatsDelta& added_delta() const;
  ::znbase::storage::engine::enginepb::MVCCStatsDelta* release_added_delta();
  ::znbase::storage::engine::enginepb::MVCCStatsDelta* mutable_added_delta();
  void set_allocated_added_delta(::znbase::storage::engine::enginepb::MVCCStatsDelta* added_delta);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.RecomputeStatsResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::ResponseHeader* header_;
  ::znbase::storage::engine::enginepb::MVCCStatsDelta* added_delta_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EndTransactionRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.EndTransactionRequest) */ {
 public:
  EndTransactionRequest();
  virtual ~EndTransactionRequest();

  EndTransactionRequest(const EndTransactionRequest& from);

  inline EndTransactionRequest& operator=(const EndTransactionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EndTransactionRequest(EndTransactionRequest&& from) noexcept
    : EndTransactionRequest() {
    *this = ::std::move(from);
  }

  inline EndTransactionRequest& operator=(EndTransactionRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const EndTransactionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EndTransactionRequest* internal_default_instance() {
    return reinterpret_cast<const EndTransactionRequest*>(
               &_EndTransactionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  void Swap(EndTransactionRequest* other);
  friend void swap(EndTransactionRequest& a, EndTransactionRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EndTransactionRequest* New() const final {
    return CreateMaybeMessage<EndTransactionRequest>(NULL);
  }

  EndTransactionRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EndTransactionRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const EndTransactionRequest& from);
  void MergeFrom(const EndTransactionRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EndTransactionRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  int lock_spans_size() const;
  void clear_lock_spans();
  static const int kLockSpansFieldNumber = 5;
  ::znbase::roachpb::Span* mutable_lock_spans(int index);
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::Span >*
      mutable_lock_spans();
  const ::znbase::roachpb::Span& lock_spans(int index) const;
  ::znbase::roachpb::Span* add_lock_spans();
  const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::Span >&
      lock_spans() const;

  int in_flight_writes_size() const;
  void clear_in_flight_writes();
  static const int kInFlightWritesFieldNumber = 17;
  ::znbase::roachpb::SequencedWrite* mutable_in_flight_writes(int index);
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::SequencedWrite >*
      mutable_in_flight_writes();
  const ::znbase::roachpb::SequencedWrite& in_flight_writes(int index) const;
  ::znbase::roachpb::SequencedWrite* add_in_flight_writes();
  const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::SequencedWrite >&
      in_flight_writes() const;

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  // .znbase.util.hlc.Timestamp deadline = 3;
  bool has_deadline() const;
  void clear_deadline();
  static const int kDeadlineFieldNumber = 3;
  private:
  const ::znbase::util::hlc::Timestamp& _internal_deadline() const;
  public:
  const ::znbase::util::hlc::Timestamp& deadline() const;
  ::znbase::util::hlc::Timestamp* release_deadline();
  ::znbase::util::hlc::Timestamp* mutable_deadline();
  void set_allocated_deadline(::znbase::util::hlc::Timestamp* deadline);

  // .znbase.roachpb.InternalCommitTrigger internal_commit_trigger = 4;
  bool has_internal_commit_trigger() const;
  void clear_internal_commit_trigger();
  static const int kInternalCommitTriggerFieldNumber = 4;
  private:
  const ::znbase::roachpb::InternalCommitTrigger& _internal_internal_commit_trigger() const;
  public:
  const ::znbase::roachpb::InternalCommitTrigger& internal_commit_trigger() const;
  ::znbase::roachpb::InternalCommitTrigger* release_internal_commit_trigger();
  ::znbase::roachpb::InternalCommitTrigger* mutable_internal_commit_trigger();
  void set_allocated_internal_commit_trigger(::znbase::roachpb::InternalCommitTrigger* internal_commit_trigger);

  // bool commit = 2;
  void clear_commit();
  static const int kCommitFieldNumber = 2;
  bool commit() const;
  void set_commit(bool value);

  void clear_require_1pc();
  static const int kRequire1PcFieldNumber = 6;
  bool require_1pc() const;
  void set_require_1pc(bool value);

  // bool can_commit_at_higher_timestamp = 8;
  void clear_can_commit_at_higher_timestamp();
  static const int kCanCommitAtHigherTimestampFieldNumber = 8;
  bool can_commit_at_higher_timestamp() const;
  void set_can_commit_at_higher_timestamp(bool value);

  // bool poison = 9;
  void clear_poison();
  static const int kPoisonFieldNumber = 9;
  bool poison() const;
  void set_poison(bool value);

  // bool heartbeat = 7;
  void clear_heartbeat();
  static const int kHeartbeatFieldNumber = 7;
  bool heartbeat() const;
  void set_heartbeat(bool value);

  // bool retrytxn = 10;
  void clear_retrytxn();
  static const int kRetrytxnFieldNumber = 10;
  bool retrytxn() const;
  void set_retrytxn(bool value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.EndTransactionRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::Span > lock_spans_;
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::SequencedWrite > in_flight_writes_;
  ::znbase::roachpb::RequestHeader* header_;
  ::znbase::util::hlc::Timestamp* deadline_;
  ::znbase::roachpb::InternalCommitTrigger* internal_commit_trigger_;
  bool commit_;
  bool require_1pc_;
  bool can_commit_at_higher_timestamp_;
  bool poison_;
  bool heartbeat_;
  bool retrytxn_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EndTransactionResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.EndTransactionResponse) */ {
 public:
  EndTransactionResponse();
  virtual ~EndTransactionResponse();

  EndTransactionResponse(const EndTransactionResponse& from);

  inline EndTransactionResponse& operator=(const EndTransactionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EndTransactionResponse(EndTransactionResponse&& from) noexcept
    : EndTransactionResponse() {
    *this = ::std::move(from);
  }

  inline EndTransactionResponse& operator=(EndTransactionResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const EndTransactionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EndTransactionResponse* internal_default_instance() {
    return reinterpret_cast<const EndTransactionResponse*>(
               &_EndTransactionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  void Swap(EndTransactionResponse* other);
  friend void swap(EndTransactionResponse& a, EndTransactionResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EndTransactionResponse* New() const final {
    return CreateMaybeMessage<EndTransactionResponse>(NULL);
  }

  EndTransactionResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EndTransactionResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const EndTransactionResponse& from);
  void MergeFrom(const EndTransactionResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EndTransactionResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  bool has_staging_timestamp() const;
  void clear_staging_timestamp();
  static const int kStagingTimestampFieldNumber = 5;
  private:
  const ::znbase::util::hlc::Timestamp& _internal_staging_timestamp() const;
  public:
  const ::znbase::util::hlc::Timestamp& staging_timestamp() const;
  ::znbase::util::hlc::Timestamp* release_staging_timestamp();
  ::znbase::util::hlc::Timestamp* mutable_staging_timestamp();
  void set_allocated_staging_timestamp(::znbase::util::hlc::Timestamp* staging_timestamp);

  // bool one_phase_commit = 4;
  void clear_one_phase_commit();
  static const int kOnePhaseCommitFieldNumber = 4;
  bool one_phase_commit() const;
  void set_one_phase_commit(bool value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.EndTransactionResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::ResponseHeader* header_;
  ::znbase::util::hlc::Timestamp* staging_timestamp_;
  bool one_phase_commit_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AdminSplitRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.AdminSplitRequest) */ {
 public:
  AdminSplitRequest();
  virtual ~AdminSplitRequest();

  AdminSplitRequest(const AdminSplitRequest& from);

  inline AdminSplitRequest& operator=(const AdminSplitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AdminSplitRequest(AdminSplitRequest&& from) noexcept
    : AdminSplitRequest() {
    *this = ::std::move(from);
  }

  inline AdminSplitRequest& operator=(AdminSplitRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const AdminSplitRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AdminSplitRequest* internal_default_instance() {
    return reinterpret_cast<const AdminSplitRequest*>(
               &_AdminSplitRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  void Swap(AdminSplitRequest* other);
  friend void swap(AdminSplitRequest& a, AdminSplitRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AdminSplitRequest* New() const final {
    return CreateMaybeMessage<AdminSplitRequest>(NULL);
  }

  AdminSplitRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AdminSplitRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const AdminSplitRequest& from);
  void MergeFrom(const AdminSplitRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AdminSplitRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  void clear_split_key();
  static const int kSplitKeyFieldNumber = 2;
  const ::std::string& split_key() const;
  void set_split_key(const ::std::string& value);
  #if LANG_CXX11
  void set_split_key(::std::string&& value);
  #endif
  void set_split_key(const char* value);
  void set_split_key(const void* value, size_t size);
  ::std::string* mutable_split_key();
  ::std::string* release_split_key();
  void set_allocated_split_key(::std::string* split_key);

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.AdminSplitRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr split_key_;
  ::znbase::roachpb::RequestHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AdminSplitResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.AdminSplitResponse) */ {
 public:
  AdminSplitResponse();
  virtual ~AdminSplitResponse();

  AdminSplitResponse(const AdminSplitResponse& from);

  inline AdminSplitResponse& operator=(const AdminSplitResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AdminSplitResponse(AdminSplitResponse&& from) noexcept
    : AdminSplitResponse() {
    *this = ::std::move(from);
  }

  inline AdminSplitResponse& operator=(AdminSplitResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const AdminSplitResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AdminSplitResponse* internal_default_instance() {
    return reinterpret_cast<const AdminSplitResponse*>(
               &_AdminSplitResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  void Swap(AdminSplitResponse* other);
  friend void swap(AdminSplitResponse& a, AdminSplitResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AdminSplitResponse* New() const final {
    return CreateMaybeMessage<AdminSplitResponse>(NULL);
  }

  AdminSplitResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AdminSplitResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const AdminSplitResponse& from);
  void MergeFrom(const AdminSplitResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AdminSplitResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.AdminSplitResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::ResponseHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AdminMergeRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.AdminMergeRequest) */ {
 public:
  AdminMergeRequest();
  virtual ~AdminMergeRequest();

  AdminMergeRequest(const AdminMergeRequest& from);

  inline AdminMergeRequest& operator=(const AdminMergeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AdminMergeRequest(AdminMergeRequest&& from) noexcept
    : AdminMergeRequest() {
    *this = ::std::move(from);
  }

  inline AdminMergeRequest& operator=(AdminMergeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const AdminMergeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AdminMergeRequest* internal_default_instance() {
    return reinterpret_cast<const AdminMergeRequest*>(
               &_AdminMergeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  void Swap(AdminMergeRequest* other);
  friend void swap(AdminMergeRequest& a, AdminMergeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AdminMergeRequest* New() const final {
    return CreateMaybeMessage<AdminMergeRequest>(NULL);
  }

  AdminMergeRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AdminMergeRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const AdminMergeRequest& from);
  void MergeFrom(const AdminMergeRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AdminMergeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.AdminMergeRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::RequestHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AdminMergeResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.AdminMergeResponse) */ {
 public:
  AdminMergeResponse();
  virtual ~AdminMergeResponse();

  AdminMergeResponse(const AdminMergeResponse& from);

  inline AdminMergeResponse& operator=(const AdminMergeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AdminMergeResponse(AdminMergeResponse&& from) noexcept
    : AdminMergeResponse() {
    *this = ::std::move(from);
  }

  inline AdminMergeResponse& operator=(AdminMergeResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const AdminMergeResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AdminMergeResponse* internal_default_instance() {
    return reinterpret_cast<const AdminMergeResponse*>(
               &_AdminMergeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  void Swap(AdminMergeResponse* other);
  friend void swap(AdminMergeResponse& a, AdminMergeResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AdminMergeResponse* New() const final {
    return CreateMaybeMessage<AdminMergeResponse>(NULL);
  }

  AdminMergeResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AdminMergeResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const AdminMergeResponse& from);
  void MergeFrom(const AdminMergeResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AdminMergeResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.AdminMergeResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::ResponseHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AdminTransferLeaseRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.AdminTransferLeaseRequest) */ {
 public:
  AdminTransferLeaseRequest();
  virtual ~AdminTransferLeaseRequest();

  AdminTransferLeaseRequest(const AdminTransferLeaseRequest& from);

  inline AdminTransferLeaseRequest& operator=(const AdminTransferLeaseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AdminTransferLeaseRequest(AdminTransferLeaseRequest&& from) noexcept
    : AdminTransferLeaseRequest() {
    *this = ::std::move(from);
  }

  inline AdminTransferLeaseRequest& operator=(AdminTransferLeaseRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const AdminTransferLeaseRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AdminTransferLeaseRequest* internal_default_instance() {
    return reinterpret_cast<const AdminTransferLeaseRequest*>(
               &_AdminTransferLeaseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  void Swap(AdminTransferLeaseRequest* other);
  friend void swap(AdminTransferLeaseRequest& a, AdminTransferLeaseRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AdminTransferLeaseRequest* New() const final {
    return CreateMaybeMessage<AdminTransferLeaseRequest>(NULL);
  }

  AdminTransferLeaseRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AdminTransferLeaseRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const AdminTransferLeaseRequest& from);
  void MergeFrom(const AdminTransferLeaseRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AdminTransferLeaseRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  void clear_target();
  static const int kTargetFieldNumber = 2;
  ::google::protobuf::int32 target() const;
  void set_target(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.AdminTransferLeaseRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::RequestHeader* header_;
  ::google::protobuf::int32 target_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AdminTransferLeaseResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.AdminTransferLeaseResponse) */ {
 public:
  AdminTransferLeaseResponse();
  virtual ~AdminTransferLeaseResponse();

  AdminTransferLeaseResponse(const AdminTransferLeaseResponse& from);

  inline AdminTransferLeaseResponse& operator=(const AdminTransferLeaseResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AdminTransferLeaseResponse(AdminTransferLeaseResponse&& from) noexcept
    : AdminTransferLeaseResponse() {
    *this = ::std::move(from);
  }

  inline AdminTransferLeaseResponse& operator=(AdminTransferLeaseResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const AdminTransferLeaseResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AdminTransferLeaseResponse* internal_default_instance() {
    return reinterpret_cast<const AdminTransferLeaseResponse*>(
               &_AdminTransferLeaseResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  void Swap(AdminTransferLeaseResponse* other);
  friend void swap(AdminTransferLeaseResponse& a, AdminTransferLeaseResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AdminTransferLeaseResponse* New() const final {
    return CreateMaybeMessage<AdminTransferLeaseResponse>(NULL);
  }

  AdminTransferLeaseResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AdminTransferLeaseResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const AdminTransferLeaseResponse& from);
  void MergeFrom(const AdminTransferLeaseResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AdminTransferLeaseResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.AdminTransferLeaseResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::ResponseHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AdminChangeReplicasRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.AdminChangeReplicasRequest) */ {
 public:
  AdminChangeReplicasRequest();
  virtual ~AdminChangeReplicasRequest();

  AdminChangeReplicasRequest(const AdminChangeReplicasRequest& from);

  inline AdminChangeReplicasRequest& operator=(const AdminChangeReplicasRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AdminChangeReplicasRequest(AdminChangeReplicasRequest&& from) noexcept
    : AdminChangeReplicasRequest() {
    *this = ::std::move(from);
  }

  inline AdminChangeReplicasRequest& operator=(AdminChangeReplicasRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const AdminChangeReplicasRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AdminChangeReplicasRequest* internal_default_instance() {
    return reinterpret_cast<const AdminChangeReplicasRequest*>(
               &_AdminChangeReplicasRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  void Swap(AdminChangeReplicasRequest* other);
  friend void swap(AdminChangeReplicasRequest& a, AdminChangeReplicasRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AdminChangeReplicasRequest* New() const final {
    return CreateMaybeMessage<AdminChangeReplicasRequest>(NULL);
  }

  AdminChangeReplicasRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AdminChangeReplicasRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const AdminChangeReplicasRequest& from);
  void MergeFrom(const AdminChangeReplicasRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AdminChangeReplicasRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  int targets_size() const;
  void clear_targets();
  static const int kTargetsFieldNumber = 3;
  ::znbase::roachpb::ReplicationTarget* mutable_targets(int index);
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::ReplicationTarget >*
      mutable_targets();
  const ::znbase::roachpb::ReplicationTarget& targets(int index) const;
  ::znbase::roachpb::ReplicationTarget* add_targets();
  const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::ReplicationTarget >&
      targets() const;

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  // .znbase.roachpb.RangeDescriptor exp_desc = 4;
  bool has_exp_desc() const;
  void clear_exp_desc();
  static const int kExpDescFieldNumber = 4;
  private:
  const ::znbase::roachpb::RangeDescriptor& _internal_exp_desc() const;
  public:
  const ::znbase::roachpb::RangeDescriptor& exp_desc() const;
  ::znbase::roachpb::RangeDescriptor* release_exp_desc();
  ::znbase::roachpb::RangeDescriptor* mutable_exp_desc();
  void set_allocated_exp_desc(::znbase::roachpb::RangeDescriptor* exp_desc);

  // .znbase.roachpb.ReplicaChangeType change_type = 2;
  void clear_change_type();
  static const int kChangeTypeFieldNumber = 2;
  ::znbase::roachpb::ReplicaChangeType change_type() const;
  void set_change_type(::znbase::roachpb::ReplicaChangeType value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.AdminChangeReplicasRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::ReplicationTarget > targets_;
  ::znbase::roachpb::RequestHeader* header_;
  ::znbase::roachpb::RangeDescriptor* exp_desc_;
  int change_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AdminChangeReplicasResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.AdminChangeReplicasResponse) */ {
 public:
  AdminChangeReplicasResponse();
  virtual ~AdminChangeReplicasResponse();

  AdminChangeReplicasResponse(const AdminChangeReplicasResponse& from);

  inline AdminChangeReplicasResponse& operator=(const AdminChangeReplicasResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AdminChangeReplicasResponse(AdminChangeReplicasResponse&& from) noexcept
    : AdminChangeReplicasResponse() {
    *this = ::std::move(from);
  }

  inline AdminChangeReplicasResponse& operator=(AdminChangeReplicasResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const AdminChangeReplicasResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AdminChangeReplicasResponse* internal_default_instance() {
    return reinterpret_cast<const AdminChangeReplicasResponse*>(
               &_AdminChangeReplicasResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  void Swap(AdminChangeReplicasResponse* other);
  friend void swap(AdminChangeReplicasResponse& a, AdminChangeReplicasResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AdminChangeReplicasResponse* New() const final {
    return CreateMaybeMessage<AdminChangeReplicasResponse>(NULL);
  }

  AdminChangeReplicasResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AdminChangeReplicasResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const AdminChangeReplicasResponse& from);
  void MergeFrom(const AdminChangeReplicasResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AdminChangeReplicasResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  // .znbase.roachpb.RangeDescriptor desc = 2;
  bool has_desc() const;
  void clear_desc();
  static const int kDescFieldNumber = 2;
  private:
  const ::znbase::roachpb::RangeDescriptor& _internal_desc() const;
  public:
  const ::znbase::roachpb::RangeDescriptor& desc() const;
  ::znbase::roachpb::RangeDescriptor* release_desc();
  ::znbase::roachpb::RangeDescriptor* mutable_desc();
  void set_allocated_desc(::znbase::roachpb::RangeDescriptor* desc);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.AdminChangeReplicasResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::ResponseHeader* header_;
  ::znbase::roachpb::RangeDescriptor* desc_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AdminRelocateRangeRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.AdminRelocateRangeRequest) */ {
 public:
  AdminRelocateRangeRequest();
  virtual ~AdminRelocateRangeRequest();

  AdminRelocateRangeRequest(const AdminRelocateRangeRequest& from);

  inline AdminRelocateRangeRequest& operator=(const AdminRelocateRangeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AdminRelocateRangeRequest(AdminRelocateRangeRequest&& from) noexcept
    : AdminRelocateRangeRequest() {
    *this = ::std::move(from);
  }

  inline AdminRelocateRangeRequest& operator=(AdminRelocateRangeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const AdminRelocateRangeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AdminRelocateRangeRequest* internal_default_instance() {
    return reinterpret_cast<const AdminRelocateRangeRequest*>(
               &_AdminRelocateRangeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  void Swap(AdminRelocateRangeRequest* other);
  friend void swap(AdminRelocateRangeRequest& a, AdminRelocateRangeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AdminRelocateRangeRequest* New() const final {
    return CreateMaybeMessage<AdminRelocateRangeRequest>(NULL);
  }

  AdminRelocateRangeRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AdminRelocateRangeRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const AdminRelocateRangeRequest& from);
  void MergeFrom(const AdminRelocateRangeRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AdminRelocateRangeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  int targets_size() const;
  void clear_targets();
  static const int kTargetsFieldNumber = 2;
  ::znbase::roachpb::ReplicationTarget* mutable_targets(int index);
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::ReplicationTarget >*
      mutable_targets();
  const ::znbase::roachpb::ReplicationTarget& targets(int index) const;
  ::znbase::roachpb::ReplicationTarget* add_targets();
  const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::ReplicationTarget >&
      targets() const;

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.AdminRelocateRangeRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::ReplicationTarget > targets_;
  ::znbase::roachpb::RequestHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AdminRelocateRangeResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.AdminRelocateRangeResponse) */ {
 public:
  AdminRelocateRangeResponse();
  virtual ~AdminRelocateRangeResponse();

  AdminRelocateRangeResponse(const AdminRelocateRangeResponse& from);

  inline AdminRelocateRangeResponse& operator=(const AdminRelocateRangeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AdminRelocateRangeResponse(AdminRelocateRangeResponse&& from) noexcept
    : AdminRelocateRangeResponse() {
    *this = ::std::move(from);
  }

  inline AdminRelocateRangeResponse& operator=(AdminRelocateRangeResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const AdminRelocateRangeResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AdminRelocateRangeResponse* internal_default_instance() {
    return reinterpret_cast<const AdminRelocateRangeResponse*>(
               &_AdminRelocateRangeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  void Swap(AdminRelocateRangeResponse* other);
  friend void swap(AdminRelocateRangeResponse& a, AdminRelocateRangeResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AdminRelocateRangeResponse* New() const final {
    return CreateMaybeMessage<AdminRelocateRangeResponse>(NULL);
  }

  AdminRelocateRangeResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AdminRelocateRangeResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const AdminRelocateRangeResponse& from);
  void MergeFrom(const AdminRelocateRangeResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AdminRelocateRangeResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.AdminRelocateRangeResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::ResponseHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HeartbeatTxnRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.HeartbeatTxnRequest) */ {
 public:
  HeartbeatTxnRequest();
  virtual ~HeartbeatTxnRequest();

  HeartbeatTxnRequest(const HeartbeatTxnRequest& from);

  inline HeartbeatTxnRequest& operator=(const HeartbeatTxnRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HeartbeatTxnRequest(HeartbeatTxnRequest&& from) noexcept
    : HeartbeatTxnRequest() {
    *this = ::std::move(from);
  }

  inline HeartbeatTxnRequest& operator=(HeartbeatTxnRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const HeartbeatTxnRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HeartbeatTxnRequest* internal_default_instance() {
    return reinterpret_cast<const HeartbeatTxnRequest*>(
               &_HeartbeatTxnRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  void Swap(HeartbeatTxnRequest* other);
  friend void swap(HeartbeatTxnRequest& a, HeartbeatTxnRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HeartbeatTxnRequest* New() const final {
    return CreateMaybeMessage<HeartbeatTxnRequest>(NULL);
  }

  HeartbeatTxnRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HeartbeatTxnRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const HeartbeatTxnRequest& from);
  void MergeFrom(const HeartbeatTxnRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HeartbeatTxnRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  bool has_now() const;
  void clear_now();
  static const int kNowFieldNumber = 2;
  private:
  const ::znbase::util::hlc::Timestamp& _internal_now() const;
  public:
  const ::znbase::util::hlc::Timestamp& now() const;
  ::znbase::util::hlc::Timestamp* release_now();
  ::znbase::util::hlc::Timestamp* mutable_now();
  void set_allocated_now(::znbase::util::hlc::Timestamp* now);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.HeartbeatTxnRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::RequestHeader* header_;
  ::znbase::util::hlc::Timestamp* now_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HeartbeatTxnResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.HeartbeatTxnResponse) */ {
 public:
  HeartbeatTxnResponse();
  virtual ~HeartbeatTxnResponse();

  HeartbeatTxnResponse(const HeartbeatTxnResponse& from);

  inline HeartbeatTxnResponse& operator=(const HeartbeatTxnResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HeartbeatTxnResponse(HeartbeatTxnResponse&& from) noexcept
    : HeartbeatTxnResponse() {
    *this = ::std::move(from);
  }

  inline HeartbeatTxnResponse& operator=(HeartbeatTxnResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const HeartbeatTxnResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HeartbeatTxnResponse* internal_default_instance() {
    return reinterpret_cast<const HeartbeatTxnResponse*>(
               &_HeartbeatTxnResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  void Swap(HeartbeatTxnResponse* other);
  friend void swap(HeartbeatTxnResponse& a, HeartbeatTxnResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HeartbeatTxnResponse* New() const final {
    return CreateMaybeMessage<HeartbeatTxnResponse>(NULL);
  }

  HeartbeatTxnResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HeartbeatTxnResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const HeartbeatTxnResponse& from);
  void MergeFrom(const HeartbeatTxnResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HeartbeatTxnResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.HeartbeatTxnResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::ResponseHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GCRequest_GCKey : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.GCRequest.GCKey) */ {
 public:
  GCRequest_GCKey();
  virtual ~GCRequest_GCKey();

  GCRequest_GCKey(const GCRequest_GCKey& from);

  inline GCRequest_GCKey& operator=(const GCRequest_GCKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GCRequest_GCKey(GCRequest_GCKey&& from) noexcept
    : GCRequest_GCKey() {
    *this = ::std::move(from);
  }

  inline GCRequest_GCKey& operator=(GCRequest_GCKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const GCRequest_GCKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GCRequest_GCKey* internal_default_instance() {
    return reinterpret_cast<const GCRequest_GCKey*>(
               &_GCRequest_GCKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  void Swap(GCRequest_GCKey* other);
  friend void swap(GCRequest_GCKey& a, GCRequest_GCKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GCRequest_GCKey* New() const final {
    return CreateMaybeMessage<GCRequest_GCKey>(NULL);
  }

  GCRequest_GCKey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GCRequest_GCKey>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const GCRequest_GCKey& from);
  void MergeFrom(const GCRequest_GCKey& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GCRequest_GCKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  private:
  const ::znbase::util::hlc::Timestamp& _internal_timestamp() const;
  public:
  const ::znbase::util::hlc::Timestamp& timestamp() const;
  ::znbase::util::hlc::Timestamp* release_timestamp();
  ::znbase::util::hlc::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::znbase::util::hlc::Timestamp* timestamp);

  bool has_from() const;
  void clear_from();
  static const int kFromFieldNumber = 3;
  private:
  const ::znbase::util::hlc::Timestamp& _internal_from() const;
  public:
  const ::znbase::util::hlc::Timestamp& from() const;
  ::znbase::util::hlc::Timestamp* release_from();
  ::znbase::util::hlc::Timestamp* mutable_from();
  void set_allocated_from(::znbase::util::hlc::Timestamp* from);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.GCRequest.GCKey)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::znbase::util::hlc::Timestamp* timestamp_;
  ::znbase::util::hlc::Timestamp* from_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GCRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.GCRequest) */ {
 public:
  GCRequest();
  virtual ~GCRequest();

  GCRequest(const GCRequest& from);

  inline GCRequest& operator=(const GCRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GCRequest(GCRequest&& from) noexcept
    : GCRequest() {
    *this = ::std::move(from);
  }

  inline GCRequest& operator=(GCRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const GCRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GCRequest* internal_default_instance() {
    return reinterpret_cast<const GCRequest*>(
               &_GCRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  void Swap(GCRequest* other);
  friend void swap(GCRequest& a, GCRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GCRequest* New() const final {
    return CreateMaybeMessage<GCRequest>(NULL);
  }

  GCRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GCRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const GCRequest& from);
  void MergeFrom(const GCRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GCRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef GCRequest_GCKey GCKey;

  // accessors -------------------------------------------------------

  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 3;
  ::znbase::roachpb::GCRequest_GCKey* mutable_keys(int index);
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::GCRequest_GCKey >*
      mutable_keys();
  const ::znbase::roachpb::GCRequest_GCKey& keys(int index) const;
  ::znbase::roachpb::GCRequest_GCKey* add_keys();
  const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::GCRequest_GCKey >&
      keys() const;

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  bool has_threshold() const;
  void clear_threshold();
  static const int kThresholdFieldNumber = 4;
  private:
  const ::znbase::util::hlc::Timestamp& _internal_threshold() const;
  public:
  const ::znbase::util::hlc::Timestamp& threshold() const;
  ::znbase::util::hlc::Timestamp* release_threshold();
  ::znbase::util::hlc::Timestamp* mutable_threshold();
  void set_allocated_threshold(::znbase::util::hlc::Timestamp* threshold);

  bool has_txn_span_gc_threshold() const;
  void clear_txn_span_gc_threshold();
  static const int kTxnSpanGcThresholdFieldNumber = 5;
  private:
  const ::znbase::util::hlc::Timestamp& _internal_txn_span_gc_threshold() const;
  public:
  const ::znbase::util::hlc::Timestamp& txn_span_gc_threshold() const;
  ::znbase::util::hlc::Timestamp* release_txn_span_gc_threshold();
  ::znbase::util::hlc::Timestamp* mutable_txn_span_gc_threshold();
  void set_allocated_txn_span_gc_threshold(::znbase::util::hlc::Timestamp* txn_span_gc_threshold);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.GCRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::GCRequest_GCKey > keys_;
  ::znbase::roachpb::RequestHeader* header_;
  ::znbase::util::hlc::Timestamp* threshold_;
  ::znbase::util::hlc::Timestamp* txn_span_gc_threshold_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GCResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.GCResponse) */ {
 public:
  GCResponse();
  virtual ~GCResponse();

  GCResponse(const GCResponse& from);

  inline GCResponse& operator=(const GCResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GCResponse(GCResponse&& from) noexcept
    : GCResponse() {
    *this = ::std::move(from);
  }

  inline GCResponse& operator=(GCResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const GCResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GCResponse* internal_default_instance() {
    return reinterpret_cast<const GCResponse*>(
               &_GCResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  void Swap(GCResponse* other);
  friend void swap(GCResponse& a, GCResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GCResponse* New() const final {
    return CreateMaybeMessage<GCResponse>(NULL);
  }

  GCResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GCResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const GCResponse& from);
  void MergeFrom(const GCResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GCResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.GCResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::ResponseHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PushTxnRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.PushTxnRequest) */ {
 public:
  PushTxnRequest();
  virtual ~PushTxnRequest();

  PushTxnRequest(const PushTxnRequest& from);

  inline PushTxnRequest& operator=(const PushTxnRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PushTxnRequest(PushTxnRequest&& from) noexcept
    : PushTxnRequest() {
    *this = ::std::move(from);
  }

  inline PushTxnRequest& operator=(PushTxnRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const PushTxnRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PushTxnRequest* internal_default_instance() {
    return reinterpret_cast<const PushTxnRequest*>(
               &_PushTxnRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  void Swap(PushTxnRequest* other);
  friend void swap(PushTxnRequest& a, PushTxnRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PushTxnRequest* New() const final {
    return CreateMaybeMessage<PushTxnRequest>(NULL);
  }

  PushTxnRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PushTxnRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const PushTxnRequest& from);
  void MergeFrom(const PushTxnRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PushTxnRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  bool has_pusher_txn() const;
  void clear_pusher_txn();
  static const int kPusherTxnFieldNumber = 2;
  private:
  const ::znbase::roachpb::Transaction& _internal_pusher_txn() const;
  public:
  const ::znbase::roachpb::Transaction& pusher_txn() const;
  ::znbase::roachpb::Transaction* release_pusher_txn();
  ::znbase::roachpb::Transaction* mutable_pusher_txn();
  void set_allocated_pusher_txn(::znbase::roachpb::Transaction* pusher_txn);

  bool has_pushee_txn() const;
  void clear_pushee_txn();
  static const int kPusheeTxnFieldNumber = 3;
  private:
  const ::znbase::storage::engine::enginepb::TxnMeta& _internal_pushee_txn() const;
  public:
  const ::znbase::storage::engine::enginepb::TxnMeta& pushee_txn() const;
  ::znbase::storage::engine::enginepb::TxnMeta* release_pushee_txn();
  ::znbase::storage::engine::enginepb::TxnMeta* mutable_pushee_txn();
  void set_allocated_pushee_txn(::znbase::storage::engine::enginepb::TxnMeta* pushee_txn);

  bool has_push_to() const;
  void clear_push_to();
  static const int kPushToFieldNumber = 4;
  private:
  const ::znbase::util::hlc::Timestamp& _internal_push_to() const;
  public:
  const ::znbase::util::hlc::Timestamp& push_to() const;
  ::znbase::util::hlc::Timestamp* release_push_to();
  ::znbase::util::hlc::Timestamp* mutable_push_to();
  void set_allocated_push_to(::znbase::util::hlc::Timestamp* push_to);

  // .znbase.roachpb.PushTxnType push_type = 6;
  void clear_push_type();
  static const int kPushTypeFieldNumber = 6;
  ::znbase::roachpb::PushTxnType push_type() const;
  void set_push_type(::znbase::roachpb::PushTxnType value);

  // bool inclusive_push_to = 9;
  void clear_inclusive_push_to();
  static const int kInclusivePushToFieldNumber = 9;
  bool inclusive_push_to() const;
  void set_inclusive_push_to(bool value);

  // bool force = 7;
  void clear_force();
  static const int kForceFieldNumber = 7;
  bool force() const;
  void set_force(bool value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.PushTxnRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::RequestHeader* header_;
  ::znbase::roachpb::Transaction* pusher_txn_;
  ::znbase::storage::engine::enginepb::TxnMeta* pushee_txn_;
  ::znbase::util::hlc::Timestamp* push_to_;
  int push_type_;
  bool inclusive_push_to_;
  bool force_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PushTxnResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.PushTxnResponse) */ {
 public:
  PushTxnResponse();
  virtual ~PushTxnResponse();

  PushTxnResponse(const PushTxnResponse& from);

  inline PushTxnResponse& operator=(const PushTxnResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PushTxnResponse(PushTxnResponse&& from) noexcept
    : PushTxnResponse() {
    *this = ::std::move(from);
  }

  inline PushTxnResponse& operator=(PushTxnResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const PushTxnResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PushTxnResponse* internal_default_instance() {
    return reinterpret_cast<const PushTxnResponse*>(
               &_PushTxnResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  void Swap(PushTxnResponse* other);
  friend void swap(PushTxnResponse& a, PushTxnResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PushTxnResponse* New() const final {
    return CreateMaybeMessage<PushTxnResponse>(NULL);
  }

  PushTxnResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PushTxnResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const PushTxnResponse& from);
  void MergeFrom(const PushTxnResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PushTxnResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  bool has_pushee_txn() const;
  void clear_pushee_txn();
  static const int kPusheeTxnFieldNumber = 2;
  private:
  const ::znbase::roachpb::Transaction& _internal_pushee_txn() const;
  public:
  const ::znbase::roachpb::Transaction& pushee_txn() const;
  ::znbase::roachpb::Transaction* release_pushee_txn();
  ::znbase::roachpb::Transaction* mutable_pushee_txn();
  void set_allocated_pushee_txn(::znbase::roachpb::Transaction* pushee_txn);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.PushTxnResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::ResponseHeader* header_;
  ::znbase::roachpb::Transaction* pushee_txn_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RecoverTxnRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.RecoverTxnRequest) */ {
 public:
  RecoverTxnRequest();
  virtual ~RecoverTxnRequest();

  RecoverTxnRequest(const RecoverTxnRequest& from);

  inline RecoverTxnRequest& operator=(const RecoverTxnRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RecoverTxnRequest(RecoverTxnRequest&& from) noexcept
    : RecoverTxnRequest() {
    *this = ::std::move(from);
  }

  inline RecoverTxnRequest& operator=(RecoverTxnRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const RecoverTxnRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RecoverTxnRequest* internal_default_instance() {
    return reinterpret_cast<const RecoverTxnRequest*>(
               &_RecoverTxnRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  void Swap(RecoverTxnRequest* other);
  friend void swap(RecoverTxnRequest& a, RecoverTxnRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RecoverTxnRequest* New() const final {
    return CreateMaybeMessage<RecoverTxnRequest>(NULL);
  }

  RecoverTxnRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RecoverTxnRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const RecoverTxnRequest& from);
  void MergeFrom(const RecoverTxnRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RecoverTxnRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  bool has_txn() const;
  void clear_txn();
  static const int kTxnFieldNumber = 2;
  private:
  const ::znbase::storage::engine::enginepb::TxnMeta& _internal_txn() const;
  public:
  const ::znbase::storage::engine::enginepb::TxnMeta& txn() const;
  ::znbase::storage::engine::enginepb::TxnMeta* release_txn();
  ::znbase::storage::engine::enginepb::TxnMeta* mutable_txn();
  void set_allocated_txn(::znbase::storage::engine::enginepb::TxnMeta* txn);

  // bool implicitly_committed = 3;
  void clear_implicitly_committed();
  static const int kImplicitlyCommittedFieldNumber = 3;
  bool implicitly_committed() const;
  void set_implicitly_committed(bool value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.RecoverTxnRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::RequestHeader* header_;
  ::znbase::storage::engine::enginepb::TxnMeta* txn_;
  bool implicitly_committed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RecoverTxnResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.RecoverTxnResponse) */ {
 public:
  RecoverTxnResponse();
  virtual ~RecoverTxnResponse();

  RecoverTxnResponse(const RecoverTxnResponse& from);

  inline RecoverTxnResponse& operator=(const RecoverTxnResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RecoverTxnResponse(RecoverTxnResponse&& from) noexcept
    : RecoverTxnResponse() {
    *this = ::std::move(from);
  }

  inline RecoverTxnResponse& operator=(RecoverTxnResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const RecoverTxnResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RecoverTxnResponse* internal_default_instance() {
    return reinterpret_cast<const RecoverTxnResponse*>(
               &_RecoverTxnResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  void Swap(RecoverTxnResponse* other);
  friend void swap(RecoverTxnResponse& a, RecoverTxnResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RecoverTxnResponse* New() const final {
    return CreateMaybeMessage<RecoverTxnResponse>(NULL);
  }

  RecoverTxnResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RecoverTxnResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const RecoverTxnResponse& from);
  void MergeFrom(const RecoverTxnResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RecoverTxnResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  bool has_recovered_txn() const;
  void clear_recovered_txn();
  static const int kRecoveredTxnFieldNumber = 2;
  private:
  const ::znbase::roachpb::Transaction& _internal_recovered_txn() const;
  public:
  const ::znbase::roachpb::Transaction& recovered_txn() const;
  ::znbase::roachpb::Transaction* release_recovered_txn();
  ::znbase::roachpb::Transaction* mutable_recovered_txn();
  void set_allocated_recovered_txn(::znbase::roachpb::Transaction* recovered_txn);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.RecoverTxnResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::ResponseHeader* header_;
  ::znbase::roachpb::Transaction* recovered_txn_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class QueryTxnRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.QueryTxnRequest) */ {
 public:
  QueryTxnRequest();
  virtual ~QueryTxnRequest();

  QueryTxnRequest(const QueryTxnRequest& from);

  inline QueryTxnRequest& operator=(const QueryTxnRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  QueryTxnRequest(QueryTxnRequest&& from) noexcept
    : QueryTxnRequest() {
    *this = ::std::move(from);
  }

  inline QueryTxnRequest& operator=(QueryTxnRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const QueryTxnRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const QueryTxnRequest* internal_default_instance() {
    return reinterpret_cast<const QueryTxnRequest*>(
               &_QueryTxnRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  void Swap(QueryTxnRequest* other);
  friend void swap(QueryTxnRequest& a, QueryTxnRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QueryTxnRequest* New() const final {
    return CreateMaybeMessage<QueryTxnRequest>(NULL);
  }

  QueryTxnRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<QueryTxnRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const QueryTxnRequest& from);
  void MergeFrom(const QueryTxnRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(QueryTxnRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  int known_waiting_txns_size() const;
  void clear_known_waiting_txns();
  static const int kKnownWaitingTxnsFieldNumber = 4;
  const ::std::string& known_waiting_txns(int index) const;
  ::std::string* mutable_known_waiting_txns(int index);
  void set_known_waiting_txns(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_known_waiting_txns(int index, ::std::string&& value);
  #endif
  void set_known_waiting_txns(int index, const char* value);
  void set_known_waiting_txns(int index, const void* value, size_t size);
  ::std::string* add_known_waiting_txns();
  void add_known_waiting_txns(const ::std::string& value);
  #if LANG_CXX11
  void add_known_waiting_txns(::std::string&& value);
  #endif
  void add_known_waiting_txns(const char* value);
  void add_known_waiting_txns(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& known_waiting_txns() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_known_waiting_txns();

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  bool has_txn() const;
  void clear_txn();
  static const int kTxnFieldNumber = 2;
  private:
  const ::znbase::storage::engine::enginepb::TxnMeta& _internal_txn() const;
  public:
  const ::znbase::storage::engine::enginepb::TxnMeta& txn() const;
  ::znbase::storage::engine::enginepb::TxnMeta* release_txn();
  ::znbase::storage::engine::enginepb::TxnMeta* mutable_txn();
  void set_allocated_txn(::znbase::storage::engine::enginepb::TxnMeta* txn);

  // bool wait_for_update = 3;
  void clear_wait_for_update();
  static const int kWaitForUpdateFieldNumber = 3;
  bool wait_for_update() const;
  void set_wait_for_update(bool value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.QueryTxnRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> known_waiting_txns_;
  ::znbase::roachpb::RequestHeader* header_;
  ::znbase::storage::engine::enginepb::TxnMeta* txn_;
  bool wait_for_update_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class QueryTxnResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.QueryTxnResponse) */ {
 public:
  QueryTxnResponse();
  virtual ~QueryTxnResponse();

  QueryTxnResponse(const QueryTxnResponse& from);

  inline QueryTxnResponse& operator=(const QueryTxnResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  QueryTxnResponse(QueryTxnResponse&& from) noexcept
    : QueryTxnResponse() {
    *this = ::std::move(from);
  }

  inline QueryTxnResponse& operator=(QueryTxnResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const QueryTxnResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const QueryTxnResponse* internal_default_instance() {
    return reinterpret_cast<const QueryTxnResponse*>(
               &_QueryTxnResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  void Swap(QueryTxnResponse* other);
  friend void swap(QueryTxnResponse& a, QueryTxnResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QueryTxnResponse* New() const final {
    return CreateMaybeMessage<QueryTxnResponse>(NULL);
  }

  QueryTxnResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<QueryTxnResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const QueryTxnResponse& from);
  void MergeFrom(const QueryTxnResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(QueryTxnResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  int waiting_txns_size() const;
  void clear_waiting_txns();
  static const int kWaitingTxnsFieldNumber = 3;
  const ::std::string& waiting_txns(int index) const;
  ::std::string* mutable_waiting_txns(int index);
  void set_waiting_txns(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_waiting_txns(int index, ::std::string&& value);
  #endif
  void set_waiting_txns(int index, const char* value);
  void set_waiting_txns(int index, const void* value, size_t size);
  ::std::string* add_waiting_txns();
  void add_waiting_txns(const ::std::string& value);
  #if LANG_CXX11
  void add_waiting_txns(::std::string&& value);
  #endif
  void add_waiting_txns(const char* value);
  void add_waiting_txns(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& waiting_txns() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_waiting_txns();

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  bool has_queried_txn() const;
  void clear_queried_txn();
  static const int kQueriedTxnFieldNumber = 2;
  private:
  const ::znbase::roachpb::Transaction& _internal_queried_txn() const;
  public:
  const ::znbase::roachpb::Transaction& queried_txn() const;
  ::znbase::roachpb::Transaction* release_queried_txn();
  ::znbase::roachpb::Transaction* mutable_queried_txn();
  void set_allocated_queried_txn(::znbase::roachpb::Transaction* queried_txn);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.QueryTxnResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> waiting_txns_;
  ::znbase::roachpb::ResponseHeader* header_;
  ::znbase::roachpb::Transaction* queried_txn_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class QueryIntentRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.QueryIntentRequest) */ {
 public:
  QueryIntentRequest();
  virtual ~QueryIntentRequest();

  QueryIntentRequest(const QueryIntentRequest& from);

  inline QueryIntentRequest& operator=(const QueryIntentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  QueryIntentRequest(QueryIntentRequest&& from) noexcept
    : QueryIntentRequest() {
    *this = ::std::move(from);
  }

  inline QueryIntentRequest& operator=(QueryIntentRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const QueryIntentRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const QueryIntentRequest* internal_default_instance() {
    return reinterpret_cast<const QueryIntentRequest*>(
               &_QueryIntentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  void Swap(QueryIntentRequest* other);
  friend void swap(QueryIntentRequest& a, QueryIntentRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QueryIntentRequest* New() const final {
    return CreateMaybeMessage<QueryIntentRequest>(NULL);
  }

  QueryIntentRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<QueryIntentRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const QueryIntentRequest& from);
  void MergeFrom(const QueryIntentRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(QueryIntentRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  bool has_txn() const;
  void clear_txn();
  static const int kTxnFieldNumber = 2;
  private:
  const ::znbase::storage::engine::enginepb::TxnMeta& _internal_txn() const;
  public:
  const ::znbase::storage::engine::enginepb::TxnMeta& txn() const;
  ::znbase::storage::engine::enginepb::TxnMeta* release_txn();
  ::znbase::storage::engine::enginepb::TxnMeta* mutable_txn();
  void set_allocated_txn(::znbase::storage::engine::enginepb::TxnMeta* txn);

  // bool error_if_missing = 3;
  void clear_error_if_missing();
  static const int kErrorIfMissingFieldNumber = 3;
  bool error_if_missing() const;
  void set_error_if_missing(bool value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.QueryIntentRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::RequestHeader* header_;
  ::znbase::storage::engine::enginepb::TxnMeta* txn_;
  bool error_if_missing_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class QueryIntentResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.QueryIntentResponse) */ {
 public:
  QueryIntentResponse();
  virtual ~QueryIntentResponse();

  QueryIntentResponse(const QueryIntentResponse& from);

  inline QueryIntentResponse& operator=(const QueryIntentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  QueryIntentResponse(QueryIntentResponse&& from) noexcept
    : QueryIntentResponse() {
    *this = ::std::move(from);
  }

  inline QueryIntentResponse& operator=(QueryIntentResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const QueryIntentResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const QueryIntentResponse* internal_default_instance() {
    return reinterpret_cast<const QueryIntentResponse*>(
               &_QueryIntentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  void Swap(QueryIntentResponse* other);
  friend void swap(QueryIntentResponse& a, QueryIntentResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QueryIntentResponse* New() const final {
    return CreateMaybeMessage<QueryIntentResponse>(NULL);
  }

  QueryIntentResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<QueryIntentResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const QueryIntentResponse& from);
  void MergeFrom(const QueryIntentResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(QueryIntentResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  // bool found_intent = 2;
  void clear_found_intent();
  static const int kFoundIntentFieldNumber = 2;
  bool found_intent() const;
  void set_found_intent(bool value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.QueryIntentResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::ResponseHeader* header_;
  bool found_intent_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResolveIntentRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.ResolveIntentRequest) */ {
 public:
  ResolveIntentRequest();
  virtual ~ResolveIntentRequest();

  ResolveIntentRequest(const ResolveIntentRequest& from);

  inline ResolveIntentRequest& operator=(const ResolveIntentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResolveIntentRequest(ResolveIntentRequest&& from) noexcept
    : ResolveIntentRequest() {
    *this = ::std::move(from);
  }

  inline ResolveIntentRequest& operator=(ResolveIntentRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ResolveIntentRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResolveIntentRequest* internal_default_instance() {
    return reinterpret_cast<const ResolveIntentRequest*>(
               &_ResolveIntentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  void Swap(ResolveIntentRequest* other);
  friend void swap(ResolveIntentRequest& a, ResolveIntentRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResolveIntentRequest* New() const final {
    return CreateMaybeMessage<ResolveIntentRequest>(NULL);
  }

  ResolveIntentRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResolveIntentRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ResolveIntentRequest& from);
  void MergeFrom(const ResolveIntentRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResolveIntentRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  int ignored_seqnums_size() const;
  void clear_ignored_seqnums();
  static const int kIgnoredSeqnumsFieldNumber = 5;
  ::znbase::storage::engine::enginepb::IgnoredSeqNumRange* mutable_ignored_seqnums(int index);
  ::google::protobuf::RepeatedPtrField< ::znbase::storage::engine::enginepb::IgnoredSeqNumRange >*
      mutable_ignored_seqnums();
  const ::znbase::storage::engine::enginepb::IgnoredSeqNumRange& ignored_seqnums(int index) const;
  ::znbase::storage::engine::enginepb::IgnoredSeqNumRange* add_ignored_seqnums();
  const ::google::protobuf::RepeatedPtrField< ::znbase::storage::engine::enginepb::IgnoredSeqNumRange >&
      ignored_seqnums() const;

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  bool has_intent_txn() const;
  void clear_intent_txn();
  static const int kIntentTxnFieldNumber = 2;
  private:
  const ::znbase::storage::engine::enginepb::TxnMeta& _internal_intent_txn() const;
  public:
  const ::znbase::storage::engine::enginepb::TxnMeta& intent_txn() const;
  ::znbase::storage::engine::enginepb::TxnMeta* release_intent_txn();
  ::znbase::storage::engine::enginepb::TxnMeta* mutable_intent_txn();
  void set_allocated_intent_txn(::znbase::storage::engine::enginepb::TxnMeta* intent_txn);

  // .znbase.roachpb.TransactionStatus status = 3;
  void clear_status();
  static const int kStatusFieldNumber = 3;
  ::znbase::roachpb::TransactionStatus status() const;
  void set_status(::znbase::roachpb::TransactionStatus value);

  // bool poison = 4;
  void clear_poison();
  static const int kPoisonFieldNumber = 4;
  bool poison() const;
  void set_poison(bool value);

  // bool back_fill = 6;
  void clear_back_fill();
  static const int kBackFillFieldNumber = 6;
  bool back_fill() const;
  void set_back_fill(bool value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.ResolveIntentRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::znbase::storage::engine::enginepb::IgnoredSeqNumRange > ignored_seqnums_;
  ::znbase::roachpb::RequestHeader* header_;
  ::znbase::storage::engine::enginepb::TxnMeta* intent_txn_;
  int status_;
  bool poison_;
  bool back_fill_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResolveIntentResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.ResolveIntentResponse) */ {
 public:
  ResolveIntentResponse();
  virtual ~ResolveIntentResponse();

  ResolveIntentResponse(const ResolveIntentResponse& from);

  inline ResolveIntentResponse& operator=(const ResolveIntentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResolveIntentResponse(ResolveIntentResponse&& from) noexcept
    : ResolveIntentResponse() {
    *this = ::std::move(from);
  }

  inline ResolveIntentResponse& operator=(ResolveIntentResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ResolveIntentResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResolveIntentResponse* internal_default_instance() {
    return reinterpret_cast<const ResolveIntentResponse*>(
               &_ResolveIntentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  void Swap(ResolveIntentResponse* other);
  friend void swap(ResolveIntentResponse& a, ResolveIntentResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResolveIntentResponse* New() const final {
    return CreateMaybeMessage<ResolveIntentResponse>(NULL);
  }

  ResolveIntentResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResolveIntentResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ResolveIntentResponse& from);
  void MergeFrom(const ResolveIntentResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResolveIntentResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.ResolveIntentResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::ResponseHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResolveIntentRangeRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.ResolveIntentRangeRequest) */ {
 public:
  ResolveIntentRangeRequest();
  virtual ~ResolveIntentRangeRequest();

  ResolveIntentRangeRequest(const ResolveIntentRangeRequest& from);

  inline ResolveIntentRangeRequest& operator=(const ResolveIntentRangeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResolveIntentRangeRequest(ResolveIntentRangeRequest&& from) noexcept
    : ResolveIntentRangeRequest() {
    *this = ::std::move(from);
  }

  inline ResolveIntentRangeRequest& operator=(ResolveIntentRangeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ResolveIntentRangeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResolveIntentRangeRequest* internal_default_instance() {
    return reinterpret_cast<const ResolveIntentRangeRequest*>(
               &_ResolveIntentRangeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  void Swap(ResolveIntentRangeRequest* other);
  friend void swap(ResolveIntentRangeRequest& a, ResolveIntentRangeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResolveIntentRangeRequest* New() const final {
    return CreateMaybeMessage<ResolveIntentRangeRequest>(NULL);
  }

  ResolveIntentRangeRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResolveIntentRangeRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ResolveIntentRangeRequest& from);
  void MergeFrom(const ResolveIntentRangeRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResolveIntentRangeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  int ignored_seqnums_size() const;
  void clear_ignored_seqnums();
  static const int kIgnoredSeqnumsFieldNumber = 6;
  ::znbase::storage::engine::enginepb::IgnoredSeqNumRange* mutable_ignored_seqnums(int index);
  ::google::protobuf::RepeatedPtrField< ::znbase::storage::engine::enginepb::IgnoredSeqNumRange >*
      mutable_ignored_seqnums();
  const ::znbase::storage::engine::enginepb::IgnoredSeqNumRange& ignored_seqnums(int index) const;
  ::znbase::storage::engine::enginepb::IgnoredSeqNumRange* add_ignored_seqnums();
  const ::google::protobuf::RepeatedPtrField< ::znbase::storage::engine::enginepb::IgnoredSeqNumRange >&
      ignored_seqnums() const;

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  bool has_intent_txn() const;
  void clear_intent_txn();
  static const int kIntentTxnFieldNumber = 2;
  private:
  const ::znbase::storage::engine::enginepb::TxnMeta& _internal_intent_txn() const;
  public:
  const ::znbase::storage::engine::enginepb::TxnMeta& intent_txn() const;
  ::znbase::storage::engine::enginepb::TxnMeta* release_intent_txn();
  ::znbase::storage::engine::enginepb::TxnMeta* mutable_intent_txn();
  void set_allocated_intent_txn(::znbase::storage::engine::enginepb::TxnMeta* intent_txn);

  bool has_min_timestamp() const;
  void clear_min_timestamp();
  static const int kMinTimestampFieldNumber = 5;
  private:
  const ::znbase::util::hlc::Timestamp& _internal_min_timestamp() const;
  public:
  const ::znbase::util::hlc::Timestamp& min_timestamp() const;
  ::znbase::util::hlc::Timestamp* release_min_timestamp();
  ::znbase::util::hlc::Timestamp* mutable_min_timestamp();
  void set_allocated_min_timestamp(::znbase::util::hlc::Timestamp* min_timestamp);

  // .znbase.roachpb.TransactionStatus status = 3;
  void clear_status();
  static const int kStatusFieldNumber = 3;
  ::znbase::roachpb::TransactionStatus status() const;
  void set_status(::znbase::roachpb::TransactionStatus value);

  // bool poison = 4;
  void clear_poison();
  static const int kPoisonFieldNumber = 4;
  bool poison() const;
  void set_poison(bool value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.ResolveIntentRangeRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::znbase::storage::engine::enginepb::IgnoredSeqNumRange > ignored_seqnums_;
  ::znbase::roachpb::RequestHeader* header_;
  ::znbase::storage::engine::enginepb::TxnMeta* intent_txn_;
  ::znbase::util::hlc::Timestamp* min_timestamp_;
  int status_;
  bool poison_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResolveIntentRangeResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.ResolveIntentRangeResponse) */ {
 public:
  ResolveIntentRangeResponse();
  virtual ~ResolveIntentRangeResponse();

  ResolveIntentRangeResponse(const ResolveIntentRangeResponse& from);

  inline ResolveIntentRangeResponse& operator=(const ResolveIntentRangeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResolveIntentRangeResponse(ResolveIntentRangeResponse&& from) noexcept
    : ResolveIntentRangeResponse() {
    *this = ::std::move(from);
  }

  inline ResolveIntentRangeResponse& operator=(ResolveIntentRangeResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ResolveIntentRangeResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResolveIntentRangeResponse* internal_default_instance() {
    return reinterpret_cast<const ResolveIntentRangeResponse*>(
               &_ResolveIntentRangeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  void Swap(ResolveIntentRangeResponse* other);
  friend void swap(ResolveIntentRangeResponse& a, ResolveIntentRangeResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResolveIntentRangeResponse* New() const final {
    return CreateMaybeMessage<ResolveIntentRangeResponse>(NULL);
  }

  ResolveIntentRangeResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResolveIntentRangeResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ResolveIntentRangeResponse& from);
  void MergeFrom(const ResolveIntentRangeResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResolveIntentRangeResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.ResolveIntentRangeResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::ResponseHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MergeRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.MergeRequest) */ {
 public:
  MergeRequest();
  virtual ~MergeRequest();

  MergeRequest(const MergeRequest& from);

  inline MergeRequest& operator=(const MergeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MergeRequest(MergeRequest&& from) noexcept
    : MergeRequest() {
    *this = ::std::move(from);
  }

  inline MergeRequest& operator=(MergeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const MergeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MergeRequest* internal_default_instance() {
    return reinterpret_cast<const MergeRequest*>(
               &_MergeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  void Swap(MergeRequest* other);
  friend void swap(MergeRequest& a, MergeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MergeRequest* New() const final {
    return CreateMaybeMessage<MergeRequest>(NULL);
  }

  MergeRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MergeRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const MergeRequest& from);
  void MergeFrom(const MergeRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MergeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  private:
  const ::znbase::roachpb::Value& _internal_value() const;
  public:
  const ::znbase::roachpb::Value& value() const;
  ::znbase::roachpb::Value* release_value();
  ::znbase::roachpb::Value* mutable_value();
  void set_allocated_value(::znbase::roachpb::Value* value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.MergeRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::RequestHeader* header_;
  ::znbase::roachpb::Value* value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MergeResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.MergeResponse) */ {
 public:
  MergeResponse();
  virtual ~MergeResponse();

  MergeResponse(const MergeResponse& from);

  inline MergeResponse& operator=(const MergeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MergeResponse(MergeResponse&& from) noexcept
    : MergeResponse() {
    *this = ::std::move(from);
  }

  inline MergeResponse& operator=(MergeResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const MergeResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MergeResponse* internal_default_instance() {
    return reinterpret_cast<const MergeResponse*>(
               &_MergeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  void Swap(MergeResponse* other);
  friend void swap(MergeResponse& a, MergeResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MergeResponse* New() const final {
    return CreateMaybeMessage<MergeResponse>(NULL);
  }

  MergeResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MergeResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const MergeResponse& from);
  void MergeFrom(const MergeResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MergeResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.MergeResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::ResponseHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TruncateLogRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.TruncateLogRequest) */ {
 public:
  TruncateLogRequest();
  virtual ~TruncateLogRequest();

  TruncateLogRequest(const TruncateLogRequest& from);

  inline TruncateLogRequest& operator=(const TruncateLogRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TruncateLogRequest(TruncateLogRequest&& from) noexcept
    : TruncateLogRequest() {
    *this = ::std::move(from);
  }

  inline TruncateLogRequest& operator=(TruncateLogRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const TruncateLogRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TruncateLogRequest* internal_default_instance() {
    return reinterpret_cast<const TruncateLogRequest*>(
               &_TruncateLogRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  void Swap(TruncateLogRequest* other);
  friend void swap(TruncateLogRequest& a, TruncateLogRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TruncateLogRequest* New() const final {
    return CreateMaybeMessage<TruncateLogRequest>(NULL);
  }

  TruncateLogRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TruncateLogRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const TruncateLogRequest& from);
  void MergeFrom(const TruncateLogRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TruncateLogRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  // uint64 index = 2;
  void clear_index();
  static const int kIndexFieldNumber = 2;
  ::google::protobuf::uint64 index() const;
  void set_index(::google::protobuf::uint64 value);

  void clear_range_id();
  static const int kRangeIdFieldNumber = 3;
  ::google::protobuf::int64 range_id() const;
  void set_range_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.TruncateLogRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::RequestHeader* header_;
  ::google::protobuf::uint64 index_;
  ::google::protobuf::int64 range_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TruncateLogResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.TruncateLogResponse) */ {
 public:
  TruncateLogResponse();
  virtual ~TruncateLogResponse();

  TruncateLogResponse(const TruncateLogResponse& from);

  inline TruncateLogResponse& operator=(const TruncateLogResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TruncateLogResponse(TruncateLogResponse&& from) noexcept
    : TruncateLogResponse() {
    *this = ::std::move(from);
  }

  inline TruncateLogResponse& operator=(TruncateLogResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const TruncateLogResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TruncateLogResponse* internal_default_instance() {
    return reinterpret_cast<const TruncateLogResponse*>(
               &_TruncateLogResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  void Swap(TruncateLogResponse* other);
  friend void swap(TruncateLogResponse& a, TruncateLogResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TruncateLogResponse* New() const final {
    return CreateMaybeMessage<TruncateLogResponse>(NULL);
  }

  TruncateLogResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TruncateLogResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const TruncateLogResponse& from);
  void MergeFrom(const TruncateLogResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TruncateLogResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.TruncateLogResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::ResponseHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestLeaseRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.RequestLeaseRequest) */ {
 public:
  RequestLeaseRequest();
  virtual ~RequestLeaseRequest();

  RequestLeaseRequest(const RequestLeaseRequest& from);

  inline RequestLeaseRequest& operator=(const RequestLeaseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestLeaseRequest(RequestLeaseRequest&& from) noexcept
    : RequestLeaseRequest() {
    *this = ::std::move(from);
  }

  inline RequestLeaseRequest& operator=(RequestLeaseRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const RequestLeaseRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestLeaseRequest* internal_default_instance() {
    return reinterpret_cast<const RequestLeaseRequest*>(
               &_RequestLeaseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  void Swap(RequestLeaseRequest* other);
  friend void swap(RequestLeaseRequest& a, RequestLeaseRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestLeaseRequest* New() const final {
    return CreateMaybeMessage<RequestLeaseRequest>(NULL);
  }

  RequestLeaseRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestLeaseRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const RequestLeaseRequest& from);
  void MergeFrom(const RequestLeaseRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestLeaseRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  bool has_lease() const;
  void clear_lease();
  static const int kLeaseFieldNumber = 2;
  private:
  const ::znbase::roachpb::Lease& _internal_lease() const;
  public:
  const ::znbase::roachpb::Lease& lease() const;
  ::znbase::roachpb::Lease* release_lease();
  ::znbase::roachpb::Lease* mutable_lease();
  void set_allocated_lease(::znbase::roachpb::Lease* lease);

  bool has_prev_lease() const;
  void clear_prev_lease();
  static const int kPrevLeaseFieldNumber = 3;
  private:
  const ::znbase::roachpb::Lease& _internal_prev_lease() const;
  public:
  const ::znbase::roachpb::Lease& prev_lease() const;
  ::znbase::roachpb::Lease* release_prev_lease();
  ::znbase::roachpb::Lease* mutable_prev_lease();
  void set_allocated_prev_lease(::znbase::roachpb::Lease* prev_lease);

  bool has_min_proposed_ts() const;
  void clear_min_proposed_ts();
  static const int kMinProposedTsFieldNumber = 4;
  private:
  const ::znbase::util::hlc::Timestamp& _internal_min_proposed_ts() const;
  public:
  const ::znbase::util::hlc::Timestamp& min_proposed_ts() const;
  ::znbase::util::hlc::Timestamp* release_min_proposed_ts();
  ::znbase::util::hlc::Timestamp* mutable_min_proposed_ts();
  void set_allocated_min_proposed_ts(::znbase::util::hlc::Timestamp* min_proposed_ts);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.RequestLeaseRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::RequestHeader* header_;
  ::znbase::roachpb::Lease* lease_;
  ::znbase::roachpb::Lease* prev_lease_;
  ::znbase::util::hlc::Timestamp* min_proposed_ts_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TransferLeaseRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.TransferLeaseRequest) */ {
 public:
  TransferLeaseRequest();
  virtual ~TransferLeaseRequest();

  TransferLeaseRequest(const TransferLeaseRequest& from);

  inline TransferLeaseRequest& operator=(const TransferLeaseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TransferLeaseRequest(TransferLeaseRequest&& from) noexcept
    : TransferLeaseRequest() {
    *this = ::std::move(from);
  }

  inline TransferLeaseRequest& operator=(TransferLeaseRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const TransferLeaseRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransferLeaseRequest* internal_default_instance() {
    return reinterpret_cast<const TransferLeaseRequest*>(
               &_TransferLeaseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  void Swap(TransferLeaseRequest* other);
  friend void swap(TransferLeaseRequest& a, TransferLeaseRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransferLeaseRequest* New() const final {
    return CreateMaybeMessage<TransferLeaseRequest>(NULL);
  }

  TransferLeaseRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TransferLeaseRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const TransferLeaseRequest& from);
  void MergeFrom(const TransferLeaseRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TransferLeaseRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  bool has_lease() const;
  void clear_lease();
  static const int kLeaseFieldNumber = 2;
  private:
  const ::znbase::roachpb::Lease& _internal_lease() const;
  public:
  const ::znbase::roachpb::Lease& lease() const;
  ::znbase::roachpb::Lease* release_lease();
  ::znbase::roachpb::Lease* mutable_lease();
  void set_allocated_lease(::znbase::roachpb::Lease* lease);

  bool has_prev_lease() const;
  void clear_prev_lease();
  static const int kPrevLeaseFieldNumber = 3;
  private:
  const ::znbase::roachpb::Lease& _internal_prev_lease() const;
  public:
  const ::znbase::roachpb::Lease& prev_lease() const;
  ::znbase::roachpb::Lease* release_prev_lease();
  ::znbase::roachpb::Lease* mutable_prev_lease();
  void set_allocated_prev_lease(::znbase::roachpb::Lease* prev_lease);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.TransferLeaseRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::RequestHeader* header_;
  ::znbase::roachpb::Lease* lease_;
  ::znbase::roachpb::Lease* prev_lease_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LeaseInfoRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.LeaseInfoRequest) */ {
 public:
  LeaseInfoRequest();
  virtual ~LeaseInfoRequest();

  LeaseInfoRequest(const LeaseInfoRequest& from);

  inline LeaseInfoRequest& operator=(const LeaseInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LeaseInfoRequest(LeaseInfoRequest&& from) noexcept
    : LeaseInfoRequest() {
    *this = ::std::move(from);
  }

  inline LeaseInfoRequest& operator=(LeaseInfoRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const LeaseInfoRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LeaseInfoRequest* internal_default_instance() {
    return reinterpret_cast<const LeaseInfoRequest*>(
               &_LeaseInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  void Swap(LeaseInfoRequest* other);
  friend void swap(LeaseInfoRequest& a, LeaseInfoRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LeaseInfoRequest* New() const final {
    return CreateMaybeMessage<LeaseInfoRequest>(NULL);
  }

  LeaseInfoRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LeaseInfoRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const LeaseInfoRequest& from);
  void MergeFrom(const LeaseInfoRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LeaseInfoRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.LeaseInfoRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::RequestHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LeaseInfoResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.LeaseInfoResponse) */ {
 public:
  LeaseInfoResponse();
  virtual ~LeaseInfoResponse();

  LeaseInfoResponse(const LeaseInfoResponse& from);

  inline LeaseInfoResponse& operator=(const LeaseInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LeaseInfoResponse(LeaseInfoResponse&& from) noexcept
    : LeaseInfoResponse() {
    *this = ::std::move(from);
  }

  inline LeaseInfoResponse& operator=(LeaseInfoResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const LeaseInfoResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LeaseInfoResponse* internal_default_instance() {
    return reinterpret_cast<const LeaseInfoResponse*>(
               &_LeaseInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  void Swap(LeaseInfoResponse* other);
  friend void swap(LeaseInfoResponse& a, LeaseInfoResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LeaseInfoResponse* New() const final {
    return CreateMaybeMessage<LeaseInfoResponse>(NULL);
  }

  LeaseInfoResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LeaseInfoResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const LeaseInfoResponse& from);
  void MergeFrom(const LeaseInfoResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LeaseInfoResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  bool has_lease() const;
  void clear_lease();
  static const int kLeaseFieldNumber = 2;
  private:
  const ::znbase::roachpb::Lease& _internal_lease() const;
  public:
  const ::znbase::roachpb::Lease& lease() const;
  ::znbase::roachpb::Lease* release_lease();
  ::znbase::roachpb::Lease* mutable_lease();
  void set_allocated_lease(::znbase::roachpb::Lease* lease);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.LeaseInfoResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::ResponseHeader* header_;
  ::znbase::roachpb::Lease* lease_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestLeaseResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.RequestLeaseResponse) */ {
 public:
  RequestLeaseResponse();
  virtual ~RequestLeaseResponse();

  RequestLeaseResponse(const RequestLeaseResponse& from);

  inline RequestLeaseResponse& operator=(const RequestLeaseResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestLeaseResponse(RequestLeaseResponse&& from) noexcept
    : RequestLeaseResponse() {
    *this = ::std::move(from);
  }

  inline RequestLeaseResponse& operator=(RequestLeaseResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const RequestLeaseResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestLeaseResponse* internal_default_instance() {
    return reinterpret_cast<const RequestLeaseResponse*>(
               &_RequestLeaseResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  void Swap(RequestLeaseResponse* other);
  friend void swap(RequestLeaseResponse& a, RequestLeaseResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestLeaseResponse* New() const final {
    return CreateMaybeMessage<RequestLeaseResponse>(NULL);
  }

  RequestLeaseResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestLeaseResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const RequestLeaseResponse& from);
  void MergeFrom(const RequestLeaseResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestLeaseResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.RequestLeaseResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::ResponseHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ComputeChecksumRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.ComputeChecksumRequest) */ {
 public:
  ComputeChecksumRequest();
  virtual ~ComputeChecksumRequest();

  ComputeChecksumRequest(const ComputeChecksumRequest& from);

  inline ComputeChecksumRequest& operator=(const ComputeChecksumRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ComputeChecksumRequest(ComputeChecksumRequest&& from) noexcept
    : ComputeChecksumRequest() {
    *this = ::std::move(from);
  }

  inline ComputeChecksumRequest& operator=(ComputeChecksumRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ComputeChecksumRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ComputeChecksumRequest* internal_default_instance() {
    return reinterpret_cast<const ComputeChecksumRequest*>(
               &_ComputeChecksumRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  void Swap(ComputeChecksumRequest* other);
  friend void swap(ComputeChecksumRequest& a, ComputeChecksumRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ComputeChecksumRequest* New() const final {
    return CreateMaybeMessage<ComputeChecksumRequest>(NULL);
  }

  ComputeChecksumRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ComputeChecksumRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ComputeChecksumRequest& from);
  void MergeFrom(const ComputeChecksumRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ComputeChecksumRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  // uint32 version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // .znbase.roachpb.ChecksumMode mode = 5;
  void clear_mode();
  static const int kModeFieldNumber = 5;
  ::znbase::roachpb::ChecksumMode mode() const;
  void set_mode(::znbase::roachpb::ChecksumMode value);

  // bool snapshot = 4;
  void clear_snapshot();
  static const int kSnapshotFieldNumber = 4;
  bool snapshot() const;
  void set_snapshot(bool value);

  // bool checkpoint = 6;
  void clear_checkpoint();
  static const int kCheckpointFieldNumber = 6;
  bool checkpoint() const;
  void set_checkpoint(bool value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.ComputeChecksumRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::RequestHeader* header_;
  ::google::protobuf::uint32 version_;
  int mode_;
  bool snapshot_;
  bool checkpoint_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ComputeChecksumResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.ComputeChecksumResponse) */ {
 public:
  ComputeChecksumResponse();
  virtual ~ComputeChecksumResponse();

  ComputeChecksumResponse(const ComputeChecksumResponse& from);

  inline ComputeChecksumResponse& operator=(const ComputeChecksumResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ComputeChecksumResponse(ComputeChecksumResponse&& from) noexcept
    : ComputeChecksumResponse() {
    *this = ::std::move(from);
  }

  inline ComputeChecksumResponse& operator=(ComputeChecksumResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ComputeChecksumResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ComputeChecksumResponse* internal_default_instance() {
    return reinterpret_cast<const ComputeChecksumResponse*>(
               &_ComputeChecksumResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  void Swap(ComputeChecksumResponse* other);
  friend void swap(ComputeChecksumResponse& a, ComputeChecksumResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ComputeChecksumResponse* New() const final {
    return CreateMaybeMessage<ComputeChecksumResponse>(NULL);
  }

  ComputeChecksumResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ComputeChecksumResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ComputeChecksumResponse& from);
  void MergeFrom(const ComputeChecksumResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ComputeChecksumResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  void clear_checksum_id();
  static const int kChecksumIdFieldNumber = 2;
  const ::std::string& checksum_id() const;
  void set_checksum_id(const ::std::string& value);
  #if LANG_CXX11
  void set_checksum_id(::std::string&& value);
  #endif
  void set_checksum_id(const char* value);
  void set_checksum_id(const void* value, size_t size);
  ::std::string* mutable_checksum_id();
  ::std::string* release_checksum_id();
  void set_allocated_checksum_id(::std::string* checksum_id);

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.ComputeChecksumResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr checksum_id_;
  ::znbase::roachpb::ResponseHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExportStorage_LocalFilePath : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.ExportStorage.LocalFilePath) */ {
 public:
  ExportStorage_LocalFilePath();
  virtual ~ExportStorage_LocalFilePath();

  ExportStorage_LocalFilePath(const ExportStorage_LocalFilePath& from);

  inline ExportStorage_LocalFilePath& operator=(const ExportStorage_LocalFilePath& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExportStorage_LocalFilePath(ExportStorage_LocalFilePath&& from) noexcept
    : ExportStorage_LocalFilePath() {
    *this = ::std::move(from);
  }

  inline ExportStorage_LocalFilePath& operator=(ExportStorage_LocalFilePath&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ExportStorage_LocalFilePath& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExportStorage_LocalFilePath* internal_default_instance() {
    return reinterpret_cast<const ExportStorage_LocalFilePath*>(
               &_ExportStorage_LocalFilePath_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  void Swap(ExportStorage_LocalFilePath* other);
  friend void swap(ExportStorage_LocalFilePath& a, ExportStorage_LocalFilePath& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExportStorage_LocalFilePath* New() const final {
    return CreateMaybeMessage<ExportStorage_LocalFilePath>(NULL);
  }

  ExportStorage_LocalFilePath* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExportStorage_LocalFilePath>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ExportStorage_LocalFilePath& from);
  void MergeFrom(const ExportStorage_LocalFilePath& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExportStorage_LocalFilePath* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string path = 1;
  void clear_path();
  static const int kPathFieldNumber = 1;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  void clear_node_id();
  static const int kNodeIdFieldNumber = 2;
  ::google::protobuf::uint32 node_id() const;
  void set_node_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.ExportStorage.LocalFilePath)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::uint32 node_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExportStorage_Http : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.ExportStorage.Http) */ {
 public:
  ExportStorage_Http();
  virtual ~ExportStorage_Http();

  ExportStorage_Http(const ExportStorage_Http& from);

  inline ExportStorage_Http& operator=(const ExportStorage_Http& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExportStorage_Http(ExportStorage_Http&& from) noexcept
    : ExportStorage_Http() {
    *this = ::std::move(from);
  }

  inline ExportStorage_Http& operator=(ExportStorage_Http&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ExportStorage_Http& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExportStorage_Http* internal_default_instance() {
    return reinterpret_cast<const ExportStorage_Http*>(
               &_ExportStorage_Http_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  void Swap(ExportStorage_Http* other);
  friend void swap(ExportStorage_Http& a, ExportStorage_Http& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExportStorage_Http* New() const final {
    return CreateMaybeMessage<ExportStorage_Http>(NULL);
  }

  ExportStorage_Http* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExportStorage_Http>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ExportStorage_Http& from);
  void MergeFrom(const ExportStorage_Http& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExportStorage_Http* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string baseUri = 1;
  void clear_baseuri();
  static const int kBaseUriFieldNumber = 1;
  const ::std::string& baseuri() const;
  void set_baseuri(const ::std::string& value);
  #if LANG_CXX11
  void set_baseuri(::std::string&& value);
  #endif
  void set_baseuri(const char* value);
  void set_baseuri(const char* value, size_t size);
  ::std::string* mutable_baseuri();
  ::std::string* release_baseuri();
  void set_allocated_baseuri(::std::string* baseuri);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.ExportStorage.Http)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr baseuri_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExportStorage_S3 : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.ExportStorage.S3) */ {
 public:
  ExportStorage_S3();
  virtual ~ExportStorage_S3();

  ExportStorage_S3(const ExportStorage_S3& from);

  inline ExportStorage_S3& operator=(const ExportStorage_S3& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExportStorage_S3(ExportStorage_S3&& from) noexcept
    : ExportStorage_S3() {
    *this = ::std::move(from);
  }

  inline ExportStorage_S3& operator=(ExportStorage_S3&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ExportStorage_S3& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExportStorage_S3* internal_default_instance() {
    return reinterpret_cast<const ExportStorage_S3*>(
               &_ExportStorage_S3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  void Swap(ExportStorage_S3* other);
  friend void swap(ExportStorage_S3& a, ExportStorage_S3& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExportStorage_S3* New() const final {
    return CreateMaybeMessage<ExportStorage_S3>(NULL);
  }

  ExportStorage_S3* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExportStorage_S3>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ExportStorage_S3& from);
  void MergeFrom(const ExportStorage_S3& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExportStorage_S3* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string bucket = 1;
  void clear_bucket();
  static const int kBucketFieldNumber = 1;
  const ::std::string& bucket() const;
  void set_bucket(const ::std::string& value);
  #if LANG_CXX11
  void set_bucket(::std::string&& value);
  #endif
  void set_bucket(const char* value);
  void set_bucket(const char* value, size_t size);
  ::std::string* mutable_bucket();
  ::std::string* release_bucket();
  void set_allocated_bucket(::std::string* bucket);

  // string prefix = 2;
  void clear_prefix();
  static const int kPrefixFieldNumber = 2;
  const ::std::string& prefix() const;
  void set_prefix(const ::std::string& value);
  #if LANG_CXX11
  void set_prefix(::std::string&& value);
  #endif
  void set_prefix(const char* value);
  void set_prefix(const char* value, size_t size);
  ::std::string* mutable_prefix();
  ::std::string* release_prefix();
  void set_allocated_prefix(::std::string* prefix);

  // string access_key = 3;
  void clear_access_key();
  static const int kAccessKeyFieldNumber = 3;
  const ::std::string& access_key() const;
  void set_access_key(const ::std::string& value);
  #if LANG_CXX11
  void set_access_key(::std::string&& value);
  #endif
  void set_access_key(const char* value);
  void set_access_key(const char* value, size_t size);
  ::std::string* mutable_access_key();
  ::std::string* release_access_key();
  void set_allocated_access_key(::std::string* access_key);

  // string secret = 4;
  void clear_secret();
  static const int kSecretFieldNumber = 4;
  const ::std::string& secret() const;
  void set_secret(const ::std::string& value);
  #if LANG_CXX11
  void set_secret(::std::string&& value);
  #endif
  void set_secret(const char* value);
  void set_secret(const char* value, size_t size);
  ::std::string* mutable_secret();
  ::std::string* release_secret();
  void set_allocated_secret(::std::string* secret);

  // string temp_token = 5;
  void clear_temp_token();
  static const int kTempTokenFieldNumber = 5;
  const ::std::string& temp_token() const;
  void set_temp_token(const ::std::string& value);
  #if LANG_CXX11
  void set_temp_token(::std::string&& value);
  #endif
  void set_temp_token(const char* value);
  void set_temp_token(const char* value, size_t size);
  ::std::string* mutable_temp_token();
  ::std::string* release_temp_token();
  void set_allocated_temp_token(::std::string* temp_token);

  // string endpoint = 6;
  void clear_endpoint();
  static const int kEndpointFieldNumber = 6;
  const ::std::string& endpoint() const;
  void set_endpoint(const ::std::string& value);
  #if LANG_CXX11
  void set_endpoint(::std::string&& value);
  #endif
  void set_endpoint(const char* value);
  void set_endpoint(const char* value, size_t size);
  ::std::string* mutable_endpoint();
  ::std::string* release_endpoint();
  void set_allocated_endpoint(::std::string* endpoint);

  // string region = 7;
  void clear_region();
  static const int kRegionFieldNumber = 7;
  const ::std::string& region() const;
  void set_region(const ::std::string& value);
  #if LANG_CXX11
  void set_region(::std::string&& value);
  #endif
  void set_region(const char* value);
  void set_region(const char* value, size_t size);
  ::std::string* mutable_region();
  ::std::string* release_region();
  void set_allocated_region(::std::string* region);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.ExportStorage.S3)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr bucket_;
  ::google::protobuf::internal::ArenaStringPtr prefix_;
  ::google::protobuf::internal::ArenaStringPtr access_key_;
  ::google::protobuf::internal::ArenaStringPtr secret_;
  ::google::protobuf::internal::ArenaStringPtr temp_token_;
  ::google::protobuf::internal::ArenaStringPtr endpoint_;
  ::google::protobuf::internal::ArenaStringPtr region_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExportStorage_GCS : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.ExportStorage.GCS) */ {
 public:
  ExportStorage_GCS();
  virtual ~ExportStorage_GCS();

  ExportStorage_GCS(const ExportStorage_GCS& from);

  inline ExportStorage_GCS& operator=(const ExportStorage_GCS& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExportStorage_GCS(ExportStorage_GCS&& from) noexcept
    : ExportStorage_GCS() {
    *this = ::std::move(from);
  }

  inline ExportStorage_GCS& operator=(ExportStorage_GCS&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ExportStorage_GCS& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExportStorage_GCS* internal_default_instance() {
    return reinterpret_cast<const ExportStorage_GCS*>(
               &_ExportStorage_GCS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  void Swap(ExportStorage_GCS* other);
  friend void swap(ExportStorage_GCS& a, ExportStorage_GCS& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExportStorage_GCS* New() const final {
    return CreateMaybeMessage<ExportStorage_GCS>(NULL);
  }

  ExportStorage_GCS* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExportStorage_GCS>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ExportStorage_GCS& from);
  void MergeFrom(const ExportStorage_GCS& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExportStorage_GCS* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string bucket = 1;
  void clear_bucket();
  static const int kBucketFieldNumber = 1;
  const ::std::string& bucket() const;
  void set_bucket(const ::std::string& value);
  #if LANG_CXX11
  void set_bucket(::std::string&& value);
  #endif
  void set_bucket(const char* value);
  void set_bucket(const char* value, size_t size);
  ::std::string* mutable_bucket();
  ::std::string* release_bucket();
  void set_allocated_bucket(::std::string* bucket);

  // string prefix = 2;
  void clear_prefix();
  static const int kPrefixFieldNumber = 2;
  const ::std::string& prefix() const;
  void set_prefix(const ::std::string& value);
  #if LANG_CXX11
  void set_prefix(::std::string&& value);
  #endif
  void set_prefix(const char* value);
  void set_prefix(const char* value, size_t size);
  ::std::string* mutable_prefix();
  ::std::string* release_prefix();
  void set_allocated_prefix(::std::string* prefix);

  // string auth = 3;
  void clear_auth();
  static const int kAuthFieldNumber = 3;
  const ::std::string& auth() const;
  void set_auth(const ::std::string& value);
  #if LANG_CXX11
  void set_auth(::std::string&& value);
  #endif
  void set_auth(const char* value);
  void set_auth(const char* value, size_t size);
  ::std::string* mutable_auth();
  ::std::string* release_auth();
  void set_allocated_auth(::std::string* auth);

  // string billing_project = 4;
  void clear_billing_project();
  static const int kBillingProjectFieldNumber = 4;
  const ::std::string& billing_project() const;
  void set_billing_project(const ::std::string& value);
  #if LANG_CXX11
  void set_billing_project(::std::string&& value);
  #endif
  void set_billing_project(const char* value);
  void set_billing_project(const char* value, size_t size);
  ::std::string* mutable_billing_project();
  ::std::string* release_billing_project();
  void set_allocated_billing_project(::std::string* billing_project);

  // string credentials = 5;
  void clear_credentials();
  static const int kCredentialsFieldNumber = 5;
  const ::std::string& credentials() const;
  void set_credentials(const ::std::string& value);
  #if LANG_CXX11
  void set_credentials(::std::string&& value);
  #endif
  void set_credentials(const char* value);
  void set_credentials(const char* value, size_t size);
  ::std::string* mutable_credentials();
  ::std::string* release_credentials();
  void set_allocated_credentials(::std::string* credentials);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.ExportStorage.GCS)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr bucket_;
  ::google::protobuf::internal::ArenaStringPtr prefix_;
  ::google::protobuf::internal::ArenaStringPtr auth_;
  ::google::protobuf::internal::ArenaStringPtr billing_project_;
  ::google::protobuf::internal::ArenaStringPtr credentials_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExportStorage_Azure : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.ExportStorage.Azure) */ {
 public:
  ExportStorage_Azure();
  virtual ~ExportStorage_Azure();

  ExportStorage_Azure(const ExportStorage_Azure& from);

  inline ExportStorage_Azure& operator=(const ExportStorage_Azure& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExportStorage_Azure(ExportStorage_Azure&& from) noexcept
    : ExportStorage_Azure() {
    *this = ::std::move(from);
  }

  inline ExportStorage_Azure& operator=(ExportStorage_Azure&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ExportStorage_Azure& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExportStorage_Azure* internal_default_instance() {
    return reinterpret_cast<const ExportStorage_Azure*>(
               &_ExportStorage_Azure_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  void Swap(ExportStorage_Azure* other);
  friend void swap(ExportStorage_Azure& a, ExportStorage_Azure& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExportStorage_Azure* New() const final {
    return CreateMaybeMessage<ExportStorage_Azure>(NULL);
  }

  ExportStorage_Azure* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExportStorage_Azure>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ExportStorage_Azure& from);
  void MergeFrom(const ExportStorage_Azure& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExportStorage_Azure* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string container = 1;
  void clear_container();
  static const int kContainerFieldNumber = 1;
  const ::std::string& container() const;
  void set_container(const ::std::string& value);
  #if LANG_CXX11
  void set_container(::std::string&& value);
  #endif
  void set_container(const char* value);
  void set_container(const char* value, size_t size);
  ::std::string* mutable_container();
  ::std::string* release_container();
  void set_allocated_container(::std::string* container);

  // string prefix = 2;
  void clear_prefix();
  static const int kPrefixFieldNumber = 2;
  const ::std::string& prefix() const;
  void set_prefix(const ::std::string& value);
  #if LANG_CXX11
  void set_prefix(::std::string&& value);
  #endif
  void set_prefix(const char* value);
  void set_prefix(const char* value, size_t size);
  ::std::string* mutable_prefix();
  ::std::string* release_prefix();
  void set_allocated_prefix(::std::string* prefix);

  // string account_name = 3;
  void clear_account_name();
  static const int kAccountNameFieldNumber = 3;
  const ::std::string& account_name() const;
  void set_account_name(const ::std::string& value);
  #if LANG_CXX11
  void set_account_name(::std::string&& value);
  #endif
  void set_account_name(const char* value);
  void set_account_name(const char* value, size_t size);
  ::std::string* mutable_account_name();
  ::std::string* release_account_name();
  void set_allocated_account_name(::std::string* account_name);

  // string account_key = 4;
  void clear_account_key();
  static const int kAccountKeyFieldNumber = 4;
  const ::std::string& account_key() const;
  void set_account_key(const ::std::string& value);
  #if LANG_CXX11
  void set_account_key(::std::string&& value);
  #endif
  void set_account_key(const char* value);
  void set_account_key(const char* value, size_t size);
  ::std::string* mutable_account_key();
  ::std::string* release_account_key();
  void set_allocated_account_key(::std::string* account_key);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.ExportStorage.Azure)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr container_;
  ::google::protobuf::internal::ArenaStringPtr prefix_;
  ::google::protobuf::internal::ArenaStringPtr account_name_;
  ::google::protobuf::internal::ArenaStringPtr account_key_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExportStorage_Workload : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.ExportStorage.Workload) */ {
 public:
  ExportStorage_Workload();
  virtual ~ExportStorage_Workload();

  ExportStorage_Workload(const ExportStorage_Workload& from);

  inline ExportStorage_Workload& operator=(const ExportStorage_Workload& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExportStorage_Workload(ExportStorage_Workload&& from) noexcept
    : ExportStorage_Workload() {
    *this = ::std::move(from);
  }

  inline ExportStorage_Workload& operator=(ExportStorage_Workload&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ExportStorage_Workload& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExportStorage_Workload* internal_default_instance() {
    return reinterpret_cast<const ExportStorage_Workload*>(
               &_ExportStorage_Workload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  void Swap(ExportStorage_Workload* other);
  friend void swap(ExportStorage_Workload& a, ExportStorage_Workload& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExportStorage_Workload* New() const final {
    return CreateMaybeMessage<ExportStorage_Workload>(NULL);
  }

  ExportStorage_Workload* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExportStorage_Workload>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ExportStorage_Workload& from);
  void MergeFrom(const ExportStorage_Workload& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExportStorage_Workload* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string flags = 4;
  int flags_size() const;
  void clear_flags();
  static const int kFlagsFieldNumber = 4;
  const ::std::string& flags(int index) const;
  ::std::string* mutable_flags(int index);
  void set_flags(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_flags(int index, ::std::string&& value);
  #endif
  void set_flags(int index, const char* value);
  void set_flags(int index, const char* value, size_t size);
  ::std::string* add_flags();
  void add_flags(const ::std::string& value);
  #if LANG_CXX11
  void add_flags(::std::string&& value);
  #endif
  void add_flags(const char* value);
  void add_flags(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& flags() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_flags();

  // string generator = 1;
  void clear_generator();
  static const int kGeneratorFieldNumber = 1;
  const ::std::string& generator() const;
  void set_generator(const ::std::string& value);
  #if LANG_CXX11
  void set_generator(::std::string&& value);
  #endif
  void set_generator(const char* value);
  void set_generator(const char* value, size_t size);
  ::std::string* mutable_generator();
  ::std::string* release_generator();
  void set_allocated_generator(::std::string* generator);

  // string version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string table = 3;
  void clear_table();
  static const int kTableFieldNumber = 3;
  const ::std::string& table() const;
  void set_table(const ::std::string& value);
  #if LANG_CXX11
  void set_table(::std::string&& value);
  #endif
  void set_table(const char* value);
  void set_table(const char* value, size_t size);
  ::std::string* mutable_table();
  ::std::string* release_table();
  void set_allocated_table(::std::string* table);

  // string format = 5;
  void clear_format();
  static const int kFormatFieldNumber = 5;
  const ::std::string& format() const;
  void set_format(const ::std::string& value);
  #if LANG_CXX11
  void set_format(::std::string&& value);
  #endif
  void set_format(const char* value);
  void set_format(const char* value, size_t size);
  ::std::string* mutable_format();
  ::std::string* release_format();
  void set_allocated_format(::std::string* format);

  // int64 batch_begin = 6;
  void clear_batch_begin();
  static const int kBatchBeginFieldNumber = 6;
  ::google::protobuf::int64 batch_begin() const;
  void set_batch_begin(::google::protobuf::int64 value);

  // int64 batch_end = 7;
  void clear_batch_end();
  static const int kBatchEndFieldNumber = 7;
  ::google::protobuf::int64 batch_end() const;
  void set_batch_end(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.ExportStorage.Workload)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> flags_;
  ::google::protobuf::internal::ArenaStringPtr generator_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr table_;
  ::google::protobuf::internal::ArenaStringPtr format_;
  ::google::protobuf::int64 batch_begin_;
  ::google::protobuf::int64 batch_end_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExportStorage : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.ExportStorage) */ {
 public:
  ExportStorage();
  virtual ~ExportStorage();

  ExportStorage(const ExportStorage& from);

  inline ExportStorage& operator=(const ExportStorage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExportStorage(ExportStorage&& from) noexcept
    : ExportStorage() {
    *this = ::std::move(from);
  }

  inline ExportStorage& operator=(ExportStorage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ExportStorage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExportStorage* internal_default_instance() {
    return reinterpret_cast<const ExportStorage*>(
               &_ExportStorage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  void Swap(ExportStorage* other);
  friend void swap(ExportStorage& a, ExportStorage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExportStorage* New() const final {
    return CreateMaybeMessage<ExportStorage>(NULL);
  }

  ExportStorage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExportStorage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ExportStorage& from);
  void MergeFrom(const ExportStorage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExportStorage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ExportStorage_LocalFilePath LocalFilePath;
  typedef ExportStorage_Http Http;
  typedef ExportStorage_S3 S3;
  typedef ExportStorage_GCS GCS;
  typedef ExportStorage_Azure Azure;
  typedef ExportStorage_Workload Workload;

  // accessors -------------------------------------------------------

  bool has_localfile() const;
  void clear_localfile();
  static const int kLocalFileFieldNumber = 2;
  private:
  const ::znbase::roachpb::ExportStorage_LocalFilePath& _internal_localfile() const;
  public:
  const ::znbase::roachpb::ExportStorage_LocalFilePath& localfile() const;
  ::znbase::roachpb::ExportStorage_LocalFilePath* release_localfile();
  ::znbase::roachpb::ExportStorage_LocalFilePath* mutable_localfile();
  void set_allocated_localfile(::znbase::roachpb::ExportStorage_LocalFilePath* localfile);

  bool has_httppath() const;
  void clear_httppath();
  static const int kHttpPathFieldNumber = 3;
  private:
  const ::znbase::roachpb::ExportStorage_Http& _internal_httppath() const;
  public:
  const ::znbase::roachpb::ExportStorage_Http& httppath() const;
  ::znbase::roachpb::ExportStorage_Http* release_httppath();
  ::znbase::roachpb::ExportStorage_Http* mutable_httppath();
  void set_allocated_httppath(::znbase::roachpb::ExportStorage_Http* httppath);

  // .znbase.roachpb.ExportStorage.GCS GoogleCloudConfig = 4;
  bool has_googlecloudconfig() const;
  void clear_googlecloudconfig();
  static const int kGoogleCloudConfigFieldNumber = 4;
  private:
  const ::znbase::roachpb::ExportStorage_GCS& _internal_googlecloudconfig() const;
  public:
  const ::znbase::roachpb::ExportStorage_GCS& googlecloudconfig() const;
  ::znbase::roachpb::ExportStorage_GCS* release_googlecloudconfig();
  ::znbase::roachpb::ExportStorage_GCS* mutable_googlecloudconfig();
  void set_allocated_googlecloudconfig(::znbase::roachpb::ExportStorage_GCS* googlecloudconfig);

  // .znbase.roachpb.ExportStorage.S3 S3Config = 5;
  bool has_s3config() const;
  void clear_s3config();
  static const int kS3ConfigFieldNumber = 5;
  private:
  const ::znbase::roachpb::ExportStorage_S3& _internal_s3config() const;
  public:
  const ::znbase::roachpb::ExportStorage_S3& s3config() const;
  ::znbase::roachpb::ExportStorage_S3* release_s3config();
  ::znbase::roachpb::ExportStorage_S3* mutable_s3config();
  void set_allocated_s3config(::znbase::roachpb::ExportStorage_S3* s3config);

  // .znbase.roachpb.ExportStorage.Azure AzureConfig = 6;
  bool has_azureconfig() const;
  void clear_azureconfig();
  static const int kAzureConfigFieldNumber = 6;
  private:
  const ::znbase::roachpb::ExportStorage_Azure& _internal_azureconfig() const;
  public:
  const ::znbase::roachpb::ExportStorage_Azure& azureconfig() const;
  ::znbase::roachpb::ExportStorage_Azure* release_azureconfig();
  ::znbase::roachpb::ExportStorage_Azure* mutable_azureconfig();
  void set_allocated_azureconfig(::znbase::roachpb::ExportStorage_Azure* azureconfig);

  // .znbase.roachpb.ExportStorage.Workload WorkloadConfig = 7;
  bool has_workloadconfig() const;
  void clear_workloadconfig();
  static const int kWorkloadConfigFieldNumber = 7;
  private:
  const ::znbase::roachpb::ExportStorage_Workload& _internal_workloadconfig() const;
  public:
  const ::znbase::roachpb::ExportStorage_Workload& workloadconfig() const;
  ::znbase::roachpb::ExportStorage_Workload* release_workloadconfig();
  ::znbase::roachpb::ExportStorage_Workload* mutable_workloadconfig();
  void set_allocated_workloadconfig(::znbase::roachpb::ExportStorage_Workload* workloadconfig);

  // .znbase.roachpb.ExportStorageProvider provider = 1;
  void clear_provider();
  static const int kProviderFieldNumber = 1;
  ::znbase::roachpb::ExportStorageProvider provider() const;
  void set_provider(::znbase::roachpb::ExportStorageProvider value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.ExportStorage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::ExportStorage_LocalFilePath* localfile_;
  ::znbase::roachpb::ExportStorage_Http* httppath_;
  ::znbase::roachpb::ExportStorage_GCS* googlecloudconfig_;
  ::znbase::roachpb::ExportStorage_S3* s3config_;
  ::znbase::roachpb::ExportStorage_Azure* azureconfig_;
  ::znbase::roachpb::ExportStorage_Workload* workloadconfig_;
  int provider_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DumpSink_LocalFilePath : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.DumpSink.LocalFilePath) */ {
 public:
  DumpSink_LocalFilePath();
  virtual ~DumpSink_LocalFilePath();

  DumpSink_LocalFilePath(const DumpSink_LocalFilePath& from);

  inline DumpSink_LocalFilePath& operator=(const DumpSink_LocalFilePath& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DumpSink_LocalFilePath(DumpSink_LocalFilePath&& from) noexcept
    : DumpSink_LocalFilePath() {
    *this = ::std::move(from);
  }

  inline DumpSink_LocalFilePath& operator=(DumpSink_LocalFilePath&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DumpSink_LocalFilePath& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DumpSink_LocalFilePath* internal_default_instance() {
    return reinterpret_cast<const DumpSink_LocalFilePath*>(
               &_DumpSink_LocalFilePath_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  void Swap(DumpSink_LocalFilePath* other);
  friend void swap(DumpSink_LocalFilePath& a, DumpSink_LocalFilePath& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DumpSink_LocalFilePath* New() const final {
    return CreateMaybeMessage<DumpSink_LocalFilePath>(NULL);
  }

  DumpSink_LocalFilePath* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DumpSink_LocalFilePath>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const DumpSink_LocalFilePath& from);
  void MergeFrom(const DumpSink_LocalFilePath& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DumpSink_LocalFilePath* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string path = 1;
  void clear_path();
  static const int kPathFieldNumber = 1;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  void clear_node_id();
  static const int kNodeIdFieldNumber = 2;
  ::google::protobuf::uint32 node_id() const;
  void set_node_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.DumpSink.LocalFilePath)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::uint32 node_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DumpSink_Http : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.DumpSink.Http) */ {
 public:
  DumpSink_Http();
  virtual ~DumpSink_Http();

  DumpSink_Http(const DumpSink_Http& from);

  inline DumpSink_Http& operator=(const DumpSink_Http& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DumpSink_Http(DumpSink_Http&& from) noexcept
    : DumpSink_Http() {
    *this = ::std::move(from);
  }

  inline DumpSink_Http& operator=(DumpSink_Http&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DumpSink_Http& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DumpSink_Http* internal_default_instance() {
    return reinterpret_cast<const DumpSink_Http*>(
               &_DumpSink_Http_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  void Swap(DumpSink_Http* other);
  friend void swap(DumpSink_Http& a, DumpSink_Http& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DumpSink_Http* New() const final {
    return CreateMaybeMessage<DumpSink_Http>(NULL);
  }

  DumpSink_Http* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DumpSink_Http>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const DumpSink_Http& from);
  void MergeFrom(const DumpSink_Http& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DumpSink_Http* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string baseUri = 1;
  void clear_baseuri();
  static const int kBaseUriFieldNumber = 1;
  const ::std::string& baseuri() const;
  void set_baseuri(const ::std::string& value);
  #if LANG_CXX11
  void set_baseuri(::std::string&& value);
  #endif
  void set_baseuri(const char* value);
  void set_baseuri(const char* value, size_t size);
  ::std::string* mutable_baseuri();
  ::std::string* release_baseuri();
  void set_allocated_baseuri(::std::string* baseuri);

  // string header = 2;
  void clear_header();
  static const int kHeaderFieldNumber = 2;
  const ::std::string& header() const;
  void set_header(const ::std::string& value);
  #if LANG_CXX11
  void set_header(::std::string&& value);
  #endif
  void set_header(const char* value);
  void set_header(const char* value, size_t size);
  ::std::string* mutable_header();
  ::std::string* release_header();
  void set_allocated_header(::std::string* header);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.DumpSink.Http)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr baseuri_;
  ::google::protobuf::internal::ArenaStringPtr header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DumpSink_S3 : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.DumpSink.S3) */ {
 public:
  DumpSink_S3();
  virtual ~DumpSink_S3();

  DumpSink_S3(const DumpSink_S3& from);

  inline DumpSink_S3& operator=(const DumpSink_S3& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DumpSink_S3(DumpSink_S3&& from) noexcept
    : DumpSink_S3() {
    *this = ::std::move(from);
  }

  inline DumpSink_S3& operator=(DumpSink_S3&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DumpSink_S3& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DumpSink_S3* internal_default_instance() {
    return reinterpret_cast<const DumpSink_S3*>(
               &_DumpSink_S3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    82;

  void Swap(DumpSink_S3* other);
  friend void swap(DumpSink_S3& a, DumpSink_S3& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DumpSink_S3* New() const final {
    return CreateMaybeMessage<DumpSink_S3>(NULL);
  }

  DumpSink_S3* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DumpSink_S3>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const DumpSink_S3& from);
  void MergeFrom(const DumpSink_S3& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DumpSink_S3* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string bucket = 1;
  void clear_bucket();
  static const int kBucketFieldNumber = 1;
  const ::std::string& bucket() const;
  void set_bucket(const ::std::string& value);
  #if LANG_CXX11
  void set_bucket(::std::string&& value);
  #endif
  void set_bucket(const char* value);
  void set_bucket(const char* value, size_t size);
  ::std::string* mutable_bucket();
  ::std::string* release_bucket();
  void set_allocated_bucket(::std::string* bucket);

  // string prefix = 2;
  void clear_prefix();
  static const int kPrefixFieldNumber = 2;
  const ::std::string& prefix() const;
  void set_prefix(const ::std::string& value);
  #if LANG_CXX11
  void set_prefix(::std::string&& value);
  #endif
  void set_prefix(const char* value);
  void set_prefix(const char* value, size_t size);
  ::std::string* mutable_prefix();
  ::std::string* release_prefix();
  void set_allocated_prefix(::std::string* prefix);

  // string access_key = 3;
  void clear_access_key();
  static const int kAccessKeyFieldNumber = 3;
  const ::std::string& access_key() const;
  void set_access_key(const ::std::string& value);
  #if LANG_CXX11
  void set_access_key(::std::string&& value);
  #endif
  void set_access_key(const char* value);
  void set_access_key(const char* value, size_t size);
  ::std::string* mutable_access_key();
  ::std::string* release_access_key();
  void set_allocated_access_key(::std::string* access_key);

  // string secret = 4;
  void clear_secret();
  static const int kSecretFieldNumber = 4;
  const ::std::string& secret() const;
  void set_secret(const ::std::string& value);
  #if LANG_CXX11
  void set_secret(::std::string&& value);
  #endif
  void set_secret(const char* value);
  void set_secret(const char* value, size_t size);
  ::std::string* mutable_secret();
  ::std::string* release_secret();
  void set_allocated_secret(::std::string* secret);

  // string temp_token = 5;
  void clear_temp_token();
  static const int kTempTokenFieldNumber = 5;
  const ::std::string& temp_token() const;
  void set_temp_token(const ::std::string& value);
  #if LANG_CXX11
  void set_temp_token(::std::string&& value);
  #endif
  void set_temp_token(const char* value);
  void set_temp_token(const char* value, size_t size);
  ::std::string* mutable_temp_token();
  ::std::string* release_temp_token();
  void set_allocated_temp_token(::std::string* temp_token);

  // string endpoint = 6;
  void clear_endpoint();
  static const int kEndpointFieldNumber = 6;
  const ::std::string& endpoint() const;
  void set_endpoint(const ::std::string& value);
  #if LANG_CXX11
  void set_endpoint(::std::string&& value);
  #endif
  void set_endpoint(const char* value);
  void set_endpoint(const char* value, size_t size);
  ::std::string* mutable_endpoint();
  ::std::string* release_endpoint();
  void set_allocated_endpoint(::std::string* endpoint);

  // string region = 7;
  void clear_region();
  static const int kRegionFieldNumber = 7;
  const ::std::string& region() const;
  void set_region(const ::std::string& value);
  #if LANG_CXX11
  void set_region(::std::string&& value);
  #endif
  void set_region(const char* value);
  void set_region(const char* value, size_t size);
  ::std::string* mutable_region();
  ::std::string* release_region();
  void set_allocated_region(::std::string* region);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.DumpSink.S3)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr bucket_;
  ::google::protobuf::internal::ArenaStringPtr prefix_;
  ::google::protobuf::internal::ArenaStringPtr access_key_;
  ::google::protobuf::internal::ArenaStringPtr secret_;
  ::google::protobuf::internal::ArenaStringPtr temp_token_;
  ::google::protobuf::internal::ArenaStringPtr endpoint_;
  ::google::protobuf::internal::ArenaStringPtr region_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DumpSink_HDFS : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.DumpSink.HDFS) */ {
 public:
  DumpSink_HDFS();
  virtual ~DumpSink_HDFS();

  DumpSink_HDFS(const DumpSink_HDFS& from);

  inline DumpSink_HDFS& operator=(const DumpSink_HDFS& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DumpSink_HDFS(DumpSink_HDFS&& from) noexcept
    : DumpSink_HDFS() {
    *this = ::std::move(from);
  }

  inline DumpSink_HDFS& operator=(DumpSink_HDFS&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DumpSink_HDFS& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DumpSink_HDFS* internal_default_instance() {
    return reinterpret_cast<const DumpSink_HDFS*>(
               &_DumpSink_HDFS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    83;

  void Swap(DumpSink_HDFS* other);
  friend void swap(DumpSink_HDFS& a, DumpSink_HDFS& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DumpSink_HDFS* New() const final {
    return CreateMaybeMessage<DumpSink_HDFS>(NULL);
  }

  DumpSink_HDFS* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DumpSink_HDFS>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const DumpSink_HDFS& from);
  void MergeFrom(const DumpSink_HDFS& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DumpSink_HDFS* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string host = 1;
  void clear_host();
  static const int kHostFieldNumber = 1;
  const ::std::string& host() const;
  void set_host(const ::std::string& value);
  #if LANG_CXX11
  void set_host(::std::string&& value);
  #endif
  void set_host(const char* value);
  void set_host(const char* value, size_t size);
  ::std::string* mutable_host();
  ::std::string* release_host();
  void set_allocated_host(::std::string* host);

  // string path = 2;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // string username = 3;
  void clear_username();
  static const int kUsernameFieldNumber = 3;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // string krb5Conf = 4;
  void clear_krb5conf();
  static const int kKrb5ConfFieldNumber = 4;
  const ::std::string& krb5conf() const;
  void set_krb5conf(const ::std::string& value);
  #if LANG_CXX11
  void set_krb5conf(::std::string&& value);
  #endif
  void set_krb5conf(const char* value);
  void set_krb5conf(const char* value, size_t size);
  ::std::string* mutable_krb5conf();
  ::std::string* release_krb5conf();
  void set_allocated_krb5conf(::std::string* krb5conf);

  // string realm = 5;
  void clear_realm();
  static const int kRealmFieldNumber = 5;
  const ::std::string& realm() const;
  void set_realm(const ::std::string& value);
  #if LANG_CXX11
  void set_realm(::std::string&& value);
  #endif
  void set_realm(const char* value);
  void set_realm(const char* value, size_t size);
  ::std::string* mutable_realm();
  ::std::string* release_realm();
  void set_allocated_realm(::std::string* realm);

  // string password = 6;
  void clear_password();
  static const int kPasswordFieldNumber = 6;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // string namenodePrincipal = 7;
  void clear_namenodeprincipal();
  static const int kNamenodePrincipalFieldNumber = 7;
  const ::std::string& namenodeprincipal() const;
  void set_namenodeprincipal(const ::std::string& value);
  #if LANG_CXX11
  void set_namenodeprincipal(::std::string&& value);
  #endif
  void set_namenodeprincipal(const char* value);
  void set_namenodeprincipal(const char* value, size_t size);
  ::std::string* mutable_namenodeprincipal();
  ::std::string* release_namenodeprincipal();
  void set_allocated_namenodeprincipal(::std::string* namenodeprincipal);

  // string hdfsConfigs = 8;
  void clear_hdfsconfigs();
  static const int kHdfsConfigsFieldNumber = 8;
  const ::std::string& hdfsconfigs() const;
  void set_hdfsconfigs(const ::std::string& value);
  #if LANG_CXX11
  void set_hdfsconfigs(::std::string&& value);
  #endif
  void set_hdfsconfigs(const char* value);
  void set_hdfsconfigs(const char* value, size_t size);
  ::std::string* mutable_hdfsconfigs();
  ::std::string* release_hdfsconfigs();
  void set_allocated_hdfsconfigs(::std::string* hdfsconfigs);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.DumpSink.HDFS)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr host_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr krb5conf_;
  ::google::protobuf::internal::ArenaStringPtr realm_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::internal::ArenaStringPtr namenodeprincipal_;
  ::google::protobuf::internal::ArenaStringPtr hdfsconfigs_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DumpSink_KAFKA : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.DumpSink.KAFKA) */ {
 public:
  DumpSink_KAFKA();
  virtual ~DumpSink_KAFKA();

  DumpSink_KAFKA(const DumpSink_KAFKA& from);

  inline DumpSink_KAFKA& operator=(const DumpSink_KAFKA& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DumpSink_KAFKA(DumpSink_KAFKA&& from) noexcept
    : DumpSink_KAFKA() {
    *this = ::std::move(from);
  }

  inline DumpSink_KAFKA& operator=(DumpSink_KAFKA&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DumpSink_KAFKA& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DumpSink_KAFKA* internal_default_instance() {
    return reinterpret_cast<const DumpSink_KAFKA*>(
               &_DumpSink_KAFKA_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    84;

  void Swap(DumpSink_KAFKA* other);
  friend void swap(DumpSink_KAFKA& a, DumpSink_KAFKA& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DumpSink_KAFKA* New() const final {
    return CreateMaybeMessage<DumpSink_KAFKA>(NULL);
  }

  DumpSink_KAFKA* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DumpSink_KAFKA>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const DumpSink_KAFKA& from);
  void MergeFrom(const DumpSink_KAFKA& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DumpSink_KAFKA* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string kafkaServer = 1;
  void clear_kafkaserver();
  static const int kKafkaServerFieldNumber = 1;
  const ::std::string& kafkaserver() const;
  void set_kafkaserver(const ::std::string& value);
  #if LANG_CXX11
  void set_kafkaserver(::std::string&& value);
  #endif
  void set_kafkaserver(const char* value);
  void set_kafkaserver(const char* value, size_t size);
  ::std::string* mutable_kafkaserver();
  ::std::string* release_kafkaserver();
  void set_allocated_kafkaserver(::std::string* kafkaserver);

  // string topic = 2;
  void clear_topic();
  static const int kTopicFieldNumber = 2;
  const ::std::string& topic() const;
  void set_topic(const ::std::string& value);
  #if LANG_CXX11
  void set_topic(::std::string&& value);
  #endif
  void set_topic(const char* value);
  void set_topic(const char* value, size_t size);
  ::std::string* mutable_topic();
  ::std::string* release_topic();
  void set_allocated_topic(::std::string* topic);

  // string krb5Conf = 3;
  void clear_krb5conf();
  static const int kKrb5ConfFieldNumber = 3;
  const ::std::string& krb5conf() const;
  void set_krb5conf(const ::std::string& value);
  #if LANG_CXX11
  void set_krb5conf(::std::string&& value);
  #endif
  void set_krb5conf(const char* value);
  void set_krb5conf(const char* value, size_t size);
  ::std::string* mutable_krb5conf();
  ::std::string* release_krb5conf();
  void set_allocated_krb5conf(::std::string* krb5conf);

  // string keytab = 4;
  void clear_keytab();
  static const int kKeytabFieldNumber = 4;
  const ::std::string& keytab() const;
  void set_keytab(const ::std::string& value);
  #if LANG_CXX11
  void set_keytab(::std::string&& value);
  #endif
  void set_keytab(const char* value);
  void set_keytab(const char* value, size_t size);
  ::std::string* mutable_keytab();
  ::std::string* release_keytab();
  void set_allocated_keytab(::std::string* keytab);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.DumpSink.KAFKA)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr kafkaserver_;
  ::google::protobuf::internal::ArenaStringPtr topic_;
  ::google::protobuf::internal::ArenaStringPtr krb5conf_;
  ::google::protobuf::internal::ArenaStringPtr keytab_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DumpSink_GCS : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.DumpSink.GCS) */ {
 public:
  DumpSink_GCS();
  virtual ~DumpSink_GCS();

  DumpSink_GCS(const DumpSink_GCS& from);

  inline DumpSink_GCS& operator=(const DumpSink_GCS& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DumpSink_GCS(DumpSink_GCS&& from) noexcept
    : DumpSink_GCS() {
    *this = ::std::move(from);
  }

  inline DumpSink_GCS& operator=(DumpSink_GCS&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DumpSink_GCS& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DumpSink_GCS* internal_default_instance() {
    return reinterpret_cast<const DumpSink_GCS*>(
               &_DumpSink_GCS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    85;

  void Swap(DumpSink_GCS* other);
  friend void swap(DumpSink_GCS& a, DumpSink_GCS& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DumpSink_GCS* New() const final {
    return CreateMaybeMessage<DumpSink_GCS>(NULL);
  }

  DumpSink_GCS* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DumpSink_GCS>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const DumpSink_GCS& from);
  void MergeFrom(const DumpSink_GCS& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DumpSink_GCS* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string bucket = 1;
  void clear_bucket();
  static const int kBucketFieldNumber = 1;
  const ::std::string& bucket() const;
  void set_bucket(const ::std::string& value);
  #if LANG_CXX11
  void set_bucket(::std::string&& value);
  #endif
  void set_bucket(const char* value);
  void set_bucket(const char* value, size_t size);
  ::std::string* mutable_bucket();
  ::std::string* release_bucket();
  void set_allocated_bucket(::std::string* bucket);

  // string prefix = 2;
  void clear_prefix();
  static const int kPrefixFieldNumber = 2;
  const ::std::string& prefix() const;
  void set_prefix(const ::std::string& value);
  #if LANG_CXX11
  void set_prefix(::std::string&& value);
  #endif
  void set_prefix(const char* value);
  void set_prefix(const char* value, size_t size);
  ::std::string* mutable_prefix();
  ::std::string* release_prefix();
  void set_allocated_prefix(::std::string* prefix);

  // string auth = 3;
  void clear_auth();
  static const int kAuthFieldNumber = 3;
  const ::std::string& auth() const;
  void set_auth(const ::std::string& value);
  #if LANG_CXX11
  void set_auth(::std::string&& value);
  #endif
  void set_auth(const char* value);
  void set_auth(const char* value, size_t size);
  ::std::string* mutable_auth();
  ::std::string* release_auth();
  void set_allocated_auth(::std::string* auth);

  // string billing_project = 4;
  void clear_billing_project();
  static const int kBillingProjectFieldNumber = 4;
  const ::std::string& billing_project() const;
  void set_billing_project(const ::std::string& value);
  #if LANG_CXX11
  void set_billing_project(::std::string&& value);
  #endif
  void set_billing_project(const char* value);
  void set_billing_project(const char* value, size_t size);
  ::std::string* mutable_billing_project();
  ::std::string* release_billing_project();
  void set_allocated_billing_project(::std::string* billing_project);

  // string credentials = 5;
  void clear_credentials();
  static const int kCredentialsFieldNumber = 5;
  const ::std::string& credentials() const;
  void set_credentials(const ::std::string& value);
  #if LANG_CXX11
  void set_credentials(::std::string&& value);
  #endif
  void set_credentials(const char* value);
  void set_credentials(const char* value, size_t size);
  ::std::string* mutable_credentials();
  ::std::string* release_credentials();
  void set_allocated_credentials(::std::string* credentials);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.DumpSink.GCS)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr bucket_;
  ::google::protobuf::internal::ArenaStringPtr prefix_;
  ::google::protobuf::internal::ArenaStringPtr auth_;
  ::google::protobuf::internal::ArenaStringPtr billing_project_;
  ::google::protobuf::internal::ArenaStringPtr credentials_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DumpSink_Azure : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.DumpSink.Azure) */ {
 public:
  DumpSink_Azure();
  virtual ~DumpSink_Azure();

  DumpSink_Azure(const DumpSink_Azure& from);

  inline DumpSink_Azure& operator=(const DumpSink_Azure& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DumpSink_Azure(DumpSink_Azure&& from) noexcept
    : DumpSink_Azure() {
    *this = ::std::move(from);
  }

  inline DumpSink_Azure& operator=(DumpSink_Azure&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DumpSink_Azure& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DumpSink_Azure* internal_default_instance() {
    return reinterpret_cast<const DumpSink_Azure*>(
               &_DumpSink_Azure_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    86;

  void Swap(DumpSink_Azure* other);
  friend void swap(DumpSink_Azure& a, DumpSink_Azure& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DumpSink_Azure* New() const final {
    return CreateMaybeMessage<DumpSink_Azure>(NULL);
  }

  DumpSink_Azure* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DumpSink_Azure>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const DumpSink_Azure& from);
  void MergeFrom(const DumpSink_Azure& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DumpSink_Azure* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string container = 1;
  void clear_container();
  static const int kContainerFieldNumber = 1;
  const ::std::string& container() const;
  void set_container(const ::std::string& value);
  #if LANG_CXX11
  void set_container(::std::string&& value);
  #endif
  void set_container(const char* value);
  void set_container(const char* value, size_t size);
  ::std::string* mutable_container();
  ::std::string* release_container();
  void set_allocated_container(::std::string* container);

  // string prefix = 2;
  void clear_prefix();
  static const int kPrefixFieldNumber = 2;
  const ::std::string& prefix() const;
  void set_prefix(const ::std::string& value);
  #if LANG_CXX11
  void set_prefix(::std::string&& value);
  #endif
  void set_prefix(const char* value);
  void set_prefix(const char* value, size_t size);
  ::std::string* mutable_prefix();
  ::std::string* release_prefix();
  void set_allocated_prefix(::std::string* prefix);

  // string account_name = 3;
  void clear_account_name();
  static const int kAccountNameFieldNumber = 3;
  const ::std::string& account_name() const;
  void set_account_name(const ::std::string& value);
  #if LANG_CXX11
  void set_account_name(::std::string&& value);
  #endif
  void set_account_name(const char* value);
  void set_account_name(const char* value, size_t size);
  ::std::string* mutable_account_name();
  ::std::string* release_account_name();
  void set_allocated_account_name(::std::string* account_name);

  // string account_key = 4;
  void clear_account_key();
  static const int kAccountKeyFieldNumber = 4;
  const ::std::string& account_key() const;
  void set_account_key(const ::std::string& value);
  #if LANG_CXX11
  void set_account_key(::std::string&& value);
  #endif
  void set_account_key(const char* value);
  void set_account_key(const char* value, size_t size);
  ::std::string* mutable_account_key();
  ::std::string* release_account_key();
  void set_allocated_account_key(::std::string* account_key);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.DumpSink.Azure)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr container_;
  ::google::protobuf::internal::ArenaStringPtr prefix_;
  ::google::protobuf::internal::ArenaStringPtr account_name_;
  ::google::protobuf::internal::ArenaStringPtr account_key_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DumpSink_Workload : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.DumpSink.Workload) */ {
 public:
  DumpSink_Workload();
  virtual ~DumpSink_Workload();

  DumpSink_Workload(const DumpSink_Workload& from);

  inline DumpSink_Workload& operator=(const DumpSink_Workload& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DumpSink_Workload(DumpSink_Workload&& from) noexcept
    : DumpSink_Workload() {
    *this = ::std::move(from);
  }

  inline DumpSink_Workload& operator=(DumpSink_Workload&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DumpSink_Workload& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DumpSink_Workload* internal_default_instance() {
    return reinterpret_cast<const DumpSink_Workload*>(
               &_DumpSink_Workload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    87;

  void Swap(DumpSink_Workload* other);
  friend void swap(DumpSink_Workload& a, DumpSink_Workload& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DumpSink_Workload* New() const final {
    return CreateMaybeMessage<DumpSink_Workload>(NULL);
  }

  DumpSink_Workload* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DumpSink_Workload>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const DumpSink_Workload& from);
  void MergeFrom(const DumpSink_Workload& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DumpSink_Workload* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string flags = 4;
  int flags_size() const;
  void clear_flags();
  static const int kFlagsFieldNumber = 4;
  const ::std::string& flags(int index) const;
  ::std::string* mutable_flags(int index);
  void set_flags(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_flags(int index, ::std::string&& value);
  #endif
  void set_flags(int index, const char* value);
  void set_flags(int index, const char* value, size_t size);
  ::std::string* add_flags();
  void add_flags(const ::std::string& value);
  #if LANG_CXX11
  void add_flags(::std::string&& value);
  #endif
  void add_flags(const char* value);
  void add_flags(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& flags() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_flags();

  // string generator = 1;
  void clear_generator();
  static const int kGeneratorFieldNumber = 1;
  const ::std::string& generator() const;
  void set_generator(const ::std::string& value);
  #if LANG_CXX11
  void set_generator(::std::string&& value);
  #endif
  void set_generator(const char* value);
  void set_generator(const char* value, size_t size);
  ::std::string* mutable_generator();
  ::std::string* release_generator();
  void set_allocated_generator(::std::string* generator);

  // string version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string table = 3;
  void clear_table();
  static const int kTableFieldNumber = 3;
  const ::std::string& table() const;
  void set_table(const ::std::string& value);
  #if LANG_CXX11
  void set_table(::std::string&& value);
  #endif
  void set_table(const char* value);
  void set_table(const char* value, size_t size);
  ::std::string* mutable_table();
  ::std::string* release_table();
  void set_allocated_table(::std::string* table);

  // string format = 5;
  void clear_format();
  static const int kFormatFieldNumber = 5;
  const ::std::string& format() const;
  void set_format(const ::std::string& value);
  #if LANG_CXX11
  void set_format(::std::string&& value);
  #endif
  void set_format(const char* value);
  void set_format(const char* value, size_t size);
  ::std::string* mutable_format();
  ::std::string* release_format();
  void set_allocated_format(::std::string* format);

  // int64 batch_begin = 6;
  void clear_batch_begin();
  static const int kBatchBeginFieldNumber = 6;
  ::google::protobuf::int64 batch_begin() const;
  void set_batch_begin(::google::protobuf::int64 value);

  // int64 batch_end = 7;
  void clear_batch_end();
  static const int kBatchEndFieldNumber = 7;
  ::google::protobuf::int64 batch_end() const;
  void set_batch_end(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.DumpSink.Workload)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> flags_;
  ::google::protobuf::internal::ArenaStringPtr generator_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr table_;
  ::google::protobuf::internal::ArenaStringPtr format_;
  ::google::protobuf::int64 batch_begin_;
  ::google::protobuf::int64 batch_end_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DumpSink : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.DumpSink) */ {
 public:
  DumpSink();
  virtual ~DumpSink();

  DumpSink(const DumpSink& from);

  inline DumpSink& operator=(const DumpSink& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DumpSink(DumpSink&& from) noexcept
    : DumpSink() {
    *this = ::std::move(from);
  }

  inline DumpSink& operator=(DumpSink&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DumpSink& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DumpSink* internal_default_instance() {
    return reinterpret_cast<const DumpSink*>(
               &_DumpSink_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    88;

  void Swap(DumpSink* other);
  friend void swap(DumpSink& a, DumpSink& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DumpSink* New() const final {
    return CreateMaybeMessage<DumpSink>(NULL);
  }

  DumpSink* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DumpSink>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const DumpSink& from);
  void MergeFrom(const DumpSink& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DumpSink* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DumpSink_LocalFilePath LocalFilePath;
  typedef DumpSink_Http Http;
  typedef DumpSink_S3 S3;
  typedef DumpSink_HDFS HDFS;
  typedef DumpSink_KAFKA KAFKA;
  typedef DumpSink_GCS GCS;
  typedef DumpSink_Azure Azure;
  typedef DumpSink_Workload Workload;

  // accessors -------------------------------------------------------

  bool has_localfile() const;
  void clear_localfile();
  static const int kLocalFileFieldNumber = 2;
  private:
  const ::znbase::roachpb::DumpSink_LocalFilePath& _internal_localfile() const;
  public:
  const ::znbase::roachpb::DumpSink_LocalFilePath& localfile() const;
  ::znbase::roachpb::DumpSink_LocalFilePath* release_localfile();
  ::znbase::roachpb::DumpSink_LocalFilePath* mutable_localfile();
  void set_allocated_localfile(::znbase::roachpb::DumpSink_LocalFilePath* localfile);

  bool has_httppath() const;
  void clear_httppath();
  static const int kHttpPathFieldNumber = 3;
  private:
  const ::znbase::roachpb::DumpSink_Http& _internal_httppath() const;
  public:
  const ::znbase::roachpb::DumpSink_Http& httppath() const;
  ::znbase::roachpb::DumpSink_Http* release_httppath();
  ::znbase::roachpb::DumpSink_Http* mutable_httppath();
  void set_allocated_httppath(::znbase::roachpb::DumpSink_Http* httppath);

  // .znbase.roachpb.DumpSink.S3 S3Config = 4;
  bool has_s3config() const;
  void clear_s3config();
  static const int kS3ConfigFieldNumber = 4;
  private:
  const ::znbase::roachpb::DumpSink_S3& _internal_s3config() const;
  public:
  const ::znbase::roachpb::DumpSink_S3& s3config() const;
  ::znbase::roachpb::DumpSink_S3* release_s3config();
  ::znbase::roachpb::DumpSink_S3* mutable_s3config();
  void set_allocated_s3config(::znbase::roachpb::DumpSink_S3* s3config);

  // .znbase.roachpb.DumpSink.HDFS HdfsConfig = 5;
  bool has_hdfsconfig() const;
  void clear_hdfsconfig();
  static const int kHdfsConfigFieldNumber = 5;
  private:
  const ::znbase::roachpb::DumpSink_HDFS& _internal_hdfsconfig() const;
  public:
  const ::znbase::roachpb::DumpSink_HDFS& hdfsconfig() const;
  ::znbase::roachpb::DumpSink_HDFS* release_hdfsconfig();
  ::znbase::roachpb::DumpSink_HDFS* mutable_hdfsconfig();
  void set_allocated_hdfsconfig(::znbase::roachpb::DumpSink_HDFS* hdfsconfig);

  // .znbase.roachpb.DumpSink.KAFKA KafkaConfig = 6;
  bool has_kafkaconfig() const;
  void clear_kafkaconfig();
  static const int kKafkaConfigFieldNumber = 6;
  private:
  const ::znbase::roachpb::DumpSink_KAFKA& _internal_kafkaconfig() const;
  public:
  const ::znbase::roachpb::DumpSink_KAFKA& kafkaconfig() const;
  ::znbase::roachpb::DumpSink_KAFKA* release_kafkaconfig();
  ::znbase::roachpb::DumpSink_KAFKA* mutable_kafkaconfig();
  void set_allocated_kafkaconfig(::znbase::roachpb::DumpSink_KAFKA* kafkaconfig);

  // .znbase.roachpb.DumpSink.GCS GoogleCloudConfig = 7;
  bool has_googlecloudconfig() const;
  void clear_googlecloudconfig();
  static const int kGoogleCloudConfigFieldNumber = 7;
  private:
  const ::znbase::roachpb::DumpSink_GCS& _internal_googlecloudconfig() const;
  public:
  const ::znbase::roachpb::DumpSink_GCS& googlecloudconfig() const;
  ::znbase::roachpb::DumpSink_GCS* release_googlecloudconfig();
  ::znbase::roachpb::DumpSink_GCS* mutable_googlecloudconfig();
  void set_allocated_googlecloudconfig(::znbase::roachpb::DumpSink_GCS* googlecloudconfig);

  // .znbase.roachpb.DumpSink.Azure AzureConfig = 8;
  bool has_azureconfig() const;
  void clear_azureconfig();
  static const int kAzureConfigFieldNumber = 8;
  private:
  const ::znbase::roachpb::DumpSink_Azure& _internal_azureconfig() const;
  public:
  const ::znbase::roachpb::DumpSink_Azure& azureconfig() const;
  ::znbase::roachpb::DumpSink_Azure* release_azureconfig();
  ::znbase::roachpb::DumpSink_Azure* mutable_azureconfig();
  void set_allocated_azureconfig(::znbase::roachpb::DumpSink_Azure* azureconfig);

  // .znbase.roachpb.DumpSink.Workload WorkloadConfig = 9;
  bool has_workloadconfig() const;
  void clear_workloadconfig();
  static const int kWorkloadConfigFieldNumber = 9;
  private:
  const ::znbase::roachpb::DumpSink_Workload& _internal_workloadconfig() const;
  public:
  const ::znbase::roachpb::DumpSink_Workload& workloadconfig() const;
  ::znbase::roachpb::DumpSink_Workload* release_workloadconfig();
  ::znbase::roachpb::DumpSink_Workload* mutable_workloadconfig();
  void set_allocated_workloadconfig(::znbase::roachpb::DumpSink_Workload* workloadconfig);

  // .znbase.roachpb.ExportStorageProvider provider = 1;
  void clear_provider();
  static const int kProviderFieldNumber = 1;
  ::znbase::roachpb::ExportStorageProvider provider() const;
  void set_provider(::znbase::roachpb::ExportStorageProvider value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.DumpSink)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::DumpSink_LocalFilePath* localfile_;
  ::znbase::roachpb::DumpSink_Http* httppath_;
  ::znbase::roachpb::DumpSink_S3* s3config_;
  ::znbase::roachpb::DumpSink_HDFS* hdfsconfig_;
  ::znbase::roachpb::DumpSink_KAFKA* kafkaconfig_;
  ::znbase::roachpb::DumpSink_GCS* googlecloudconfig_;
  ::znbase::roachpb::DumpSink_Azure* azureconfig_;
  ::znbase::roachpb::DumpSink_Workload* workloadconfig_;
  int provider_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WriteBatchRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.WriteBatchRequest) */ {
 public:
  WriteBatchRequest();
  virtual ~WriteBatchRequest();

  WriteBatchRequest(const WriteBatchRequest& from);

  inline WriteBatchRequest& operator=(const WriteBatchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WriteBatchRequest(WriteBatchRequest&& from) noexcept
    : WriteBatchRequest() {
    *this = ::std::move(from);
  }

  inline WriteBatchRequest& operator=(WriteBatchRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const WriteBatchRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WriteBatchRequest* internal_default_instance() {
    return reinterpret_cast<const WriteBatchRequest*>(
               &_WriteBatchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    89;

  void Swap(WriteBatchRequest* other);
  friend void swap(WriteBatchRequest& a, WriteBatchRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WriteBatchRequest* New() const final {
    return CreateMaybeMessage<WriteBatchRequest>(NULL);
  }

  WriteBatchRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WriteBatchRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const WriteBatchRequest& from);
  void MergeFrom(const WriteBatchRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WriteBatchRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes data = 3;
  void clear_data();
  static const int kDataFieldNumber = 3;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  bool has_data_span() const;
  void clear_data_span();
  static const int kDataSpanFieldNumber = 2;
  private:
  const ::znbase::roachpb::Span& _internal_data_span() const;
  public:
  const ::znbase::roachpb::Span& data_span() const;
  ::znbase::roachpb::Span* release_data_span();
  ::znbase::roachpb::Span* mutable_data_span();
  void set_allocated_data_span(::znbase::roachpb::Span* data_span);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.WriteBatchRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::znbase::roachpb::RequestHeader* header_;
  ::znbase::roachpb::Span* data_span_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WriteBatchResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.WriteBatchResponse) */ {
 public:
  WriteBatchResponse();
  virtual ~WriteBatchResponse();

  WriteBatchResponse(const WriteBatchResponse& from);

  inline WriteBatchResponse& operator=(const WriteBatchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WriteBatchResponse(WriteBatchResponse&& from) noexcept
    : WriteBatchResponse() {
    *this = ::std::move(from);
  }

  inline WriteBatchResponse& operator=(WriteBatchResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const WriteBatchResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WriteBatchResponse* internal_default_instance() {
    return reinterpret_cast<const WriteBatchResponse*>(
               &_WriteBatchResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    90;

  void Swap(WriteBatchResponse* other);
  friend void swap(WriteBatchResponse& a, WriteBatchResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WriteBatchResponse* New() const final {
    return CreateMaybeMessage<WriteBatchResponse>(NULL);
  }

  WriteBatchResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WriteBatchResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const WriteBatchResponse& from);
  void MergeFrom(const WriteBatchResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WriteBatchResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.WriteBatchResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::ResponseHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FileEncryptionOptions : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.FileEncryptionOptions) */ {
 public:
  FileEncryptionOptions();
  virtual ~FileEncryptionOptions();

  FileEncryptionOptions(const FileEncryptionOptions& from);

  inline FileEncryptionOptions& operator=(const FileEncryptionOptions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileEncryptionOptions(FileEncryptionOptions&& from) noexcept
    : FileEncryptionOptions() {
    *this = ::std::move(from);
  }

  inline FileEncryptionOptions& operator=(FileEncryptionOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const FileEncryptionOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileEncryptionOptions* internal_default_instance() {
    return reinterpret_cast<const FileEncryptionOptions*>(
               &_FileEncryptionOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    91;

  void Swap(FileEncryptionOptions* other);
  friend void swap(FileEncryptionOptions& a, FileEncryptionOptions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileEncryptionOptions* New() const final {
    return CreateMaybeMessage<FileEncryptionOptions>(NULL);
  }

  FileEncryptionOptions* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileEncryptionOptions>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const FileEncryptionOptions& from);
  void MergeFrom(const FileEncryptionOptions& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FileEncryptionOptions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.FileEncryptionOptions)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExportRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.ExportRequest) */ {
 public:
  ExportRequest();
  virtual ~ExportRequest();

  ExportRequest(const ExportRequest& from);

  inline ExportRequest& operator=(const ExportRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExportRequest(ExportRequest&& from) noexcept
    : ExportRequest() {
    *this = ::std::move(from);
  }

  inline ExportRequest& operator=(ExportRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ExportRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExportRequest* internal_default_instance() {
    return reinterpret_cast<const ExportRequest*>(
               &_ExportRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    92;

  void Swap(ExportRequest* other);
  friend void swap(ExportRequest& a, ExportRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExportRequest* New() const final {
    return CreateMaybeMessage<ExportRequest>(NULL);
  }

  ExportRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExportRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ExportRequest& from);
  void MergeFrom(const ExportRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExportRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  bool has_storage() const;
  void clear_storage();
  static const int kStorageFieldNumber = 2;
  private:
  const ::znbase::roachpb::ExportStorage& _internal_storage() const;
  public:
  const ::znbase::roachpb::ExportStorage& storage() const;
  ::znbase::roachpb::ExportStorage* release_storage();
  ::znbase::roachpb::ExportStorage* mutable_storage();
  void set_allocated_storage(::znbase::roachpb::ExportStorage* storage);

  bool has_start_time() const;
  void clear_start_time();
  static const int kStartTimeFieldNumber = 3;
  private:
  const ::znbase::util::hlc::Timestamp& _internal_start_time() const;
  public:
  const ::znbase::util::hlc::Timestamp& start_time() const;
  ::znbase::util::hlc::Timestamp* release_start_time();
  ::znbase::util::hlc::Timestamp* mutable_start_time();
  void set_allocated_start_time(::znbase::util::hlc::Timestamp* start_time);

  // .znbase.roachpb.FileEncryptionOptions encryption = 9;
  bool has_encryption() const;
  void clear_encryption();
  static const int kEncryptionFieldNumber = 9;
  private:
  const ::znbase::roachpb::FileEncryptionOptions& _internal_encryption() const;
  public:
  const ::znbase::roachpb::FileEncryptionOptions& encryption() const;
  ::znbase::roachpb::FileEncryptionOptions* release_encryption();
  ::znbase::roachpb::FileEncryptionOptions* mutable_encryption();
  void set_allocated_encryption(::znbase::roachpb::FileEncryptionOptions* encryption);

  void clear_mvcc_filter();
  static const int kMvccFilterFieldNumber = 4;
  ::znbase::roachpb::MVCCFilter mvcc_filter() const;
  void set_mvcc_filter(::znbase::roachpb::MVCCFilter value);

  void clear_return_sst();
  static const int kReturnSstFieldNumber = 5;
  bool return_sst() const;
  void set_return_sst(bool value);

  // bool omit_checksum = 6;
  void clear_omit_checksum();
  static const int kOmitChecksumFieldNumber = 6;
  bool omit_checksum() const;
  void set_omit_checksum(bool value);

  // bool enable_time_bound_iterator_optimization = 7;
  void clear_enable_time_bound_iterator_optimization();
  static const int kEnableTimeBoundIteratorOptimizationFieldNumber = 7;
  bool enable_time_bound_iterator_optimization() const;
  void set_enable_time_bound_iterator_optimization(bool value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.ExportRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::RequestHeader* header_;
  ::znbase::roachpb::ExportStorage* storage_;
  ::znbase::util::hlc::Timestamp* start_time_;
  ::znbase::roachpb::FileEncryptionOptions* encryption_;
  int mvcc_filter_;
  bool return_sst_;
  bool omit_checksum_;
  bool enable_time_bound_iterator_optimization_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RevertRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.RevertRequest) */ {
 public:
  RevertRequest();
  virtual ~RevertRequest();

  RevertRequest(const RevertRequest& from);

  inline RevertRequest& operator=(const RevertRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RevertRequest(RevertRequest&& from) noexcept
    : RevertRequest() {
    *this = ::std::move(from);
  }

  inline RevertRequest& operator=(RevertRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const RevertRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RevertRequest* internal_default_instance() {
    return reinterpret_cast<const RevertRequest*>(
               &_RevertRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    93;

  void Swap(RevertRequest* other);
  friend void swap(RevertRequest& a, RevertRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RevertRequest* New() const final {
    return CreateMaybeMessage<RevertRequest>(NULL);
  }

  RevertRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RevertRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const RevertRequest& from);
  void MergeFrom(const RevertRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RevertRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  int clearintents_size() const;
  void clear_clearintents();
  static const int kClearIntentsFieldNumber = 4;
  ::znbase::roachpb::Intent* mutable_clearintents(int index);
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::Intent >*
      mutable_clearintents();
  const ::znbase::roachpb::Intent& clearintents(int index) const;
  ::znbase::roachpb::Intent* add_clearintents();
  const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::Intent >&
      clearintents() const;

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  bool has_snapshot_time() const;
  void clear_snapshot_time();
  static const int kSnapshotTimeFieldNumber = 2;
  private:
  const ::znbase::util::hlc::Timestamp& _internal_snapshot_time() const;
  public:
  const ::znbase::util::hlc::Timestamp& snapshot_time() const;
  ::znbase::util::hlc::Timestamp* release_snapshot_time();
  ::znbase::util::hlc::Timestamp* mutable_snapshot_time();
  void set_allocated_snapshot_time(::znbase::util::hlc::Timestamp* snapshot_time);

  // bool return_keys = 3;
  void clear_return_keys();
  static const int kReturnKeysFieldNumber = 3;
  bool return_keys() const;
  void set_return_keys(bool value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.RevertRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::Intent > clearintents_;
  ::znbase::roachpb::RequestHeader* header_;
  ::znbase::util::hlc::Timestamp* snapshot_time_;
  bool return_keys_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RevertResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.RevertResponse) */ {
 public:
  RevertResponse();
  virtual ~RevertResponse();

  RevertResponse(const RevertResponse& from);

  inline RevertResponse& operator=(const RevertResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RevertResponse(RevertResponse&& from) noexcept
    : RevertResponse() {
    *this = ::std::move(from);
  }

  inline RevertResponse& operator=(RevertResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const RevertResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RevertResponse* internal_default_instance() {
    return reinterpret_cast<const RevertResponse*>(
               &_RevertResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    94;

  void Swap(RevertResponse* other);
  friend void swap(RevertResponse& a, RevertResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RevertResponse* New() const final {
    return CreateMaybeMessage<RevertResponse>(NULL);
  }

  RevertResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RevertResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const RevertResponse& from);
  void MergeFrom(const RevertResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RevertResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 3;
  const ::std::string& keys(int index) const;
  ::std::string* mutable_keys(int index);
  void set_keys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_keys(int index, ::std::string&& value);
  #endif
  void set_keys(int index, const char* value);
  void set_keys(int index, const void* value, size_t size);
  ::std::string* add_keys();
  void add_keys(const ::std::string& value);
  #if LANG_CXX11
  void add_keys(::std::string&& value);
  #endif
  void add_keys(const char* value);
  void add_keys(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  int unknownintents_size() const;
  void clear_unknownintents();
  static const int kUnknownIntentsFieldNumber = 4;
  ::znbase::roachpb::Intent* mutable_unknownintents(int index);
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::Intent >*
      mutable_unknownintents();
  const ::znbase::roachpb::Intent& unknownintents(int index) const;
  ::znbase::roachpb::Intent* add_unknownintents();
  const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::Intent >&
      unknownintents() const;

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  // int64 reverted = 2;
  void clear_reverted();
  static const int kRevertedFieldNumber = 2;
  ::google::protobuf::int64 reverted() const;
  void set_reverted(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.RevertResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::Intent > unknownintents_;
  ::znbase::roachpb::ResponseHeader* header_;
  ::google::protobuf::int64 reverted_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClearIntentRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.ClearIntentRequest) */ {
 public:
  ClearIntentRequest();
  virtual ~ClearIntentRequest();

  ClearIntentRequest(const ClearIntentRequest& from);

  inline ClearIntentRequest& operator=(const ClearIntentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClearIntentRequest(ClearIntentRequest&& from) noexcept
    : ClearIntentRequest() {
    *this = ::std::move(from);
  }

  inline ClearIntentRequest& operator=(ClearIntentRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ClearIntentRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClearIntentRequest* internal_default_instance() {
    return reinterpret_cast<const ClearIntentRequest*>(
               &_ClearIntentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    95;

  void Swap(ClearIntentRequest* other);
  friend void swap(ClearIntentRequest& a, ClearIntentRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClearIntentRequest* New() const final {
    return CreateMaybeMessage<ClearIntentRequest>(NULL);
  }

  ClearIntentRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClearIntentRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ClearIntentRequest& from);
  void MergeFrom(const ClearIntentRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClearIntentRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  int clearintents_size() const;
  void clear_clearintents();
  static const int kClearIntentsFieldNumber = 3;
  ::znbase::roachpb::Intent* mutable_clearintents(int index);
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::Intent >*
      mutable_clearintents();
  const ::znbase::roachpb::Intent& clearintents(int index) const;
  ::znbase::roachpb::Intent* add_clearintents();
  const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::Intent >&
      clearintents() const;

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  // bool return_keys = 2;
  void clear_return_keys();
  static const int kReturnKeysFieldNumber = 2;
  bool return_keys() const;
  void set_return_keys(bool value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.ClearIntentRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::Intent > clearintents_;
  ::znbase::roachpb::RequestHeader* header_;
  bool return_keys_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClearIntentResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.ClearIntentResponse) */ {
 public:
  ClearIntentResponse();
  virtual ~ClearIntentResponse();

  ClearIntentResponse(const ClearIntentResponse& from);

  inline ClearIntentResponse& operator=(const ClearIntentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClearIntentResponse(ClearIntentResponse&& from) noexcept
    : ClearIntentResponse() {
    *this = ::std::move(from);
  }

  inline ClearIntentResponse& operator=(ClearIntentResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ClearIntentResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClearIntentResponse* internal_default_instance() {
    return reinterpret_cast<const ClearIntentResponse*>(
               &_ClearIntentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    96;

  void Swap(ClearIntentResponse* other);
  friend void swap(ClearIntentResponse& a, ClearIntentResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClearIntentResponse* New() const final {
    return CreateMaybeMessage<ClearIntentResponse>(NULL);
  }

  ClearIntentResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClearIntentResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ClearIntentResponse& from);
  void MergeFrom(const ClearIntentResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClearIntentResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 3;
  const ::std::string& keys(int index) const;
  ::std::string* mutable_keys(int index);
  void set_keys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_keys(int index, ::std::string&& value);
  #endif
  void set_keys(int index, const char* value);
  void set_keys(int index, const void* value, size_t size);
  ::std::string* add_keys();
  void add_keys(const ::std::string& value);
  #if LANG_CXX11
  void add_keys(::std::string&& value);
  #endif
  void add_keys(const char* value);
  void add_keys(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  int unknownintents_size() const;
  void clear_unknownintents();
  static const int kUnknownIntentsFieldNumber = 4;
  ::znbase::roachpb::Intent* mutable_unknownintents(int index);
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::Intent >*
      mutable_unknownintents();
  const ::znbase::roachpb::Intent& unknownintents(int index) const;
  ::znbase::roachpb::Intent* add_unknownintents();
  const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::Intent >&
      unknownintents() const;

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  // int64 reverted = 2;
  void clear_reverted();
  static const int kRevertedFieldNumber = 2;
  ::google::protobuf::int64 reverted() const;
  void set_reverted(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.ClearIntentResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::Intent > unknownintents_;
  ::znbase::roachpb::ResponseHeader* header_;
  ::google::protobuf::int64 reverted_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DumpRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.DumpRequest) */ {
 public:
  DumpRequest();
  virtual ~DumpRequest();

  DumpRequest(const DumpRequest& from);

  inline DumpRequest& operator=(const DumpRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DumpRequest(DumpRequest&& from) noexcept
    : DumpRequest() {
    *this = ::std::move(from);
  }

  inline DumpRequest& operator=(DumpRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DumpRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DumpRequest* internal_default_instance() {
    return reinterpret_cast<const DumpRequest*>(
               &_DumpRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    97;

  void Swap(DumpRequest* other);
  friend void swap(DumpRequest& a, DumpRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DumpRequest* New() const final {
    return CreateMaybeMessage<DumpRequest>(NULL);
  }

  DumpRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DumpRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const DumpRequest& from);
  void MergeFrom(const DumpRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DumpRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string http_header = 11;
  void clear_http_header();
  static const int kHttpHeaderFieldNumber = 11;
  const ::std::string& http_header() const;
  void set_http_header(const ::std::string& value);
  #if LANG_CXX11
  void set_http_header(::std::string&& value);
  #endif
  void set_http_header(const char* value);
  void set_http_header(const char* value, size_t size);
  ::std::string* mutable_http_header();
  ::std::string* release_http_header();
  void set_allocated_http_header(::std::string* http_header);

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  bool has_sink() const;
  void clear_sink();
  static const int kSinkFieldNumber = 2;
  private:
  const ::znbase::roachpb::DumpSink& _internal_sink() const;
  public:
  const ::znbase::roachpb::DumpSink& sink() const;
  ::znbase::roachpb::DumpSink* release_sink();
  ::znbase::roachpb::DumpSink* mutable_sink();
  void set_allocated_sink(::znbase::roachpb::DumpSink* sink);

  bool has_start_time() const;
  void clear_start_time();
  static const int kStartTimeFieldNumber = 3;
  private:
  const ::znbase::util::hlc::Timestamp& _internal_start_time() const;
  public:
  const ::znbase::util::hlc::Timestamp& start_time() const;
  ::znbase::util::hlc::Timestamp* release_start_time();
  ::znbase::util::hlc::Timestamp* mutable_start_time();
  void set_allocated_start_time(::znbase::util::hlc::Timestamp* start_time);

  // .znbase.roachpb.FileEncryptionOptions encryption = 9;
  bool has_encryption() const;
  void clear_encryption();
  static const int kEncryptionFieldNumber = 9;
  private:
  const ::znbase::roachpb::FileEncryptionOptions& _internal_encryption() const;
  public:
  const ::znbase::roachpb::FileEncryptionOptions& encryption() const;
  ::znbase::roachpb::FileEncryptionOptions* release_encryption();
  ::znbase::roachpb::FileEncryptionOptions* mutable_encryption();
  void set_allocated_encryption(::znbase::roachpb::FileEncryptionOptions* encryption);

  void clear_mvcc_filter();
  static const int kMvccFilterFieldNumber = 4;
  ::znbase::roachpb::MVCCFilter mvcc_filter() const;
  void set_mvcc_filter(::znbase::roachpb::MVCCFilter value);

  void clear_return_sst();
  static const int kReturnSstFieldNumber = 5;
  bool return_sst() const;
  void set_return_sst(bool value);

  // bool omit_checksum = 6;
  void clear_omit_checksum();
  static const int kOmitChecksumFieldNumber = 6;
  bool omit_checksum() const;
  void set_omit_checksum(bool value);

  // bool enable_time_bound_iterator_optimization = 7;
  void clear_enable_time_bound_iterator_optimization();
  static const int kEnableTimeBoundIteratorOptimizationFieldNumber = 7;
  bool enable_time_bound_iterator_optimization() const;
  void set_enable_time_bound_iterator_optimization(bool value);

  // .znbase.roachpb.FileCompression compression_codec = 10;
  void clear_compression_codec();
  static const int kCompressionCodecFieldNumber = 10;
  ::znbase::roachpb::FileCompression compression_codec() const;
  void set_compression_codec(::znbase::roachpb::FileCompression value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.DumpRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr http_header_;
  ::znbase::roachpb::RequestHeader* header_;
  ::znbase::roachpb::DumpSink* sink_;
  ::znbase::util::hlc::Timestamp* start_time_;
  ::znbase::roachpb::FileEncryptionOptions* encryption_;
  int mvcc_filter_;
  bool return_sst_;
  bool omit_checksum_;
  bool enable_time_bound_iterator_optimization_;
  int compression_codec_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Result : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.Result) */ {
 public:
  Result();
  virtual ~Result();

  Result(const Result& from);

  inline Result& operator=(const Result& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Result(Result&& from) noexcept
    : Result() {
    *this = ::std::move(from);
  }

  inline Result& operator=(Result&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Result& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Result* internal_default_instance() {
    return reinterpret_cast<const Result*>(
               &_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    98;

  void Swap(Result* other);
  friend void swap(Result& a, Result& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Result* New() const final {
    return CreateMaybeMessage<Result>(NULL);
  }

  Result* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Result>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Result& from);
  void MergeFrom(const Result& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Result* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // bool remove = 2;
  void clear_remove();
  static const int kRemoveFieldNumber = 2;
  bool remove() const;
  void set_remove(bool value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.Result)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  bool remove_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DumpOnlineRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.DumpOnlineRequest) */ {
 public:
  DumpOnlineRequest();
  virtual ~DumpOnlineRequest();

  DumpOnlineRequest(const DumpOnlineRequest& from);

  inline DumpOnlineRequest& operator=(const DumpOnlineRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DumpOnlineRequest(DumpOnlineRequest&& from) noexcept
    : DumpOnlineRequest() {
    *this = ::std::move(from);
  }

  inline DumpOnlineRequest& operator=(DumpOnlineRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DumpOnlineRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DumpOnlineRequest* internal_default_instance() {
    return reinterpret_cast<const DumpOnlineRequest*>(
               &_DumpOnlineRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    99;

  void Swap(DumpOnlineRequest* other);
  friend void swap(DumpOnlineRequest& a, DumpOnlineRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DumpOnlineRequest* New() const final {
    return CreateMaybeMessage<DumpOnlineRequest>(NULL);
  }

  DumpOnlineRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DumpOnlineRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const DumpOnlineRequest& from);
  void MergeFrom(const DumpOnlineRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DumpOnlineRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  int results_size() const;
  void clear_results();
  static const int kResultsFieldNumber = 12;
  ::znbase::roachpb::Result* mutable_results(int index);
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::Result >*
      mutable_results();
  const ::znbase::roachpb::Result& results(int index) const;
  ::znbase::roachpb::Result* add_results();
  const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::Result >&
      results() const;

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  bool has_sink() const;
  void clear_sink();
  static const int kSinkFieldNumber = 2;
  private:
  const ::znbase::roachpb::DumpSink& _internal_sink() const;
  public:
  const ::znbase::roachpb::DumpSink& sink() const;
  ::znbase::roachpb::DumpSink* release_sink();
  ::znbase::roachpb::DumpSink* mutable_sink();
  void set_allocated_sink(::znbase::roachpb::DumpSink* sink);

  bool has_start_time() const;
  void clear_start_time();
  static const int kStartTimeFieldNumber = 3;
  private:
  const ::znbase::util::hlc::Timestamp& _internal_start_time() const;
  public:
  const ::znbase::util::hlc::Timestamp& start_time() const;
  ::znbase::util::hlc::Timestamp* release_start_time();
  ::znbase::util::hlc::Timestamp* mutable_start_time();
  void set_allocated_start_time(::znbase::util::hlc::Timestamp* start_time);

  // .znbase.roachpb.FileEncryptionOptions encryption = 9;
  bool has_encryption() const;
  void clear_encryption();
  static const int kEncryptionFieldNumber = 9;
  private:
  const ::znbase::roachpb::FileEncryptionOptions& _internal_encryption() const;
  public:
  const ::znbase::roachpb::FileEncryptionOptions& encryption() const;
  ::znbase::roachpb::FileEncryptionOptions* release_encryption();
  ::znbase::roachpb::FileEncryptionOptions* mutable_encryption();
  void set_allocated_encryption(::znbase::roachpb::FileEncryptionOptions* encryption);

  void clear_mvcc_filter();
  static const int kMvccFilterFieldNumber = 4;
  ::znbase::roachpb::MVCCFilter mvcc_filter() const;
  void set_mvcc_filter(::znbase::roachpb::MVCCFilter value);

  void clear_return_sst();
  static const int kReturnSstFieldNumber = 5;
  bool return_sst() const;
  void set_return_sst(bool value);

  // bool omit_checksum = 6;
  void clear_omit_checksum();
  static const int kOmitChecksumFieldNumber = 6;
  bool omit_checksum() const;
  void set_omit_checksum(bool value);

  // bool enable_time_bound_iterator_optimization = 7;
  void clear_enable_time_bound_iterator_optimization();
  static const int kEnableTimeBoundIteratorOptimizationFieldNumber = 7;
  bool enable_time_bound_iterator_optimization() const;
  void set_enable_time_bound_iterator_optimization(bool value);

  // bool seekTime = 11;
  void clear_seektime();
  static const int kSeekTimeFieldNumber = 11;
  bool seektime() const;
  void set_seektime(bool value);

  // .znbase.roachpb.FileCompression compression_codec = 10;
  void clear_compression_codec();
  static const int kCompressionCodecFieldNumber = 10;
  ::znbase::roachpb::FileCompression compression_codec() const;
  void set_compression_codec(::znbase::roachpb::FileCompression value);

  // int64 job_id = 14;
  void clear_job_id();
  static const int kJobIdFieldNumber = 14;
  ::google::protobuf::int64 job_id() const;
  void set_job_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.DumpOnlineRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::Result > results_;
  ::znbase::roachpb::RequestHeader* header_;
  ::znbase::roachpb::DumpSink* sink_;
  ::znbase::util::hlc::Timestamp* start_time_;
  ::znbase::roachpb::FileEncryptionOptions* encryption_;
  int mvcc_filter_;
  bool return_sst_;
  bool omit_checksum_;
  bool enable_time_bound_iterator_optimization_;
  bool seektime_;
  int compression_codec_;
  ::google::protobuf::int64 job_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DumpOnlineResponse_File : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.DumpOnlineResponse.File) */ {
 public:
  DumpOnlineResponse_File();
  virtual ~DumpOnlineResponse_File();

  DumpOnlineResponse_File(const DumpOnlineResponse_File& from);

  inline DumpOnlineResponse_File& operator=(const DumpOnlineResponse_File& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DumpOnlineResponse_File(DumpOnlineResponse_File&& from) noexcept
    : DumpOnlineResponse_File() {
    *this = ::std::move(from);
  }

  inline DumpOnlineResponse_File& operator=(DumpOnlineResponse_File&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DumpOnlineResponse_File& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DumpOnlineResponse_File* internal_default_instance() {
    return reinterpret_cast<const DumpOnlineResponse_File*>(
               &_DumpOnlineResponse_File_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    100;

  void Swap(DumpOnlineResponse_File* other);
  friend void swap(DumpOnlineResponse_File& a, DumpOnlineResponse_File& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DumpOnlineResponse_File* New() const final {
    return CreateMaybeMessage<DumpOnlineResponse_File>(NULL);
  }

  DumpOnlineResponse_File* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DumpOnlineResponse_File>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const DumpOnlineResponse_File& from);
  void MergeFrom(const DumpOnlineResponse_File& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DumpOnlineResponse_File* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string path = 2;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // bytes sha512 = 5;
  void clear_sha512();
  static const int kSha512FieldNumber = 5;
  const ::std::string& sha512() const;
  void set_sha512(const ::std::string& value);
  #if LANG_CXX11
  void set_sha512(::std::string&& value);
  #endif
  void set_sha512(const char* value);
  void set_sha512(const void* value, size_t size);
  ::std::string* mutable_sha512();
  ::std::string* release_sha512();
  void set_allocated_sha512(::std::string* sha512);

  void clear_sst();
  static const int kSstFieldNumber = 7;
  const ::std::string& sst() const;
  void set_sst(const ::std::string& value);
  #if LANG_CXX11
  void set_sst(::std::string&& value);
  #endif
  void set_sst(const char* value);
  void set_sst(const void* value, size_t size);
  ::std::string* mutable_sst();
  ::std::string* release_sst();
  void set_allocated_sst(::std::string* sst);

  bool has_span() const;
  void clear_span();
  static const int kSpanFieldNumber = 1;
  private:
  const ::znbase::roachpb::Span& _internal_span() const;
  public:
  const ::znbase::roachpb::Span& span() const;
  ::znbase::roachpb::Span* release_span();
  ::znbase::roachpb::Span* mutable_span();
  void set_allocated_span(::znbase::roachpb::Span* span);

  bool has_dumped() const;
  void clear_dumped();
  static const int kDumpedFieldNumber = 6;
  private:
  const ::znbase::roachpb::BulkOpSummary& _internal_dumped() const;
  public:
  const ::znbase::roachpb::BulkOpSummary& dumped() const;
  ::znbase::roachpb::BulkOpSummary* release_dumped();
  ::znbase::roachpb::BulkOpSummary* mutable_dumped();
  void set_allocated_dumped(::znbase::roachpb::BulkOpSummary* dumped);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.DumpOnlineResponse.File)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::internal::ArenaStringPtr sha512_;
  ::google::protobuf::internal::ArenaStringPtr sst_;
  ::znbase::roachpb::Span* span_;
  ::znbase::roachpb::BulkOpSummary* dumped_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DumpOnlineResponse_Files : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.DumpOnlineResponse.Files) */ {
 public:
  DumpOnlineResponse_Files();
  virtual ~DumpOnlineResponse_Files();

  DumpOnlineResponse_Files(const DumpOnlineResponse_Files& from);

  inline DumpOnlineResponse_Files& operator=(const DumpOnlineResponse_Files& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DumpOnlineResponse_Files(DumpOnlineResponse_Files&& from) noexcept
    : DumpOnlineResponse_Files() {
    *this = ::std::move(from);
  }

  inline DumpOnlineResponse_Files& operator=(DumpOnlineResponse_Files&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DumpOnlineResponse_Files& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DumpOnlineResponse_Files* internal_default_instance() {
    return reinterpret_cast<const DumpOnlineResponse_Files*>(
               &_DumpOnlineResponse_Files_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    101;

  void Swap(DumpOnlineResponse_Files* other);
  friend void swap(DumpOnlineResponse_Files& a, DumpOnlineResponse_Files& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DumpOnlineResponse_Files* New() const final {
    return CreateMaybeMessage<DumpOnlineResponse_Files>(NULL);
  }

  DumpOnlineResponse_Files* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DumpOnlineResponse_Files>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const DumpOnlineResponse_Files& from);
  void MergeFrom(const DumpOnlineResponse_Files& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DumpOnlineResponse_Files* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  int files_size() const;
  void clear_files();
  static const int kFilesFieldNumber = 1;
  ::znbase::roachpb::DumpOnlineResponse_File* mutable_files(int index);
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::DumpOnlineResponse_File >*
      mutable_files();
  const ::znbase::roachpb::DumpOnlineResponse_File& files(int index) const;
  ::znbase::roachpb::DumpOnlineResponse_File* add_files();
  const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::DumpOnlineResponse_File >&
      files() const;

  // @@protoc_insertion_point(class_scope:znbase.roachpb.DumpOnlineResponse.Files)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::DumpOnlineResponse_File > files_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DumpOnlineResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.DumpOnlineResponse) */ {
 public:
  DumpOnlineResponse();
  virtual ~DumpOnlineResponse();

  DumpOnlineResponse(const DumpOnlineResponse& from);

  inline DumpOnlineResponse& operator=(const DumpOnlineResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DumpOnlineResponse(DumpOnlineResponse&& from) noexcept
    : DumpOnlineResponse() {
    *this = ::std::move(from);
  }

  inline DumpOnlineResponse& operator=(DumpOnlineResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DumpOnlineResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DumpOnlineResponse* internal_default_instance() {
    return reinterpret_cast<const DumpOnlineResponse*>(
               &_DumpOnlineResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    102;

  void Swap(DumpOnlineResponse* other);
  friend void swap(DumpOnlineResponse& a, DumpOnlineResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DumpOnlineResponse* New() const final {
    return CreateMaybeMessage<DumpOnlineResponse>(NULL);
  }

  DumpOnlineResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DumpOnlineResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const DumpOnlineResponse& from);
  void MergeFrom(const DumpOnlineResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DumpOnlineResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DumpOnlineResponse_File File;
  typedef DumpOnlineResponse_Files Files;

  // accessors -------------------------------------------------------

  int files_size() const;
  void clear_files();
  static const int kFilesFieldNumber = 2;
  ::znbase::roachpb::DumpOnlineResponse_File* mutable_files(int index);
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::DumpOnlineResponse_File >*
      mutable_files();
  const ::znbase::roachpb::DumpOnlineResponse_File& files(int index) const;
  ::znbase::roachpb::DumpOnlineResponse_File* add_files();
  const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::DumpOnlineResponse_File >&
      files() const;

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  bool has_start_time() const;
  void clear_start_time();
  static const int kStartTimeFieldNumber = 3;
  private:
  const ::znbase::util::hlc::Timestamp& _internal_start_time() const;
  public:
  const ::znbase::util::hlc::Timestamp& start_time() const;
  ::znbase::util::hlc::Timestamp* release_start_time();
  ::znbase::util::hlc::Timestamp* mutable_start_time();
  void set_allocated_start_time(::znbase::util::hlc::Timestamp* start_time);

  bool has_min_time() const;
  void clear_min_time();
  static const int kMinTimeFieldNumber = 4;
  private:
  const ::znbase::util::hlc::Timestamp& _internal_min_time() const;
  public:
  const ::znbase::util::hlc::Timestamp& min_time() const;
  ::znbase::util::hlc::Timestamp* release_min_time();
  ::znbase::util::hlc::Timestamp* mutable_min_time();
  void set_allocated_min_time(::znbase::util::hlc::Timestamp* min_time);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.DumpOnlineResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::DumpOnlineResponse_File > files_;
  ::znbase::roachpb::ResponseHeader* header_;
  ::znbase::util::hlc::Timestamp* start_time_;
  ::znbase::util::hlc::Timestamp* min_time_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BulkOpSummary : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.BulkOpSummary) */ {
 public:
  BulkOpSummary();
  virtual ~BulkOpSummary();

  BulkOpSummary(const BulkOpSummary& from);

  inline BulkOpSummary& operator=(const BulkOpSummary& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BulkOpSummary(BulkOpSummary&& from) noexcept
    : BulkOpSummary() {
    *this = ::std::move(from);
  }

  inline BulkOpSummary& operator=(BulkOpSummary&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const BulkOpSummary& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BulkOpSummary* internal_default_instance() {
    return reinterpret_cast<const BulkOpSummary*>(
               &_BulkOpSummary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    103;

  void Swap(BulkOpSummary* other);
  friend void swap(BulkOpSummary& a, BulkOpSummary& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BulkOpSummary* New() const final {
    return CreateMaybeMessage<BulkOpSummary>(NULL);
  }

  BulkOpSummary* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BulkOpSummary>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const BulkOpSummary& from);
  void MergeFrom(const BulkOpSummary& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BulkOpSummary* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .znbase.roachpb.FileEncryptionOptions encryption = 7;
  bool has_encryption() const;
  void clear_encryption();
  static const int kEncryptionFieldNumber = 7;
  private:
  const ::znbase::roachpb::FileEncryptionOptions& _internal_encryption() const;
  public:
  const ::znbase::roachpb::FileEncryptionOptions& encryption() const;
  ::znbase::roachpb::FileEncryptionOptions* release_encryption();
  ::znbase::roachpb::FileEncryptionOptions* mutable_encryption();
  void set_allocated_encryption(::znbase::roachpb::FileEncryptionOptions* encryption);

  // int64 data_size = 1;
  void clear_data_size();
  static const int kDataSizeFieldNumber = 1;
  ::google::protobuf::int64 data_size() const;
  void set_data_size(::google::protobuf::int64 value);

  // int64 rows = 2;
  void clear_rows();
  static const int kRowsFieldNumber = 2;
  ::google::protobuf::int64 rows() const;
  void set_rows(::google::protobuf::int64 value);

  // int64 index_entries = 3;
  void clear_index_entries();
  static const int kIndexEntriesFieldNumber = 3;
  ::google::protobuf::int64 index_entries() const;
  void set_index_entries(::google::protobuf::int64 value);

  // int64 system_records = 4;
  void clear_system_records();
  static const int kSystemRecordsFieldNumber = 4;
  ::google::protobuf::int64 system_records() const;
  void set_system_records(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.BulkOpSummary)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::FileEncryptionOptions* encryption_;
  ::google::protobuf::int64 data_size_;
  ::google::protobuf::int64 rows_;
  ::google::protobuf::int64 index_entries_;
  ::google::protobuf::int64 system_records_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExportResponse_File : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.ExportResponse.File) */ {
 public:
  ExportResponse_File();
  virtual ~ExportResponse_File();

  ExportResponse_File(const ExportResponse_File& from);

  inline ExportResponse_File& operator=(const ExportResponse_File& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExportResponse_File(ExportResponse_File&& from) noexcept
    : ExportResponse_File() {
    *this = ::std::move(from);
  }

  inline ExportResponse_File& operator=(ExportResponse_File&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ExportResponse_File& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExportResponse_File* internal_default_instance() {
    return reinterpret_cast<const ExportResponse_File*>(
               &_ExportResponse_File_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    104;

  void Swap(ExportResponse_File* other);
  friend void swap(ExportResponse_File& a, ExportResponse_File& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExportResponse_File* New() const final {
    return CreateMaybeMessage<ExportResponse_File>(NULL);
  }

  ExportResponse_File* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExportResponse_File>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ExportResponse_File& from);
  void MergeFrom(const ExportResponse_File& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExportResponse_File* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string path = 2;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // bytes sha512 = 5;
  void clear_sha512();
  static const int kSha512FieldNumber = 5;
  const ::std::string& sha512() const;
  void set_sha512(const ::std::string& value);
  #if LANG_CXX11
  void set_sha512(::std::string&& value);
  #endif
  void set_sha512(const char* value);
  void set_sha512(const void* value, size_t size);
  ::std::string* mutable_sha512();
  ::std::string* release_sha512();
  void set_allocated_sha512(::std::string* sha512);

  void clear_sst();
  static const int kSstFieldNumber = 7;
  const ::std::string& sst() const;
  void set_sst(const ::std::string& value);
  #if LANG_CXX11
  void set_sst(::std::string&& value);
  #endif
  void set_sst(const char* value);
  void set_sst(const void* value, size_t size);
  ::std::string* mutable_sst();
  ::std::string* release_sst();
  void set_allocated_sst(::std::string* sst);

  bool has_span() const;
  void clear_span();
  static const int kSpanFieldNumber = 1;
  private:
  const ::znbase::roachpb::Span& _internal_span() const;
  public:
  const ::znbase::roachpb::Span& span() const;
  ::znbase::roachpb::Span* release_span();
  ::znbase::roachpb::Span* mutable_span();
  void set_allocated_span(::znbase::roachpb::Span* span);

  bool has_exported() const;
  void clear_exported();
  static const int kExportedFieldNumber = 6;
  private:
  const ::znbase::roachpb::BulkOpSummary& _internal_exported() const;
  public:
  const ::znbase::roachpb::BulkOpSummary& exported() const;
  ::znbase::roachpb::BulkOpSummary* release_exported();
  ::znbase::roachpb::BulkOpSummary* mutable_exported();
  void set_allocated_exported(::znbase::roachpb::BulkOpSummary* exported);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.ExportResponse.File)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::internal::ArenaStringPtr sha512_;
  ::google::protobuf::internal::ArenaStringPtr sst_;
  ::znbase::roachpb::Span* span_;
  ::znbase::roachpb::BulkOpSummary* exported_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExportResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.ExportResponse) */ {
 public:
  ExportResponse();
  virtual ~ExportResponse();

  ExportResponse(const ExportResponse& from);

  inline ExportResponse& operator=(const ExportResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExportResponse(ExportResponse&& from) noexcept
    : ExportResponse() {
    *this = ::std::move(from);
  }

  inline ExportResponse& operator=(ExportResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ExportResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExportResponse* internal_default_instance() {
    return reinterpret_cast<const ExportResponse*>(
               &_ExportResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    105;

  void Swap(ExportResponse* other);
  friend void swap(ExportResponse& a, ExportResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExportResponse* New() const final {
    return CreateMaybeMessage<ExportResponse>(NULL);
  }

  ExportResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExportResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ExportResponse& from);
  void MergeFrom(const ExportResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExportResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ExportResponse_File File;

  // accessors -------------------------------------------------------

  int files_size() const;
  void clear_files();
  static const int kFilesFieldNumber = 2;
  ::znbase::roachpb::ExportResponse_File* mutable_files(int index);
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::ExportResponse_File >*
      mutable_files();
  const ::znbase::roachpb::ExportResponse_File& files(int index) const;
  ::znbase::roachpb::ExportResponse_File* add_files();
  const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::ExportResponse_File >&
      files() const;

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  bool has_start_time() const;
  void clear_start_time();
  static const int kStartTimeFieldNumber = 3;
  private:
  const ::znbase::util::hlc::Timestamp& _internal_start_time() const;
  public:
  const ::znbase::util::hlc::Timestamp& start_time() const;
  ::znbase::util::hlc::Timestamp* release_start_time();
  ::znbase::util::hlc::Timestamp* mutable_start_time();
  void set_allocated_start_time(::znbase::util::hlc::Timestamp* start_time);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.ExportResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::ExportResponse_File > files_;
  ::znbase::roachpb::ResponseHeader* header_;
  ::znbase::util::hlc::Timestamp* start_time_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DumpResponse_File : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.DumpResponse.File) */ {
 public:
  DumpResponse_File();
  virtual ~DumpResponse_File();

  DumpResponse_File(const DumpResponse_File& from);

  inline DumpResponse_File& operator=(const DumpResponse_File& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DumpResponse_File(DumpResponse_File&& from) noexcept
    : DumpResponse_File() {
    *this = ::std::move(from);
  }

  inline DumpResponse_File& operator=(DumpResponse_File&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DumpResponse_File& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DumpResponse_File* internal_default_instance() {
    return reinterpret_cast<const DumpResponse_File*>(
               &_DumpResponse_File_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    106;

  void Swap(DumpResponse_File* other);
  friend void swap(DumpResponse_File& a, DumpResponse_File& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DumpResponse_File* New() const final {
    return CreateMaybeMessage<DumpResponse_File>(NULL);
  }

  DumpResponse_File* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DumpResponse_File>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const DumpResponse_File& from);
  void MergeFrom(const DumpResponse_File& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DumpResponse_File* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string path = 2;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // bytes sha512 = 5;
  void clear_sha512();
  static const int kSha512FieldNumber = 5;
  const ::std::string& sha512() const;
  void set_sha512(const ::std::string& value);
  #if LANG_CXX11
  void set_sha512(::std::string&& value);
  #endif
  void set_sha512(const char* value);
  void set_sha512(const void* value, size_t size);
  ::std::string* mutable_sha512();
  ::std::string* release_sha512();
  void set_allocated_sha512(::std::string* sha512);

  void clear_sst();
  static const int kSstFieldNumber = 7;
  const ::std::string& sst() const;
  void set_sst(const ::std::string& value);
  #if LANG_CXX11
  void set_sst(::std::string&& value);
  #endif
  void set_sst(const char* value);
  void set_sst(const void* value, size_t size);
  ::std::string* mutable_sst();
  ::std::string* release_sst();
  void set_allocated_sst(::std::string* sst);

  bool has_span() const;
  void clear_span();
  static const int kSpanFieldNumber = 1;
  private:
  const ::znbase::roachpb::Span& _internal_span() const;
  public:
  const ::znbase::roachpb::Span& span() const;
  ::znbase::roachpb::Span* release_span();
  ::znbase::roachpb::Span* mutable_span();
  void set_allocated_span(::znbase::roachpb::Span* span);

  bool has_dumped() const;
  void clear_dumped();
  static const int kDumpedFieldNumber = 6;
  private:
  const ::znbase::roachpb::BulkOpSummary& _internal_dumped() const;
  public:
  const ::znbase::roachpb::BulkOpSummary& dumped() const;
  ::znbase::roachpb::BulkOpSummary* release_dumped();
  ::znbase::roachpb::BulkOpSummary* mutable_dumped();
  void set_allocated_dumped(::znbase::roachpb::BulkOpSummary* dumped);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.DumpResponse.File)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::internal::ArenaStringPtr sha512_;
  ::google::protobuf::internal::ArenaStringPtr sst_;
  ::znbase::roachpb::Span* span_;
  ::znbase::roachpb::BulkOpSummary* dumped_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DumpResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.DumpResponse) */ {
 public:
  DumpResponse();
  virtual ~DumpResponse();

  DumpResponse(const DumpResponse& from);

  inline DumpResponse& operator=(const DumpResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DumpResponse(DumpResponse&& from) noexcept
    : DumpResponse() {
    *this = ::std::move(from);
  }

  inline DumpResponse& operator=(DumpResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DumpResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DumpResponse* internal_default_instance() {
    return reinterpret_cast<const DumpResponse*>(
               &_DumpResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    107;

  void Swap(DumpResponse* other);
  friend void swap(DumpResponse& a, DumpResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DumpResponse* New() const final {
    return CreateMaybeMessage<DumpResponse>(NULL);
  }

  DumpResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DumpResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const DumpResponse& from);
  void MergeFrom(const DumpResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DumpResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DumpResponse_File File;

  // accessors -------------------------------------------------------

  int files_size() const;
  void clear_files();
  static const int kFilesFieldNumber = 2;
  ::znbase::roachpb::DumpResponse_File* mutable_files(int index);
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::DumpResponse_File >*
      mutable_files();
  const ::znbase::roachpb::DumpResponse_File& files(int index) const;
  ::znbase::roachpb::DumpResponse_File* add_files();
  const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::DumpResponse_File >&
      files() const;

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  bool has_start_time() const;
  void clear_start_time();
  static const int kStartTimeFieldNumber = 3;
  private:
  const ::znbase::util::hlc::Timestamp& _internal_start_time() const;
  public:
  const ::znbase::util::hlc::Timestamp& start_time() const;
  ::znbase::util::hlc::Timestamp* release_start_time();
  ::znbase::util::hlc::Timestamp* mutable_start_time();
  void set_allocated_start_time(::znbase::util::hlc::Timestamp* start_time);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.DumpResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::DumpResponse_File > files_;
  ::znbase::roachpb::ResponseHeader* header_;
  ::znbase::util::hlc::Timestamp* start_time_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ImportRequest_File : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.ImportRequest.File) */ {
 public:
  ImportRequest_File();
  virtual ~ImportRequest_File();

  ImportRequest_File(const ImportRequest_File& from);

  inline ImportRequest_File& operator=(const ImportRequest_File& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImportRequest_File(ImportRequest_File&& from) noexcept
    : ImportRequest_File() {
    *this = ::std::move(from);
  }

  inline ImportRequest_File& operator=(ImportRequest_File&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ImportRequest_File& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImportRequest_File* internal_default_instance() {
    return reinterpret_cast<const ImportRequest_File*>(
               &_ImportRequest_File_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    108;

  void Swap(ImportRequest_File* other);
  friend void swap(ImportRequest_File& a, ImportRequest_File& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImportRequest_File* New() const final {
    return CreateMaybeMessage<ImportRequest_File>(NULL);
  }

  ImportRequest_File* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ImportRequest_File>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ImportRequest_File& from);
  void MergeFrom(const ImportRequest_File& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ImportRequest_File* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string path = 2;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // bytes sha512 = 4;
  void clear_sha512();
  static const int kSha512FieldNumber = 4;
  const ::std::string& sha512() const;
  void set_sha512(const ::std::string& value);
  #if LANG_CXX11
  void set_sha512(::std::string&& value);
  #endif
  void set_sha512(const char* value);
  void set_sha512(const void* value, size_t size);
  ::std::string* mutable_sha512();
  ::std::string* release_sha512();
  void set_allocated_sha512(::std::string* sha512);

  bool has_dir() const;
  void clear_dir();
  static const int kDirFieldNumber = 1;
  private:
  const ::znbase::roachpb::ExportStorage& _internal_dir() const;
  public:
  const ::znbase::roachpb::ExportStorage& dir() const;
  ::znbase::roachpb::ExportStorage* release_dir();
  ::znbase::roachpb::ExportStorage* mutable_dir();
  void set_allocated_dir(::znbase::roachpb::ExportStorage* dir);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.ImportRequest.File)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::internal::ArenaStringPtr sha512_;
  ::znbase::roachpb::ExportStorage* dir_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ImportRequest_TableRekey : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.ImportRequest.TableRekey) */ {
 public:
  ImportRequest_TableRekey();
  virtual ~ImportRequest_TableRekey();

  ImportRequest_TableRekey(const ImportRequest_TableRekey& from);

  inline ImportRequest_TableRekey& operator=(const ImportRequest_TableRekey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImportRequest_TableRekey(ImportRequest_TableRekey&& from) noexcept
    : ImportRequest_TableRekey() {
    *this = ::std::move(from);
  }

  inline ImportRequest_TableRekey& operator=(ImportRequest_TableRekey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ImportRequest_TableRekey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImportRequest_TableRekey* internal_default_instance() {
    return reinterpret_cast<const ImportRequest_TableRekey*>(
               &_ImportRequest_TableRekey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    109;

  void Swap(ImportRequest_TableRekey* other);
  friend void swap(ImportRequest_TableRekey& a, ImportRequest_TableRekey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImportRequest_TableRekey* New() const final {
    return CreateMaybeMessage<ImportRequest_TableRekey>(NULL);
  }

  ImportRequest_TableRekey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ImportRequest_TableRekey>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ImportRequest_TableRekey& from);
  void MergeFrom(const ImportRequest_TableRekey& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ImportRequest_TableRekey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes new_desc = 2;
  void clear_new_desc();
  static const int kNewDescFieldNumber = 2;
  const ::std::string& new_desc() const;
  void set_new_desc(const ::std::string& value);
  #if LANG_CXX11
  void set_new_desc(::std::string&& value);
  #endif
  void set_new_desc(const char* value);
  void set_new_desc(const void* value, size_t size);
  ::std::string* mutable_new_desc();
  ::std::string* release_new_desc();
  void set_allocated_new_desc(::std::string* new_desc);

  void clear_old_id();
  static const int kOldIdFieldNumber = 1;
  ::google::protobuf::uint32 old_id() const;
  void set_old_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.ImportRequest.TableRekey)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr new_desc_;
  ::google::protobuf::uint32 old_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ImportRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.ImportRequest) */ {
 public:
  ImportRequest();
  virtual ~ImportRequest();

  ImportRequest(const ImportRequest& from);

  inline ImportRequest& operator=(const ImportRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImportRequest(ImportRequest&& from) noexcept
    : ImportRequest() {
    *this = ::std::move(from);
  }

  inline ImportRequest& operator=(ImportRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ImportRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImportRequest* internal_default_instance() {
    return reinterpret_cast<const ImportRequest*>(
               &_ImportRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    110;

  void Swap(ImportRequest* other);
  friend void swap(ImportRequest& a, ImportRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImportRequest* New() const final {
    return CreateMaybeMessage<ImportRequest>(NULL);
  }

  ImportRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ImportRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ImportRequest& from);
  void MergeFrom(const ImportRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ImportRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ImportRequest_File File;
  typedef ImportRequest_TableRekey TableRekey;

  // accessors -------------------------------------------------------

  int files_size() const;
  void clear_files();
  static const int kFilesFieldNumber = 2;
  ::znbase::roachpb::ImportRequest_File* mutable_files(int index);
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::ImportRequest_File >*
      mutable_files();
  const ::znbase::roachpb::ImportRequest_File& files(int index) const;
  ::znbase::roachpb::ImportRequest_File* add_files();
  const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::ImportRequest_File >&
      files() const;

  int rekeys_size() const;
  void clear_rekeys();
  static const int kRekeysFieldNumber = 5;
  ::znbase::roachpb::ImportRequest_TableRekey* mutable_rekeys(int index);
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::ImportRequest_TableRekey >*
      mutable_rekeys();
  const ::znbase::roachpb::ImportRequest_TableRekey& rekeys(int index) const;
  ::znbase::roachpb::ImportRequest_TableRekey* add_rekeys();
  const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::ImportRequest_TableRekey >&
      rekeys() const;

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  bool has_data_span() const;
  void clear_data_span();
  static const int kDataSpanFieldNumber = 3;
  private:
  const ::znbase::roachpb::Span& _internal_data_span() const;
  public:
  const ::znbase::roachpb::Span& data_span() const;
  ::znbase::roachpb::Span* release_data_span();
  ::znbase::roachpb::Span* mutable_data_span();
  void set_allocated_data_span(::znbase::roachpb::Span* data_span);

  bool has_end_time() const;
  void clear_end_time();
  static const int kEndTimeFieldNumber = 6;
  private:
  const ::znbase::util::hlc::Timestamp& _internal_end_time() const;
  public:
  const ::znbase::util::hlc::Timestamp& end_time() const;
  ::znbase::util::hlc::Timestamp* release_end_time();
  ::znbase::util::hlc::Timestamp* mutable_end_time();
  void set_allocated_end_time(::znbase::util::hlc::Timestamp* end_time);

  // .znbase.roachpb.FileEncryptionOptions encryption = 12;
  bool has_encryption() const;
  void clear_encryption();
  static const int kEncryptionFieldNumber = 12;
  private:
  const ::znbase::roachpb::FileEncryptionOptions& _internal_encryption() const;
  public:
  const ::znbase::roachpb::FileEncryptionOptions& encryption() const;
  ::znbase::roachpb::FileEncryptionOptions* release_encryption();
  ::znbase::roachpb::FileEncryptionOptions* mutable_encryption();
  void set_allocated_encryption(::znbase::roachpb::FileEncryptionOptions* encryption);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.ImportRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::ImportRequest_File > files_;
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::ImportRequest_TableRekey > rekeys_;
  ::znbase::roachpb::RequestHeader* header_;
  ::znbase::roachpb::Span* data_span_;
  ::znbase::util::hlc::Timestamp* end_time_;
  ::znbase::roachpb::FileEncryptionOptions* encryption_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ImportResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.ImportResponse) */ {
 public:
  ImportResponse();
  virtual ~ImportResponse();

  ImportResponse(const ImportResponse& from);

  inline ImportResponse& operator=(const ImportResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImportResponse(ImportResponse&& from) noexcept
    : ImportResponse() {
    *this = ::std::move(from);
  }

  inline ImportResponse& operator=(ImportResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ImportResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImportResponse* internal_default_instance() {
    return reinterpret_cast<const ImportResponse*>(
               &_ImportResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    111;

  void Swap(ImportResponse* other);
  friend void swap(ImportResponse& a, ImportResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImportResponse* New() const final {
    return CreateMaybeMessage<ImportResponse>(NULL);
  }

  ImportResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ImportResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ImportResponse& from);
  void MergeFrom(const ImportResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ImportResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  bool has_imported() const;
  void clear_imported();
  static const int kImportedFieldNumber = 3;
  private:
  const ::znbase::roachpb::BulkOpSummary& _internal_imported() const;
  public:
  const ::znbase::roachpb::BulkOpSummary& imported() const;
  ::znbase::roachpb::BulkOpSummary* release_imported();
  ::znbase::roachpb::BulkOpSummary* mutable_imported();
  void set_allocated_imported(::znbase::roachpb::BulkOpSummary* imported);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.ImportResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::ResponseHeader* header_;
  ::znbase::roachpb::BulkOpSummary* imported_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LoadRequest_File : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.LoadRequest.File) */ {
 public:
  LoadRequest_File();
  virtual ~LoadRequest_File();

  LoadRequest_File(const LoadRequest_File& from);

  inline LoadRequest_File& operator=(const LoadRequest_File& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoadRequest_File(LoadRequest_File&& from) noexcept
    : LoadRequest_File() {
    *this = ::std::move(from);
  }

  inline LoadRequest_File& operator=(LoadRequest_File&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const LoadRequest_File& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoadRequest_File* internal_default_instance() {
    return reinterpret_cast<const LoadRequest_File*>(
               &_LoadRequest_File_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    112;

  void Swap(LoadRequest_File* other);
  friend void swap(LoadRequest_File& a, LoadRequest_File& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoadRequest_File* New() const final {
    return CreateMaybeMessage<LoadRequest_File>(NULL);
  }

  LoadRequest_File* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LoadRequest_File>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const LoadRequest_File& from);
  void MergeFrom(const LoadRequest_File& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LoadRequest_File* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string path = 2;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // bytes sha512 = 4;
  void clear_sha512();
  static const int kSha512FieldNumber = 4;
  const ::std::string& sha512() const;
  void set_sha512(const ::std::string& value);
  #if LANG_CXX11
  void set_sha512(::std::string&& value);
  #endif
  void set_sha512(const char* value);
  void set_sha512(const void* value, size_t size);
  ::std::string* mutable_sha512();
  ::std::string* release_sha512();
  void set_allocated_sha512(::std::string* sha512);

  bool has_dir() const;
  void clear_dir();
  static const int kDirFieldNumber = 1;
  private:
  const ::znbase::roachpb::DumpSink& _internal_dir() const;
  public:
  const ::znbase::roachpb::DumpSink& dir() const;
  ::znbase::roachpb::DumpSink* release_dir();
  ::znbase::roachpb::DumpSink* mutable_dir();
  void set_allocated_dir(::znbase::roachpb::DumpSink* dir);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.LoadRequest.File)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::internal::ArenaStringPtr sha512_;
  ::znbase::roachpb::DumpSink* dir_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LoadRequest_TableRekey : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.LoadRequest.TableRekey) */ {
 public:
  LoadRequest_TableRekey();
  virtual ~LoadRequest_TableRekey();

  LoadRequest_TableRekey(const LoadRequest_TableRekey& from);

  inline LoadRequest_TableRekey& operator=(const LoadRequest_TableRekey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoadRequest_TableRekey(LoadRequest_TableRekey&& from) noexcept
    : LoadRequest_TableRekey() {
    *this = ::std::move(from);
  }

  inline LoadRequest_TableRekey& operator=(LoadRequest_TableRekey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const LoadRequest_TableRekey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoadRequest_TableRekey* internal_default_instance() {
    return reinterpret_cast<const LoadRequest_TableRekey*>(
               &_LoadRequest_TableRekey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    113;

  void Swap(LoadRequest_TableRekey* other);
  friend void swap(LoadRequest_TableRekey& a, LoadRequest_TableRekey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoadRequest_TableRekey* New() const final {
    return CreateMaybeMessage<LoadRequest_TableRekey>(NULL);
  }

  LoadRequest_TableRekey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LoadRequest_TableRekey>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const LoadRequest_TableRekey& from);
  void MergeFrom(const LoadRequest_TableRekey& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LoadRequest_TableRekey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes new_desc = 2;
  void clear_new_desc();
  static const int kNewDescFieldNumber = 2;
  const ::std::string& new_desc() const;
  void set_new_desc(const ::std::string& value);
  #if LANG_CXX11
  void set_new_desc(::std::string&& value);
  #endif
  void set_new_desc(const char* value);
  void set_new_desc(const void* value, size_t size);
  ::std::string* mutable_new_desc();
  ::std::string* release_new_desc();
  void set_allocated_new_desc(::std::string* new_desc);

  void clear_old_id();
  static const int kOldIdFieldNumber = 1;
  ::google::protobuf::uint32 old_id() const;
  void set_old_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.LoadRequest.TableRekey)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr new_desc_;
  ::google::protobuf::uint32 old_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LoadRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.LoadRequest) */ {
 public:
  LoadRequest();
  virtual ~LoadRequest();

  LoadRequest(const LoadRequest& from);

  inline LoadRequest& operator=(const LoadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoadRequest(LoadRequest&& from) noexcept
    : LoadRequest() {
    *this = ::std::move(from);
  }

  inline LoadRequest& operator=(LoadRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const LoadRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoadRequest* internal_default_instance() {
    return reinterpret_cast<const LoadRequest*>(
               &_LoadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    114;

  void Swap(LoadRequest* other);
  friend void swap(LoadRequest& a, LoadRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoadRequest* New() const final {
    return CreateMaybeMessage<LoadRequest>(NULL);
  }

  LoadRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LoadRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const LoadRequest& from);
  void MergeFrom(const LoadRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LoadRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef LoadRequest_File File;
  typedef LoadRequest_TableRekey TableRekey;

  // accessors -------------------------------------------------------

  int files_size() const;
  void clear_files();
  static const int kFilesFieldNumber = 2;
  ::znbase::roachpb::LoadRequest_File* mutable_files(int index);
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::LoadRequest_File >*
      mutable_files();
  const ::znbase::roachpb::LoadRequest_File& files(int index) const;
  ::znbase::roachpb::LoadRequest_File* add_files();
  const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::LoadRequest_File >&
      files() const;

  int rekeys_size() const;
  void clear_rekeys();
  static const int kRekeysFieldNumber = 5;
  ::znbase::roachpb::LoadRequest_TableRekey* mutable_rekeys(int index);
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::LoadRequest_TableRekey >*
      mutable_rekeys();
  const ::znbase::roachpb::LoadRequest_TableRekey& rekeys(int index) const;
  ::znbase::roachpb::LoadRequest_TableRekey* add_rekeys();
  const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::LoadRequest_TableRekey >&
      rekeys() const;

  // string http_header = 13;
  void clear_http_header();
  static const int kHttpHeaderFieldNumber = 13;
  const ::std::string& http_header() const;
  void set_http_header(const ::std::string& value);
  #if LANG_CXX11
  void set_http_header(::std::string&& value);
  #endif
  void set_http_header(const char* value);
  void set_http_header(const char* value, size_t size);
  ::std::string* mutable_http_header();
  ::std::string* release_http_header();
  void set_allocated_http_header(::std::string* http_header);

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  bool has_data_span() const;
  void clear_data_span();
  static const int kDataSpanFieldNumber = 3;
  private:
  const ::znbase::roachpb::Span& _internal_data_span() const;
  public:
  const ::znbase::roachpb::Span& data_span() const;
  ::znbase::roachpb::Span* release_data_span();
  ::znbase::roachpb::Span* mutable_data_span();
  void set_allocated_data_span(::znbase::roachpb::Span* data_span);

  bool has_end_time() const;
  void clear_end_time();
  static const int kEndTimeFieldNumber = 6;
  private:
  const ::znbase::util::hlc::Timestamp& _internal_end_time() const;
  public:
  const ::znbase::util::hlc::Timestamp& end_time() const;
  ::znbase::util::hlc::Timestamp* release_end_time();
  ::znbase::util::hlc::Timestamp* mutable_end_time();
  void set_allocated_end_time(::znbase::util::hlc::Timestamp* end_time);

  // .znbase.roachpb.FileEncryptionOptions encryption = 12;
  bool has_encryption() const;
  void clear_encryption();
  static const int kEncryptionFieldNumber = 12;
  private:
  const ::znbase::roachpb::FileEncryptionOptions& _internal_encryption() const;
  public:
  const ::znbase::roachpb::FileEncryptionOptions& encryption() const;
  ::znbase::roachpb::FileEncryptionOptions* release_encryption();
  ::znbase::roachpb::FileEncryptionOptions* mutable_encryption();
  void set_allocated_encryption(::znbase::roachpb::FileEncryptionOptions* encryption);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.LoadRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::LoadRequest_File > files_;
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::LoadRequest_TableRekey > rekeys_;
  ::google::protobuf::internal::ArenaStringPtr http_header_;
  ::znbase::roachpb::RequestHeader* header_;
  ::znbase::roachpb::Span* data_span_;
  ::znbase::util::hlc::Timestamp* end_time_;
  ::znbase::roachpb::FileEncryptionOptions* encryption_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LoadResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.LoadResponse) */ {
 public:
  LoadResponse();
  virtual ~LoadResponse();

  LoadResponse(const LoadResponse& from);

  inline LoadResponse& operator=(const LoadResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoadResponse(LoadResponse&& from) noexcept
    : LoadResponse() {
    *this = ::std::move(from);
  }

  inline LoadResponse& operator=(LoadResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const LoadResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoadResponse* internal_default_instance() {
    return reinterpret_cast<const LoadResponse*>(
               &_LoadResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    115;

  void Swap(LoadResponse* other);
  friend void swap(LoadResponse& a, LoadResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoadResponse* New() const final {
    return CreateMaybeMessage<LoadResponse>(NULL);
  }

  LoadResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LoadResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const LoadResponse& from);
  void MergeFrom(const LoadResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LoadResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  bool has_loaded() const;
  void clear_loaded();
  static const int kLoadedFieldNumber = 3;
  private:
  const ::znbase::roachpb::BulkOpSummary& _internal_loaded() const;
  public:
  const ::znbase::roachpb::BulkOpSummary& loaded() const;
  ::znbase::roachpb::BulkOpSummary* release_loaded();
  ::znbase::roachpb::BulkOpSummary* mutable_loaded();
  void set_allocated_loaded(::znbase::roachpb::BulkOpSummary* loaded);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.LoadResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::ResponseHeader* header_;
  ::znbase::roachpb::BulkOpSummary* loaded_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AdminScatterRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.AdminScatterRequest) */ {
 public:
  AdminScatterRequest();
  virtual ~AdminScatterRequest();

  AdminScatterRequest(const AdminScatterRequest& from);

  inline AdminScatterRequest& operator=(const AdminScatterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AdminScatterRequest(AdminScatterRequest&& from) noexcept
    : AdminScatterRequest() {
    *this = ::std::move(from);
  }

  inline AdminScatterRequest& operator=(AdminScatterRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const AdminScatterRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AdminScatterRequest* internal_default_instance() {
    return reinterpret_cast<const AdminScatterRequest*>(
               &_AdminScatterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    116;

  void Swap(AdminScatterRequest* other);
  friend void swap(AdminScatterRequest& a, AdminScatterRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AdminScatterRequest* New() const final {
    return CreateMaybeMessage<AdminScatterRequest>(NULL);
  }

  AdminScatterRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AdminScatterRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const AdminScatterRequest& from);
  void MergeFrom(const AdminScatterRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AdminScatterRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  // bool randomize_leases = 2;
  void clear_randomize_leases();
  static const int kRandomizeLeasesFieldNumber = 2;
  bool randomize_leases() const;
  void set_randomize_leases(bool value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.AdminScatterRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::RequestHeader* header_;
  bool randomize_leases_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AdminScatterResponse_Range : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.AdminScatterResponse.Range) */ {
 public:
  AdminScatterResponse_Range();
  virtual ~AdminScatterResponse_Range();

  AdminScatterResponse_Range(const AdminScatterResponse_Range& from);

  inline AdminScatterResponse_Range& operator=(const AdminScatterResponse_Range& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AdminScatterResponse_Range(AdminScatterResponse_Range&& from) noexcept
    : AdminScatterResponse_Range() {
    *this = ::std::move(from);
  }

  inline AdminScatterResponse_Range& operator=(AdminScatterResponse_Range&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const AdminScatterResponse_Range& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AdminScatterResponse_Range* internal_default_instance() {
    return reinterpret_cast<const AdminScatterResponse_Range*>(
               &_AdminScatterResponse_Range_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    117;

  void Swap(AdminScatterResponse_Range* other);
  friend void swap(AdminScatterResponse_Range& a, AdminScatterResponse_Range& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AdminScatterResponse_Range* New() const final {
    return CreateMaybeMessage<AdminScatterResponse_Range>(NULL);
  }

  AdminScatterResponse_Range* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AdminScatterResponse_Range>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const AdminScatterResponse_Range& from);
  void MergeFrom(const AdminScatterResponse_Range& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AdminScatterResponse_Range* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_span() const;
  void clear_span();
  static const int kSpanFieldNumber = 1;
  private:
  const ::znbase::roachpb::Span& _internal_span() const;
  public:
  const ::znbase::roachpb::Span& span() const;
  ::znbase::roachpb::Span* release_span();
  ::znbase::roachpb::Span* mutable_span();
  void set_allocated_span(::znbase::roachpb::Span* span);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.AdminScatterResponse.Range)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::Span* span_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AdminScatterResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.AdminScatterResponse) */ {
 public:
  AdminScatterResponse();
  virtual ~AdminScatterResponse();

  AdminScatterResponse(const AdminScatterResponse& from);

  inline AdminScatterResponse& operator=(const AdminScatterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AdminScatterResponse(AdminScatterResponse&& from) noexcept
    : AdminScatterResponse() {
    *this = ::std::move(from);
  }

  inline AdminScatterResponse& operator=(AdminScatterResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const AdminScatterResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AdminScatterResponse* internal_default_instance() {
    return reinterpret_cast<const AdminScatterResponse*>(
               &_AdminScatterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    118;

  void Swap(AdminScatterResponse* other);
  friend void swap(AdminScatterResponse& a, AdminScatterResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AdminScatterResponse* New() const final {
    return CreateMaybeMessage<AdminScatterResponse>(NULL);
  }

  AdminScatterResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AdminScatterResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const AdminScatterResponse& from);
  void MergeFrom(const AdminScatterResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AdminScatterResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AdminScatterResponse_Range Range;

  // accessors -------------------------------------------------------

  int ranges_size() const;
  void clear_ranges();
  static const int kRangesFieldNumber = 2;
  ::znbase::roachpb::AdminScatterResponse_Range* mutable_ranges(int index);
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::AdminScatterResponse_Range >*
      mutable_ranges();
  const ::znbase::roachpb::AdminScatterResponse_Range& ranges(int index) const;
  ::znbase::roachpb::AdminScatterResponse_Range* add_ranges();
  const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::AdminScatterResponse_Range >&
      ranges() const;

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.AdminScatterResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::AdminScatterResponse_Range > ranges_;
  ::znbase::roachpb::ResponseHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddSSTableRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.AddSSTableRequest) */ {
 public:
  AddSSTableRequest();
  virtual ~AddSSTableRequest();

  AddSSTableRequest(const AddSSTableRequest& from);

  inline AddSSTableRequest& operator=(const AddSSTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddSSTableRequest(AddSSTableRequest&& from) noexcept
    : AddSSTableRequest() {
    *this = ::std::move(from);
  }

  inline AddSSTableRequest& operator=(AddSSTableRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const AddSSTableRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddSSTableRequest* internal_default_instance() {
    return reinterpret_cast<const AddSSTableRequest*>(
               &_AddSSTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    119;

  void Swap(AddSSTableRequest* other);
  friend void swap(AddSSTableRequest& a, AddSSTableRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddSSTableRequest* New() const final {
    return CreateMaybeMessage<AddSSTableRequest>(NULL);
  }

  AddSSTableRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AddSSTableRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const AddSSTableRequest& from);
  void MergeFrom(const AddSSTableRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AddSSTableRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes data = 2;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  bool has_mvcc_stats() const;
  void clear_mvcc_stats();
  static const int kMvccStatsFieldNumber = 4;
  private:
  const ::znbase::storage::engine::enginepb::MVCCStats& _internal_mvcc_stats() const;
  public:
  const ::znbase::storage::engine::enginepb::MVCCStats& mvcc_stats() const;
  ::znbase::storage::engine::enginepb::MVCCStats* release_mvcc_stats();
  ::znbase::storage::engine::enginepb::MVCCStats* mutable_mvcc_stats();
  void set_allocated_mvcc_stats(::znbase::storage::engine::enginepb::MVCCStats* mvcc_stats);

  // bool disallow_shadowing = 3;
  void clear_disallow_shadowing();
  static const int kDisallowShadowingFieldNumber = 3;
  bool disallow_shadowing() const;
  void set_disallow_shadowing(bool value);

  // bool ingest_as_writes = 5;
  void clear_ingest_as_writes();
  static const int kIngestAsWritesFieldNumber = 5;
  bool ingest_as_writes() const;
  void set_ingest_as_writes(bool value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.AddSSTableRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::znbase::roachpb::RequestHeader* header_;
  ::znbase::storage::engine::enginepb::MVCCStats* mvcc_stats_;
  bool disallow_shadowing_;
  bool ingest_as_writes_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddSSTableResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.AddSSTableResponse) */ {
 public:
  AddSSTableResponse();
  virtual ~AddSSTableResponse();

  AddSSTableResponse(const AddSSTableResponse& from);

  inline AddSSTableResponse& operator=(const AddSSTableResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddSSTableResponse(AddSSTableResponse&& from) noexcept
    : AddSSTableResponse() {
    *this = ::std::move(from);
  }

  inline AddSSTableResponse& operator=(AddSSTableResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const AddSSTableResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddSSTableResponse* internal_default_instance() {
    return reinterpret_cast<const AddSSTableResponse*>(
               &_AddSSTableResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    120;

  void Swap(AddSSTableResponse* other);
  friend void swap(AddSSTableResponse& a, AddSSTableResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddSSTableResponse* New() const final {
    return CreateMaybeMessage<AddSSTableResponse>(NULL);
  }

  AddSSTableResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AddSSTableResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const AddSSTableResponse& from);
  void MergeFrom(const AddSSTableResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AddSSTableResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.AddSSTableResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::ResponseHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RefreshRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.RefreshRequest) */ {
 public:
  RefreshRequest();
  virtual ~RefreshRequest();

  RefreshRequest(const RefreshRequest& from);

  inline RefreshRequest& operator=(const RefreshRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RefreshRequest(RefreshRequest&& from) noexcept
    : RefreshRequest() {
    *this = ::std::move(from);
  }

  inline RefreshRequest& operator=(RefreshRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const RefreshRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RefreshRequest* internal_default_instance() {
    return reinterpret_cast<const RefreshRequest*>(
               &_RefreshRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    121;

  void Swap(RefreshRequest* other);
  friend void swap(RefreshRequest& a, RefreshRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RefreshRequest* New() const final {
    return CreateMaybeMessage<RefreshRequest>(NULL);
  }

  RefreshRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RefreshRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const RefreshRequest& from);
  void MergeFrom(const RefreshRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RefreshRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  bool has_refresh_from() const;
  void clear_refresh_from();
  static const int kRefreshFromFieldNumber = 3;
  private:
  const ::znbase::util::hlc::Timestamp& _internal_refresh_from() const;
  public:
  const ::znbase::util::hlc::Timestamp& refresh_from() const;
  ::znbase::util::hlc::Timestamp* release_refresh_from();
  ::znbase::util::hlc::Timestamp* mutable_refresh_from();
  void set_allocated_refresh_from(::znbase::util::hlc::Timestamp* refresh_from);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.RefreshRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::RequestHeader* header_;
  ::znbase::util::hlc::Timestamp* refresh_from_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RefreshResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.RefreshResponse) */ {
 public:
  RefreshResponse();
  virtual ~RefreshResponse();

  RefreshResponse(const RefreshResponse& from);

  inline RefreshResponse& operator=(const RefreshResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RefreshResponse(RefreshResponse&& from) noexcept
    : RefreshResponse() {
    *this = ::std::move(from);
  }

  inline RefreshResponse& operator=(RefreshResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const RefreshResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RefreshResponse* internal_default_instance() {
    return reinterpret_cast<const RefreshResponse*>(
               &_RefreshResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    122;

  void Swap(RefreshResponse* other);
  friend void swap(RefreshResponse& a, RefreshResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RefreshResponse* New() const final {
    return CreateMaybeMessage<RefreshResponse>(NULL);
  }

  RefreshResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RefreshResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const RefreshResponse& from);
  void MergeFrom(const RefreshResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RefreshResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.RefreshResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::ResponseHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RefreshRangeRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.RefreshRangeRequest) */ {
 public:
  RefreshRangeRequest();
  virtual ~RefreshRangeRequest();

  RefreshRangeRequest(const RefreshRangeRequest& from);

  inline RefreshRangeRequest& operator=(const RefreshRangeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RefreshRangeRequest(RefreshRangeRequest&& from) noexcept
    : RefreshRangeRequest() {
    *this = ::std::move(from);
  }

  inline RefreshRangeRequest& operator=(RefreshRangeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const RefreshRangeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RefreshRangeRequest* internal_default_instance() {
    return reinterpret_cast<const RefreshRangeRequest*>(
               &_RefreshRangeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    123;

  void Swap(RefreshRangeRequest* other);
  friend void swap(RefreshRangeRequest& a, RefreshRangeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RefreshRangeRequest* New() const final {
    return CreateMaybeMessage<RefreshRangeRequest>(NULL);
  }

  RefreshRangeRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RefreshRangeRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const RefreshRangeRequest& from);
  void MergeFrom(const RefreshRangeRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RefreshRangeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  bool has_refresh_from() const;
  void clear_refresh_from();
  static const int kRefreshFromFieldNumber = 3;
  private:
  const ::znbase::util::hlc::Timestamp& _internal_refresh_from() const;
  public:
  const ::znbase::util::hlc::Timestamp& refresh_from() const;
  ::znbase::util::hlc::Timestamp* release_refresh_from();
  ::znbase::util::hlc::Timestamp* mutable_refresh_from();
  void set_allocated_refresh_from(::znbase::util::hlc::Timestamp* refresh_from);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.RefreshRangeRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::RequestHeader* header_;
  ::znbase::util::hlc::Timestamp* refresh_from_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RefreshRangeResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.RefreshRangeResponse) */ {
 public:
  RefreshRangeResponse();
  virtual ~RefreshRangeResponse();

  RefreshRangeResponse(const RefreshRangeResponse& from);

  inline RefreshRangeResponse& operator=(const RefreshRangeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RefreshRangeResponse(RefreshRangeResponse&& from) noexcept
    : RefreshRangeResponse() {
    *this = ::std::move(from);
  }

  inline RefreshRangeResponse& operator=(RefreshRangeResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const RefreshRangeResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RefreshRangeResponse* internal_default_instance() {
    return reinterpret_cast<const RefreshRangeResponse*>(
               &_RefreshRangeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    124;

  void Swap(RefreshRangeResponse* other);
  friend void swap(RefreshRangeResponse& a, RefreshRangeResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RefreshRangeResponse* New() const final {
    return CreateMaybeMessage<RefreshRangeResponse>(NULL);
  }

  RefreshRangeResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RefreshRangeResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const RefreshRangeResponse& from);
  void MergeFrom(const RefreshRangeResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RefreshRangeResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.RefreshRangeResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::ResponseHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SubsumeRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.SubsumeRequest) */ {
 public:
  SubsumeRequest();
  virtual ~SubsumeRequest();

  SubsumeRequest(const SubsumeRequest& from);

  inline SubsumeRequest& operator=(const SubsumeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SubsumeRequest(SubsumeRequest&& from) noexcept
    : SubsumeRequest() {
    *this = ::std::move(from);
  }

  inline SubsumeRequest& operator=(SubsumeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const SubsumeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubsumeRequest* internal_default_instance() {
    return reinterpret_cast<const SubsumeRequest*>(
               &_SubsumeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    125;

  void Swap(SubsumeRequest* other);
  friend void swap(SubsumeRequest& a, SubsumeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SubsumeRequest* New() const final {
    return CreateMaybeMessage<SubsumeRequest>(NULL);
  }

  SubsumeRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SubsumeRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const SubsumeRequest& from);
  void MergeFrom(const SubsumeRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SubsumeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  bool has_left_range() const;
  void clear_left_range();
  static const int kLeftRangeFieldNumber = 2;
  private:
  const ::znbase::roachpb::RangeDescriptor& _internal_left_range() const;
  public:
  const ::znbase::roachpb::RangeDescriptor& left_range() const;
  ::znbase::roachpb::RangeDescriptor* release_left_range();
  ::znbase::roachpb::RangeDescriptor* mutable_left_range();
  void set_allocated_left_range(::znbase::roachpb::RangeDescriptor* left_range);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.SubsumeRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::RequestHeader* header_;
  ::znbase::roachpb::RangeDescriptor* left_range_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SubsumeResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.SubsumeResponse) */ {
 public:
  SubsumeResponse();
  virtual ~SubsumeResponse();

  SubsumeResponse(const SubsumeResponse& from);

  inline SubsumeResponse& operator=(const SubsumeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SubsumeResponse(SubsumeResponse&& from) noexcept
    : SubsumeResponse() {
    *this = ::std::move(from);
  }

  inline SubsumeResponse& operator=(SubsumeResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const SubsumeResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubsumeResponse* internal_default_instance() {
    return reinterpret_cast<const SubsumeResponse*>(
               &_SubsumeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    126;

  void Swap(SubsumeResponse* other);
  friend void swap(SubsumeResponse& a, SubsumeResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SubsumeResponse* New() const final {
    return CreateMaybeMessage<SubsumeResponse>(NULL);
  }

  SubsumeResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SubsumeResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const SubsumeResponse& from);
  void MergeFrom(const SubsumeResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SubsumeResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  bool has_mvcc_stats() const;
  void clear_mvcc_stats();
  static const int kMvccStatsFieldNumber = 3;
  private:
  const ::znbase::storage::engine::enginepb::MVCCStats& _internal_mvcc_stats() const;
  public:
  const ::znbase::storage::engine::enginepb::MVCCStats& mvcc_stats() const;
  ::znbase::storage::engine::enginepb::MVCCStats* release_mvcc_stats();
  ::znbase::storage::engine::enginepb::MVCCStats* mutable_mvcc_stats();
  void set_allocated_mvcc_stats(::znbase::storage::engine::enginepb::MVCCStats* mvcc_stats);

  bool has_freeze_start() const;
  void clear_freeze_start();
  static const int kFreezeStartFieldNumber = 5;
  private:
  const ::znbase::util::hlc::Timestamp& _internal_freeze_start() const;
  public:
  const ::znbase::util::hlc::Timestamp& freeze_start() const;
  ::znbase::util::hlc::Timestamp* release_freeze_start();
  ::znbase::util::hlc::Timestamp* mutable_freeze_start();
  void set_allocated_freeze_start(::znbase::util::hlc::Timestamp* freeze_start);

  // uint64 lease_applied_index = 4;
  void clear_lease_applied_index();
  static const int kLeaseAppliedIndexFieldNumber = 4;
  ::google::protobuf::uint64 lease_applied_index() const;
  void set_lease_applied_index(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.SubsumeResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::ResponseHeader* header_;
  ::znbase::storage::engine::enginepb::MVCCStats* mvcc_stats_;
  ::znbase::util::hlc::Timestamp* freeze_start_;
  ::google::protobuf::uint64 lease_applied_index_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RangeStatsRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.RangeStatsRequest) */ {
 public:
  RangeStatsRequest();
  virtual ~RangeStatsRequest();

  RangeStatsRequest(const RangeStatsRequest& from);

  inline RangeStatsRequest& operator=(const RangeStatsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RangeStatsRequest(RangeStatsRequest&& from) noexcept
    : RangeStatsRequest() {
    *this = ::std::move(from);
  }

  inline RangeStatsRequest& operator=(RangeStatsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const RangeStatsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RangeStatsRequest* internal_default_instance() {
    return reinterpret_cast<const RangeStatsRequest*>(
               &_RangeStatsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    127;

  void Swap(RangeStatsRequest* other);
  friend void swap(RangeStatsRequest& a, RangeStatsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RangeStatsRequest* New() const final {
    return CreateMaybeMessage<RangeStatsRequest>(NULL);
  }

  RangeStatsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RangeStatsRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const RangeStatsRequest& from);
  void MergeFrom(const RangeStatsRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RangeStatsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.RangeStatsRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::RequestHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RangeStatsResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.RangeStatsResponse) */ {
 public:
  RangeStatsResponse();
  virtual ~RangeStatsResponse();

  RangeStatsResponse(const RangeStatsResponse& from);

  inline RangeStatsResponse& operator=(const RangeStatsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RangeStatsResponse(RangeStatsResponse&& from) noexcept
    : RangeStatsResponse() {
    *this = ::std::move(from);
  }

  inline RangeStatsResponse& operator=(RangeStatsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const RangeStatsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RangeStatsResponse* internal_default_instance() {
    return reinterpret_cast<const RangeStatsResponse*>(
               &_RangeStatsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    128;

  void Swap(RangeStatsResponse* other);
  friend void swap(RangeStatsResponse& a, RangeStatsResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RangeStatsResponse* New() const final {
    return CreateMaybeMessage<RangeStatsResponse>(NULL);
  }

  RangeStatsResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RangeStatsResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const RangeStatsResponse& from);
  void MergeFrom(const RangeStatsResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RangeStatsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  bool has_mvcc_stats() const;
  void clear_mvcc_stats();
  static const int kMvccStatsFieldNumber = 2;
  private:
  const ::znbase::storage::engine::enginepb::MVCCStats& _internal_mvcc_stats() const;
  public:
  const ::znbase::storage::engine::enginepb::MVCCStats& mvcc_stats() const;
  ::znbase::storage::engine::enginepb::MVCCStats* release_mvcc_stats();
  ::znbase::storage::engine::enginepb::MVCCStats* mutable_mvcc_stats();
  void set_allocated_mvcc_stats(::znbase::storage::engine::enginepb::MVCCStats* mvcc_stats);

  // double queries_per_second = 3;
  void clear_queries_per_second();
  static const int kQueriesPerSecondFieldNumber = 3;
  double queries_per_second() const;
  void set_queries_per_second(double value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.RangeStatsResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::ResponseHeader* header_;
  ::znbase::storage::engine::enginepb::MVCCStats* mvcc_stats_;
  double queries_per_second_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestUnion : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.RequestUnion) */ {
 public:
  RequestUnion();
  virtual ~RequestUnion();

  RequestUnion(const RequestUnion& from);

  inline RequestUnion& operator=(const RequestUnion& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestUnion(RequestUnion&& from) noexcept
    : RequestUnion() {
    *this = ::std::move(from);
  }

  inline RequestUnion& operator=(RequestUnion&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const RequestUnion& default_instance();

  enum ValueCase {
    kGet = 1,
    kPut = 2,
    kConditionalPut = 3,
    kIncrement = 4,
    kDelete = 5,
    kDeleteRange = 6,
    kClearRange = 38,
    kRevertRange = 51,
    kScan = 7,
    kEndTransaction = 9,
    kAdminSplit = 10,
    kAdminMerge = 11,
    kAdminTransferLease = 29,
    kAdminChangeReplicas = 35,
    kAdminRelocateRange = 45,
    kHeartbeatTxn = 12,
    kGc = 13,
    kPushTxn = 14,
    kRecoverTxn = 46,
    kResolveIntent = 16,
    kResolveIntentRange = 17,
    kMerge = 18,
    kTruncateLog = 19,
    kRequestLease = 20,
    kReverseScan = 21,
    kComputeChecksum = 22,
    kCheckConsistency = 24,
    kInitPut = 26,
    kTransferLease = 28,
    kLeaseInfo = 30,
    kWriteBatch = 31,
    kExport = 32,
    kImport = 34,
    kQueryTxn = 33,
    kQueryIntent = 42,
    kAdminScatter = 36,
    kAddSstable = 37,
    kRecomputeStats = 39,
    kRefresh = 40,
    kRefreshRange = 41,
    kSubsume = 43,
    kRangeStats = 44,
    kRevert = 48,
    kDump = 49,
    kDumpOnline = 50,
    kLoad = 47,
    kClearIntent = 52,
    kQueryLock = 53,
    kVecScan = 54,
    VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestUnion* internal_default_instance() {
    return reinterpret_cast<const RequestUnion*>(
               &_RequestUnion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    129;

  void Swap(RequestUnion* other);
  friend void swap(RequestUnion& a, RequestUnion& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestUnion* New() const final {
    return CreateMaybeMessage<RequestUnion>(NULL);
  }

  RequestUnion* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestUnion>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const RequestUnion& from);
  void MergeFrom(const RequestUnion& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestUnion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .znbase.roachpb.GetRequest get = 1;
  bool has_get() const;
  void clear_get();
  static const int kGetFieldNumber = 1;
  private:
  const ::znbase::roachpb::GetRequest& _internal_get() const;
  public:
  const ::znbase::roachpb::GetRequest& get() const;
  ::znbase::roachpb::GetRequest* release_get();
  ::znbase::roachpb::GetRequest* mutable_get();
  void set_allocated_get(::znbase::roachpb::GetRequest* get);

  // .znbase.roachpb.PutRequest put = 2;
  bool has_put() const;
  void clear_put();
  static const int kPutFieldNumber = 2;
  private:
  const ::znbase::roachpb::PutRequest& _internal_put() const;
  public:
  const ::znbase::roachpb::PutRequest& put() const;
  ::znbase::roachpb::PutRequest* release_put();
  ::znbase::roachpb::PutRequest* mutable_put();
  void set_allocated_put(::znbase::roachpb::PutRequest* put);

  // .znbase.roachpb.ConditionalPutRequest conditional_put = 3;
  bool has_conditional_put() const;
  void clear_conditional_put();
  static const int kConditionalPutFieldNumber = 3;
  private:
  const ::znbase::roachpb::ConditionalPutRequest& _internal_conditional_put() const;
  public:
  const ::znbase::roachpb::ConditionalPutRequest& conditional_put() const;
  ::znbase::roachpb::ConditionalPutRequest* release_conditional_put();
  ::znbase::roachpb::ConditionalPutRequest* mutable_conditional_put();
  void set_allocated_conditional_put(::znbase::roachpb::ConditionalPutRequest* conditional_put);

  // .znbase.roachpb.IncrementRequest increment = 4;
  bool has_increment() const;
  void clear_increment();
  static const int kIncrementFieldNumber = 4;
  private:
  const ::znbase::roachpb::IncrementRequest& _internal_increment() const;
  public:
  const ::znbase::roachpb::IncrementRequest& increment() const;
  ::znbase::roachpb::IncrementRequest* release_increment();
  ::znbase::roachpb::IncrementRequest* mutable_increment();
  void set_allocated_increment(::znbase::roachpb::IncrementRequest* increment);

  // .znbase.roachpb.DeleteRequest delete = 5;
  bool has_delete_() const;
  void clear_delete_();
  static const int kDeleteFieldNumber = 5;
  private:
  const ::znbase::roachpb::DeleteRequest& _internal_delete_() const;
  public:
  const ::znbase::roachpb::DeleteRequest& delete_() const;
  ::znbase::roachpb::DeleteRequest* release_delete_();
  ::znbase::roachpb::DeleteRequest* mutable_delete_();
  void set_allocated_delete_(::znbase::roachpb::DeleteRequest* delete_);

  // .znbase.roachpb.DeleteRangeRequest delete_range = 6;
  bool has_delete_range() const;
  void clear_delete_range();
  static const int kDeleteRangeFieldNumber = 6;
  private:
  const ::znbase::roachpb::DeleteRangeRequest& _internal_delete_range() const;
  public:
  const ::znbase::roachpb::DeleteRangeRequest& delete_range() const;
  ::znbase::roachpb::DeleteRangeRequest* release_delete_range();
  ::znbase::roachpb::DeleteRangeRequest* mutable_delete_range();
  void set_allocated_delete_range(::znbase::roachpb::DeleteRangeRequest* delete_range);

  // .znbase.roachpb.ClearRangeRequest clear_range = 38;
  bool has_clear_range() const;
  void clear_clear_range();
  static const int kClearRangeFieldNumber = 38;
  private:
  const ::znbase::roachpb::ClearRangeRequest& _internal_clear_range() const;
  public:
  const ::znbase::roachpb::ClearRangeRequest& clear_range() const;
  ::znbase::roachpb::ClearRangeRequest* release_clear_range();
  ::znbase::roachpb::ClearRangeRequest* mutable_clear_range();
  void set_allocated_clear_range(::znbase::roachpb::ClearRangeRequest* clear_range);

  // .znbase.roachpb.RevertRangeRequest revert_range = 51;
  bool has_revert_range() const;
  void clear_revert_range();
  static const int kRevertRangeFieldNumber = 51;
  private:
  const ::znbase::roachpb::RevertRangeRequest& _internal_revert_range() const;
  public:
  const ::znbase::roachpb::RevertRangeRequest& revert_range() const;
  ::znbase::roachpb::RevertRangeRequest* release_revert_range();
  ::znbase::roachpb::RevertRangeRequest* mutable_revert_range();
  void set_allocated_revert_range(::znbase::roachpb::RevertRangeRequest* revert_range);

  // .znbase.roachpb.ScanRequest scan = 7;
  bool has_scan() const;
  void clear_scan();
  static const int kScanFieldNumber = 7;
  private:
  const ::znbase::roachpb::ScanRequest& _internal_scan() const;
  public:
  const ::znbase::roachpb::ScanRequest& scan() const;
  ::znbase::roachpb::ScanRequest* release_scan();
  ::znbase::roachpb::ScanRequest* mutable_scan();
  void set_allocated_scan(::znbase::roachpb::ScanRequest* scan);

  // .znbase.roachpb.EndTransactionRequest end_transaction = 9;
  bool has_end_transaction() const;
  void clear_end_transaction();
  static const int kEndTransactionFieldNumber = 9;
  private:
  const ::znbase::roachpb::EndTransactionRequest& _internal_end_transaction() const;
  public:
  const ::znbase::roachpb::EndTransactionRequest& end_transaction() const;
  ::znbase::roachpb::EndTransactionRequest* release_end_transaction();
  ::znbase::roachpb::EndTransactionRequest* mutable_end_transaction();
  void set_allocated_end_transaction(::znbase::roachpb::EndTransactionRequest* end_transaction);

  // .znbase.roachpb.AdminSplitRequest admin_split = 10;
  bool has_admin_split() const;
  void clear_admin_split();
  static const int kAdminSplitFieldNumber = 10;
  private:
  const ::znbase::roachpb::AdminSplitRequest& _internal_admin_split() const;
  public:
  const ::znbase::roachpb::AdminSplitRequest& admin_split() const;
  ::znbase::roachpb::AdminSplitRequest* release_admin_split();
  ::znbase::roachpb::AdminSplitRequest* mutable_admin_split();
  void set_allocated_admin_split(::znbase::roachpb::AdminSplitRequest* admin_split);

  // .znbase.roachpb.AdminMergeRequest admin_merge = 11;
  bool has_admin_merge() const;
  void clear_admin_merge();
  static const int kAdminMergeFieldNumber = 11;
  private:
  const ::znbase::roachpb::AdminMergeRequest& _internal_admin_merge() const;
  public:
  const ::znbase::roachpb::AdminMergeRequest& admin_merge() const;
  ::znbase::roachpb::AdminMergeRequest* release_admin_merge();
  ::znbase::roachpb::AdminMergeRequest* mutable_admin_merge();
  void set_allocated_admin_merge(::znbase::roachpb::AdminMergeRequest* admin_merge);

  // .znbase.roachpb.AdminTransferLeaseRequest admin_transfer_lease = 29;
  bool has_admin_transfer_lease() const;
  void clear_admin_transfer_lease();
  static const int kAdminTransferLeaseFieldNumber = 29;
  private:
  const ::znbase::roachpb::AdminTransferLeaseRequest& _internal_admin_transfer_lease() const;
  public:
  const ::znbase::roachpb::AdminTransferLeaseRequest& admin_transfer_lease() const;
  ::znbase::roachpb::AdminTransferLeaseRequest* release_admin_transfer_lease();
  ::znbase::roachpb::AdminTransferLeaseRequest* mutable_admin_transfer_lease();
  void set_allocated_admin_transfer_lease(::znbase::roachpb::AdminTransferLeaseRequest* admin_transfer_lease);

  // .znbase.roachpb.AdminChangeReplicasRequest admin_change_replicas = 35;
  bool has_admin_change_replicas() const;
  void clear_admin_change_replicas();
  static const int kAdminChangeReplicasFieldNumber = 35;
  private:
  const ::znbase::roachpb::AdminChangeReplicasRequest& _internal_admin_change_replicas() const;
  public:
  const ::znbase::roachpb::AdminChangeReplicasRequest& admin_change_replicas() const;
  ::znbase::roachpb::AdminChangeReplicasRequest* release_admin_change_replicas();
  ::znbase::roachpb::AdminChangeReplicasRequest* mutable_admin_change_replicas();
  void set_allocated_admin_change_replicas(::znbase::roachpb::AdminChangeReplicasRequest* admin_change_replicas);

  // .znbase.roachpb.AdminRelocateRangeRequest admin_relocate_range = 45;
  bool has_admin_relocate_range() const;
  void clear_admin_relocate_range();
  static const int kAdminRelocateRangeFieldNumber = 45;
  private:
  const ::znbase::roachpb::AdminRelocateRangeRequest& _internal_admin_relocate_range() const;
  public:
  const ::znbase::roachpb::AdminRelocateRangeRequest& admin_relocate_range() const;
  ::znbase::roachpb::AdminRelocateRangeRequest* release_admin_relocate_range();
  ::znbase::roachpb::AdminRelocateRangeRequest* mutable_admin_relocate_range();
  void set_allocated_admin_relocate_range(::znbase::roachpb::AdminRelocateRangeRequest* admin_relocate_range);

  // .znbase.roachpb.HeartbeatTxnRequest heartbeat_txn = 12;
  bool has_heartbeat_txn() const;
  void clear_heartbeat_txn();
  static const int kHeartbeatTxnFieldNumber = 12;
  private:
  const ::znbase::roachpb::HeartbeatTxnRequest& _internal_heartbeat_txn() const;
  public:
  const ::znbase::roachpb::HeartbeatTxnRequest& heartbeat_txn() const;
  ::znbase::roachpb::HeartbeatTxnRequest* release_heartbeat_txn();
  ::znbase::roachpb::HeartbeatTxnRequest* mutable_heartbeat_txn();
  void set_allocated_heartbeat_txn(::znbase::roachpb::HeartbeatTxnRequest* heartbeat_txn);

  // .znbase.roachpb.GCRequest gc = 13;
  bool has_gc() const;
  void clear_gc();
  static const int kGcFieldNumber = 13;
  private:
  const ::znbase::roachpb::GCRequest& _internal_gc() const;
  public:
  const ::znbase::roachpb::GCRequest& gc() const;
  ::znbase::roachpb::GCRequest* release_gc();
  ::znbase::roachpb::GCRequest* mutable_gc();
  void set_allocated_gc(::znbase::roachpb::GCRequest* gc);

  // .znbase.roachpb.PushTxnRequest push_txn = 14;
  bool has_push_txn() const;
  void clear_push_txn();
  static const int kPushTxnFieldNumber = 14;
  private:
  const ::znbase::roachpb::PushTxnRequest& _internal_push_txn() const;
  public:
  const ::znbase::roachpb::PushTxnRequest& push_txn() const;
  ::znbase::roachpb::PushTxnRequest* release_push_txn();
  ::znbase::roachpb::PushTxnRequest* mutable_push_txn();
  void set_allocated_push_txn(::znbase::roachpb::PushTxnRequest* push_txn);

  // .znbase.roachpb.RecoverTxnRequest recover_txn = 46;
  bool has_recover_txn() const;
  void clear_recover_txn();
  static const int kRecoverTxnFieldNumber = 46;
  private:
  const ::znbase::roachpb::RecoverTxnRequest& _internal_recover_txn() const;
  public:
  const ::znbase::roachpb::RecoverTxnRequest& recover_txn() const;
  ::znbase::roachpb::RecoverTxnRequest* release_recover_txn();
  ::znbase::roachpb::RecoverTxnRequest* mutable_recover_txn();
  void set_allocated_recover_txn(::znbase::roachpb::RecoverTxnRequest* recover_txn);

  // .znbase.roachpb.ResolveIntentRequest resolve_intent = 16;
  bool has_resolve_intent() const;
  void clear_resolve_intent();
  static const int kResolveIntentFieldNumber = 16;
  private:
  const ::znbase::roachpb::ResolveIntentRequest& _internal_resolve_intent() const;
  public:
  const ::znbase::roachpb::ResolveIntentRequest& resolve_intent() const;
  ::znbase::roachpb::ResolveIntentRequest* release_resolve_intent();
  ::znbase::roachpb::ResolveIntentRequest* mutable_resolve_intent();
  void set_allocated_resolve_intent(::znbase::roachpb::ResolveIntentRequest* resolve_intent);

  // .znbase.roachpb.ResolveIntentRangeRequest resolve_intent_range = 17;
  bool has_resolve_intent_range() const;
  void clear_resolve_intent_range();
  static const int kResolveIntentRangeFieldNumber = 17;
  private:
  const ::znbase::roachpb::ResolveIntentRangeRequest& _internal_resolve_intent_range() const;
  public:
  const ::znbase::roachpb::ResolveIntentRangeRequest& resolve_intent_range() const;
  ::znbase::roachpb::ResolveIntentRangeRequest* release_resolve_intent_range();
  ::znbase::roachpb::ResolveIntentRangeRequest* mutable_resolve_intent_range();
  void set_allocated_resolve_intent_range(::znbase::roachpb::ResolveIntentRangeRequest* resolve_intent_range);

  // .znbase.roachpb.MergeRequest merge = 18;
  bool has_merge() const;
  void clear_merge();
  static const int kMergeFieldNumber = 18;
  private:
  const ::znbase::roachpb::MergeRequest& _internal_merge() const;
  public:
  const ::znbase::roachpb::MergeRequest& merge() const;
  ::znbase::roachpb::MergeRequest* release_merge();
  ::znbase::roachpb::MergeRequest* mutable_merge();
  void set_allocated_merge(::znbase::roachpb::MergeRequest* merge);

  // .znbase.roachpb.TruncateLogRequest truncate_log = 19;
  bool has_truncate_log() const;
  void clear_truncate_log();
  static const int kTruncateLogFieldNumber = 19;
  private:
  const ::znbase::roachpb::TruncateLogRequest& _internal_truncate_log() const;
  public:
  const ::znbase::roachpb::TruncateLogRequest& truncate_log() const;
  ::znbase::roachpb::TruncateLogRequest* release_truncate_log();
  ::znbase::roachpb::TruncateLogRequest* mutable_truncate_log();
  void set_allocated_truncate_log(::znbase::roachpb::TruncateLogRequest* truncate_log);

  // .znbase.roachpb.RequestLeaseRequest request_lease = 20;
  bool has_request_lease() const;
  void clear_request_lease();
  static const int kRequestLeaseFieldNumber = 20;
  private:
  const ::znbase::roachpb::RequestLeaseRequest& _internal_request_lease() const;
  public:
  const ::znbase::roachpb::RequestLeaseRequest& request_lease() const;
  ::znbase::roachpb::RequestLeaseRequest* release_request_lease();
  ::znbase::roachpb::RequestLeaseRequest* mutable_request_lease();
  void set_allocated_request_lease(::znbase::roachpb::RequestLeaseRequest* request_lease);

  // .znbase.roachpb.ReverseScanRequest reverse_scan = 21;
  bool has_reverse_scan() const;
  void clear_reverse_scan();
  static const int kReverseScanFieldNumber = 21;
  private:
  const ::znbase::roachpb::ReverseScanRequest& _internal_reverse_scan() const;
  public:
  const ::znbase::roachpb::ReverseScanRequest& reverse_scan() const;
  ::znbase::roachpb::ReverseScanRequest* release_reverse_scan();
  ::znbase::roachpb::ReverseScanRequest* mutable_reverse_scan();
  void set_allocated_reverse_scan(::znbase::roachpb::ReverseScanRequest* reverse_scan);

  // .znbase.roachpb.ComputeChecksumRequest compute_checksum = 22;
  bool has_compute_checksum() const;
  void clear_compute_checksum();
  static const int kComputeChecksumFieldNumber = 22;
  private:
  const ::znbase::roachpb::ComputeChecksumRequest& _internal_compute_checksum() const;
  public:
  const ::znbase::roachpb::ComputeChecksumRequest& compute_checksum() const;
  ::znbase::roachpb::ComputeChecksumRequest* release_compute_checksum();
  ::znbase::roachpb::ComputeChecksumRequest* mutable_compute_checksum();
  void set_allocated_compute_checksum(::znbase::roachpb::ComputeChecksumRequest* compute_checksum);

  // .znbase.roachpb.CheckConsistencyRequest check_consistency = 24;
  bool has_check_consistency() const;
  void clear_check_consistency();
  static const int kCheckConsistencyFieldNumber = 24;
  private:
  const ::znbase::roachpb::CheckConsistencyRequest& _internal_check_consistency() const;
  public:
  const ::znbase::roachpb::CheckConsistencyRequest& check_consistency() const;
  ::znbase::roachpb::CheckConsistencyRequest* release_check_consistency();
  ::znbase::roachpb::CheckConsistencyRequest* mutable_check_consistency();
  void set_allocated_check_consistency(::znbase::roachpb::CheckConsistencyRequest* check_consistency);

  // .znbase.roachpb.InitPutRequest init_put = 26;
  bool has_init_put() const;
  void clear_init_put();
  static const int kInitPutFieldNumber = 26;
  private:
  const ::znbase::roachpb::InitPutRequest& _internal_init_put() const;
  public:
  const ::znbase::roachpb::InitPutRequest& init_put() const;
  ::znbase::roachpb::InitPutRequest* release_init_put();
  ::znbase::roachpb::InitPutRequest* mutable_init_put();
  void set_allocated_init_put(::znbase::roachpb::InitPutRequest* init_put);

  // .znbase.roachpb.TransferLeaseRequest transfer_lease = 28;
  bool has_transfer_lease() const;
  void clear_transfer_lease();
  static const int kTransferLeaseFieldNumber = 28;
  private:
  const ::znbase::roachpb::TransferLeaseRequest& _internal_transfer_lease() const;
  public:
  const ::znbase::roachpb::TransferLeaseRequest& transfer_lease() const;
  ::znbase::roachpb::TransferLeaseRequest* release_transfer_lease();
  ::znbase::roachpb::TransferLeaseRequest* mutable_transfer_lease();
  void set_allocated_transfer_lease(::znbase::roachpb::TransferLeaseRequest* transfer_lease);

  // .znbase.roachpb.LeaseInfoRequest lease_info = 30;
  bool has_lease_info() const;
  void clear_lease_info();
  static const int kLeaseInfoFieldNumber = 30;
  private:
  const ::znbase::roachpb::LeaseInfoRequest& _internal_lease_info() const;
  public:
  const ::znbase::roachpb::LeaseInfoRequest& lease_info() const;
  ::znbase::roachpb::LeaseInfoRequest* release_lease_info();
  ::znbase::roachpb::LeaseInfoRequest* mutable_lease_info();
  void set_allocated_lease_info(::znbase::roachpb::LeaseInfoRequest* lease_info);

  // .znbase.roachpb.WriteBatchRequest write_batch = 31;
  bool has_write_batch() const;
  void clear_write_batch();
  static const int kWriteBatchFieldNumber = 31;
  private:
  const ::znbase::roachpb::WriteBatchRequest& _internal_write_batch() const;
  public:
  const ::znbase::roachpb::WriteBatchRequest& write_batch() const;
  ::znbase::roachpb::WriteBatchRequest* release_write_batch();
  ::znbase::roachpb::WriteBatchRequest* mutable_write_batch();
  void set_allocated_write_batch(::znbase::roachpb::WriteBatchRequest* write_batch);

  // .znbase.roachpb.ExportRequest export = 32;
  bool has_export_() const;
  void clear_export_();
  static const int kExportFieldNumber = 32;
  private:
  const ::znbase::roachpb::ExportRequest& _internal_export_() const;
  public:
  const ::znbase::roachpb::ExportRequest& export_() const;
  ::znbase::roachpb::ExportRequest* release_export_();
  ::znbase::roachpb::ExportRequest* mutable_export_();
  void set_allocated_export_(::znbase::roachpb::ExportRequest* export_);

  // .znbase.roachpb.ImportRequest import = 34;
  bool has_import() const;
  void clear_import();
  static const int kImportFieldNumber = 34;
  private:
  const ::znbase::roachpb::ImportRequest& _internal_import() const;
  public:
  const ::znbase::roachpb::ImportRequest& import() const;
  ::znbase::roachpb::ImportRequest* release_import();
  ::znbase::roachpb::ImportRequest* mutable_import();
  void set_allocated_import(::znbase::roachpb::ImportRequest* import);

  // .znbase.roachpb.QueryTxnRequest query_txn = 33;
  bool has_query_txn() const;
  void clear_query_txn();
  static const int kQueryTxnFieldNumber = 33;
  private:
  const ::znbase::roachpb::QueryTxnRequest& _internal_query_txn() const;
  public:
  const ::znbase::roachpb::QueryTxnRequest& query_txn() const;
  ::znbase::roachpb::QueryTxnRequest* release_query_txn();
  ::znbase::roachpb::QueryTxnRequest* mutable_query_txn();
  void set_allocated_query_txn(::znbase::roachpb::QueryTxnRequest* query_txn);

  // .znbase.roachpb.QueryIntentRequest query_intent = 42;
  bool has_query_intent() const;
  void clear_query_intent();
  static const int kQueryIntentFieldNumber = 42;
  private:
  const ::znbase::roachpb::QueryIntentRequest& _internal_query_intent() const;
  public:
  const ::znbase::roachpb::QueryIntentRequest& query_intent() const;
  ::znbase::roachpb::QueryIntentRequest* release_query_intent();
  ::znbase::roachpb::QueryIntentRequest* mutable_query_intent();
  void set_allocated_query_intent(::znbase::roachpb::QueryIntentRequest* query_intent);

  // .znbase.roachpb.AdminScatterRequest admin_scatter = 36;
  bool has_admin_scatter() const;
  void clear_admin_scatter();
  static const int kAdminScatterFieldNumber = 36;
  private:
  const ::znbase::roachpb::AdminScatterRequest& _internal_admin_scatter() const;
  public:
  const ::znbase::roachpb::AdminScatterRequest& admin_scatter() const;
  ::znbase::roachpb::AdminScatterRequest* release_admin_scatter();
  ::znbase::roachpb::AdminScatterRequest* mutable_admin_scatter();
  void set_allocated_admin_scatter(::znbase::roachpb::AdminScatterRequest* admin_scatter);

  // .znbase.roachpb.AddSSTableRequest add_sstable = 37;
  bool has_add_sstable() const;
  void clear_add_sstable();
  static const int kAddSstableFieldNumber = 37;
  private:
  const ::znbase::roachpb::AddSSTableRequest& _internal_add_sstable() const;
  public:
  const ::znbase::roachpb::AddSSTableRequest& add_sstable() const;
  ::znbase::roachpb::AddSSTableRequest* release_add_sstable();
  ::znbase::roachpb::AddSSTableRequest* mutable_add_sstable();
  void set_allocated_add_sstable(::znbase::roachpb::AddSSTableRequest* add_sstable);

  // .znbase.roachpb.RecomputeStatsRequest recompute_stats = 39;
  bool has_recompute_stats() const;
  void clear_recompute_stats();
  static const int kRecomputeStatsFieldNumber = 39;
  private:
  const ::znbase::roachpb::RecomputeStatsRequest& _internal_recompute_stats() const;
  public:
  const ::znbase::roachpb::RecomputeStatsRequest& recompute_stats() const;
  ::znbase::roachpb::RecomputeStatsRequest* release_recompute_stats();
  ::znbase::roachpb::RecomputeStatsRequest* mutable_recompute_stats();
  void set_allocated_recompute_stats(::znbase::roachpb::RecomputeStatsRequest* recompute_stats);

  // .znbase.roachpb.RefreshRequest refresh = 40;
  bool has_refresh() const;
  void clear_refresh();
  static const int kRefreshFieldNumber = 40;
  private:
  const ::znbase::roachpb::RefreshRequest& _internal_refresh() const;
  public:
  const ::znbase::roachpb::RefreshRequest& refresh() const;
  ::znbase::roachpb::RefreshRequest* release_refresh();
  ::znbase::roachpb::RefreshRequest* mutable_refresh();
  void set_allocated_refresh(::znbase::roachpb::RefreshRequest* refresh);

  // .znbase.roachpb.RefreshRangeRequest refresh_range = 41;
  bool has_refresh_range() const;
  void clear_refresh_range();
  static const int kRefreshRangeFieldNumber = 41;
  private:
  const ::znbase::roachpb::RefreshRangeRequest& _internal_refresh_range() const;
  public:
  const ::znbase::roachpb::RefreshRangeRequest& refresh_range() const;
  ::znbase::roachpb::RefreshRangeRequest* release_refresh_range();
  ::znbase::roachpb::RefreshRangeRequest* mutable_refresh_range();
  void set_allocated_refresh_range(::znbase::roachpb::RefreshRangeRequest* refresh_range);

  // .znbase.roachpb.SubsumeRequest subsume = 43;
  bool has_subsume() const;
  void clear_subsume();
  static const int kSubsumeFieldNumber = 43;
  private:
  const ::znbase::roachpb::SubsumeRequest& _internal_subsume() const;
  public:
  const ::znbase::roachpb::SubsumeRequest& subsume() const;
  ::znbase::roachpb::SubsumeRequest* release_subsume();
  ::znbase::roachpb::SubsumeRequest* mutable_subsume();
  void set_allocated_subsume(::znbase::roachpb::SubsumeRequest* subsume);

  // .znbase.roachpb.RangeStatsRequest range_stats = 44;
  bool has_range_stats() const;
  void clear_range_stats();
  static const int kRangeStatsFieldNumber = 44;
  private:
  const ::znbase::roachpb::RangeStatsRequest& _internal_range_stats() const;
  public:
  const ::znbase::roachpb::RangeStatsRequest& range_stats() const;
  ::znbase::roachpb::RangeStatsRequest* release_range_stats();
  ::znbase::roachpb::RangeStatsRequest* mutable_range_stats();
  void set_allocated_range_stats(::znbase::roachpb::RangeStatsRequest* range_stats);

  // .znbase.roachpb.RevertRequest revert = 48;
  bool has_revert() const;
  void clear_revert();
  static const int kRevertFieldNumber = 48;
  private:
  const ::znbase::roachpb::RevertRequest& _internal_revert() const;
  public:
  const ::znbase::roachpb::RevertRequest& revert() const;
  ::znbase::roachpb::RevertRequest* release_revert();
  ::znbase::roachpb::RevertRequest* mutable_revert();
  void set_allocated_revert(::znbase::roachpb::RevertRequest* revert);

  // .znbase.roachpb.DumpRequest dump = 49;
  bool has_dump() const;
  void clear_dump();
  static const int kDumpFieldNumber = 49;
  private:
  const ::znbase::roachpb::DumpRequest& _internal_dump() const;
  public:
  const ::znbase::roachpb::DumpRequest& dump() const;
  ::znbase::roachpb::DumpRequest* release_dump();
  ::znbase::roachpb::DumpRequest* mutable_dump();
  void set_allocated_dump(::znbase::roachpb::DumpRequest* dump);

  // .znbase.roachpb.DumpOnlineRequest dump_online = 50;
  bool has_dump_online() const;
  void clear_dump_online();
  static const int kDumpOnlineFieldNumber = 50;
  private:
  const ::znbase::roachpb::DumpOnlineRequest& _internal_dump_online() const;
  public:
  const ::znbase::roachpb::DumpOnlineRequest& dump_online() const;
  ::znbase::roachpb::DumpOnlineRequest* release_dump_online();
  ::znbase::roachpb::DumpOnlineRequest* mutable_dump_online();
  void set_allocated_dump_online(::znbase::roachpb::DumpOnlineRequest* dump_online);

  // .znbase.roachpb.LoadRequest load = 47;
  bool has_load() const;
  void clear_load();
  static const int kLoadFieldNumber = 47;
  private:
  const ::znbase::roachpb::LoadRequest& _internal_load() const;
  public:
  const ::znbase::roachpb::LoadRequest& load() const;
  ::znbase::roachpb::LoadRequest* release_load();
  ::znbase::roachpb::LoadRequest* mutable_load();
  void set_allocated_load(::znbase::roachpb::LoadRequest* load);

  // .znbase.roachpb.ClearIntentRequest clear_intent = 52;
  bool has_clear_intent() const;
  void clear_clear_intent();
  static const int kClearIntentFieldNumber = 52;
  private:
  const ::znbase::roachpb::ClearIntentRequest& _internal_clear_intent() const;
  public:
  const ::znbase::roachpb::ClearIntentRequest& clear_intent() const;
  ::znbase::roachpb::ClearIntentRequest* release_clear_intent();
  ::znbase::roachpb::ClearIntentRequest* mutable_clear_intent();
  void set_allocated_clear_intent(::znbase::roachpb::ClearIntentRequest* clear_intent);

  // .znbase.roachpb.QueryLockRequest query_lock = 53;
  bool has_query_lock() const;
  void clear_query_lock();
  static const int kQueryLockFieldNumber = 53;
  private:
  const ::znbase::roachpb::QueryLockRequest& _internal_query_lock() const;
  public:
  const ::znbase::roachpb::QueryLockRequest& query_lock() const;
  ::znbase::roachpb::QueryLockRequest* release_query_lock();
  ::znbase::roachpb::QueryLockRequest* mutable_query_lock();
  void set_allocated_query_lock(::znbase::roachpb::QueryLockRequest* query_lock);

  // .znbase.roachpb.VecScanRequest vec_scan = 54;
  bool has_vec_scan() const;
  void clear_vec_scan();
  static const int kVecScanFieldNumber = 54;
  private:
  const ::znbase::roachpb::VecScanRequest& _internal_vec_scan() const;
  public:
  const ::znbase::roachpb::VecScanRequest& vec_scan() const;
  ::znbase::roachpb::VecScanRequest* release_vec_scan();
  ::znbase::roachpb::VecScanRequest* mutable_vec_scan();
  void set_allocated_vec_scan(::znbase::roachpb::VecScanRequest* vec_scan);

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:znbase.roachpb.RequestUnion)
 private:
  void set_has_get();
  void set_has_put();
  void set_has_conditional_put();
  void set_has_increment();
  void set_has_delete_();
  void set_has_delete_range();
  void set_has_clear_range();
  void set_has_revert_range();
  void set_has_scan();
  void set_has_end_transaction();
  void set_has_admin_split();
  void set_has_admin_merge();
  void set_has_admin_transfer_lease();
  void set_has_admin_change_replicas();
  void set_has_admin_relocate_range();
  void set_has_heartbeat_txn();
  void set_has_gc();
  void set_has_push_txn();
  void set_has_recover_txn();
  void set_has_resolve_intent();
  void set_has_resolve_intent_range();
  void set_has_merge();
  void set_has_truncate_log();
  void set_has_request_lease();
  void set_has_reverse_scan();
  void set_has_compute_checksum();
  void set_has_check_consistency();
  void set_has_init_put();
  void set_has_transfer_lease();
  void set_has_lease_info();
  void set_has_write_batch();
  void set_has_export_();
  void set_has_import();
  void set_has_query_txn();
  void set_has_query_intent();
  void set_has_admin_scatter();
  void set_has_add_sstable();
  void set_has_recompute_stats();
  void set_has_refresh();
  void set_has_refresh_range();
  void set_has_subsume();
  void set_has_range_stats();
  void set_has_revert();
  void set_has_dump();
  void set_has_dump_online();
  void set_has_load();
  void set_has_clear_intent();
  void set_has_query_lock();
  void set_has_vec_scan();

  inline bool has_value() const;
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  union ValueUnion {
    ValueUnion() {}
    ::znbase::roachpb::GetRequest* get_;
    ::znbase::roachpb::PutRequest* put_;
    ::znbase::roachpb::ConditionalPutRequest* conditional_put_;
    ::znbase::roachpb::IncrementRequest* increment_;
    ::znbase::roachpb::DeleteRequest* delete__;
    ::znbase::roachpb::DeleteRangeRequest* delete_range_;
    ::znbase::roachpb::ClearRangeRequest* clear_range_;
    ::znbase::roachpb::RevertRangeRequest* revert_range_;
    ::znbase::roachpb::ScanRequest* scan_;
    ::znbase::roachpb::EndTransactionRequest* end_transaction_;
    ::znbase::roachpb::AdminSplitRequest* admin_split_;
    ::znbase::roachpb::AdminMergeRequest* admin_merge_;
    ::znbase::roachpb::AdminTransferLeaseRequest* admin_transfer_lease_;
    ::znbase::roachpb::AdminChangeReplicasRequest* admin_change_replicas_;
    ::znbase::roachpb::AdminRelocateRangeRequest* admin_relocate_range_;
    ::znbase::roachpb::HeartbeatTxnRequest* heartbeat_txn_;
    ::znbase::roachpb::GCRequest* gc_;
    ::znbase::roachpb::PushTxnRequest* push_txn_;
    ::znbase::roachpb::RecoverTxnRequest* recover_txn_;
    ::znbase::roachpb::ResolveIntentRequest* resolve_intent_;
    ::znbase::roachpb::ResolveIntentRangeRequest* resolve_intent_range_;
    ::znbase::roachpb::MergeRequest* merge_;
    ::znbase::roachpb::TruncateLogRequest* truncate_log_;
    ::znbase::roachpb::RequestLeaseRequest* request_lease_;
    ::znbase::roachpb::ReverseScanRequest* reverse_scan_;
    ::znbase::roachpb::ComputeChecksumRequest* compute_checksum_;
    ::znbase::roachpb::CheckConsistencyRequest* check_consistency_;
    ::znbase::roachpb::InitPutRequest* init_put_;
    ::znbase::roachpb::TransferLeaseRequest* transfer_lease_;
    ::znbase::roachpb::LeaseInfoRequest* lease_info_;
    ::znbase::roachpb::WriteBatchRequest* write_batch_;
    ::znbase::roachpb::ExportRequest* export__;
    ::znbase::roachpb::ImportRequest* import_;
    ::znbase::roachpb::QueryTxnRequest* query_txn_;
    ::znbase::roachpb::QueryIntentRequest* query_intent_;
    ::znbase::roachpb::AdminScatterRequest* admin_scatter_;
    ::znbase::roachpb::AddSSTableRequest* add_sstable_;
    ::znbase::roachpb::RecomputeStatsRequest* recompute_stats_;
    ::znbase::roachpb::RefreshRequest* refresh_;
    ::znbase::roachpb::RefreshRangeRequest* refresh_range_;
    ::znbase::roachpb::SubsumeRequest* subsume_;
    ::znbase::roachpb::RangeStatsRequest* range_stats_;
    ::znbase::roachpb::RevertRequest* revert_;
    ::znbase::roachpb::DumpRequest* dump_;
    ::znbase::roachpb::DumpOnlineRequest* dump_online_;
    ::znbase::roachpb::LoadRequest* load_;
    ::znbase::roachpb::ClearIntentRequest* clear_intent_;
    ::znbase::roachpb::QueryLockRequest* query_lock_;
    ::znbase::roachpb::VecScanRequest* vec_scan_;
  } value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseUnion : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.ResponseUnion) */ {
 public:
  ResponseUnion();
  virtual ~ResponseUnion();

  ResponseUnion(const ResponseUnion& from);

  inline ResponseUnion& operator=(const ResponseUnion& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseUnion(ResponseUnion&& from) noexcept
    : ResponseUnion() {
    *this = ::std::move(from);
  }

  inline ResponseUnion& operator=(ResponseUnion&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ResponseUnion& default_instance();

  enum ValueCase {
    kGet = 1,
    kPut = 2,
    kConditionalPut = 3,
    kIncrement = 4,
    kDelete = 5,
    kDeleteRange = 6,
    kClearRange = 38,
    kRevertRange = 51,
    kScan = 7,
    kEndTransaction = 9,
    kAdminSplit = 10,
    kAdminMerge = 11,
    kAdminTransferLease = 29,
    kAdminChangeReplicas = 35,
    kAdminRelocateRange = 45,
    kHeartbeatTxn = 12,
    kGc = 13,
    kPushTxn = 14,
    kRecoverTxn = 46,
    kResolveIntent = 16,
    kResolveIntentRange = 17,
    kMerge = 18,
    kTruncateLog = 19,
    kRequestLease = 20,
    kReverseScan = 21,
    kComputeChecksum = 22,
    kCheckConsistency = 24,
    kInitPut = 26,
    kLeaseInfo = 30,
    kWriteBatch = 31,
    kExport = 32,
    kImport = 34,
    kQueryTxn = 33,
    kQueryIntent = 42,
    kAdminScatter = 36,
    kAddSstable = 37,
    kRecomputeStats = 39,
    kRefresh = 40,
    kRefreshRange = 41,
    kSubsume = 43,
    kRangeStats = 44,
    kRevert = 48,
    kDump = 49,
    kLoad = 47,
    kDumpOnline = 50,
    kClearIntent = 52,
    kQueryLock = 53,
    kVecScan = 54,
    VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseUnion* internal_default_instance() {
    return reinterpret_cast<const ResponseUnion*>(
               &_ResponseUnion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    130;

  void Swap(ResponseUnion* other);
  friend void swap(ResponseUnion& a, ResponseUnion& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseUnion* New() const final {
    return CreateMaybeMessage<ResponseUnion>(NULL);
  }

  ResponseUnion* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseUnion>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ResponseUnion& from);
  void MergeFrom(const ResponseUnion& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResponseUnion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .znbase.roachpb.GetResponse get = 1;
  bool has_get() const;
  void clear_get();
  static const int kGetFieldNumber = 1;
  private:
  const ::znbase::roachpb::GetResponse& _internal_get() const;
  public:
  const ::znbase::roachpb::GetResponse& get() const;
  ::znbase::roachpb::GetResponse* release_get();
  ::znbase::roachpb::GetResponse* mutable_get();
  void set_allocated_get(::znbase::roachpb::GetResponse* get);

  // .znbase.roachpb.PutResponse put = 2;
  bool has_put() const;
  void clear_put();
  static const int kPutFieldNumber = 2;
  private:
  const ::znbase::roachpb::PutResponse& _internal_put() const;
  public:
  const ::znbase::roachpb::PutResponse& put() const;
  ::znbase::roachpb::PutResponse* release_put();
  ::znbase::roachpb::PutResponse* mutable_put();
  void set_allocated_put(::znbase::roachpb::PutResponse* put);

  // .znbase.roachpb.ConditionalPutResponse conditional_put = 3;
  bool has_conditional_put() const;
  void clear_conditional_put();
  static const int kConditionalPutFieldNumber = 3;
  private:
  const ::znbase::roachpb::ConditionalPutResponse& _internal_conditional_put() const;
  public:
  const ::znbase::roachpb::ConditionalPutResponse& conditional_put() const;
  ::znbase::roachpb::ConditionalPutResponse* release_conditional_put();
  ::znbase::roachpb::ConditionalPutResponse* mutable_conditional_put();
  void set_allocated_conditional_put(::znbase::roachpb::ConditionalPutResponse* conditional_put);

  // .znbase.roachpb.IncrementResponse increment = 4;
  bool has_increment() const;
  void clear_increment();
  static const int kIncrementFieldNumber = 4;
  private:
  const ::znbase::roachpb::IncrementResponse& _internal_increment() const;
  public:
  const ::znbase::roachpb::IncrementResponse& increment() const;
  ::znbase::roachpb::IncrementResponse* release_increment();
  ::znbase::roachpb::IncrementResponse* mutable_increment();
  void set_allocated_increment(::znbase::roachpb::IncrementResponse* increment);

  // .znbase.roachpb.DeleteResponse delete = 5;
  bool has_delete_() const;
  void clear_delete_();
  static const int kDeleteFieldNumber = 5;
  private:
  const ::znbase::roachpb::DeleteResponse& _internal_delete_() const;
  public:
  const ::znbase::roachpb::DeleteResponse& delete_() const;
  ::znbase::roachpb::DeleteResponse* release_delete_();
  ::znbase::roachpb::DeleteResponse* mutable_delete_();
  void set_allocated_delete_(::znbase::roachpb::DeleteResponse* delete_);

  // .znbase.roachpb.DeleteRangeResponse delete_range = 6;
  bool has_delete_range() const;
  void clear_delete_range();
  static const int kDeleteRangeFieldNumber = 6;
  private:
  const ::znbase::roachpb::DeleteRangeResponse& _internal_delete_range() const;
  public:
  const ::znbase::roachpb::DeleteRangeResponse& delete_range() const;
  ::znbase::roachpb::DeleteRangeResponse* release_delete_range();
  ::znbase::roachpb::DeleteRangeResponse* mutable_delete_range();
  void set_allocated_delete_range(::znbase::roachpb::DeleteRangeResponse* delete_range);

  // .znbase.roachpb.ClearRangeResponse clear_range = 38;
  bool has_clear_range() const;
  void clear_clear_range();
  static const int kClearRangeFieldNumber = 38;
  private:
  const ::znbase::roachpb::ClearRangeResponse& _internal_clear_range() const;
  public:
  const ::znbase::roachpb::ClearRangeResponse& clear_range() const;
  ::znbase::roachpb::ClearRangeResponse* release_clear_range();
  ::znbase::roachpb::ClearRangeResponse* mutable_clear_range();
  void set_allocated_clear_range(::znbase::roachpb::ClearRangeResponse* clear_range);

  // .znbase.roachpb.RevertRangeResponse revert_range = 51;
  bool has_revert_range() const;
  void clear_revert_range();
  static const int kRevertRangeFieldNumber = 51;
  private:
  const ::znbase::roachpb::RevertRangeResponse& _internal_revert_range() const;
  public:
  const ::znbase::roachpb::RevertRangeResponse& revert_range() const;
  ::znbase::roachpb::RevertRangeResponse* release_revert_range();
  ::znbase::roachpb::RevertRangeResponse* mutable_revert_range();
  void set_allocated_revert_range(::znbase::roachpb::RevertRangeResponse* revert_range);

  // .znbase.roachpb.ScanResponse scan = 7;
  bool has_scan() const;
  void clear_scan();
  static const int kScanFieldNumber = 7;
  private:
  const ::znbase::roachpb::ScanResponse& _internal_scan() const;
  public:
  const ::znbase::roachpb::ScanResponse& scan() const;
  ::znbase::roachpb::ScanResponse* release_scan();
  ::znbase::roachpb::ScanResponse* mutable_scan();
  void set_allocated_scan(::znbase::roachpb::ScanResponse* scan);

  // .znbase.roachpb.EndTransactionResponse end_transaction = 9;
  bool has_end_transaction() const;
  void clear_end_transaction();
  static const int kEndTransactionFieldNumber = 9;
  private:
  const ::znbase::roachpb::EndTransactionResponse& _internal_end_transaction() const;
  public:
  const ::znbase::roachpb::EndTransactionResponse& end_transaction() const;
  ::znbase::roachpb::EndTransactionResponse* release_end_transaction();
  ::znbase::roachpb::EndTransactionResponse* mutable_end_transaction();
  void set_allocated_end_transaction(::znbase::roachpb::EndTransactionResponse* end_transaction);

  // .znbase.roachpb.AdminSplitResponse admin_split = 10;
  bool has_admin_split() const;
  void clear_admin_split();
  static const int kAdminSplitFieldNumber = 10;
  private:
  const ::znbase::roachpb::AdminSplitResponse& _internal_admin_split() const;
  public:
  const ::znbase::roachpb::AdminSplitResponse& admin_split() const;
  ::znbase::roachpb::AdminSplitResponse* release_admin_split();
  ::znbase::roachpb::AdminSplitResponse* mutable_admin_split();
  void set_allocated_admin_split(::znbase::roachpb::AdminSplitResponse* admin_split);

  // .znbase.roachpb.AdminMergeResponse admin_merge = 11;
  bool has_admin_merge() const;
  void clear_admin_merge();
  static const int kAdminMergeFieldNumber = 11;
  private:
  const ::znbase::roachpb::AdminMergeResponse& _internal_admin_merge() const;
  public:
  const ::znbase::roachpb::AdminMergeResponse& admin_merge() const;
  ::znbase::roachpb::AdminMergeResponse* release_admin_merge();
  ::znbase::roachpb::AdminMergeResponse* mutable_admin_merge();
  void set_allocated_admin_merge(::znbase::roachpb::AdminMergeResponse* admin_merge);

  // .znbase.roachpb.AdminTransferLeaseResponse admin_transfer_lease = 29;
  bool has_admin_transfer_lease() const;
  void clear_admin_transfer_lease();
  static const int kAdminTransferLeaseFieldNumber = 29;
  private:
  const ::znbase::roachpb::AdminTransferLeaseResponse& _internal_admin_transfer_lease() const;
  public:
  const ::znbase::roachpb::AdminTransferLeaseResponse& admin_transfer_lease() const;
  ::znbase::roachpb::AdminTransferLeaseResponse* release_admin_transfer_lease();
  ::znbase::roachpb::AdminTransferLeaseResponse* mutable_admin_transfer_lease();
  void set_allocated_admin_transfer_lease(::znbase::roachpb::AdminTransferLeaseResponse* admin_transfer_lease);

  // .znbase.roachpb.AdminChangeReplicasResponse admin_change_replicas = 35;
  bool has_admin_change_replicas() const;
  void clear_admin_change_replicas();
  static const int kAdminChangeReplicasFieldNumber = 35;
  private:
  const ::znbase::roachpb::AdminChangeReplicasResponse& _internal_admin_change_replicas() const;
  public:
  const ::znbase::roachpb::AdminChangeReplicasResponse& admin_change_replicas() const;
  ::znbase::roachpb::AdminChangeReplicasResponse* release_admin_change_replicas();
  ::znbase::roachpb::AdminChangeReplicasResponse* mutable_admin_change_replicas();
  void set_allocated_admin_change_replicas(::znbase::roachpb::AdminChangeReplicasResponse* admin_change_replicas);

  // .znbase.roachpb.AdminRelocateRangeResponse admin_relocate_range = 45;
  bool has_admin_relocate_range() const;
  void clear_admin_relocate_range();
  static const int kAdminRelocateRangeFieldNumber = 45;
  private:
  const ::znbase::roachpb::AdminRelocateRangeResponse& _internal_admin_relocate_range() const;
  public:
  const ::znbase::roachpb::AdminRelocateRangeResponse& admin_relocate_range() const;
  ::znbase::roachpb::AdminRelocateRangeResponse* release_admin_relocate_range();
  ::znbase::roachpb::AdminRelocateRangeResponse* mutable_admin_relocate_range();
  void set_allocated_admin_relocate_range(::znbase::roachpb::AdminRelocateRangeResponse* admin_relocate_range);

  // .znbase.roachpb.HeartbeatTxnResponse heartbeat_txn = 12;
  bool has_heartbeat_txn() const;
  void clear_heartbeat_txn();
  static const int kHeartbeatTxnFieldNumber = 12;
  private:
  const ::znbase::roachpb::HeartbeatTxnResponse& _internal_heartbeat_txn() const;
  public:
  const ::znbase::roachpb::HeartbeatTxnResponse& heartbeat_txn() const;
  ::znbase::roachpb::HeartbeatTxnResponse* release_heartbeat_txn();
  ::znbase::roachpb::HeartbeatTxnResponse* mutable_heartbeat_txn();
  void set_allocated_heartbeat_txn(::znbase::roachpb::HeartbeatTxnResponse* heartbeat_txn);

  // .znbase.roachpb.GCResponse gc = 13;
  bool has_gc() const;
  void clear_gc();
  static const int kGcFieldNumber = 13;
  private:
  const ::znbase::roachpb::GCResponse& _internal_gc() const;
  public:
  const ::znbase::roachpb::GCResponse& gc() const;
  ::znbase::roachpb::GCResponse* release_gc();
  ::znbase::roachpb::GCResponse* mutable_gc();
  void set_allocated_gc(::znbase::roachpb::GCResponse* gc);

  // .znbase.roachpb.PushTxnResponse push_txn = 14;
  bool has_push_txn() const;
  void clear_push_txn();
  static const int kPushTxnFieldNumber = 14;
  private:
  const ::znbase::roachpb::PushTxnResponse& _internal_push_txn() const;
  public:
  const ::znbase::roachpb::PushTxnResponse& push_txn() const;
  ::znbase::roachpb::PushTxnResponse* release_push_txn();
  ::znbase::roachpb::PushTxnResponse* mutable_push_txn();
  void set_allocated_push_txn(::znbase::roachpb::PushTxnResponse* push_txn);

  // .znbase.roachpb.RecoverTxnResponse recover_txn = 46;
  bool has_recover_txn() const;
  void clear_recover_txn();
  static const int kRecoverTxnFieldNumber = 46;
  private:
  const ::znbase::roachpb::RecoverTxnResponse& _internal_recover_txn() const;
  public:
  const ::znbase::roachpb::RecoverTxnResponse& recover_txn() const;
  ::znbase::roachpb::RecoverTxnResponse* release_recover_txn();
  ::znbase::roachpb::RecoverTxnResponse* mutable_recover_txn();
  void set_allocated_recover_txn(::znbase::roachpb::RecoverTxnResponse* recover_txn);

  // .znbase.roachpb.ResolveIntentResponse resolve_intent = 16;
  bool has_resolve_intent() const;
  void clear_resolve_intent();
  static const int kResolveIntentFieldNumber = 16;
  private:
  const ::znbase::roachpb::ResolveIntentResponse& _internal_resolve_intent() const;
  public:
  const ::znbase::roachpb::ResolveIntentResponse& resolve_intent() const;
  ::znbase::roachpb::ResolveIntentResponse* release_resolve_intent();
  ::znbase::roachpb::ResolveIntentResponse* mutable_resolve_intent();
  void set_allocated_resolve_intent(::znbase::roachpb::ResolveIntentResponse* resolve_intent);

  // .znbase.roachpb.ResolveIntentRangeResponse resolve_intent_range = 17;
  bool has_resolve_intent_range() const;
  void clear_resolve_intent_range();
  static const int kResolveIntentRangeFieldNumber = 17;
  private:
  const ::znbase::roachpb::ResolveIntentRangeResponse& _internal_resolve_intent_range() const;
  public:
  const ::znbase::roachpb::ResolveIntentRangeResponse& resolve_intent_range() const;
  ::znbase::roachpb::ResolveIntentRangeResponse* release_resolve_intent_range();
  ::znbase::roachpb::ResolveIntentRangeResponse* mutable_resolve_intent_range();
  void set_allocated_resolve_intent_range(::znbase::roachpb::ResolveIntentRangeResponse* resolve_intent_range);

  // .znbase.roachpb.MergeResponse merge = 18;
  bool has_merge() const;
  void clear_merge();
  static const int kMergeFieldNumber = 18;
  private:
  const ::znbase::roachpb::MergeResponse& _internal_merge() const;
  public:
  const ::znbase::roachpb::MergeResponse& merge() const;
  ::znbase::roachpb::MergeResponse* release_merge();
  ::znbase::roachpb::MergeResponse* mutable_merge();
  void set_allocated_merge(::znbase::roachpb::MergeResponse* merge);

  // .znbase.roachpb.TruncateLogResponse truncate_log = 19;
  bool has_truncate_log() const;
  void clear_truncate_log();
  static const int kTruncateLogFieldNumber = 19;
  private:
  const ::znbase::roachpb::TruncateLogResponse& _internal_truncate_log() const;
  public:
  const ::znbase::roachpb::TruncateLogResponse& truncate_log() const;
  ::znbase::roachpb::TruncateLogResponse* release_truncate_log();
  ::znbase::roachpb::TruncateLogResponse* mutable_truncate_log();
  void set_allocated_truncate_log(::znbase::roachpb::TruncateLogResponse* truncate_log);

  // .znbase.roachpb.RequestLeaseResponse request_lease = 20;
  bool has_request_lease() const;
  void clear_request_lease();
  static const int kRequestLeaseFieldNumber = 20;
  private:
  const ::znbase::roachpb::RequestLeaseResponse& _internal_request_lease() const;
  public:
  const ::znbase::roachpb::RequestLeaseResponse& request_lease() const;
  ::znbase::roachpb::RequestLeaseResponse* release_request_lease();
  ::znbase::roachpb::RequestLeaseResponse* mutable_request_lease();
  void set_allocated_request_lease(::znbase::roachpb::RequestLeaseResponse* request_lease);

  // .znbase.roachpb.ReverseScanResponse reverse_scan = 21;
  bool has_reverse_scan() const;
  void clear_reverse_scan();
  static const int kReverseScanFieldNumber = 21;
  private:
  const ::znbase::roachpb::ReverseScanResponse& _internal_reverse_scan() const;
  public:
  const ::znbase::roachpb::ReverseScanResponse& reverse_scan() const;
  ::znbase::roachpb::ReverseScanResponse* release_reverse_scan();
  ::znbase::roachpb::ReverseScanResponse* mutable_reverse_scan();
  void set_allocated_reverse_scan(::znbase::roachpb::ReverseScanResponse* reverse_scan);

  // .znbase.roachpb.ComputeChecksumResponse compute_checksum = 22;
  bool has_compute_checksum() const;
  void clear_compute_checksum();
  static const int kComputeChecksumFieldNumber = 22;
  private:
  const ::znbase::roachpb::ComputeChecksumResponse& _internal_compute_checksum() const;
  public:
  const ::znbase::roachpb::ComputeChecksumResponse& compute_checksum() const;
  ::znbase::roachpb::ComputeChecksumResponse* release_compute_checksum();
  ::znbase::roachpb::ComputeChecksumResponse* mutable_compute_checksum();
  void set_allocated_compute_checksum(::znbase::roachpb::ComputeChecksumResponse* compute_checksum);

  // .znbase.roachpb.CheckConsistencyResponse check_consistency = 24;
  bool has_check_consistency() const;
  void clear_check_consistency();
  static const int kCheckConsistencyFieldNumber = 24;
  private:
  const ::znbase::roachpb::CheckConsistencyResponse& _internal_check_consistency() const;
  public:
  const ::znbase::roachpb::CheckConsistencyResponse& check_consistency() const;
  ::znbase::roachpb::CheckConsistencyResponse* release_check_consistency();
  ::znbase::roachpb::CheckConsistencyResponse* mutable_check_consistency();
  void set_allocated_check_consistency(::znbase::roachpb::CheckConsistencyResponse* check_consistency);

  // .znbase.roachpb.InitPutResponse init_put = 26;
  bool has_init_put() const;
  void clear_init_put();
  static const int kInitPutFieldNumber = 26;
  private:
  const ::znbase::roachpb::InitPutResponse& _internal_init_put() const;
  public:
  const ::znbase::roachpb::InitPutResponse& init_put() const;
  ::znbase::roachpb::InitPutResponse* release_init_put();
  ::znbase::roachpb::InitPutResponse* mutable_init_put();
  void set_allocated_init_put(::znbase::roachpb::InitPutResponse* init_put);

  // .znbase.roachpb.LeaseInfoResponse lease_info = 30;
  bool has_lease_info() const;
  void clear_lease_info();
  static const int kLeaseInfoFieldNumber = 30;
  private:
  const ::znbase::roachpb::LeaseInfoResponse& _internal_lease_info() const;
  public:
  const ::znbase::roachpb::LeaseInfoResponse& lease_info() const;
  ::znbase::roachpb::LeaseInfoResponse* release_lease_info();
  ::znbase::roachpb::LeaseInfoResponse* mutable_lease_info();
  void set_allocated_lease_info(::znbase::roachpb::LeaseInfoResponse* lease_info);

  // .znbase.roachpb.WriteBatchResponse write_batch = 31;
  bool has_write_batch() const;
  void clear_write_batch();
  static const int kWriteBatchFieldNumber = 31;
  private:
  const ::znbase::roachpb::WriteBatchResponse& _internal_write_batch() const;
  public:
  const ::znbase::roachpb::WriteBatchResponse& write_batch() const;
  ::znbase::roachpb::WriteBatchResponse* release_write_batch();
  ::znbase::roachpb::WriteBatchResponse* mutable_write_batch();
  void set_allocated_write_batch(::znbase::roachpb::WriteBatchResponse* write_batch);

  // .znbase.roachpb.ExportResponse export = 32;
  bool has_export_() const;
  void clear_export_();
  static const int kExportFieldNumber = 32;
  private:
  const ::znbase::roachpb::ExportResponse& _internal_export_() const;
  public:
  const ::znbase::roachpb::ExportResponse& export_() const;
  ::znbase::roachpb::ExportResponse* release_export_();
  ::znbase::roachpb::ExportResponse* mutable_export_();
  void set_allocated_export_(::znbase::roachpb::ExportResponse* export_);

  // .znbase.roachpb.ImportResponse import = 34;
  bool has_import() const;
  void clear_import();
  static const int kImportFieldNumber = 34;
  private:
  const ::znbase::roachpb::ImportResponse& _internal_import() const;
  public:
  const ::znbase::roachpb::ImportResponse& import() const;
  ::znbase::roachpb::ImportResponse* release_import();
  ::znbase::roachpb::ImportResponse* mutable_import();
  void set_allocated_import(::znbase::roachpb::ImportResponse* import);

  // .znbase.roachpb.QueryTxnResponse query_txn = 33;
  bool has_query_txn() const;
  void clear_query_txn();
  static const int kQueryTxnFieldNumber = 33;
  private:
  const ::znbase::roachpb::QueryTxnResponse& _internal_query_txn() const;
  public:
  const ::znbase::roachpb::QueryTxnResponse& query_txn() const;
  ::znbase::roachpb::QueryTxnResponse* release_query_txn();
  ::znbase::roachpb::QueryTxnResponse* mutable_query_txn();
  void set_allocated_query_txn(::znbase::roachpb::QueryTxnResponse* query_txn);

  // .znbase.roachpb.QueryIntentResponse query_intent = 42;
  bool has_query_intent() const;
  void clear_query_intent();
  static const int kQueryIntentFieldNumber = 42;
  private:
  const ::znbase::roachpb::QueryIntentResponse& _internal_query_intent() const;
  public:
  const ::znbase::roachpb::QueryIntentResponse& query_intent() const;
  ::znbase::roachpb::QueryIntentResponse* release_query_intent();
  ::znbase::roachpb::QueryIntentResponse* mutable_query_intent();
  void set_allocated_query_intent(::znbase::roachpb::QueryIntentResponse* query_intent);

  // .znbase.roachpb.AdminScatterResponse admin_scatter = 36;
  bool has_admin_scatter() const;
  void clear_admin_scatter();
  static const int kAdminScatterFieldNumber = 36;
  private:
  const ::znbase::roachpb::AdminScatterResponse& _internal_admin_scatter() const;
  public:
  const ::znbase::roachpb::AdminScatterResponse& admin_scatter() const;
  ::znbase::roachpb::AdminScatterResponse* release_admin_scatter();
  ::znbase::roachpb::AdminScatterResponse* mutable_admin_scatter();
  void set_allocated_admin_scatter(::znbase::roachpb::AdminScatterResponse* admin_scatter);

  // .znbase.roachpb.AddSSTableResponse add_sstable = 37;
  bool has_add_sstable() const;
  void clear_add_sstable();
  static const int kAddSstableFieldNumber = 37;
  private:
  const ::znbase::roachpb::AddSSTableResponse& _internal_add_sstable() const;
  public:
  const ::znbase::roachpb::AddSSTableResponse& add_sstable() const;
  ::znbase::roachpb::AddSSTableResponse* release_add_sstable();
  ::znbase::roachpb::AddSSTableResponse* mutable_add_sstable();
  void set_allocated_add_sstable(::znbase::roachpb::AddSSTableResponse* add_sstable);

  // .znbase.roachpb.RecomputeStatsResponse recompute_stats = 39;
  bool has_recompute_stats() const;
  void clear_recompute_stats();
  static const int kRecomputeStatsFieldNumber = 39;
  private:
  const ::znbase::roachpb::RecomputeStatsResponse& _internal_recompute_stats() const;
  public:
  const ::znbase::roachpb::RecomputeStatsResponse& recompute_stats() const;
  ::znbase::roachpb::RecomputeStatsResponse* release_recompute_stats();
  ::znbase::roachpb::RecomputeStatsResponse* mutable_recompute_stats();
  void set_allocated_recompute_stats(::znbase::roachpb::RecomputeStatsResponse* recompute_stats);

  // .znbase.roachpb.RefreshResponse refresh = 40;
  bool has_refresh() const;
  void clear_refresh();
  static const int kRefreshFieldNumber = 40;
  private:
  const ::znbase::roachpb::RefreshResponse& _internal_refresh() const;
  public:
  const ::znbase::roachpb::RefreshResponse& refresh() const;
  ::znbase::roachpb::RefreshResponse* release_refresh();
  ::znbase::roachpb::RefreshResponse* mutable_refresh();
  void set_allocated_refresh(::znbase::roachpb::RefreshResponse* refresh);

  // .znbase.roachpb.RefreshRangeResponse refresh_range = 41;
  bool has_refresh_range() const;
  void clear_refresh_range();
  static const int kRefreshRangeFieldNumber = 41;
  private:
  const ::znbase::roachpb::RefreshRangeResponse& _internal_refresh_range() const;
  public:
  const ::znbase::roachpb::RefreshRangeResponse& refresh_range() const;
  ::znbase::roachpb::RefreshRangeResponse* release_refresh_range();
  ::znbase::roachpb::RefreshRangeResponse* mutable_refresh_range();
  void set_allocated_refresh_range(::znbase::roachpb::RefreshRangeResponse* refresh_range);

  // .znbase.roachpb.SubsumeResponse subsume = 43;
  bool has_subsume() const;
  void clear_subsume();
  static const int kSubsumeFieldNumber = 43;
  private:
  const ::znbase::roachpb::SubsumeResponse& _internal_subsume() const;
  public:
  const ::znbase::roachpb::SubsumeResponse& subsume() const;
  ::znbase::roachpb::SubsumeResponse* release_subsume();
  ::znbase::roachpb::SubsumeResponse* mutable_subsume();
  void set_allocated_subsume(::znbase::roachpb::SubsumeResponse* subsume);

  // .znbase.roachpb.RangeStatsResponse range_stats = 44;
  bool has_range_stats() const;
  void clear_range_stats();
  static const int kRangeStatsFieldNumber = 44;
  private:
  const ::znbase::roachpb::RangeStatsResponse& _internal_range_stats() const;
  public:
  const ::znbase::roachpb::RangeStatsResponse& range_stats() const;
  ::znbase::roachpb::RangeStatsResponse* release_range_stats();
  ::znbase::roachpb::RangeStatsResponse* mutable_range_stats();
  void set_allocated_range_stats(::znbase::roachpb::RangeStatsResponse* range_stats);

  // .znbase.roachpb.RevertResponse revert = 48;
  bool has_revert() const;
  void clear_revert();
  static const int kRevertFieldNumber = 48;
  private:
  const ::znbase::roachpb::RevertResponse& _internal_revert() const;
  public:
  const ::znbase::roachpb::RevertResponse& revert() const;
  ::znbase::roachpb::RevertResponse* release_revert();
  ::znbase::roachpb::RevertResponse* mutable_revert();
  void set_allocated_revert(::znbase::roachpb::RevertResponse* revert);

  // .znbase.roachpb.DumpResponse dump = 49;
  bool has_dump() const;
  void clear_dump();
  static const int kDumpFieldNumber = 49;
  private:
  const ::znbase::roachpb::DumpResponse& _internal_dump() const;
  public:
  const ::znbase::roachpb::DumpResponse& dump() const;
  ::znbase::roachpb::DumpResponse* release_dump();
  ::znbase::roachpb::DumpResponse* mutable_dump();
  void set_allocated_dump(::znbase::roachpb::DumpResponse* dump);

  // .znbase.roachpb.LoadResponse load = 47;
  bool has_load() const;
  void clear_load();
  static const int kLoadFieldNumber = 47;
  private:
  const ::znbase::roachpb::LoadResponse& _internal_load() const;
  public:
  const ::znbase::roachpb::LoadResponse& load() const;
  ::znbase::roachpb::LoadResponse* release_load();
  ::znbase::roachpb::LoadResponse* mutable_load();
  void set_allocated_load(::znbase::roachpb::LoadResponse* load);

  // .znbase.roachpb.DumpOnlineResponse dump_online = 50;
  bool has_dump_online() const;
  void clear_dump_online();
  static const int kDumpOnlineFieldNumber = 50;
  private:
  const ::znbase::roachpb::DumpOnlineResponse& _internal_dump_online() const;
  public:
  const ::znbase::roachpb::DumpOnlineResponse& dump_online() const;
  ::znbase::roachpb::DumpOnlineResponse* release_dump_online();
  ::znbase::roachpb::DumpOnlineResponse* mutable_dump_online();
  void set_allocated_dump_online(::znbase::roachpb::DumpOnlineResponse* dump_online);

  // .znbase.roachpb.ClearIntentResponse clear_intent = 52;
  bool has_clear_intent() const;
  void clear_clear_intent();
  static const int kClearIntentFieldNumber = 52;
  private:
  const ::znbase::roachpb::ClearIntentResponse& _internal_clear_intent() const;
  public:
  const ::znbase::roachpb::ClearIntentResponse& clear_intent() const;
  ::znbase::roachpb::ClearIntentResponse* release_clear_intent();
  ::znbase::roachpb::ClearIntentResponse* mutable_clear_intent();
  void set_allocated_clear_intent(::znbase::roachpb::ClearIntentResponse* clear_intent);

  // .znbase.roachpb.QueryLockResponse query_lock = 53;
  bool has_query_lock() const;
  void clear_query_lock();
  static const int kQueryLockFieldNumber = 53;
  private:
  const ::znbase::roachpb::QueryLockResponse& _internal_query_lock() const;
  public:
  const ::znbase::roachpb::QueryLockResponse& query_lock() const;
  ::znbase::roachpb::QueryLockResponse* release_query_lock();
  ::znbase::roachpb::QueryLockResponse* mutable_query_lock();
  void set_allocated_query_lock(::znbase::roachpb::QueryLockResponse* query_lock);

  // .znbase.roachpb.VecScanResponse vec_scan = 54;
  bool has_vec_scan() const;
  void clear_vec_scan();
  static const int kVecScanFieldNumber = 54;
  private:
  const ::znbase::roachpb::VecScanResponse& _internal_vec_scan() const;
  public:
  const ::znbase::roachpb::VecScanResponse& vec_scan() const;
  ::znbase::roachpb::VecScanResponse* release_vec_scan();
  ::znbase::roachpb::VecScanResponse* mutable_vec_scan();
  void set_allocated_vec_scan(::znbase::roachpb::VecScanResponse* vec_scan);

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:znbase.roachpb.ResponseUnion)
 private:
  void set_has_get();
  void set_has_put();
  void set_has_conditional_put();
  void set_has_increment();
  void set_has_delete_();
  void set_has_delete_range();
  void set_has_clear_range();
  void set_has_revert_range();
  void set_has_scan();
  void set_has_end_transaction();
  void set_has_admin_split();
  void set_has_admin_merge();
  void set_has_admin_transfer_lease();
  void set_has_admin_change_replicas();
  void set_has_admin_relocate_range();
  void set_has_heartbeat_txn();
  void set_has_gc();
  void set_has_push_txn();
  void set_has_recover_txn();
  void set_has_resolve_intent();
  void set_has_resolve_intent_range();
  void set_has_merge();
  void set_has_truncate_log();
  void set_has_request_lease();
  void set_has_reverse_scan();
  void set_has_compute_checksum();
  void set_has_check_consistency();
  void set_has_init_put();
  void set_has_lease_info();
  void set_has_write_batch();
  void set_has_export_();
  void set_has_import();
  void set_has_query_txn();
  void set_has_query_intent();
  void set_has_admin_scatter();
  void set_has_add_sstable();
  void set_has_recompute_stats();
  void set_has_refresh();
  void set_has_refresh_range();
  void set_has_subsume();
  void set_has_range_stats();
  void set_has_revert();
  void set_has_dump();
  void set_has_load();
  void set_has_dump_online();
  void set_has_clear_intent();
  void set_has_query_lock();
  void set_has_vec_scan();

  inline bool has_value() const;
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  union ValueUnion {
    ValueUnion() {}
    ::znbase::roachpb::GetResponse* get_;
    ::znbase::roachpb::PutResponse* put_;
    ::znbase::roachpb::ConditionalPutResponse* conditional_put_;
    ::znbase::roachpb::IncrementResponse* increment_;
    ::znbase::roachpb::DeleteResponse* delete__;
    ::znbase::roachpb::DeleteRangeResponse* delete_range_;
    ::znbase::roachpb::ClearRangeResponse* clear_range_;
    ::znbase::roachpb::RevertRangeResponse* revert_range_;
    ::znbase::roachpb::ScanResponse* scan_;
    ::znbase::roachpb::EndTransactionResponse* end_transaction_;
    ::znbase::roachpb::AdminSplitResponse* admin_split_;
    ::znbase::roachpb::AdminMergeResponse* admin_merge_;
    ::znbase::roachpb::AdminTransferLeaseResponse* admin_transfer_lease_;
    ::znbase::roachpb::AdminChangeReplicasResponse* admin_change_replicas_;
    ::znbase::roachpb::AdminRelocateRangeResponse* admin_relocate_range_;
    ::znbase::roachpb::HeartbeatTxnResponse* heartbeat_txn_;
    ::znbase::roachpb::GCResponse* gc_;
    ::znbase::roachpb::PushTxnResponse* push_txn_;
    ::znbase::roachpb::RecoverTxnResponse* recover_txn_;
    ::znbase::roachpb::ResolveIntentResponse* resolve_intent_;
    ::znbase::roachpb::ResolveIntentRangeResponse* resolve_intent_range_;
    ::znbase::roachpb::MergeResponse* merge_;
    ::znbase::roachpb::TruncateLogResponse* truncate_log_;
    ::znbase::roachpb::RequestLeaseResponse* request_lease_;
    ::znbase::roachpb::ReverseScanResponse* reverse_scan_;
    ::znbase::roachpb::ComputeChecksumResponse* compute_checksum_;
    ::znbase::roachpb::CheckConsistencyResponse* check_consistency_;
    ::znbase::roachpb::InitPutResponse* init_put_;
    ::znbase::roachpb::LeaseInfoResponse* lease_info_;
    ::znbase::roachpb::WriteBatchResponse* write_batch_;
    ::znbase::roachpb::ExportResponse* export__;
    ::znbase::roachpb::ImportResponse* import_;
    ::znbase::roachpb::QueryTxnResponse* query_txn_;
    ::znbase::roachpb::QueryIntentResponse* query_intent_;
    ::znbase::roachpb::AdminScatterResponse* admin_scatter_;
    ::znbase::roachpb::AddSSTableResponse* add_sstable_;
    ::znbase::roachpb::RecomputeStatsResponse* recompute_stats_;
    ::znbase::roachpb::RefreshResponse* refresh_;
    ::znbase::roachpb::RefreshRangeResponse* refresh_range_;
    ::znbase::roachpb::SubsumeResponse* subsume_;
    ::znbase::roachpb::RangeStatsResponse* range_stats_;
    ::znbase::roachpb::RevertResponse* revert_;
    ::znbase::roachpb::DumpResponse* dump_;
    ::znbase::roachpb::LoadResponse* load_;
    ::znbase::roachpb::DumpOnlineResponse* dump_online_;
    ::znbase::roachpb::ClearIntentResponse* clear_intent_;
    ::znbase::roachpb::QueryLockResponse* query_lock_;
    ::znbase::roachpb::VecScanResponse* vec_scan_;
  } value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Header : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.Header) */ {
 public:
  Header();
  virtual ~Header();

  Header(const Header& from);

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Header(Header&& from) noexcept
    : Header() {
    *this = ::std::move(from);
  }

  inline Header& operator=(Header&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Header& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Header* internal_default_instance() {
    return reinterpret_cast<const Header*>(
               &_Header_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    131;

  void Swap(Header* other);
  friend void swap(Header& a, Header& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Header* New() const final {
    return CreateMaybeMessage<Header>(NULL);
  }

  Header* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Header>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Header& from);
  void MergeFrom(const Header& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Header* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  private:
  const ::znbase::util::hlc::Timestamp& _internal_timestamp() const;
  public:
  const ::znbase::util::hlc::Timestamp& timestamp() const;
  ::znbase::util::hlc::Timestamp* release_timestamp();
  ::znbase::util::hlc::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::znbase::util::hlc::Timestamp* timestamp);

  bool has_replica() const;
  void clear_replica();
  static const int kReplicaFieldNumber = 2;
  private:
  const ::znbase::roachpb::ReplicaDescriptor& _internal_replica() const;
  public:
  const ::znbase::roachpb::ReplicaDescriptor& replica() const;
  ::znbase::roachpb::ReplicaDescriptor* release_replica();
  ::znbase::roachpb::ReplicaDescriptor* mutable_replica();
  void set_allocated_replica(::znbase::roachpb::ReplicaDescriptor* replica);

  // .znbase.roachpb.Transaction txn = 5;
  bool has_txn() const;
  void clear_txn();
  static const int kTxnFieldNumber = 5;
  private:
  const ::znbase::roachpb::Transaction& _internal_txn() const;
  public:
  const ::znbase::roachpb::Transaction& txn() const;
  ::znbase::roachpb::Transaction* release_txn();
  ::znbase::roachpb::Transaction* mutable_txn();
  void set_allocated_txn(::znbase::roachpb::Transaction* txn);

  // .znbase.roachpb.ScanOptions scan_options = 12;
  bool has_scan_options() const;
  void clear_scan_options();
  static const int kScanOptionsFieldNumber = 12;
  private:
  const ::znbase::roachpb::ScanOptions& _internal_scan_options() const;
  public:
  const ::znbase::roachpb::ScanOptions& scan_options() const;
  ::znbase::roachpb::ScanOptions* release_scan_options();
  ::znbase::roachpb::ScanOptions* mutable_scan_options();
  void set_allocated_scan_options(::znbase::roachpb::ScanOptions* scan_options);

  bool has_wait_time() const;
  void clear_wait_time();
  static const int kWaitTimeFieldNumber = 17;
  private:
  const ::znbase::util::hlc::Timestamp& _internal_wait_time() const;
  public:
  const ::znbase::util::hlc::Timestamp& wait_time() const;
  ::znbase::util::hlc::Timestamp* release_wait_time();
  ::znbase::util::hlc::Timestamp* mutable_wait_time();
  void set_allocated_wait_time(::znbase::util::hlc::Timestamp* wait_time);

  void clear_range_id();
  static const int kRangeIdFieldNumber = 3;
  ::google::protobuf::int64 range_id() const;
  void set_range_id(::google::protobuf::int64 value);

  void clear_user_priority();
  static const int kUserPriorityFieldNumber = 4;
  double user_priority() const;
  void set_user_priority(double value);

  // int64 max_span_request_keys = 8;
  void clear_max_span_request_keys();
  static const int kMaxSpanRequestKeysFieldNumber = 8;
  ::google::protobuf::int64 max_span_request_keys() const;
  void set_max_span_request_keys(::google::protobuf::int64 value);

  // .znbase.roachpb.ReadConsistencyType read_consistency = 6;
  void clear_read_consistency();
  static const int kReadConsistencyFieldNumber = 6;
  ::znbase::roachpb::ReadConsistencyType read_consistency() const;
  void set_read_consistency(::znbase::roachpb::ReadConsistencyType value);

  void clear_gateway_node_id();
  static const int kGatewayNodeIdFieldNumber = 11;
  ::google::protobuf::int32 gateway_node_id() const;
  void set_gateway_node_id(::google::protobuf::int32 value);

  // bool distinct_spans = 9;
  void clear_distinct_spans();
  static const int kDistinctSpansFieldNumber = 9;
  bool distinct_spans() const;
  void set_distinct_spans(bool value);

  // bool return_range_info = 10;
  void clear_return_range_info();
  static const int kReturnRangeInfoFieldNumber = 10;
  bool return_range_info() const;
  void set_return_range_info(bool value);

  // bool async_consensus = 13;
  void clear_async_consensus();
  static const int kAsyncConsensusFieldNumber = 13;
  bool async_consensus() const;
  void set_async_consensus(bool value);

  // bool can_forward_read = 16;
  void clear_can_forward_read();
  static const int kCanForwardReadFieldNumber = 16;
  bool can_forward_read() const;
  void set_can_forward_read(bool value);

  // .znbase.storage.concurrency.lock.WaitPolicy wait_policy = 18;
  void clear_wait_policy();
  static const int kWaitPolicyFieldNumber = 18;
  ::znbase::storage::concurrency::lock::WaitPolicy wait_policy() const;
  void set_wait_policy(::znbase::storage::concurrency::lock::WaitPolicy value);

  // bool back_fill = 19;
  void clear_back_fill();
  static const int kBackFillFieldNumber = 19;
  bool back_fill() const;
  void set_back_fill(bool value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.Header)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::util::hlc::Timestamp* timestamp_;
  ::znbase::roachpb::ReplicaDescriptor* replica_;
  ::znbase::roachpb::Transaction* txn_;
  ::znbase::roachpb::ScanOptions* scan_options_;
  ::znbase::util::hlc::Timestamp* wait_time_;
  ::google::protobuf::int64 range_id_;
  double user_priority_;
  ::google::protobuf::int64 max_span_request_keys_;
  int read_consistency_;
  ::google::protobuf::int32 gateway_node_id_;
  bool distinct_spans_;
  bool return_range_info_;
  bool async_consensus_;
  bool can_forward_read_;
  int wait_policy_;
  bool back_fill_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BatchRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.BatchRequest) */ {
 public:
  BatchRequest();
  virtual ~BatchRequest();

  BatchRequest(const BatchRequest& from);

  inline BatchRequest& operator=(const BatchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BatchRequest(BatchRequest&& from) noexcept
    : BatchRequest() {
    *this = ::std::move(from);
  }

  inline BatchRequest& operator=(BatchRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const BatchRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BatchRequest* internal_default_instance() {
    return reinterpret_cast<const BatchRequest*>(
               &_BatchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    132;

  void Swap(BatchRequest* other);
  friend void swap(BatchRequest& a, BatchRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BatchRequest* New() const final {
    return CreateMaybeMessage<BatchRequest>(NULL);
  }

  BatchRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BatchRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const BatchRequest& from);
  void MergeFrom(const BatchRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BatchRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  int requests_size() const;
  void clear_requests();
  static const int kRequestsFieldNumber = 2;
  ::znbase::roachpb::RequestUnion* mutable_requests(int index);
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::RequestUnion >*
      mutable_requests();
  const ::znbase::roachpb::RequestUnion& requests(int index) const;
  ::znbase::roachpb::RequestUnion* add_requests();
  const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::RequestUnion >&
      requests() const;

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::Header& _internal_header() const;
  public:
  const ::znbase::roachpb::Header& header() const;
  ::znbase::roachpb::Header* release_header();
  ::znbase::roachpb::Header* mutable_header();
  void set_allocated_header(::znbase::roachpb::Header* header);

  void clear_dont_need_meta();
  static const int kDontNeedMetaFieldNumber = 3;
  bool dont_need_meta() const;
  void set_dont_need_meta(bool value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.BatchRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::RequestUnion > requests_;
  ::znbase::roachpb::Header* header_;
  bool dont_need_meta_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BatchResponse_Header : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.BatchResponse.Header) */ {
 public:
  BatchResponse_Header();
  virtual ~BatchResponse_Header();

  BatchResponse_Header(const BatchResponse_Header& from);

  inline BatchResponse_Header& operator=(const BatchResponse_Header& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BatchResponse_Header(BatchResponse_Header&& from) noexcept
    : BatchResponse_Header() {
    *this = ::std::move(from);
  }

  inline BatchResponse_Header& operator=(BatchResponse_Header&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const BatchResponse_Header& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BatchResponse_Header* internal_default_instance() {
    return reinterpret_cast<const BatchResponse_Header*>(
               &_BatchResponse_Header_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    133;

  void Swap(BatchResponse_Header* other);
  friend void swap(BatchResponse_Header& a, BatchResponse_Header& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BatchResponse_Header* New() const final {
    return CreateMaybeMessage<BatchResponse_Header>(NULL);
  }

  BatchResponse_Header* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BatchResponse_Header>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const BatchResponse_Header& from);
  void MergeFrom(const BatchResponse_Header& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BatchResponse_Header* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  int collected_spans_size() const;
  void clear_collected_spans();
  static const int kCollectedSpansFieldNumber = 6;
  ::znbase::util::tracing::RecordedSpan* mutable_collected_spans(int index);
  ::google::protobuf::RepeatedPtrField< ::znbase::util::tracing::RecordedSpan >*
      mutable_collected_spans();
  const ::znbase::util::tracing::RecordedSpan& collected_spans(int index) const;
  ::znbase::util::tracing::RecordedSpan* add_collected_spans();
  const ::google::protobuf::RepeatedPtrField< ::znbase::util::tracing::RecordedSpan >&
      collected_spans() const;

  // .znbase.roachpb.Error error = 1;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  private:
  const ::znbase::roachpb::Error& _internal_error() const;
  public:
  const ::znbase::roachpb::Error& error() const;
  ::znbase::roachpb::Error* release_error();
  ::znbase::roachpb::Error* mutable_error();
  void set_allocated_error(::znbase::roachpb::Error* error);

  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  private:
  const ::znbase::util::hlc::Timestamp& _internal_timestamp() const;
  public:
  const ::znbase::util::hlc::Timestamp& timestamp() const;
  ::znbase::util::hlc::Timestamp* release_timestamp();
  ::znbase::util::hlc::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::znbase::util::hlc::Timestamp* timestamp);

  // .znbase.roachpb.Transaction txn = 3;
  bool has_txn() const;
  void clear_txn();
  static const int kTxnFieldNumber = 3;
  private:
  const ::znbase::roachpb::Transaction& _internal_txn() const;
  public:
  const ::znbase::roachpb::Transaction& txn() const;
  ::znbase::roachpb::Transaction* release_txn();
  ::znbase::roachpb::Transaction* mutable_txn();
  void set_allocated_txn(::znbase::roachpb::Transaction* txn);

  bool has_now() const;
  void clear_now();
  static const int kNowFieldNumber = 5;
  private:
  const ::znbase::util::hlc::Timestamp& _internal_now() const;
  public:
  const ::znbase::util::hlc::Timestamp& now() const;
  ::znbase::util::hlc::Timestamp* release_now();
  ::znbase::util::hlc::Timestamp* mutable_now();
  void set_allocated_now(::znbase::util::hlc::Timestamp* now);

  // int64 count_row = 7;
  void clear_count_row();
  static const int kCountRowFieldNumber = 7;
  ::google::protobuf::int64 count_row() const;
  void set_count_row(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.BatchResponse.Header)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::znbase::util::tracing::RecordedSpan > collected_spans_;
  ::znbase::roachpb::Error* error_;
  ::znbase::util::hlc::Timestamp* timestamp_;
  ::znbase::roachpb::Transaction* txn_;
  ::znbase::util::hlc::Timestamp* now_;
  ::google::protobuf::int64 count_row_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BatchResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.BatchResponse) */ {
 public:
  BatchResponse();
  virtual ~BatchResponse();

  BatchResponse(const BatchResponse& from);

  inline BatchResponse& operator=(const BatchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BatchResponse(BatchResponse&& from) noexcept
    : BatchResponse() {
    *this = ::std::move(from);
  }

  inline BatchResponse& operator=(BatchResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const BatchResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BatchResponse* internal_default_instance() {
    return reinterpret_cast<const BatchResponse*>(
               &_BatchResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    134;

  void Swap(BatchResponse* other);
  friend void swap(BatchResponse& a, BatchResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BatchResponse* New() const final {
    return CreateMaybeMessage<BatchResponse>(NULL);
  }

  BatchResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BatchResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const BatchResponse& from);
  void MergeFrom(const BatchResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BatchResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef BatchResponse_Header Header;

  // accessors -------------------------------------------------------

  int responses_size() const;
  void clear_responses();
  static const int kResponsesFieldNumber = 2;
  ::znbase::roachpb::ResponseUnion* mutable_responses(int index);
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::ResponseUnion >*
      mutable_responses();
  const ::znbase::roachpb::ResponseUnion& responses(int index) const;
  ::znbase::roachpb::ResponseUnion* add_responses();
  const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::ResponseUnion >&
      responses() const;

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::BatchResponse_Header& _internal_header() const;
  public:
  const ::znbase::roachpb::BatchResponse_Header& header() const;
  ::znbase::roachpb::BatchResponse_Header* release_header();
  ::znbase::roachpb::BatchResponse_Header* mutable_header();
  void set_allocated_header(::znbase::roachpb::BatchResponse_Header* header);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.BatchResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::ResponseUnion > responses_;
  ::znbase::roachpb::BatchResponse_Header* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RangeFeedRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.RangeFeedRequest) */ {
 public:
  RangeFeedRequest();
  virtual ~RangeFeedRequest();

  RangeFeedRequest(const RangeFeedRequest& from);

  inline RangeFeedRequest& operator=(const RangeFeedRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RangeFeedRequest(RangeFeedRequest&& from) noexcept
    : RangeFeedRequest() {
    *this = ::std::move(from);
  }

  inline RangeFeedRequest& operator=(RangeFeedRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const RangeFeedRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RangeFeedRequest* internal_default_instance() {
    return reinterpret_cast<const RangeFeedRequest*>(
               &_RangeFeedRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    135;

  void Swap(RangeFeedRequest* other);
  friend void swap(RangeFeedRequest& a, RangeFeedRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RangeFeedRequest* New() const final {
    return CreateMaybeMessage<RangeFeedRequest>(NULL);
  }

  RangeFeedRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RangeFeedRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const RangeFeedRequest& from);
  void MergeFrom(const RangeFeedRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RangeFeedRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::Header& _internal_header() const;
  public:
  const ::znbase::roachpb::Header& header() const;
  ::znbase::roachpb::Header* release_header();
  ::znbase::roachpb::Header* mutable_header();
  void set_allocated_header(::znbase::roachpb::Header* header);

  bool has_span() const;
  void clear_span();
  static const int kSpanFieldNumber = 2;
  private:
  const ::znbase::roachpb::Span& _internal_span() const;
  public:
  const ::znbase::roachpb::Span& span() const;
  ::znbase::roachpb::Span* release_span();
  ::znbase::roachpb::Span* mutable_span();
  void set_allocated_span(::znbase::roachpb::Span* span);

  // .znbase.util.hlc.Timestamp filter = 4;
  bool has_filter() const;
  void clear_filter();
  static const int kFilterFieldNumber = 4;
  private:
  const ::znbase::util::hlc::Timestamp& _internal_filter() const;
  public:
  const ::znbase::util::hlc::Timestamp& filter() const;
  ::znbase::util::hlc::Timestamp* release_filter();
  ::znbase::util::hlc::Timestamp* mutable_filter();
  void set_allocated_filter(::znbase::util::hlc::Timestamp* filter);

  // bool with_diff = 3;
  void clear_with_diff();
  static const int kWithDiffFieldNumber = 3;
  bool with_diff() const;
  void set_with_diff(bool value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.RangeFeedRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::Header* header_;
  ::znbase::roachpb::Span* span_;
  ::znbase::util::hlc::Timestamp* filter_;
  bool with_diff_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RangeFeedValue : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.RangeFeedValue) */ {
 public:
  RangeFeedValue();
  virtual ~RangeFeedValue();

  RangeFeedValue(const RangeFeedValue& from);

  inline RangeFeedValue& operator=(const RangeFeedValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RangeFeedValue(RangeFeedValue&& from) noexcept
    : RangeFeedValue() {
    *this = ::std::move(from);
  }

  inline RangeFeedValue& operator=(RangeFeedValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const RangeFeedValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RangeFeedValue* internal_default_instance() {
    return reinterpret_cast<const RangeFeedValue*>(
               &_RangeFeedValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    136;

  void Swap(RangeFeedValue* other);
  friend void swap(RangeFeedValue& a, RangeFeedValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RangeFeedValue* New() const final {
    return CreateMaybeMessage<RangeFeedValue>(NULL);
  }

  RangeFeedValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RangeFeedValue>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const RangeFeedValue& from);
  void MergeFrom(const RangeFeedValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RangeFeedValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  private:
  const ::znbase::roachpb::Value& _internal_value() const;
  public:
  const ::znbase::roachpb::Value& value() const;
  ::znbase::roachpb::Value* release_value();
  ::znbase::roachpb::Value* mutable_value();
  void set_allocated_value(::znbase::roachpb::Value* value);

  bool has_prev_value() const;
  void clear_prev_value();
  static const int kPrevValueFieldNumber = 3;
  private:
  const ::znbase::roachpb::Value& _internal_prev_value() const;
  public:
  const ::znbase::roachpb::Value& prev_value() const;
  ::znbase::roachpb::Value* release_prev_value();
  ::znbase::roachpb::Value* mutable_prev_value();
  void set_allocated_prev_value(::znbase::roachpb::Value* prev_value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.RangeFeedValue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::znbase::roachpb::Value* value_;
  ::znbase::roachpb::Value* prev_value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RangeFeedCheckpoint : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.RangeFeedCheckpoint) */ {
 public:
  RangeFeedCheckpoint();
  virtual ~RangeFeedCheckpoint();

  RangeFeedCheckpoint(const RangeFeedCheckpoint& from);

  inline RangeFeedCheckpoint& operator=(const RangeFeedCheckpoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RangeFeedCheckpoint(RangeFeedCheckpoint&& from) noexcept
    : RangeFeedCheckpoint() {
    *this = ::std::move(from);
  }

  inline RangeFeedCheckpoint& operator=(RangeFeedCheckpoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const RangeFeedCheckpoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RangeFeedCheckpoint* internal_default_instance() {
    return reinterpret_cast<const RangeFeedCheckpoint*>(
               &_RangeFeedCheckpoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    137;

  void Swap(RangeFeedCheckpoint* other);
  friend void swap(RangeFeedCheckpoint& a, RangeFeedCheckpoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RangeFeedCheckpoint* New() const final {
    return CreateMaybeMessage<RangeFeedCheckpoint>(NULL);
  }

  RangeFeedCheckpoint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RangeFeedCheckpoint>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const RangeFeedCheckpoint& from);
  void MergeFrom(const RangeFeedCheckpoint& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RangeFeedCheckpoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_span() const;
  void clear_span();
  static const int kSpanFieldNumber = 1;
  private:
  const ::znbase::roachpb::Span& _internal_span() const;
  public:
  const ::znbase::roachpb::Span& span() const;
  ::znbase::roachpb::Span* release_span();
  ::znbase::roachpb::Span* mutable_span();
  void set_allocated_span(::znbase::roachpb::Span* span);

  bool has_resolved_ts() const;
  void clear_resolved_ts();
  static const int kResolvedTsFieldNumber = 2;
  private:
  const ::znbase::util::hlc::Timestamp& _internal_resolved_ts() const;
  public:
  const ::znbase::util::hlc::Timestamp& resolved_ts() const;
  ::znbase::util::hlc::Timestamp* release_resolved_ts();
  ::znbase::util::hlc::Timestamp* mutable_resolved_ts();
  void set_allocated_resolved_ts(::znbase::util::hlc::Timestamp* resolved_ts);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.RangeFeedCheckpoint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::Span* span_;
  ::znbase::util::hlc::Timestamp* resolved_ts_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RangeFeedError : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.RangeFeedError) */ {
 public:
  RangeFeedError();
  virtual ~RangeFeedError();

  RangeFeedError(const RangeFeedError& from);

  inline RangeFeedError& operator=(const RangeFeedError& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RangeFeedError(RangeFeedError&& from) noexcept
    : RangeFeedError() {
    *this = ::std::move(from);
  }

  inline RangeFeedError& operator=(RangeFeedError&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const RangeFeedError& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RangeFeedError* internal_default_instance() {
    return reinterpret_cast<const RangeFeedError*>(
               &_RangeFeedError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    138;

  void Swap(RangeFeedError* other);
  friend void swap(RangeFeedError& a, RangeFeedError& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RangeFeedError* New() const final {
    return CreateMaybeMessage<RangeFeedError>(NULL);
  }

  RangeFeedError* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RangeFeedError>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const RangeFeedError& from);
  void MergeFrom(const RangeFeedError& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RangeFeedError* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  private:
  const ::znbase::roachpb::Error& _internal_error() const;
  public:
  const ::znbase::roachpb::Error& error() const;
  ::znbase::roachpb::Error* release_error();
  ::znbase::roachpb::Error* mutable_error();
  void set_allocated_error(::znbase::roachpb::Error* error);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.RangeFeedError)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::Error* error_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RangeFeedEvent : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.RangeFeedEvent) */ {
 public:
  RangeFeedEvent();
  virtual ~RangeFeedEvent();

  RangeFeedEvent(const RangeFeedEvent& from);

  inline RangeFeedEvent& operator=(const RangeFeedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RangeFeedEvent(RangeFeedEvent&& from) noexcept
    : RangeFeedEvent() {
    *this = ::std::move(from);
  }

  inline RangeFeedEvent& operator=(RangeFeedEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const RangeFeedEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RangeFeedEvent* internal_default_instance() {
    return reinterpret_cast<const RangeFeedEvent*>(
               &_RangeFeedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    139;

  void Swap(RangeFeedEvent* other);
  friend void swap(RangeFeedEvent& a, RangeFeedEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RangeFeedEvent* New() const final {
    return CreateMaybeMessage<RangeFeedEvent>(NULL);
  }

  RangeFeedEvent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RangeFeedEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const RangeFeedEvent& from);
  void MergeFrom(const RangeFeedEvent& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RangeFeedEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .znbase.roachpb.RangeFeedValue val = 1;
  bool has_val() const;
  void clear_val();
  static const int kValFieldNumber = 1;
  private:
  const ::znbase::roachpb::RangeFeedValue& _internal_val() const;
  public:
  const ::znbase::roachpb::RangeFeedValue& val() const;
  ::znbase::roachpb::RangeFeedValue* release_val();
  ::znbase::roachpb::RangeFeedValue* mutable_val();
  void set_allocated_val(::znbase::roachpb::RangeFeedValue* val);

  // .znbase.roachpb.RangeFeedCheckpoint checkpoint = 2;
  bool has_checkpoint() const;
  void clear_checkpoint();
  static const int kCheckpointFieldNumber = 2;
  private:
  const ::znbase::roachpb::RangeFeedCheckpoint& _internal_checkpoint() const;
  public:
  const ::znbase::roachpb::RangeFeedCheckpoint& checkpoint() const;
  ::znbase::roachpb::RangeFeedCheckpoint* release_checkpoint();
  ::znbase::roachpb::RangeFeedCheckpoint* mutable_checkpoint();
  void set_allocated_checkpoint(::znbase::roachpb::RangeFeedCheckpoint* checkpoint);

  // .znbase.roachpb.RangeFeedError error = 3;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 3;
  private:
  const ::znbase::roachpb::RangeFeedError& _internal_error() const;
  public:
  const ::znbase::roachpb::RangeFeedError& error() const;
  ::znbase::roachpb::RangeFeedError* release_error();
  ::znbase::roachpb::RangeFeedError* mutable_error();
  void set_allocated_error(::znbase::roachpb::RangeFeedError* error);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.RangeFeedEvent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::znbase::roachpb::RangeFeedValue* val_;
  ::znbase::roachpb::RangeFeedCheckpoint* checkpoint_;
  ::znbase::roachpb::RangeFeedError* error_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VecScanRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.VecScanRequest) */ {
 public:
  VecScanRequest();
  virtual ~VecScanRequest();

  VecScanRequest(const VecScanRequest& from);

  inline VecScanRequest& operator=(const VecScanRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VecScanRequest(VecScanRequest&& from) noexcept
    : VecScanRequest() {
    *this = ::std::move(from);
  }

  inline VecScanRequest& operator=(VecScanRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const VecScanRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VecScanRequest* internal_default_instance() {
    return reinterpret_cast<const VecScanRequest*>(
               &_VecScanRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    140;

  void Swap(VecScanRequest* other);
  friend void swap(VecScanRequest& a, VecScanRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VecScanRequest* New() const final {
    return CreateMaybeMessage<VecScanRequest>(NULL);
  }

  VecScanRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VecScanRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const VecScanRequest& from);
  void MergeFrom(const VecScanRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VecScanRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  int col_ids_size() const;
  void clear_col_ids();
  static const int kColIdsFieldNumber = 4;
  ::google::protobuf::int32 col_ids(int index) const;
  void set_col_ids(int index, ::google::protobuf::int32 value);
  void add_col_ids(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      col_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_col_ids();

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::RequestHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::RequestHeader& header() const;
  ::znbase::roachpb::RequestHeader* release_header();
  ::znbase::roachpb::RequestHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::RequestHeader* header);

  // .znbase.roachpb.PushDownExpr push_down = 6;
  bool has_push_down() const;
  void clear_push_down();
  static const int kPushDownFieldNumber = 6;
  private:
  const ::znbase::roachpb::PushDownExpr& _internal_push_down() const;
  public:
  const ::znbase::roachpb::PushDownExpr& push_down() const;
  ::znbase::roachpb::PushDownExpr* release_push_down();
  ::znbase::roachpb::PushDownExpr* mutable_push_down();
  void set_allocated_push_down(::znbase::roachpb::PushDownExpr* push_down);

  // int32 override_flags = 2;
  void clear_override_flags();
  static const int kOverrideFlagsFieldNumber = 2;
  ::google::protobuf::int32 override_flags() const;
  void set_override_flags(::google::protobuf::int32 value);

  // .znbase.roachpb.ScanFormat scan_format = 3;
  void clear_scan_format();
  static const int kScanFormatFieldNumber = 3;
  ::znbase::roachpb::ScanFormat scan_format() const;
  void set_scan_format(::znbase::roachpb::ScanFormat value);

  // uint32 table_id = 5;
  void clear_table_id();
  static const int kTableIdFieldNumber = 5;
  ::google::protobuf::uint32 table_id() const;
  void set_table_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.VecScanRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > col_ids_;
  mutable int _col_ids_cached_byte_size_;
  ::znbase::roachpb::RequestHeader* header_;
  ::znbase::roachpb::PushDownExpr* push_down_;
  ::google::protobuf::int32 override_flags_;
  int scan_format_;
  ::google::protobuf::uint32 table_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VecScanResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:znbase.roachpb.VecScanResponse) */ {
 public:
  VecScanResponse();
  virtual ~VecScanResponse();

  VecScanResponse(const VecScanResponse& from);

  inline VecScanResponse& operator=(const VecScanResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VecScanResponse(VecScanResponse&& from) noexcept
    : VecScanResponse() {
    *this = ::std::move(from);
  }

  inline VecScanResponse& operator=(VecScanResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const VecScanResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VecScanResponse* internal_default_instance() {
    return reinterpret_cast<const VecScanResponse*>(
               &_VecScanResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    141;

  void Swap(VecScanResponse* other);
  friend void swap(VecScanResponse& a, VecScanResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VecScanResponse* New() const final {
    return CreateMaybeMessage<VecScanResponse>(NULL);
  }

  VecScanResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VecScanResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const VecScanResponse& from);
  void MergeFrom(const VecScanResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VecScanResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  int intent_rows_size() const;
  void clear_intent_rows();
  static const int kIntentRowsFieldNumber = 4;
  ::znbase::roachpb::KeyValue* mutable_intent_rows(int index);
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::KeyValue >*
      mutable_intent_rows();
  const ::znbase::roachpb::KeyValue& intent_rows(int index) const;
  ::znbase::roachpb::KeyValue* add_intent_rows();
  const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::KeyValue >&
      intent_rows() const;

  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::znbase::roachpb::ResponseHeader& _internal_header() const;
  public:
  const ::znbase::roachpb::ResponseHeader& header() const;
  ::znbase::roachpb::ResponseHeader* release_header();
  ::znbase::roachpb::ResponseHeader* mutable_header();
  void set_allocated_header(::znbase::roachpb::ResponseHeader* header);

  bool has_batch() const;
  void clear_batch();
  static const int kBatchFieldNumber = 3;
  private:
  const ::znbase::roachpb::VecResults& _internal_batch() const;
  public:
  const ::znbase::roachpb::VecResults& batch() const;
  ::znbase::roachpb::VecResults* release_batch();
  ::znbase::roachpb::VecResults* mutable_batch();
  void set_allocated_batch(::znbase::roachpb::VecResults* batch);

  // @@protoc_insertion_point(class_scope:znbase.roachpb.VecScanResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::KeyValue > intent_rows_;
  ::znbase::roachpb::ResponseHeader* header_;
  ::znbase::roachpb::VecResults* batch_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_roachpb_2fapi_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RangeInfo

inline bool RangeInfo::has_desc() const {
  return this != internal_default_instance() && desc_ != NULL;
}
inline const ::znbase::roachpb::RangeDescriptor& RangeInfo::_internal_desc() const {
  return *desc_;
}
inline const ::znbase::roachpb::RangeDescriptor& RangeInfo::desc() const {
  const ::znbase::roachpb::RangeDescriptor* p = desc_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.RangeInfo.desc)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RangeDescriptor*>(
      &::znbase::roachpb::_RangeDescriptor_default_instance_);
}
inline ::znbase::roachpb::RangeDescriptor* RangeInfo::release_desc() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RangeInfo.desc)
  
  ::znbase::roachpb::RangeDescriptor* temp = desc_;
  desc_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RangeDescriptor* RangeInfo::mutable_desc() {
  
  if (desc_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RangeDescriptor>(GetArenaNoVirtual());
    desc_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RangeInfo.desc)
  return desc_;
}
inline void RangeInfo::set_allocated_desc(::znbase::roachpb::RangeDescriptor* desc) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(desc_);
  }
  if (desc) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      desc = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, desc, submessage_arena);
    }
    
  } else {
    
  }
  desc_ = desc;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.RangeInfo.desc)
}

inline bool RangeInfo::has_lease() const {
  return this != internal_default_instance() && lease_ != NULL;
}
inline const ::znbase::roachpb::Lease& RangeInfo::_internal_lease() const {
  return *lease_;
}
inline const ::znbase::roachpb::Lease& RangeInfo::lease() const {
  const ::znbase::roachpb::Lease* p = lease_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.RangeInfo.lease)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::Lease*>(
      &::znbase::roachpb::_Lease_default_instance_);
}
inline ::znbase::roachpb::Lease* RangeInfo::release_lease() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RangeInfo.lease)
  
  ::znbase::roachpb::Lease* temp = lease_;
  lease_ = NULL;
  return temp;
}
inline ::znbase::roachpb::Lease* RangeInfo::mutable_lease() {
  
  if (lease_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::Lease>(GetArenaNoVirtual());
    lease_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RangeInfo.lease)
  return lease_;
}
inline void RangeInfo::set_allocated_lease(::znbase::roachpb::Lease* lease) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(lease_);
  }
  if (lease) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      lease = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lease, submessage_arena);
    }
    
  } else {
    
  }
  lease_ = lease;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.RangeInfo.lease)
}

// -------------------------------------------------------------------

// RequestHeader

inline void RequestHeader::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RequestHeader::key() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestHeader.key)
  return key_.GetNoArena();
}
inline void RequestHeader::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.RequestHeader.key)
}
#if LANG_CXX11
inline void RequestHeader::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.RequestHeader.key)
}
#endif
inline void RequestHeader::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.RequestHeader.key)
}
inline void RequestHeader::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.RequestHeader.key)
}
inline ::std::string* RequestHeader::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestHeader.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestHeader::release_key() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestHeader.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestHeader::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.RequestHeader.key)
}

inline void RequestHeader::clear_end_key() {
  end_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RequestHeader::end_key() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestHeader.end_key)
  return end_key_.GetNoArena();
}
inline void RequestHeader::set_end_key(const ::std::string& value) {
  
  end_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.RequestHeader.end_key)
}
#if LANG_CXX11
inline void RequestHeader::set_end_key(::std::string&& value) {
  
  end_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.RequestHeader.end_key)
}
#endif
inline void RequestHeader::set_end_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  end_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.RequestHeader.end_key)
}
inline void RequestHeader::set_end_key(const void* value, size_t size) {
  
  end_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.RequestHeader.end_key)
}
inline ::std::string* RequestHeader::mutable_end_key() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestHeader.end_key)
  return end_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestHeader::release_end_key() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestHeader.end_key)
  
  return end_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestHeader::set_allocated_end_key(::std::string* end_key) {
  if (end_key != NULL) {
    
  } else {
    
  }
  end_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), end_key);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.RequestHeader.end_key)
}

inline void RequestHeader::clear_sequence() {
  sequence_ = 0;
}
inline ::google::protobuf::int32 RequestHeader::sequence() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestHeader.sequence)
  return sequence_;
}
inline void RequestHeader::set_sequence(::google::protobuf::int32 value) {
  
  sequence_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.RequestHeader.sequence)
}

// -------------------------------------------------------------------

// ResponseHeader

// .znbase.roachpb.Transaction txn = 3;
inline bool ResponseHeader::has_txn() const {
  return this != internal_default_instance() && txn_ != NULL;
}
inline const ::znbase::roachpb::Transaction& ResponseHeader::_internal_txn() const {
  return *txn_;
}
inline const ::znbase::roachpb::Transaction& ResponseHeader::txn() const {
  const ::znbase::roachpb::Transaction* p = txn_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseHeader.txn)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::Transaction*>(
      &::znbase::roachpb::_Transaction_default_instance_);
}
inline ::znbase::roachpb::Transaction* ResponseHeader::release_txn() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseHeader.txn)
  
  ::znbase::roachpb::Transaction* temp = txn_;
  txn_ = NULL;
  return temp;
}
inline ::znbase::roachpb::Transaction* ResponseHeader::mutable_txn() {
  
  if (txn_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::Transaction>(GetArenaNoVirtual());
    txn_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseHeader.txn)
  return txn_;
}
inline void ResponseHeader::set_allocated_txn(::znbase::roachpb::Transaction* txn) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(txn_);
  }
  if (txn) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      txn = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, txn, submessage_arena);
    }
    
  } else {
    
  }
  txn_ = txn;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ResponseHeader.txn)
}

// .znbase.roachpb.Span resume_span = 4;
inline bool ResponseHeader::has_resume_span() const {
  return this != internal_default_instance() && resume_span_ != NULL;
}
inline const ::znbase::roachpb::Span& ResponseHeader::_internal_resume_span() const {
  return *resume_span_;
}
inline const ::znbase::roachpb::Span& ResponseHeader::resume_span() const {
  const ::znbase::roachpb::Span* p = resume_span_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseHeader.resume_span)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::Span*>(
      &::znbase::roachpb::_Span_default_instance_);
}
inline ::znbase::roachpb::Span* ResponseHeader::release_resume_span() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseHeader.resume_span)
  
  ::znbase::roachpb::Span* temp = resume_span_;
  resume_span_ = NULL;
  return temp;
}
inline ::znbase::roachpb::Span* ResponseHeader::mutable_resume_span() {
  
  if (resume_span_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::Span>(GetArenaNoVirtual());
    resume_span_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseHeader.resume_span)
  return resume_span_;
}
inline void ResponseHeader::set_allocated_resume_span(::znbase::roachpb::Span* resume_span) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(resume_span_);
  }
  if (resume_span) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      resume_span = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resume_span, submessage_arena);
    }
    
  } else {
    
  }
  resume_span_ = resume_span;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ResponseHeader.resume_span)
}

// .znbase.roachpb.ResponseHeader.ResumeReason resume_reason = 7;
inline void ResponseHeader::clear_resume_reason() {
  resume_reason_ = 0;
}
inline ::znbase::roachpb::ResponseHeader_ResumeReason ResponseHeader::resume_reason() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseHeader.resume_reason)
  return static_cast< ::znbase::roachpb::ResponseHeader_ResumeReason >(resume_reason_);
}
inline void ResponseHeader::set_resume_reason(::znbase::roachpb::ResponseHeader_ResumeReason value) {
  
  resume_reason_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.ResponseHeader.resume_reason)
}

// int64 num_keys = 5;
inline void ResponseHeader::clear_num_keys() {
  num_keys_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ResponseHeader::num_keys() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseHeader.num_keys)
  return num_keys_;
}
inline void ResponseHeader::set_num_keys(::google::protobuf::int64 value) {
  
  num_keys_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.ResponseHeader.num_keys)
}

inline int ResponseHeader::range_infos_size() const {
  return range_infos_.size();
}
inline void ResponseHeader::clear_range_infos() {
  range_infos_.Clear();
}
inline ::znbase::roachpb::RangeInfo* ResponseHeader::mutable_range_infos(int index) {
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseHeader.range_infos)
  return range_infos_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::RangeInfo >*
ResponseHeader::mutable_range_infos() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.ResponseHeader.range_infos)
  return &range_infos_;
}
inline const ::znbase::roachpb::RangeInfo& ResponseHeader::range_infos(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseHeader.range_infos)
  return range_infos_.Get(index);
}
inline ::znbase::roachpb::RangeInfo* ResponseHeader::add_range_infos() {
  // @@protoc_insertion_point(field_add:znbase.roachpb.ResponseHeader.range_infos)
  return range_infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::RangeInfo >&
ResponseHeader::range_infos() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.ResponseHeader.range_infos)
  return range_infos_;
}

// -------------------------------------------------------------------

// GetRequest

inline bool GetRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& GetRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& GetRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.GetRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* GetRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.GetRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* GetRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.GetRequest.header)
  return header_;
}
inline void GetRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.GetRequest.header)
}

// -------------------------------------------------------------------

// GetResponse

inline bool GetResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& GetResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& GetResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.GetResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* GetResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.GetResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* GetResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.GetResponse.header)
  return header_;
}
inline void GetResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.GetResponse.header)
}

// .znbase.roachpb.Value value = 2;
inline bool GetResponse::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline const ::znbase::roachpb::Value& GetResponse::_internal_value() const {
  return *value_;
}
inline const ::znbase::roachpb::Value& GetResponse::value() const {
  const ::znbase::roachpb::Value* p = value_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.GetResponse.value)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::Value*>(
      &::znbase::roachpb::_Value_default_instance_);
}
inline ::znbase::roachpb::Value* GetResponse::release_value() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.GetResponse.value)
  
  ::znbase::roachpb::Value* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::znbase::roachpb::Value* GetResponse::mutable_value() {
  
  if (value_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::Value>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.GetResponse.value)
  return value_;
}
inline void GetResponse::set_allocated_value(::znbase::roachpb::Value* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(value_);
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.GetResponse.value)
}

// .znbase.roachpb.Value intent_value = 3;
inline bool GetResponse::has_intent_value() const {
  return this != internal_default_instance() && intent_value_ != NULL;
}
inline const ::znbase::roachpb::Value& GetResponse::_internal_intent_value() const {
  return *intent_value_;
}
inline const ::znbase::roachpb::Value& GetResponse::intent_value() const {
  const ::znbase::roachpb::Value* p = intent_value_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.GetResponse.intent_value)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::Value*>(
      &::znbase::roachpb::_Value_default_instance_);
}
inline ::znbase::roachpb::Value* GetResponse::release_intent_value() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.GetResponse.intent_value)
  
  ::znbase::roachpb::Value* temp = intent_value_;
  intent_value_ = NULL;
  return temp;
}
inline ::znbase::roachpb::Value* GetResponse::mutable_intent_value() {
  
  if (intent_value_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::Value>(GetArenaNoVirtual());
    intent_value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.GetResponse.intent_value)
  return intent_value_;
}
inline void GetResponse::set_allocated_intent_value(::znbase::roachpb::Value* intent_value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(intent_value_);
  }
  if (intent_value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      intent_value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, intent_value, submessage_arena);
    }
    
  } else {
    
  }
  intent_value_ = intent_value;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.GetResponse.intent_value)
}

// -------------------------------------------------------------------

// PutRequest

inline bool PutRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void PutRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& PutRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& PutRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.PutRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* PutRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.PutRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* PutRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.PutRequest.header)
  return header_;
}
inline void PutRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.PutRequest.header)
}

inline bool PutRequest::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline const ::znbase::roachpb::Value& PutRequest::_internal_value() const {
  return *value_;
}
inline const ::znbase::roachpb::Value& PutRequest::value() const {
  const ::znbase::roachpb::Value* p = value_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.PutRequest.value)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::Value*>(
      &::znbase::roachpb::_Value_default_instance_);
}
inline ::znbase::roachpb::Value* PutRequest::release_value() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.PutRequest.value)
  
  ::znbase::roachpb::Value* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::znbase::roachpb::Value* PutRequest::mutable_value() {
  
  if (value_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::Value>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.PutRequest.value)
  return value_;
}
inline void PutRequest::set_allocated_value(::znbase::roachpb::Value* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(value_);
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.PutRequest.value)
}

// bool inline = 3;
inline void PutRequest::clear_inline_() {
  inline__ = false;
}
inline bool PutRequest::inline_() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.PutRequest.inline)
  return inline__;
}
inline void PutRequest::set_inline_(bool value) {
  
  inline__ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.PutRequest.inline)
}

// bool blind = 4;
inline void PutRequest::clear_blind() {
  blind_ = false;
}
inline bool PutRequest::blind() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.PutRequest.blind)
  return blind_;
}
inline void PutRequest::set_blind(bool value) {
  
  blind_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.PutRequest.blind)
}

// bool original = 5;
inline void PutRequest::clear_original() {
  original_ = false;
}
inline bool PutRequest::original() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.PutRequest.original)
  return original_;
}
inline void PutRequest::set_original(bool value) {
  
  original_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.PutRequest.original)
}

// .znbase.util.hlc.Timestamp key_timestamp = 6;
inline bool PutRequest::has_key_timestamp() const {
  return this != internal_default_instance() && key_timestamp_ != NULL;
}
inline const ::znbase::util::hlc::Timestamp& PutRequest::_internal_key_timestamp() const {
  return *key_timestamp_;
}
inline const ::znbase::util::hlc::Timestamp& PutRequest::key_timestamp() const {
  const ::znbase::util::hlc::Timestamp* p = key_timestamp_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.PutRequest.key_timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::util::hlc::Timestamp*>(
      &::znbase::util::hlc::_Timestamp_default_instance_);
}
inline ::znbase::util::hlc::Timestamp* PutRequest::release_key_timestamp() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.PutRequest.key_timestamp)
  
  ::znbase::util::hlc::Timestamp* temp = key_timestamp_;
  key_timestamp_ = NULL;
  return temp;
}
inline ::znbase::util::hlc::Timestamp* PutRequest::mutable_key_timestamp() {
  
  if (key_timestamp_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::util::hlc::Timestamp>(GetArenaNoVirtual());
    key_timestamp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.PutRequest.key_timestamp)
  return key_timestamp_;
}
inline void PutRequest::set_allocated_key_timestamp(::znbase::util::hlc::Timestamp* key_timestamp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(key_timestamp_);
  }
  if (key_timestamp) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      key_timestamp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, key_timestamp, submessage_arena);
    }
    
  } else {
    
  }
  key_timestamp_ = key_timestamp;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.PutRequest.key_timestamp)
}

// -------------------------------------------------------------------

// PutResponse

inline bool PutResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void PutResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& PutResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& PutResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.PutResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* PutResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.PutResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* PutResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.PutResponse.header)
  return header_;
}
inline void PutResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.PutResponse.header)
}

// -------------------------------------------------------------------

// ConditionalPutRequest

inline bool ConditionalPutRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ConditionalPutRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& ConditionalPutRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& ConditionalPutRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.ConditionalPutRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* ConditionalPutRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ConditionalPutRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* ConditionalPutRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ConditionalPutRequest.header)
  return header_;
}
inline void ConditionalPutRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ConditionalPutRequest.header)
}

inline bool ConditionalPutRequest::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline const ::znbase::roachpb::Value& ConditionalPutRequest::_internal_value() const {
  return *value_;
}
inline const ::znbase::roachpb::Value& ConditionalPutRequest::value() const {
  const ::znbase::roachpb::Value* p = value_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.ConditionalPutRequest.value)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::Value*>(
      &::znbase::roachpb::_Value_default_instance_);
}
inline ::znbase::roachpb::Value* ConditionalPutRequest::release_value() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ConditionalPutRequest.value)
  
  ::znbase::roachpb::Value* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::znbase::roachpb::Value* ConditionalPutRequest::mutable_value() {
  
  if (value_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::Value>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ConditionalPutRequest.value)
  return value_;
}
inline void ConditionalPutRequest::set_allocated_value(::znbase::roachpb::Value* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(value_);
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ConditionalPutRequest.value)
}

// .znbase.roachpb.Value exp_value = 3;
inline bool ConditionalPutRequest::has_exp_value() const {
  return this != internal_default_instance() && exp_value_ != NULL;
}
inline const ::znbase::roachpb::Value& ConditionalPutRequest::_internal_exp_value() const {
  return *exp_value_;
}
inline const ::znbase::roachpb::Value& ConditionalPutRequest::exp_value() const {
  const ::znbase::roachpb::Value* p = exp_value_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.ConditionalPutRequest.exp_value)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::Value*>(
      &::znbase::roachpb::_Value_default_instance_);
}
inline ::znbase::roachpb::Value* ConditionalPutRequest::release_exp_value() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ConditionalPutRequest.exp_value)
  
  ::znbase::roachpb::Value* temp = exp_value_;
  exp_value_ = NULL;
  return temp;
}
inline ::znbase::roachpb::Value* ConditionalPutRequest::mutable_exp_value() {
  
  if (exp_value_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::Value>(GetArenaNoVirtual());
    exp_value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ConditionalPutRequest.exp_value)
  return exp_value_;
}
inline void ConditionalPutRequest::set_allocated_exp_value(::znbase::roachpb::Value* exp_value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(exp_value_);
  }
  if (exp_value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      exp_value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, exp_value, submessage_arena);
    }
    
  } else {
    
  }
  exp_value_ = exp_value;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ConditionalPutRequest.exp_value)
}

// bool blind = 4;
inline void ConditionalPutRequest::clear_blind() {
  blind_ = false;
}
inline bool ConditionalPutRequest::blind() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ConditionalPutRequest.blind)
  return blind_;
}
inline void ConditionalPutRequest::set_blind(bool value) {
  
  blind_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.ConditionalPutRequest.blind)
}

// bool allow_if_does_not_exist = 5;
inline void ConditionalPutRequest::clear_allow_if_does_not_exist() {
  allow_if_does_not_exist_ = false;
}
inline bool ConditionalPutRequest::allow_if_does_not_exist() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ConditionalPutRequest.allow_if_does_not_exist)
  return allow_if_does_not_exist_;
}
inline void ConditionalPutRequest::set_allow_if_does_not_exist(bool value) {
  
  allow_if_does_not_exist_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.ConditionalPutRequest.allow_if_does_not_exist)
}

// -------------------------------------------------------------------

// ConditionalPutResponse

inline bool ConditionalPutResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ConditionalPutResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& ConditionalPutResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& ConditionalPutResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.ConditionalPutResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* ConditionalPutResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ConditionalPutResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* ConditionalPutResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ConditionalPutResponse.header)
  return header_;
}
inline void ConditionalPutResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ConditionalPutResponse.header)
}

// -------------------------------------------------------------------

// InitPutRequest

inline bool InitPutRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void InitPutRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& InitPutRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& InitPutRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.InitPutRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* InitPutRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.InitPutRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* InitPutRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.InitPutRequest.header)
  return header_;
}
inline void InitPutRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.InitPutRequest.header)
}

inline bool InitPutRequest::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline const ::znbase::roachpb::Value& InitPutRequest::_internal_value() const {
  return *value_;
}
inline const ::znbase::roachpb::Value& InitPutRequest::value() const {
  const ::znbase::roachpb::Value* p = value_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.InitPutRequest.value)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::Value*>(
      &::znbase::roachpb::_Value_default_instance_);
}
inline ::znbase::roachpb::Value* InitPutRequest::release_value() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.InitPutRequest.value)
  
  ::znbase::roachpb::Value* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::znbase::roachpb::Value* InitPutRequest::mutable_value() {
  
  if (value_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::Value>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.InitPutRequest.value)
  return value_;
}
inline void InitPutRequest::set_allocated_value(::znbase::roachpb::Value* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(value_);
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.InitPutRequest.value)
}

// bool blind = 3;
inline void InitPutRequest::clear_blind() {
  blind_ = false;
}
inline bool InitPutRequest::blind() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.InitPutRequest.blind)
  return blind_;
}
inline void InitPutRequest::set_blind(bool value) {
  
  blind_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.InitPutRequest.blind)
}

// bool failOnTombstones = 4;
inline void InitPutRequest::clear_failontombstones() {
  failontombstones_ = false;
}
inline bool InitPutRequest::failontombstones() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.InitPutRequest.failOnTombstones)
  return failontombstones_;
}
inline void InitPutRequest::set_failontombstones(bool value) {
  
  failontombstones_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.InitPutRequest.failOnTombstones)
}

// -------------------------------------------------------------------

// InitPutResponse

inline bool InitPutResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void InitPutResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& InitPutResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& InitPutResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.InitPutResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* InitPutResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.InitPutResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* InitPutResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.InitPutResponse.header)
  return header_;
}
inline void InitPutResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.InitPutResponse.header)
}

// -------------------------------------------------------------------

// IncrementRequest

inline bool IncrementRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void IncrementRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& IncrementRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& IncrementRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.IncrementRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* IncrementRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.IncrementRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* IncrementRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.IncrementRequest.header)
  return header_;
}
inline void IncrementRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.IncrementRequest.header)
}

// int64 increment = 2;
inline void IncrementRequest::clear_increment() {
  increment_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 IncrementRequest::increment() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.IncrementRequest.increment)
  return increment_;
}
inline void IncrementRequest::set_increment(::google::protobuf::int64 value) {
  
  increment_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.IncrementRequest.increment)
}

// -------------------------------------------------------------------

// IncrementResponse

inline bool IncrementResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void IncrementResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& IncrementResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& IncrementResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.IncrementResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* IncrementResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.IncrementResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* IncrementResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.IncrementResponse.header)
  return header_;
}
inline void IncrementResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.IncrementResponse.header)
}

// int64 new_value = 2;
inline void IncrementResponse::clear_new_value() {
  new_value_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 IncrementResponse::new_value() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.IncrementResponse.new_value)
  return new_value_;
}
inline void IncrementResponse::set_new_value(::google::protobuf::int64 value) {
  
  new_value_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.IncrementResponse.new_value)
}

// -------------------------------------------------------------------

// DeleteRequest

inline bool DeleteRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DeleteRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& DeleteRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& DeleteRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.DeleteRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* DeleteRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DeleteRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* DeleteRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DeleteRequest.header)
  return header_;
}
inline void DeleteRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DeleteRequest.header)
}

// -------------------------------------------------------------------

// DeleteResponse

inline bool DeleteResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DeleteResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& DeleteResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& DeleteResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.DeleteResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* DeleteResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DeleteResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* DeleteResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DeleteResponse.header)
  return header_;
}
inline void DeleteResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DeleteResponse.header)
}

// -------------------------------------------------------------------

// DeleteRangeRequest

inline bool DeleteRangeRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DeleteRangeRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& DeleteRangeRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& DeleteRangeRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.DeleteRangeRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* DeleteRangeRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DeleteRangeRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* DeleteRangeRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DeleteRangeRequest.header)
  return header_;
}
inline void DeleteRangeRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DeleteRangeRequest.header)
}

// bool return_keys = 3;
inline void DeleteRangeRequest::clear_return_keys() {
  return_keys_ = false;
}
inline bool DeleteRangeRequest::return_keys() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DeleteRangeRequest.return_keys)
  return return_keys_;
}
inline void DeleteRangeRequest::set_return_keys(bool value) {
  
  return_keys_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.DeleteRangeRequest.return_keys)
}

// bool inline = 4;
inline void DeleteRangeRequest::clear_inline_() {
  inline__ = false;
}
inline bool DeleteRangeRequest::inline_() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DeleteRangeRequest.inline)
  return inline__;
}
inline void DeleteRangeRequest::set_inline_(bool value) {
  
  inline__ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.DeleteRangeRequest.inline)
}

// -------------------------------------------------------------------

// DeleteRangeResponse

inline bool DeleteRangeResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DeleteRangeResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& DeleteRangeResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& DeleteRangeResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.DeleteRangeResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* DeleteRangeResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DeleteRangeResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* DeleteRangeResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DeleteRangeResponse.header)
  return header_;
}
inline void DeleteRangeResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DeleteRangeResponse.header)
}

inline int DeleteRangeResponse::keys_size() const {
  return keys_.size();
}
inline void DeleteRangeResponse::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& DeleteRangeResponse::keys(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DeleteRangeResponse.keys)
  return keys_.Get(index);
}
inline ::std::string* DeleteRangeResponse::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DeleteRangeResponse.keys)
  return keys_.Mutable(index);
}
inline void DeleteRangeResponse::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:znbase.roachpb.DeleteRangeResponse.keys)
  keys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void DeleteRangeResponse::set_keys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:znbase.roachpb.DeleteRangeResponse.keys)
  keys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void DeleteRangeResponse::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.DeleteRangeResponse.keys)
}
inline void DeleteRangeResponse::set_keys(int index, const void* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.DeleteRangeResponse.keys)
}
inline ::std::string* DeleteRangeResponse::add_keys() {
  // @@protoc_insertion_point(field_add_mutable:znbase.roachpb.DeleteRangeResponse.keys)
  return keys_.Add();
}
inline void DeleteRangeResponse::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:znbase.roachpb.DeleteRangeResponse.keys)
}
#if LANG_CXX11
inline void DeleteRangeResponse::add_keys(::std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:znbase.roachpb.DeleteRangeResponse.keys)
}
#endif
inline void DeleteRangeResponse::add_keys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:znbase.roachpb.DeleteRangeResponse.keys)
}
inline void DeleteRangeResponse::add_keys(const void* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:znbase.roachpb.DeleteRangeResponse.keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DeleteRangeResponse::keys() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.DeleteRangeResponse.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DeleteRangeResponse::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.DeleteRangeResponse.keys)
  return &keys_;
}

// -------------------------------------------------------------------

// ClearRangeRequest

inline bool ClearRangeRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ClearRangeRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& ClearRangeRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& ClearRangeRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.ClearRangeRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* ClearRangeRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ClearRangeRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* ClearRangeRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ClearRangeRequest.header)
  return header_;
}
inline void ClearRangeRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ClearRangeRequest.header)
}

// -------------------------------------------------------------------

// ClearRangeResponse

inline bool ClearRangeResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ClearRangeResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& ClearRangeResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& ClearRangeResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.ClearRangeResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* ClearRangeResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ClearRangeResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* ClearRangeResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ClearRangeResponse.header)
  return header_;
}
inline void ClearRangeResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ClearRangeResponse.header)
}

// -------------------------------------------------------------------

// RevertRangeRequest

inline bool RevertRangeRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void RevertRangeRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& RevertRangeRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& RevertRangeRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.RevertRangeRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* RevertRangeRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RevertRangeRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* RevertRangeRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RevertRangeRequest.header)
  return header_;
}
inline void RevertRangeRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.RevertRangeRequest.header)
}

inline bool RevertRangeRequest::has_target_time() const {
  return this != internal_default_instance() && target_time_ != NULL;
}
inline const ::znbase::util::hlc::Timestamp& RevertRangeRequest::_internal_target_time() const {
  return *target_time_;
}
inline const ::znbase::util::hlc::Timestamp& RevertRangeRequest::target_time() const {
  const ::znbase::util::hlc::Timestamp* p = target_time_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.RevertRangeRequest.target_time)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::util::hlc::Timestamp*>(
      &::znbase::util::hlc::_Timestamp_default_instance_);
}
inline ::znbase::util::hlc::Timestamp* RevertRangeRequest::release_target_time() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RevertRangeRequest.target_time)
  
  ::znbase::util::hlc::Timestamp* temp = target_time_;
  target_time_ = NULL;
  return temp;
}
inline ::znbase::util::hlc::Timestamp* RevertRangeRequest::mutable_target_time() {
  
  if (target_time_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::util::hlc::Timestamp>(GetArenaNoVirtual());
    target_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RevertRangeRequest.target_time)
  return target_time_;
}
inline void RevertRangeRequest::set_allocated_target_time(::znbase::util::hlc::Timestamp* target_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(target_time_);
  }
  if (target_time) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      target_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, target_time, submessage_arena);
    }
    
  } else {
    
  }
  target_time_ = target_time;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.RevertRangeRequest.target_time)
}

// -------------------------------------------------------------------

// RevertRangeResponse

inline bool RevertRangeResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void RevertRangeResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& RevertRangeResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& RevertRangeResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.RevertRangeResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* RevertRangeResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RevertRangeResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* RevertRangeResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RevertRangeResponse.header)
  return header_;
}
inline void RevertRangeResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.RevertRangeResponse.header)
}

// -------------------------------------------------------------------

// QueryLockRequest

inline bool QueryLockRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void QueryLockRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& QueryLockRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& QueryLockRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.QueryLockRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* QueryLockRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.QueryLockRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* QueryLockRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.QueryLockRequest.header)
  return header_;
}
inline void QueryLockRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.QueryLockRequest.header)
}

// string transaction_id = 2;
inline void QueryLockRequest::clear_transaction_id() {
  transaction_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& QueryLockRequest::transaction_id() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.QueryLockRequest.transaction_id)
  return transaction_id_.GetNoArena();
}
inline void QueryLockRequest::set_transaction_id(const ::std::string& value) {
  
  transaction_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.QueryLockRequest.transaction_id)
}
#if LANG_CXX11
inline void QueryLockRequest::set_transaction_id(::std::string&& value) {
  
  transaction_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.QueryLockRequest.transaction_id)
}
#endif
inline void QueryLockRequest::set_transaction_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  transaction_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.QueryLockRequest.transaction_id)
}
inline void QueryLockRequest::set_transaction_id(const char* value, size_t size) {
  
  transaction_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.QueryLockRequest.transaction_id)
}
inline ::std::string* QueryLockRequest::mutable_transaction_id() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.QueryLockRequest.transaction_id)
  return transaction_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* QueryLockRequest::release_transaction_id() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.QueryLockRequest.transaction_id)
  
  return transaction_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void QueryLockRequest::set_allocated_transaction_id(::std::string* transaction_id) {
  if (transaction_id != NULL) {
    
  } else {
    
  }
  transaction_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), transaction_id);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.QueryLockRequest.transaction_id)
}

// bool scan_intent = 3;
inline void QueryLockRequest::clear_scan_intent() {
  scan_intent_ = false;
}
inline bool QueryLockRequest::scan_intent() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.QueryLockRequest.scan_intent)
  return scan_intent_;
}
inline void QueryLockRequest::set_scan_intent(bool value) {
  
  scan_intent_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.QueryLockRequest.scan_intent)
}

// -------------------------------------------------------------------

// QueryLockResponse

inline bool QueryLockResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void QueryLockResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& QueryLockResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& QueryLockResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.QueryLockResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* QueryLockResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.QueryLockResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* QueryLockResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.QueryLockResponse.header)
  return header_;
}
inline void QueryLockResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.QueryLockResponse.header)
}

// bool durability_replicated = 2;
inline void QueryLockResponse::clear_durability_replicated() {
  durability_replicated_ = false;
}
inline bool QueryLockResponse::durability_replicated() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.QueryLockResponse.durability_replicated)
  return durability_replicated_;
}
inline void QueryLockResponse::set_durability_replicated(bool value) {
  
  durability_replicated_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.QueryLockResponse.durability_replicated)
}

// bool durability_unreplicated = 3;
inline void QueryLockResponse::clear_durability_unreplicated() {
  durability_unreplicated_ = false;
}
inline bool QueryLockResponse::durability_unreplicated() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.QueryLockResponse.durability_unreplicated)
  return durability_unreplicated_;
}
inline void QueryLockResponse::set_durability_unreplicated(bool value) {
  
  durability_unreplicated_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.QueryLockResponse.durability_unreplicated)
}

// .znbase.roachpb.Span k_vspan = 4;
inline bool QueryLockResponse::has_k_vspan() const {
  return this != internal_default_instance() && k_vspan_ != NULL;
}
inline const ::znbase::roachpb::Span& QueryLockResponse::_internal_k_vspan() const {
  return *k_vspan_;
}
inline const ::znbase::roachpb::Span& QueryLockResponse::k_vspan() const {
  const ::znbase::roachpb::Span* p = k_vspan_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.QueryLockResponse.k_vspan)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::Span*>(
      &::znbase::roachpb::_Span_default_instance_);
}
inline ::znbase::roachpb::Span* QueryLockResponse::release_k_vspan() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.QueryLockResponse.k_vspan)
  
  ::znbase::roachpb::Span* temp = k_vspan_;
  k_vspan_ = NULL;
  return temp;
}
inline ::znbase::roachpb::Span* QueryLockResponse::mutable_k_vspan() {
  
  if (k_vspan_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::Span>(GetArenaNoVirtual());
    k_vspan_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.QueryLockResponse.k_vspan)
  return k_vspan_;
}
inline void QueryLockResponse::set_allocated_k_vspan(::znbase::roachpb::Span* k_vspan) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(k_vspan_);
  }
  if (k_vspan) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      k_vspan = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, k_vspan, submessage_arena);
    }
    
  } else {
    
  }
  k_vspan_ = k_vspan;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.QueryLockResponse.k_vspan)
}

// repeated bytes intent_keys = 5;
inline int QueryLockResponse::intent_keys_size() const {
  return intent_keys_.size();
}
inline void QueryLockResponse::clear_intent_keys() {
  intent_keys_.Clear();
}
inline const ::std::string& QueryLockResponse::intent_keys(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.QueryLockResponse.intent_keys)
  return intent_keys_.Get(index);
}
inline ::std::string* QueryLockResponse::mutable_intent_keys(int index) {
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.QueryLockResponse.intent_keys)
  return intent_keys_.Mutable(index);
}
inline void QueryLockResponse::set_intent_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:znbase.roachpb.QueryLockResponse.intent_keys)
  intent_keys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void QueryLockResponse::set_intent_keys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:znbase.roachpb.QueryLockResponse.intent_keys)
  intent_keys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void QueryLockResponse::set_intent_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  intent_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.QueryLockResponse.intent_keys)
}
inline void QueryLockResponse::set_intent_keys(int index, const void* value, size_t size) {
  intent_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.QueryLockResponse.intent_keys)
}
inline ::std::string* QueryLockResponse::add_intent_keys() {
  // @@protoc_insertion_point(field_add_mutable:znbase.roachpb.QueryLockResponse.intent_keys)
  return intent_keys_.Add();
}
inline void QueryLockResponse::add_intent_keys(const ::std::string& value) {
  intent_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:znbase.roachpb.QueryLockResponse.intent_keys)
}
#if LANG_CXX11
inline void QueryLockResponse::add_intent_keys(::std::string&& value) {
  intent_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:znbase.roachpb.QueryLockResponse.intent_keys)
}
#endif
inline void QueryLockResponse::add_intent_keys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  intent_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:znbase.roachpb.QueryLockResponse.intent_keys)
}
inline void QueryLockResponse::add_intent_keys(const void* value, size_t size) {
  intent_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:znbase.roachpb.QueryLockResponse.intent_keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
QueryLockResponse::intent_keys() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.QueryLockResponse.intent_keys)
  return intent_keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
QueryLockResponse::mutable_intent_keys() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.QueryLockResponse.intent_keys)
  return &intent_keys_;
}

// -------------------------------------------------------------------

// ScanOptions

// bool stop_at_range_boundary = 1;
inline void ScanOptions::clear_stop_at_range_boundary() {
  stop_at_range_boundary_ = false;
}
inline bool ScanOptions::stop_at_range_boundary() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ScanOptions.stop_at_range_boundary)
  return stop_at_range_boundary_;
}
inline void ScanOptions::set_stop_at_range_boundary(bool value) {
  
  stop_at_range_boundary_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.ScanOptions.stop_at_range_boundary)
}

// int64 min_results = 2;
inline void ScanOptions::clear_min_results() {
  min_results_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ScanOptions::min_results() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ScanOptions.min_results)
  return min_results_;
}
inline void ScanOptions::set_min_results(::google::protobuf::int64 value) {
  
  min_results_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.ScanOptions.min_results)
}

// -------------------------------------------------------------------

// ScanRequest

inline bool ScanRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ScanRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& ScanRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& ScanRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.ScanRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* ScanRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ScanRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* ScanRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ScanRequest.header)
  return header_;
}
inline void ScanRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ScanRequest.header)
}

// bool replicationTable = 3;
inline void ScanRequest::clear_replicationtable() {
  replicationtable_ = false;
}
inline bool ScanRequest::replicationtable() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ScanRequest.replicationTable)
  return replicationtable_;
}
inline void ScanRequest::set_replicationtable(bool value) {
  
  replicationtable_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.ScanRequest.replicationTable)
}

// .znbase.roachpb.ScanFormat scan_format = 4;
inline void ScanRequest::clear_scan_format() {
  scan_format_ = 0;
}
inline ::znbase::roachpb::ScanFormat ScanRequest::scan_format() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ScanRequest.scan_format)
  return static_cast< ::znbase::roachpb::ScanFormat >(scan_format_);
}
inline void ScanRequest::set_scan_format(::znbase::roachpb::ScanFormat value) {
  
  scan_format_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.ScanRequest.scan_format)
}

// bool NeedMeta = 5;
inline void ScanRequest::clear_needmeta() {
  needmeta_ = false;
}
inline bool ScanRequest::needmeta() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ScanRequest.NeedMeta)
  return needmeta_;
}
inline void ScanRequest::set_needmeta(bool value) {
  
  needmeta_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.ScanRequest.NeedMeta)
}

// .znbase.storage.concurrency.lock.Strength key_locking = 6;
inline void ScanRequest::clear_key_locking() {
  key_locking_ = 0;
}
inline ::znbase::storage::concurrency::lock::Strength ScanRequest::key_locking() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ScanRequest.key_locking)
  return static_cast< ::znbase::storage::concurrency::lock::Strength >(key_locking_);
}
inline void ScanRequest::set_key_locking(::znbase::storage::concurrency::lock::Strength value) {
  
  key_locking_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.ScanRequest.key_locking)
}

// -------------------------------------------------------------------

// ScanResponse

inline bool ScanResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ScanResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& ScanResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& ScanResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.ScanResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* ScanResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ScanResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* ScanResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ScanResponse.header)
  return header_;
}
inline void ScanResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ScanResponse.header)
}

inline int ScanResponse::rows_size() const {
  return rows_.size();
}
inline ::znbase::roachpb::KeyValue* ScanResponse::mutable_rows(int index) {
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ScanResponse.rows)
  return rows_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::KeyValue >*
ScanResponse::mutable_rows() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.ScanResponse.rows)
  return &rows_;
}
inline const ::znbase::roachpb::KeyValue& ScanResponse::rows(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ScanResponse.rows)
  return rows_.Get(index);
}
inline ::znbase::roachpb::KeyValue* ScanResponse::add_rows() {
  // @@protoc_insertion_point(field_add:znbase.roachpb.ScanResponse.rows)
  return rows_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::KeyValue >&
ScanResponse::rows() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.ScanResponse.rows)
  return rows_;
}

inline int ScanResponse::intent_rows_size() const {
  return intent_rows_.size();
}
inline ::znbase::roachpb::KeyValue* ScanResponse::mutable_intent_rows(int index) {
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ScanResponse.intent_rows)
  return intent_rows_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::KeyValue >*
ScanResponse::mutable_intent_rows() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.ScanResponse.intent_rows)
  return &intent_rows_;
}
inline const ::znbase::roachpb::KeyValue& ScanResponse::intent_rows(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ScanResponse.intent_rows)
  return intent_rows_.Get(index);
}
inline ::znbase::roachpb::KeyValue* ScanResponse::add_intent_rows() {
  // @@protoc_insertion_point(field_add:znbase.roachpb.ScanResponse.intent_rows)
  return intent_rows_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::KeyValue >&
ScanResponse::intent_rows() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.ScanResponse.intent_rows)
  return intent_rows_;
}

// repeated bytes batch_responses = 4;
inline int ScanResponse::batch_responses_size() const {
  return batch_responses_.size();
}
inline void ScanResponse::clear_batch_responses() {
  batch_responses_.Clear();
}
inline const ::std::string& ScanResponse::batch_responses(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ScanResponse.batch_responses)
  return batch_responses_.Get(index);
}
inline ::std::string* ScanResponse::mutable_batch_responses(int index) {
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ScanResponse.batch_responses)
  return batch_responses_.Mutable(index);
}
inline void ScanResponse::set_batch_responses(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:znbase.roachpb.ScanResponse.batch_responses)
  batch_responses_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ScanResponse::set_batch_responses(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:znbase.roachpb.ScanResponse.batch_responses)
  batch_responses_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ScanResponse::set_batch_responses(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  batch_responses_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.ScanResponse.batch_responses)
}
inline void ScanResponse::set_batch_responses(int index, const void* value, size_t size) {
  batch_responses_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.ScanResponse.batch_responses)
}
inline ::std::string* ScanResponse::add_batch_responses() {
  // @@protoc_insertion_point(field_add_mutable:znbase.roachpb.ScanResponse.batch_responses)
  return batch_responses_.Add();
}
inline void ScanResponse::add_batch_responses(const ::std::string& value) {
  batch_responses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:znbase.roachpb.ScanResponse.batch_responses)
}
#if LANG_CXX11
inline void ScanResponse::add_batch_responses(::std::string&& value) {
  batch_responses_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:znbase.roachpb.ScanResponse.batch_responses)
}
#endif
inline void ScanResponse::add_batch_responses(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  batch_responses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:znbase.roachpb.ScanResponse.batch_responses)
}
inline void ScanResponse::add_batch_responses(const void* value, size_t size) {
  batch_responses_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:znbase.roachpb.ScanResponse.batch_responses)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ScanResponse::batch_responses() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.ScanResponse.batch_responses)
  return batch_responses_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ScanResponse::mutable_batch_responses() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.ScanResponse.batch_responses)
  return &batch_responses_;
}

// -------------------------------------------------------------------

// ReverseScanRequest

inline bool ReverseScanRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ReverseScanRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& ReverseScanRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& ReverseScanRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.ReverseScanRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* ReverseScanRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ReverseScanRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* ReverseScanRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ReverseScanRequest.header)
  return header_;
}
inline void ReverseScanRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ReverseScanRequest.header)
}

// bool replicationTable = 3;
inline void ReverseScanRequest::clear_replicationtable() {
  replicationtable_ = false;
}
inline bool ReverseScanRequest::replicationtable() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ReverseScanRequest.replicationTable)
  return replicationtable_;
}
inline void ReverseScanRequest::set_replicationtable(bool value) {
  
  replicationtable_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.ReverseScanRequest.replicationTable)
}

// .znbase.roachpb.ScanFormat scan_format = 4;
inline void ReverseScanRequest::clear_scan_format() {
  scan_format_ = 0;
}
inline ::znbase::roachpb::ScanFormat ReverseScanRequest::scan_format() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ReverseScanRequest.scan_format)
  return static_cast< ::znbase::roachpb::ScanFormat >(scan_format_);
}
inline void ReverseScanRequest::set_scan_format(::znbase::roachpb::ScanFormat value) {
  
  scan_format_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.ReverseScanRequest.scan_format)
}

// .znbase.storage.concurrency.lock.Strength key_locking = 5;
inline void ReverseScanRequest::clear_key_locking() {
  key_locking_ = 0;
}
inline ::znbase::storage::concurrency::lock::Strength ReverseScanRequest::key_locking() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ReverseScanRequest.key_locking)
  return static_cast< ::znbase::storage::concurrency::lock::Strength >(key_locking_);
}
inline void ReverseScanRequest::set_key_locking(::znbase::storage::concurrency::lock::Strength value) {
  
  key_locking_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.ReverseScanRequest.key_locking)
}

// -------------------------------------------------------------------

// ReverseScanResponse

inline bool ReverseScanResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ReverseScanResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& ReverseScanResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& ReverseScanResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.ReverseScanResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* ReverseScanResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ReverseScanResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* ReverseScanResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ReverseScanResponse.header)
  return header_;
}
inline void ReverseScanResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ReverseScanResponse.header)
}

inline int ReverseScanResponse::rows_size() const {
  return rows_.size();
}
inline ::znbase::roachpb::KeyValue* ReverseScanResponse::mutable_rows(int index) {
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ReverseScanResponse.rows)
  return rows_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::KeyValue >*
ReverseScanResponse::mutable_rows() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.ReverseScanResponse.rows)
  return &rows_;
}
inline const ::znbase::roachpb::KeyValue& ReverseScanResponse::rows(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ReverseScanResponse.rows)
  return rows_.Get(index);
}
inline ::znbase::roachpb::KeyValue* ReverseScanResponse::add_rows() {
  // @@protoc_insertion_point(field_add:znbase.roachpb.ReverseScanResponse.rows)
  return rows_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::KeyValue >&
ReverseScanResponse::rows() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.ReverseScanResponse.rows)
  return rows_;
}

inline int ReverseScanResponse::intent_rows_size() const {
  return intent_rows_.size();
}
inline ::znbase::roachpb::KeyValue* ReverseScanResponse::mutable_intent_rows(int index) {
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ReverseScanResponse.intent_rows)
  return intent_rows_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::KeyValue >*
ReverseScanResponse::mutable_intent_rows() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.ReverseScanResponse.intent_rows)
  return &intent_rows_;
}
inline const ::znbase::roachpb::KeyValue& ReverseScanResponse::intent_rows(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ReverseScanResponse.intent_rows)
  return intent_rows_.Get(index);
}
inline ::znbase::roachpb::KeyValue* ReverseScanResponse::add_intent_rows() {
  // @@protoc_insertion_point(field_add:znbase.roachpb.ReverseScanResponse.intent_rows)
  return intent_rows_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::KeyValue >&
ReverseScanResponse::intent_rows() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.ReverseScanResponse.intent_rows)
  return intent_rows_;
}

// repeated bytes batch_responses = 4;
inline int ReverseScanResponse::batch_responses_size() const {
  return batch_responses_.size();
}
inline void ReverseScanResponse::clear_batch_responses() {
  batch_responses_.Clear();
}
inline const ::std::string& ReverseScanResponse::batch_responses(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ReverseScanResponse.batch_responses)
  return batch_responses_.Get(index);
}
inline ::std::string* ReverseScanResponse::mutable_batch_responses(int index) {
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ReverseScanResponse.batch_responses)
  return batch_responses_.Mutable(index);
}
inline void ReverseScanResponse::set_batch_responses(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:znbase.roachpb.ReverseScanResponse.batch_responses)
  batch_responses_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ReverseScanResponse::set_batch_responses(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:znbase.roachpb.ReverseScanResponse.batch_responses)
  batch_responses_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ReverseScanResponse::set_batch_responses(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  batch_responses_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.ReverseScanResponse.batch_responses)
}
inline void ReverseScanResponse::set_batch_responses(int index, const void* value, size_t size) {
  batch_responses_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.ReverseScanResponse.batch_responses)
}
inline ::std::string* ReverseScanResponse::add_batch_responses() {
  // @@protoc_insertion_point(field_add_mutable:znbase.roachpb.ReverseScanResponse.batch_responses)
  return batch_responses_.Add();
}
inline void ReverseScanResponse::add_batch_responses(const ::std::string& value) {
  batch_responses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:znbase.roachpb.ReverseScanResponse.batch_responses)
}
#if LANG_CXX11
inline void ReverseScanResponse::add_batch_responses(::std::string&& value) {
  batch_responses_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:znbase.roachpb.ReverseScanResponse.batch_responses)
}
#endif
inline void ReverseScanResponse::add_batch_responses(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  batch_responses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:znbase.roachpb.ReverseScanResponse.batch_responses)
}
inline void ReverseScanResponse::add_batch_responses(const void* value, size_t size) {
  batch_responses_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:znbase.roachpb.ReverseScanResponse.batch_responses)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ReverseScanResponse::batch_responses() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.ReverseScanResponse.batch_responses)
  return batch_responses_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ReverseScanResponse::mutable_batch_responses() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.ReverseScanResponse.batch_responses)
  return &batch_responses_;
}

// -------------------------------------------------------------------

// CheckConsistencyRequest

inline bool CheckConsistencyRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void CheckConsistencyRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& CheckConsistencyRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& CheckConsistencyRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.CheckConsistencyRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* CheckConsistencyRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.CheckConsistencyRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* CheckConsistencyRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.CheckConsistencyRequest.header)
  return header_;
}
inline void CheckConsistencyRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.CheckConsistencyRequest.header)
}

// bool with_diff = 2;
inline void CheckConsistencyRequest::clear_with_diff() {
  with_diff_ = false;
}
inline bool CheckConsistencyRequest::with_diff() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.CheckConsistencyRequest.with_diff)
  return with_diff_;
}
inline void CheckConsistencyRequest::set_with_diff(bool value) {
  
  with_diff_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.CheckConsistencyRequest.with_diff)
}

// .znbase.roachpb.ChecksumMode mode = 3;
inline void CheckConsistencyRequest::clear_mode() {
  mode_ = 0;
}
inline ::znbase::roachpb::ChecksumMode CheckConsistencyRequest::mode() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.CheckConsistencyRequest.mode)
  return static_cast< ::znbase::roachpb::ChecksumMode >(mode_);
}
inline void CheckConsistencyRequest::set_mode(::znbase::roachpb::ChecksumMode value) {
  
  mode_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.CheckConsistencyRequest.mode)
}

// bool checkpoint = 4;
inline void CheckConsistencyRequest::clear_checkpoint() {
  checkpoint_ = false;
}
inline bool CheckConsistencyRequest::checkpoint() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.CheckConsistencyRequest.checkpoint)
  return checkpoint_;
}
inline void CheckConsistencyRequest::set_checkpoint(bool value) {
  
  checkpoint_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.CheckConsistencyRequest.checkpoint)
}

// -------------------------------------------------------------------

// CheckConsistencyResponse_Result

inline void CheckConsistencyResponse_Result::clear_range_id() {
  range_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 CheckConsistencyResponse_Result::range_id() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.CheckConsistencyResponse.Result.range_id)
  return range_id_;
}
inline void CheckConsistencyResponse_Result::set_range_id(::google::protobuf::int64 value) {
  
  range_id_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.CheckConsistencyResponse.Result.range_id)
}

// bytes start_key = 2;
inline void CheckConsistencyResponse_Result::clear_start_key() {
  start_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CheckConsistencyResponse_Result::start_key() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.CheckConsistencyResponse.Result.start_key)
  return start_key_.GetNoArena();
}
inline void CheckConsistencyResponse_Result::set_start_key(const ::std::string& value) {
  
  start_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.CheckConsistencyResponse.Result.start_key)
}
#if LANG_CXX11
inline void CheckConsistencyResponse_Result::set_start_key(::std::string&& value) {
  
  start_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.CheckConsistencyResponse.Result.start_key)
}
#endif
inline void CheckConsistencyResponse_Result::set_start_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  start_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.CheckConsistencyResponse.Result.start_key)
}
inline void CheckConsistencyResponse_Result::set_start_key(const void* value, size_t size) {
  
  start_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.CheckConsistencyResponse.Result.start_key)
}
inline ::std::string* CheckConsistencyResponse_Result::mutable_start_key() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.CheckConsistencyResponse.Result.start_key)
  return start_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CheckConsistencyResponse_Result::release_start_key() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.CheckConsistencyResponse.Result.start_key)
  
  return start_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CheckConsistencyResponse_Result::set_allocated_start_key(::std::string* start_key) {
  if (start_key != NULL) {
    
  } else {
    
  }
  start_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), start_key);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.CheckConsistencyResponse.Result.start_key)
}

// .znbase.roachpb.CheckConsistencyResponse.Status status = 3;
inline void CheckConsistencyResponse_Result::clear_status() {
  status_ = 0;
}
inline ::znbase::roachpb::CheckConsistencyResponse_Status CheckConsistencyResponse_Result::status() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.CheckConsistencyResponse.Result.status)
  return static_cast< ::znbase::roachpb::CheckConsistencyResponse_Status >(status_);
}
inline void CheckConsistencyResponse_Result::set_status(::znbase::roachpb::CheckConsistencyResponse_Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.CheckConsistencyResponse.Result.status)
}

// string detail = 4;
inline void CheckConsistencyResponse_Result::clear_detail() {
  detail_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CheckConsistencyResponse_Result::detail() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.CheckConsistencyResponse.Result.detail)
  return detail_.GetNoArena();
}
inline void CheckConsistencyResponse_Result::set_detail(const ::std::string& value) {
  
  detail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.CheckConsistencyResponse.Result.detail)
}
#if LANG_CXX11
inline void CheckConsistencyResponse_Result::set_detail(::std::string&& value) {
  
  detail_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.CheckConsistencyResponse.Result.detail)
}
#endif
inline void CheckConsistencyResponse_Result::set_detail(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  detail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.CheckConsistencyResponse.Result.detail)
}
inline void CheckConsistencyResponse_Result::set_detail(const char* value, size_t size) {
  
  detail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.CheckConsistencyResponse.Result.detail)
}
inline ::std::string* CheckConsistencyResponse_Result::mutable_detail() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.CheckConsistencyResponse.Result.detail)
  return detail_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CheckConsistencyResponse_Result::release_detail() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.CheckConsistencyResponse.Result.detail)
  
  return detail_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CheckConsistencyResponse_Result::set_allocated_detail(::std::string* detail) {
  if (detail != NULL) {
    
  } else {
    
  }
  detail_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), detail);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.CheckConsistencyResponse.Result.detail)
}

// -------------------------------------------------------------------

// CheckConsistencyResponse

inline bool CheckConsistencyResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void CheckConsistencyResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& CheckConsistencyResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& CheckConsistencyResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.CheckConsistencyResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* CheckConsistencyResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.CheckConsistencyResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* CheckConsistencyResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.CheckConsistencyResponse.header)
  return header_;
}
inline void CheckConsistencyResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.CheckConsistencyResponse.header)
}

inline int CheckConsistencyResponse::result_size() const {
  return result_.size();
}
inline void CheckConsistencyResponse::clear_result() {
  result_.Clear();
}
inline ::znbase::roachpb::CheckConsistencyResponse_Result* CheckConsistencyResponse::mutable_result(int index) {
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.CheckConsistencyResponse.result)
  return result_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::CheckConsistencyResponse_Result >*
CheckConsistencyResponse::mutable_result() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.CheckConsistencyResponse.result)
  return &result_;
}
inline const ::znbase::roachpb::CheckConsistencyResponse_Result& CheckConsistencyResponse::result(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.CheckConsistencyResponse.result)
  return result_.Get(index);
}
inline ::znbase::roachpb::CheckConsistencyResponse_Result* CheckConsistencyResponse::add_result() {
  // @@protoc_insertion_point(field_add:znbase.roachpb.CheckConsistencyResponse.result)
  return result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::CheckConsistencyResponse_Result >&
CheckConsistencyResponse::result() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.CheckConsistencyResponse.result)
  return result_;
}

// -------------------------------------------------------------------

// RecomputeStatsRequest

inline bool RecomputeStatsRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void RecomputeStatsRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& RecomputeStatsRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& RecomputeStatsRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.RecomputeStatsRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* RecomputeStatsRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RecomputeStatsRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* RecomputeStatsRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RecomputeStatsRequest.header)
  return header_;
}
inline void RecomputeStatsRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.RecomputeStatsRequest.header)
}

// bool dry_run = 2;
inline void RecomputeStatsRequest::clear_dry_run() {
  dry_run_ = false;
}
inline bool RecomputeStatsRequest::dry_run() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RecomputeStatsRequest.dry_run)
  return dry_run_;
}
inline void RecomputeStatsRequest::set_dry_run(bool value) {
  
  dry_run_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.RecomputeStatsRequest.dry_run)
}

// -------------------------------------------------------------------

// RecomputeStatsResponse

inline bool RecomputeStatsResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void RecomputeStatsResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& RecomputeStatsResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& RecomputeStatsResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.RecomputeStatsResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* RecomputeStatsResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RecomputeStatsResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* RecomputeStatsResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RecomputeStatsResponse.header)
  return header_;
}
inline void RecomputeStatsResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.RecomputeStatsResponse.header)
}

inline bool RecomputeStatsResponse::has_added_delta() const {
  return this != internal_default_instance() && added_delta_ != NULL;
}
inline const ::znbase::storage::engine::enginepb::MVCCStatsDelta& RecomputeStatsResponse::_internal_added_delta() const {
  return *added_delta_;
}
inline const ::znbase::storage::engine::enginepb::MVCCStatsDelta& RecomputeStatsResponse::added_delta() const {
  const ::znbase::storage::engine::enginepb::MVCCStatsDelta* p = added_delta_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.RecomputeStatsResponse.added_delta)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::storage::engine::enginepb::MVCCStatsDelta*>(
      &::znbase::storage::engine::enginepb::_MVCCStatsDelta_default_instance_);
}
inline ::znbase::storage::engine::enginepb::MVCCStatsDelta* RecomputeStatsResponse::release_added_delta() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RecomputeStatsResponse.added_delta)
  
  ::znbase::storage::engine::enginepb::MVCCStatsDelta* temp = added_delta_;
  added_delta_ = NULL;
  return temp;
}
inline ::znbase::storage::engine::enginepb::MVCCStatsDelta* RecomputeStatsResponse::mutable_added_delta() {
  
  if (added_delta_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::storage::engine::enginepb::MVCCStatsDelta>(GetArenaNoVirtual());
    added_delta_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RecomputeStatsResponse.added_delta)
  return added_delta_;
}
inline void RecomputeStatsResponse::set_allocated_added_delta(::znbase::storage::engine::enginepb::MVCCStatsDelta* added_delta) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(added_delta_);
  }
  if (added_delta) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      added_delta = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, added_delta, submessage_arena);
    }
    
  } else {
    
  }
  added_delta_ = added_delta;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.RecomputeStatsResponse.added_delta)
}

// -------------------------------------------------------------------

// EndTransactionRequest

inline bool EndTransactionRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void EndTransactionRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& EndTransactionRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& EndTransactionRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.EndTransactionRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* EndTransactionRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.EndTransactionRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* EndTransactionRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.EndTransactionRequest.header)
  return header_;
}
inline void EndTransactionRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.EndTransactionRequest.header)
}

// bool commit = 2;
inline void EndTransactionRequest::clear_commit() {
  commit_ = false;
}
inline bool EndTransactionRequest::commit() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.EndTransactionRequest.commit)
  return commit_;
}
inline void EndTransactionRequest::set_commit(bool value) {
  
  commit_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.EndTransactionRequest.commit)
}

// .znbase.util.hlc.Timestamp deadline = 3;
inline bool EndTransactionRequest::has_deadline() const {
  return this != internal_default_instance() && deadline_ != NULL;
}
inline const ::znbase::util::hlc::Timestamp& EndTransactionRequest::_internal_deadline() const {
  return *deadline_;
}
inline const ::znbase::util::hlc::Timestamp& EndTransactionRequest::deadline() const {
  const ::znbase::util::hlc::Timestamp* p = deadline_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.EndTransactionRequest.deadline)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::util::hlc::Timestamp*>(
      &::znbase::util::hlc::_Timestamp_default_instance_);
}
inline ::znbase::util::hlc::Timestamp* EndTransactionRequest::release_deadline() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.EndTransactionRequest.deadline)
  
  ::znbase::util::hlc::Timestamp* temp = deadline_;
  deadline_ = NULL;
  return temp;
}
inline ::znbase::util::hlc::Timestamp* EndTransactionRequest::mutable_deadline() {
  
  if (deadline_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::util::hlc::Timestamp>(GetArenaNoVirtual());
    deadline_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.EndTransactionRequest.deadline)
  return deadline_;
}
inline void EndTransactionRequest::set_allocated_deadline(::znbase::util::hlc::Timestamp* deadline) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(deadline_);
  }
  if (deadline) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      deadline = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, deadline, submessage_arena);
    }
    
  } else {
    
  }
  deadline_ = deadline;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.EndTransactionRequest.deadline)
}

// .znbase.roachpb.InternalCommitTrigger internal_commit_trigger = 4;
inline bool EndTransactionRequest::has_internal_commit_trigger() const {
  return this != internal_default_instance() && internal_commit_trigger_ != NULL;
}
inline const ::znbase::roachpb::InternalCommitTrigger& EndTransactionRequest::_internal_internal_commit_trigger() const {
  return *internal_commit_trigger_;
}
inline const ::znbase::roachpb::InternalCommitTrigger& EndTransactionRequest::internal_commit_trigger() const {
  const ::znbase::roachpb::InternalCommitTrigger* p = internal_commit_trigger_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.EndTransactionRequest.internal_commit_trigger)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::InternalCommitTrigger*>(
      &::znbase::roachpb::_InternalCommitTrigger_default_instance_);
}
inline ::znbase::roachpb::InternalCommitTrigger* EndTransactionRequest::release_internal_commit_trigger() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.EndTransactionRequest.internal_commit_trigger)
  
  ::znbase::roachpb::InternalCommitTrigger* temp = internal_commit_trigger_;
  internal_commit_trigger_ = NULL;
  return temp;
}
inline ::znbase::roachpb::InternalCommitTrigger* EndTransactionRequest::mutable_internal_commit_trigger() {
  
  if (internal_commit_trigger_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::InternalCommitTrigger>(GetArenaNoVirtual());
    internal_commit_trigger_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.EndTransactionRequest.internal_commit_trigger)
  return internal_commit_trigger_;
}
inline void EndTransactionRequest::set_allocated_internal_commit_trigger(::znbase::roachpb::InternalCommitTrigger* internal_commit_trigger) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(internal_commit_trigger_);
  }
  if (internal_commit_trigger) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      internal_commit_trigger = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, internal_commit_trigger, submessage_arena);
    }
    
  } else {
    
  }
  internal_commit_trigger_ = internal_commit_trigger;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.EndTransactionRequest.internal_commit_trigger)
}

inline int EndTransactionRequest::lock_spans_size() const {
  return lock_spans_.size();
}
inline ::znbase::roachpb::Span* EndTransactionRequest::mutable_lock_spans(int index) {
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.EndTransactionRequest.lock_spans)
  return lock_spans_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::Span >*
EndTransactionRequest::mutable_lock_spans() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.EndTransactionRequest.lock_spans)
  return &lock_spans_;
}
inline const ::znbase::roachpb::Span& EndTransactionRequest::lock_spans(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.EndTransactionRequest.lock_spans)
  return lock_spans_.Get(index);
}
inline ::znbase::roachpb::Span* EndTransactionRequest::add_lock_spans() {
  // @@protoc_insertion_point(field_add:znbase.roachpb.EndTransactionRequest.lock_spans)
  return lock_spans_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::Span >&
EndTransactionRequest::lock_spans() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.EndTransactionRequest.lock_spans)
  return lock_spans_;
}

inline int EndTransactionRequest::in_flight_writes_size() const {
  return in_flight_writes_.size();
}
inline ::znbase::roachpb::SequencedWrite* EndTransactionRequest::mutable_in_flight_writes(int index) {
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.EndTransactionRequest.in_flight_writes)
  return in_flight_writes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::SequencedWrite >*
EndTransactionRequest::mutable_in_flight_writes() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.EndTransactionRequest.in_flight_writes)
  return &in_flight_writes_;
}
inline const ::znbase::roachpb::SequencedWrite& EndTransactionRequest::in_flight_writes(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.EndTransactionRequest.in_flight_writes)
  return in_flight_writes_.Get(index);
}
inline ::znbase::roachpb::SequencedWrite* EndTransactionRequest::add_in_flight_writes() {
  // @@protoc_insertion_point(field_add:znbase.roachpb.EndTransactionRequest.in_flight_writes)
  return in_flight_writes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::SequencedWrite >&
EndTransactionRequest::in_flight_writes() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.EndTransactionRequest.in_flight_writes)
  return in_flight_writes_;
}

inline void EndTransactionRequest::clear_require_1pc() {
  require_1pc_ = false;
}
inline bool EndTransactionRequest::require_1pc() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.EndTransactionRequest.require_1pc)
  return require_1pc_;
}
inline void EndTransactionRequest::set_require_1pc(bool value) {
  
  require_1pc_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.EndTransactionRequest.require_1pc)
}

// bool can_commit_at_higher_timestamp = 8;
inline void EndTransactionRequest::clear_can_commit_at_higher_timestamp() {
  can_commit_at_higher_timestamp_ = false;
}
inline bool EndTransactionRequest::can_commit_at_higher_timestamp() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.EndTransactionRequest.can_commit_at_higher_timestamp)
  return can_commit_at_higher_timestamp_;
}
inline void EndTransactionRequest::set_can_commit_at_higher_timestamp(bool value) {
  
  can_commit_at_higher_timestamp_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.EndTransactionRequest.can_commit_at_higher_timestamp)
}

// bool poison = 9;
inline void EndTransactionRequest::clear_poison() {
  poison_ = false;
}
inline bool EndTransactionRequest::poison() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.EndTransactionRequest.poison)
  return poison_;
}
inline void EndTransactionRequest::set_poison(bool value) {
  
  poison_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.EndTransactionRequest.poison)
}

// bool heartbeat = 7;
inline void EndTransactionRequest::clear_heartbeat() {
  heartbeat_ = false;
}
inline bool EndTransactionRequest::heartbeat() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.EndTransactionRequest.heartbeat)
  return heartbeat_;
}
inline void EndTransactionRequest::set_heartbeat(bool value) {
  
  heartbeat_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.EndTransactionRequest.heartbeat)
}

// bool retrytxn = 10;
inline void EndTransactionRequest::clear_retrytxn() {
  retrytxn_ = false;
}
inline bool EndTransactionRequest::retrytxn() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.EndTransactionRequest.retrytxn)
  return retrytxn_;
}
inline void EndTransactionRequest::set_retrytxn(bool value) {
  
  retrytxn_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.EndTransactionRequest.retrytxn)
}

// -------------------------------------------------------------------

// EndTransactionResponse

inline bool EndTransactionResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void EndTransactionResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& EndTransactionResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& EndTransactionResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.EndTransactionResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* EndTransactionResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.EndTransactionResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* EndTransactionResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.EndTransactionResponse.header)
  return header_;
}
inline void EndTransactionResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.EndTransactionResponse.header)
}

// bool one_phase_commit = 4;
inline void EndTransactionResponse::clear_one_phase_commit() {
  one_phase_commit_ = false;
}
inline bool EndTransactionResponse::one_phase_commit() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.EndTransactionResponse.one_phase_commit)
  return one_phase_commit_;
}
inline void EndTransactionResponse::set_one_phase_commit(bool value) {
  
  one_phase_commit_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.EndTransactionResponse.one_phase_commit)
}

inline bool EndTransactionResponse::has_staging_timestamp() const {
  return this != internal_default_instance() && staging_timestamp_ != NULL;
}
inline const ::znbase::util::hlc::Timestamp& EndTransactionResponse::_internal_staging_timestamp() const {
  return *staging_timestamp_;
}
inline const ::znbase::util::hlc::Timestamp& EndTransactionResponse::staging_timestamp() const {
  const ::znbase::util::hlc::Timestamp* p = staging_timestamp_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.EndTransactionResponse.staging_timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::util::hlc::Timestamp*>(
      &::znbase::util::hlc::_Timestamp_default_instance_);
}
inline ::znbase::util::hlc::Timestamp* EndTransactionResponse::release_staging_timestamp() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.EndTransactionResponse.staging_timestamp)
  
  ::znbase::util::hlc::Timestamp* temp = staging_timestamp_;
  staging_timestamp_ = NULL;
  return temp;
}
inline ::znbase::util::hlc::Timestamp* EndTransactionResponse::mutable_staging_timestamp() {
  
  if (staging_timestamp_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::util::hlc::Timestamp>(GetArenaNoVirtual());
    staging_timestamp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.EndTransactionResponse.staging_timestamp)
  return staging_timestamp_;
}
inline void EndTransactionResponse::set_allocated_staging_timestamp(::znbase::util::hlc::Timestamp* staging_timestamp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(staging_timestamp_);
  }
  if (staging_timestamp) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      staging_timestamp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, staging_timestamp, submessage_arena);
    }
    
  } else {
    
  }
  staging_timestamp_ = staging_timestamp;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.EndTransactionResponse.staging_timestamp)
}

// -------------------------------------------------------------------

// AdminSplitRequest

inline bool AdminSplitRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void AdminSplitRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& AdminSplitRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& AdminSplitRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.AdminSplitRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* AdminSplitRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.AdminSplitRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* AdminSplitRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.AdminSplitRequest.header)
  return header_;
}
inline void AdminSplitRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.AdminSplitRequest.header)
}

inline void AdminSplitRequest::clear_split_key() {
  split_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AdminSplitRequest::split_key() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.AdminSplitRequest.split_key)
  return split_key_.GetNoArena();
}
inline void AdminSplitRequest::set_split_key(const ::std::string& value) {
  
  split_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.AdminSplitRequest.split_key)
}
#if LANG_CXX11
inline void AdminSplitRequest::set_split_key(::std::string&& value) {
  
  split_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.AdminSplitRequest.split_key)
}
#endif
inline void AdminSplitRequest::set_split_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  split_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.AdminSplitRequest.split_key)
}
inline void AdminSplitRequest::set_split_key(const void* value, size_t size) {
  
  split_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.AdminSplitRequest.split_key)
}
inline ::std::string* AdminSplitRequest::mutable_split_key() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.AdminSplitRequest.split_key)
  return split_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AdminSplitRequest::release_split_key() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.AdminSplitRequest.split_key)
  
  return split_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AdminSplitRequest::set_allocated_split_key(::std::string* split_key) {
  if (split_key != NULL) {
    
  } else {
    
  }
  split_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), split_key);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.AdminSplitRequest.split_key)
}

// -------------------------------------------------------------------

// AdminSplitResponse

inline bool AdminSplitResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void AdminSplitResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& AdminSplitResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& AdminSplitResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.AdminSplitResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* AdminSplitResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.AdminSplitResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* AdminSplitResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.AdminSplitResponse.header)
  return header_;
}
inline void AdminSplitResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.AdminSplitResponse.header)
}

// -------------------------------------------------------------------

// AdminMergeRequest

inline bool AdminMergeRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void AdminMergeRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& AdminMergeRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& AdminMergeRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.AdminMergeRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* AdminMergeRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.AdminMergeRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* AdminMergeRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.AdminMergeRequest.header)
  return header_;
}
inline void AdminMergeRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.AdminMergeRequest.header)
}

// -------------------------------------------------------------------

// AdminMergeResponse

inline bool AdminMergeResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void AdminMergeResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& AdminMergeResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& AdminMergeResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.AdminMergeResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* AdminMergeResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.AdminMergeResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* AdminMergeResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.AdminMergeResponse.header)
  return header_;
}
inline void AdminMergeResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.AdminMergeResponse.header)
}

// -------------------------------------------------------------------

// AdminTransferLeaseRequest

inline bool AdminTransferLeaseRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void AdminTransferLeaseRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& AdminTransferLeaseRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& AdminTransferLeaseRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.AdminTransferLeaseRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* AdminTransferLeaseRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.AdminTransferLeaseRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* AdminTransferLeaseRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.AdminTransferLeaseRequest.header)
  return header_;
}
inline void AdminTransferLeaseRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.AdminTransferLeaseRequest.header)
}

inline void AdminTransferLeaseRequest::clear_target() {
  target_ = 0;
}
inline ::google::protobuf::int32 AdminTransferLeaseRequest::target() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.AdminTransferLeaseRequest.target)
  return target_;
}
inline void AdminTransferLeaseRequest::set_target(::google::protobuf::int32 value) {
  
  target_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.AdminTransferLeaseRequest.target)
}

// -------------------------------------------------------------------

// AdminTransferLeaseResponse

inline bool AdminTransferLeaseResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void AdminTransferLeaseResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& AdminTransferLeaseResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& AdminTransferLeaseResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.AdminTransferLeaseResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* AdminTransferLeaseResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.AdminTransferLeaseResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* AdminTransferLeaseResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.AdminTransferLeaseResponse.header)
  return header_;
}
inline void AdminTransferLeaseResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.AdminTransferLeaseResponse.header)
}

// -------------------------------------------------------------------

// AdminChangeReplicasRequest

inline bool AdminChangeReplicasRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void AdminChangeReplicasRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& AdminChangeReplicasRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& AdminChangeReplicasRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.AdminChangeReplicasRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* AdminChangeReplicasRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.AdminChangeReplicasRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* AdminChangeReplicasRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.AdminChangeReplicasRequest.header)
  return header_;
}
inline void AdminChangeReplicasRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.AdminChangeReplicasRequest.header)
}

// .znbase.roachpb.ReplicaChangeType change_type = 2;
inline void AdminChangeReplicasRequest::clear_change_type() {
  change_type_ = 0;
}
inline ::znbase::roachpb::ReplicaChangeType AdminChangeReplicasRequest::change_type() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.AdminChangeReplicasRequest.change_type)
  return static_cast< ::znbase::roachpb::ReplicaChangeType >(change_type_);
}
inline void AdminChangeReplicasRequest::set_change_type(::znbase::roachpb::ReplicaChangeType value) {
  
  change_type_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.AdminChangeReplicasRequest.change_type)
}

inline int AdminChangeReplicasRequest::targets_size() const {
  return targets_.size();
}
inline ::znbase::roachpb::ReplicationTarget* AdminChangeReplicasRequest::mutable_targets(int index) {
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.AdminChangeReplicasRequest.targets)
  return targets_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::ReplicationTarget >*
AdminChangeReplicasRequest::mutable_targets() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.AdminChangeReplicasRequest.targets)
  return &targets_;
}
inline const ::znbase::roachpb::ReplicationTarget& AdminChangeReplicasRequest::targets(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.AdminChangeReplicasRequest.targets)
  return targets_.Get(index);
}
inline ::znbase::roachpb::ReplicationTarget* AdminChangeReplicasRequest::add_targets() {
  // @@protoc_insertion_point(field_add:znbase.roachpb.AdminChangeReplicasRequest.targets)
  return targets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::ReplicationTarget >&
AdminChangeReplicasRequest::targets() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.AdminChangeReplicasRequest.targets)
  return targets_;
}

// .znbase.roachpb.RangeDescriptor exp_desc = 4;
inline bool AdminChangeReplicasRequest::has_exp_desc() const {
  return this != internal_default_instance() && exp_desc_ != NULL;
}
inline const ::znbase::roachpb::RangeDescriptor& AdminChangeReplicasRequest::_internal_exp_desc() const {
  return *exp_desc_;
}
inline const ::znbase::roachpb::RangeDescriptor& AdminChangeReplicasRequest::exp_desc() const {
  const ::znbase::roachpb::RangeDescriptor* p = exp_desc_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.AdminChangeReplicasRequest.exp_desc)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RangeDescriptor*>(
      &::znbase::roachpb::_RangeDescriptor_default_instance_);
}
inline ::znbase::roachpb::RangeDescriptor* AdminChangeReplicasRequest::release_exp_desc() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.AdminChangeReplicasRequest.exp_desc)
  
  ::znbase::roachpb::RangeDescriptor* temp = exp_desc_;
  exp_desc_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RangeDescriptor* AdminChangeReplicasRequest::mutable_exp_desc() {
  
  if (exp_desc_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RangeDescriptor>(GetArenaNoVirtual());
    exp_desc_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.AdminChangeReplicasRequest.exp_desc)
  return exp_desc_;
}
inline void AdminChangeReplicasRequest::set_allocated_exp_desc(::znbase::roachpb::RangeDescriptor* exp_desc) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(exp_desc_);
  }
  if (exp_desc) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      exp_desc = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, exp_desc, submessage_arena);
    }
    
  } else {
    
  }
  exp_desc_ = exp_desc;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.AdminChangeReplicasRequest.exp_desc)
}

// -------------------------------------------------------------------

// AdminChangeReplicasResponse

inline bool AdminChangeReplicasResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void AdminChangeReplicasResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& AdminChangeReplicasResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& AdminChangeReplicasResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.AdminChangeReplicasResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* AdminChangeReplicasResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.AdminChangeReplicasResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* AdminChangeReplicasResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.AdminChangeReplicasResponse.header)
  return header_;
}
inline void AdminChangeReplicasResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.AdminChangeReplicasResponse.header)
}

// .znbase.roachpb.RangeDescriptor desc = 2;
inline bool AdminChangeReplicasResponse::has_desc() const {
  return this != internal_default_instance() && desc_ != NULL;
}
inline const ::znbase::roachpb::RangeDescriptor& AdminChangeReplicasResponse::_internal_desc() const {
  return *desc_;
}
inline const ::znbase::roachpb::RangeDescriptor& AdminChangeReplicasResponse::desc() const {
  const ::znbase::roachpb::RangeDescriptor* p = desc_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.AdminChangeReplicasResponse.desc)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RangeDescriptor*>(
      &::znbase::roachpb::_RangeDescriptor_default_instance_);
}
inline ::znbase::roachpb::RangeDescriptor* AdminChangeReplicasResponse::release_desc() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.AdminChangeReplicasResponse.desc)
  
  ::znbase::roachpb::RangeDescriptor* temp = desc_;
  desc_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RangeDescriptor* AdminChangeReplicasResponse::mutable_desc() {
  
  if (desc_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RangeDescriptor>(GetArenaNoVirtual());
    desc_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.AdminChangeReplicasResponse.desc)
  return desc_;
}
inline void AdminChangeReplicasResponse::set_allocated_desc(::znbase::roachpb::RangeDescriptor* desc) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(desc_);
  }
  if (desc) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      desc = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, desc, submessage_arena);
    }
    
  } else {
    
  }
  desc_ = desc;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.AdminChangeReplicasResponse.desc)
}

// -------------------------------------------------------------------

// AdminRelocateRangeRequest

inline bool AdminRelocateRangeRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void AdminRelocateRangeRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& AdminRelocateRangeRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& AdminRelocateRangeRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.AdminRelocateRangeRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* AdminRelocateRangeRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.AdminRelocateRangeRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* AdminRelocateRangeRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.AdminRelocateRangeRequest.header)
  return header_;
}
inline void AdminRelocateRangeRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.AdminRelocateRangeRequest.header)
}

inline int AdminRelocateRangeRequest::targets_size() const {
  return targets_.size();
}
inline ::znbase::roachpb::ReplicationTarget* AdminRelocateRangeRequest::mutable_targets(int index) {
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.AdminRelocateRangeRequest.targets)
  return targets_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::ReplicationTarget >*
AdminRelocateRangeRequest::mutable_targets() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.AdminRelocateRangeRequest.targets)
  return &targets_;
}
inline const ::znbase::roachpb::ReplicationTarget& AdminRelocateRangeRequest::targets(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.AdminRelocateRangeRequest.targets)
  return targets_.Get(index);
}
inline ::znbase::roachpb::ReplicationTarget* AdminRelocateRangeRequest::add_targets() {
  // @@protoc_insertion_point(field_add:znbase.roachpb.AdminRelocateRangeRequest.targets)
  return targets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::ReplicationTarget >&
AdminRelocateRangeRequest::targets() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.AdminRelocateRangeRequest.targets)
  return targets_;
}

// -------------------------------------------------------------------

// AdminRelocateRangeResponse

inline bool AdminRelocateRangeResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void AdminRelocateRangeResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& AdminRelocateRangeResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& AdminRelocateRangeResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.AdminRelocateRangeResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* AdminRelocateRangeResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.AdminRelocateRangeResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* AdminRelocateRangeResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.AdminRelocateRangeResponse.header)
  return header_;
}
inline void AdminRelocateRangeResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.AdminRelocateRangeResponse.header)
}

// -------------------------------------------------------------------

// HeartbeatTxnRequest

inline bool HeartbeatTxnRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void HeartbeatTxnRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& HeartbeatTxnRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& HeartbeatTxnRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.HeartbeatTxnRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* HeartbeatTxnRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.HeartbeatTxnRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* HeartbeatTxnRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.HeartbeatTxnRequest.header)
  return header_;
}
inline void HeartbeatTxnRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.HeartbeatTxnRequest.header)
}

inline bool HeartbeatTxnRequest::has_now() const {
  return this != internal_default_instance() && now_ != NULL;
}
inline const ::znbase::util::hlc::Timestamp& HeartbeatTxnRequest::_internal_now() const {
  return *now_;
}
inline const ::znbase::util::hlc::Timestamp& HeartbeatTxnRequest::now() const {
  const ::znbase::util::hlc::Timestamp* p = now_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.HeartbeatTxnRequest.now)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::util::hlc::Timestamp*>(
      &::znbase::util::hlc::_Timestamp_default_instance_);
}
inline ::znbase::util::hlc::Timestamp* HeartbeatTxnRequest::release_now() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.HeartbeatTxnRequest.now)
  
  ::znbase::util::hlc::Timestamp* temp = now_;
  now_ = NULL;
  return temp;
}
inline ::znbase::util::hlc::Timestamp* HeartbeatTxnRequest::mutable_now() {
  
  if (now_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::util::hlc::Timestamp>(GetArenaNoVirtual());
    now_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.HeartbeatTxnRequest.now)
  return now_;
}
inline void HeartbeatTxnRequest::set_allocated_now(::znbase::util::hlc::Timestamp* now) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(now_);
  }
  if (now) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      now = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, now, submessage_arena);
    }
    
  } else {
    
  }
  now_ = now;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.HeartbeatTxnRequest.now)
}

// -------------------------------------------------------------------

// HeartbeatTxnResponse

inline bool HeartbeatTxnResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void HeartbeatTxnResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& HeartbeatTxnResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& HeartbeatTxnResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.HeartbeatTxnResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* HeartbeatTxnResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.HeartbeatTxnResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* HeartbeatTxnResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.HeartbeatTxnResponse.header)
  return header_;
}
inline void HeartbeatTxnResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.HeartbeatTxnResponse.header)
}

// -------------------------------------------------------------------

// GCRequest_GCKey

inline void GCRequest_GCKey::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GCRequest_GCKey::key() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.GCRequest.GCKey.key)
  return key_.GetNoArena();
}
inline void GCRequest_GCKey::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.GCRequest.GCKey.key)
}
#if LANG_CXX11
inline void GCRequest_GCKey::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.GCRequest.GCKey.key)
}
#endif
inline void GCRequest_GCKey::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.GCRequest.GCKey.key)
}
inline void GCRequest_GCKey::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.GCRequest.GCKey.key)
}
inline ::std::string* GCRequest_GCKey::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.GCRequest.GCKey.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GCRequest_GCKey::release_key() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.GCRequest.GCKey.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GCRequest_GCKey::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.GCRequest.GCKey.key)
}

inline bool GCRequest_GCKey::has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != NULL;
}
inline const ::znbase::util::hlc::Timestamp& GCRequest_GCKey::_internal_timestamp() const {
  return *timestamp_;
}
inline const ::znbase::util::hlc::Timestamp& GCRequest_GCKey::timestamp() const {
  const ::znbase::util::hlc::Timestamp* p = timestamp_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.GCRequest.GCKey.timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::util::hlc::Timestamp*>(
      &::znbase::util::hlc::_Timestamp_default_instance_);
}
inline ::znbase::util::hlc::Timestamp* GCRequest_GCKey::release_timestamp() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.GCRequest.GCKey.timestamp)
  
  ::znbase::util::hlc::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline ::znbase::util::hlc::Timestamp* GCRequest_GCKey::mutable_timestamp() {
  
  if (timestamp_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::util::hlc::Timestamp>(GetArenaNoVirtual());
    timestamp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.GCRequest.GCKey.timestamp)
  return timestamp_;
}
inline void GCRequest_GCKey::set_allocated_timestamp(::znbase::util::hlc::Timestamp* timestamp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      timestamp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.GCRequest.GCKey.timestamp)
}

inline bool GCRequest_GCKey::has_from() const {
  return this != internal_default_instance() && from_ != NULL;
}
inline const ::znbase::util::hlc::Timestamp& GCRequest_GCKey::_internal_from() const {
  return *from_;
}
inline const ::znbase::util::hlc::Timestamp& GCRequest_GCKey::from() const {
  const ::znbase::util::hlc::Timestamp* p = from_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.GCRequest.GCKey.from)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::util::hlc::Timestamp*>(
      &::znbase::util::hlc::_Timestamp_default_instance_);
}
inline ::znbase::util::hlc::Timestamp* GCRequest_GCKey::release_from() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.GCRequest.GCKey.from)
  
  ::znbase::util::hlc::Timestamp* temp = from_;
  from_ = NULL;
  return temp;
}
inline ::znbase::util::hlc::Timestamp* GCRequest_GCKey::mutable_from() {
  
  if (from_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::util::hlc::Timestamp>(GetArenaNoVirtual());
    from_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.GCRequest.GCKey.from)
  return from_;
}
inline void GCRequest_GCKey::set_allocated_from(::znbase::util::hlc::Timestamp* from) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(from_);
  }
  if (from) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      from = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, from, submessage_arena);
    }
    
  } else {
    
  }
  from_ = from;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.GCRequest.GCKey.from)
}

// -------------------------------------------------------------------

// GCRequest

inline bool GCRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GCRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& GCRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& GCRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.GCRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* GCRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.GCRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* GCRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.GCRequest.header)
  return header_;
}
inline void GCRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.GCRequest.header)
}

inline int GCRequest::keys_size() const {
  return keys_.size();
}
inline void GCRequest::clear_keys() {
  keys_.Clear();
}
inline ::znbase::roachpb::GCRequest_GCKey* GCRequest::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.GCRequest.keys)
  return keys_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::GCRequest_GCKey >*
GCRequest::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.GCRequest.keys)
  return &keys_;
}
inline const ::znbase::roachpb::GCRequest_GCKey& GCRequest::keys(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.GCRequest.keys)
  return keys_.Get(index);
}
inline ::znbase::roachpb::GCRequest_GCKey* GCRequest::add_keys() {
  // @@protoc_insertion_point(field_add:znbase.roachpb.GCRequest.keys)
  return keys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::GCRequest_GCKey >&
GCRequest::keys() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.GCRequest.keys)
  return keys_;
}

inline bool GCRequest::has_threshold() const {
  return this != internal_default_instance() && threshold_ != NULL;
}
inline const ::znbase::util::hlc::Timestamp& GCRequest::_internal_threshold() const {
  return *threshold_;
}
inline const ::znbase::util::hlc::Timestamp& GCRequest::threshold() const {
  const ::znbase::util::hlc::Timestamp* p = threshold_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.GCRequest.threshold)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::util::hlc::Timestamp*>(
      &::znbase::util::hlc::_Timestamp_default_instance_);
}
inline ::znbase::util::hlc::Timestamp* GCRequest::release_threshold() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.GCRequest.threshold)
  
  ::znbase::util::hlc::Timestamp* temp = threshold_;
  threshold_ = NULL;
  return temp;
}
inline ::znbase::util::hlc::Timestamp* GCRequest::mutable_threshold() {
  
  if (threshold_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::util::hlc::Timestamp>(GetArenaNoVirtual());
    threshold_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.GCRequest.threshold)
  return threshold_;
}
inline void GCRequest::set_allocated_threshold(::znbase::util::hlc::Timestamp* threshold) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(threshold_);
  }
  if (threshold) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      threshold = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, threshold, submessage_arena);
    }
    
  } else {
    
  }
  threshold_ = threshold;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.GCRequest.threshold)
}

inline bool GCRequest::has_txn_span_gc_threshold() const {
  return this != internal_default_instance() && txn_span_gc_threshold_ != NULL;
}
inline const ::znbase::util::hlc::Timestamp& GCRequest::_internal_txn_span_gc_threshold() const {
  return *txn_span_gc_threshold_;
}
inline const ::znbase::util::hlc::Timestamp& GCRequest::txn_span_gc_threshold() const {
  const ::znbase::util::hlc::Timestamp* p = txn_span_gc_threshold_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.GCRequest.txn_span_gc_threshold)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::util::hlc::Timestamp*>(
      &::znbase::util::hlc::_Timestamp_default_instance_);
}
inline ::znbase::util::hlc::Timestamp* GCRequest::release_txn_span_gc_threshold() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.GCRequest.txn_span_gc_threshold)
  
  ::znbase::util::hlc::Timestamp* temp = txn_span_gc_threshold_;
  txn_span_gc_threshold_ = NULL;
  return temp;
}
inline ::znbase::util::hlc::Timestamp* GCRequest::mutable_txn_span_gc_threshold() {
  
  if (txn_span_gc_threshold_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::util::hlc::Timestamp>(GetArenaNoVirtual());
    txn_span_gc_threshold_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.GCRequest.txn_span_gc_threshold)
  return txn_span_gc_threshold_;
}
inline void GCRequest::set_allocated_txn_span_gc_threshold(::znbase::util::hlc::Timestamp* txn_span_gc_threshold) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(txn_span_gc_threshold_);
  }
  if (txn_span_gc_threshold) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      txn_span_gc_threshold = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, txn_span_gc_threshold, submessage_arena);
    }
    
  } else {
    
  }
  txn_span_gc_threshold_ = txn_span_gc_threshold;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.GCRequest.txn_span_gc_threshold)
}

// -------------------------------------------------------------------

// GCResponse

inline bool GCResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GCResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& GCResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& GCResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.GCResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* GCResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.GCResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* GCResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.GCResponse.header)
  return header_;
}
inline void GCResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.GCResponse.header)
}

// -------------------------------------------------------------------

// PushTxnRequest

inline bool PushTxnRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void PushTxnRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& PushTxnRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& PushTxnRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.PushTxnRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* PushTxnRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.PushTxnRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* PushTxnRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.PushTxnRequest.header)
  return header_;
}
inline void PushTxnRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.PushTxnRequest.header)
}

inline bool PushTxnRequest::has_pusher_txn() const {
  return this != internal_default_instance() && pusher_txn_ != NULL;
}
inline const ::znbase::roachpb::Transaction& PushTxnRequest::_internal_pusher_txn() const {
  return *pusher_txn_;
}
inline const ::znbase::roachpb::Transaction& PushTxnRequest::pusher_txn() const {
  const ::znbase::roachpb::Transaction* p = pusher_txn_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.PushTxnRequest.pusher_txn)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::Transaction*>(
      &::znbase::roachpb::_Transaction_default_instance_);
}
inline ::znbase::roachpb::Transaction* PushTxnRequest::release_pusher_txn() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.PushTxnRequest.pusher_txn)
  
  ::znbase::roachpb::Transaction* temp = pusher_txn_;
  pusher_txn_ = NULL;
  return temp;
}
inline ::znbase::roachpb::Transaction* PushTxnRequest::mutable_pusher_txn() {
  
  if (pusher_txn_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::Transaction>(GetArenaNoVirtual());
    pusher_txn_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.PushTxnRequest.pusher_txn)
  return pusher_txn_;
}
inline void PushTxnRequest::set_allocated_pusher_txn(::znbase::roachpb::Transaction* pusher_txn) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pusher_txn_);
  }
  if (pusher_txn) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pusher_txn = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pusher_txn, submessage_arena);
    }
    
  } else {
    
  }
  pusher_txn_ = pusher_txn;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.PushTxnRequest.pusher_txn)
}

inline bool PushTxnRequest::has_pushee_txn() const {
  return this != internal_default_instance() && pushee_txn_ != NULL;
}
inline const ::znbase::storage::engine::enginepb::TxnMeta& PushTxnRequest::_internal_pushee_txn() const {
  return *pushee_txn_;
}
inline const ::znbase::storage::engine::enginepb::TxnMeta& PushTxnRequest::pushee_txn() const {
  const ::znbase::storage::engine::enginepb::TxnMeta* p = pushee_txn_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.PushTxnRequest.pushee_txn)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::storage::engine::enginepb::TxnMeta*>(
      &::znbase::storage::engine::enginepb::_TxnMeta_default_instance_);
}
inline ::znbase::storage::engine::enginepb::TxnMeta* PushTxnRequest::release_pushee_txn() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.PushTxnRequest.pushee_txn)
  
  ::znbase::storage::engine::enginepb::TxnMeta* temp = pushee_txn_;
  pushee_txn_ = NULL;
  return temp;
}
inline ::znbase::storage::engine::enginepb::TxnMeta* PushTxnRequest::mutable_pushee_txn() {
  
  if (pushee_txn_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::storage::engine::enginepb::TxnMeta>(GetArenaNoVirtual());
    pushee_txn_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.PushTxnRequest.pushee_txn)
  return pushee_txn_;
}
inline void PushTxnRequest::set_allocated_pushee_txn(::znbase::storage::engine::enginepb::TxnMeta* pushee_txn) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pushee_txn_);
  }
  if (pushee_txn) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pushee_txn = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pushee_txn, submessage_arena);
    }
    
  } else {
    
  }
  pushee_txn_ = pushee_txn;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.PushTxnRequest.pushee_txn)
}

inline bool PushTxnRequest::has_push_to() const {
  return this != internal_default_instance() && push_to_ != NULL;
}
inline const ::znbase::util::hlc::Timestamp& PushTxnRequest::_internal_push_to() const {
  return *push_to_;
}
inline const ::znbase::util::hlc::Timestamp& PushTxnRequest::push_to() const {
  const ::znbase::util::hlc::Timestamp* p = push_to_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.PushTxnRequest.push_to)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::util::hlc::Timestamp*>(
      &::znbase::util::hlc::_Timestamp_default_instance_);
}
inline ::znbase::util::hlc::Timestamp* PushTxnRequest::release_push_to() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.PushTxnRequest.push_to)
  
  ::znbase::util::hlc::Timestamp* temp = push_to_;
  push_to_ = NULL;
  return temp;
}
inline ::znbase::util::hlc::Timestamp* PushTxnRequest::mutable_push_to() {
  
  if (push_to_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::util::hlc::Timestamp>(GetArenaNoVirtual());
    push_to_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.PushTxnRequest.push_to)
  return push_to_;
}
inline void PushTxnRequest::set_allocated_push_to(::znbase::util::hlc::Timestamp* push_to) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(push_to_);
  }
  if (push_to) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      push_to = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, push_to, submessage_arena);
    }
    
  } else {
    
  }
  push_to_ = push_to;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.PushTxnRequest.push_to)
}

// bool inclusive_push_to = 9;
inline void PushTxnRequest::clear_inclusive_push_to() {
  inclusive_push_to_ = false;
}
inline bool PushTxnRequest::inclusive_push_to() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.PushTxnRequest.inclusive_push_to)
  return inclusive_push_to_;
}
inline void PushTxnRequest::set_inclusive_push_to(bool value) {
  
  inclusive_push_to_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.PushTxnRequest.inclusive_push_to)
}

// .znbase.roachpb.PushTxnType push_type = 6;
inline void PushTxnRequest::clear_push_type() {
  push_type_ = 0;
}
inline ::znbase::roachpb::PushTxnType PushTxnRequest::push_type() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.PushTxnRequest.push_type)
  return static_cast< ::znbase::roachpb::PushTxnType >(push_type_);
}
inline void PushTxnRequest::set_push_type(::znbase::roachpb::PushTxnType value) {
  
  push_type_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.PushTxnRequest.push_type)
}

// bool force = 7;
inline void PushTxnRequest::clear_force() {
  force_ = false;
}
inline bool PushTxnRequest::force() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.PushTxnRequest.force)
  return force_;
}
inline void PushTxnRequest::set_force(bool value) {
  
  force_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.PushTxnRequest.force)
}

// -------------------------------------------------------------------

// PushTxnResponse

inline bool PushTxnResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void PushTxnResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& PushTxnResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& PushTxnResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.PushTxnResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* PushTxnResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.PushTxnResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* PushTxnResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.PushTxnResponse.header)
  return header_;
}
inline void PushTxnResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.PushTxnResponse.header)
}

inline bool PushTxnResponse::has_pushee_txn() const {
  return this != internal_default_instance() && pushee_txn_ != NULL;
}
inline const ::znbase::roachpb::Transaction& PushTxnResponse::_internal_pushee_txn() const {
  return *pushee_txn_;
}
inline const ::znbase::roachpb::Transaction& PushTxnResponse::pushee_txn() const {
  const ::znbase::roachpb::Transaction* p = pushee_txn_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.PushTxnResponse.pushee_txn)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::Transaction*>(
      &::znbase::roachpb::_Transaction_default_instance_);
}
inline ::znbase::roachpb::Transaction* PushTxnResponse::release_pushee_txn() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.PushTxnResponse.pushee_txn)
  
  ::znbase::roachpb::Transaction* temp = pushee_txn_;
  pushee_txn_ = NULL;
  return temp;
}
inline ::znbase::roachpb::Transaction* PushTxnResponse::mutable_pushee_txn() {
  
  if (pushee_txn_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::Transaction>(GetArenaNoVirtual());
    pushee_txn_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.PushTxnResponse.pushee_txn)
  return pushee_txn_;
}
inline void PushTxnResponse::set_allocated_pushee_txn(::znbase::roachpb::Transaction* pushee_txn) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pushee_txn_);
  }
  if (pushee_txn) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pushee_txn = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pushee_txn, submessage_arena);
    }
    
  } else {
    
  }
  pushee_txn_ = pushee_txn;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.PushTxnResponse.pushee_txn)
}

// -------------------------------------------------------------------

// RecoverTxnRequest

inline bool RecoverTxnRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void RecoverTxnRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& RecoverTxnRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& RecoverTxnRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.RecoverTxnRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* RecoverTxnRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RecoverTxnRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* RecoverTxnRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RecoverTxnRequest.header)
  return header_;
}
inline void RecoverTxnRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.RecoverTxnRequest.header)
}

inline bool RecoverTxnRequest::has_txn() const {
  return this != internal_default_instance() && txn_ != NULL;
}
inline const ::znbase::storage::engine::enginepb::TxnMeta& RecoverTxnRequest::_internal_txn() const {
  return *txn_;
}
inline const ::znbase::storage::engine::enginepb::TxnMeta& RecoverTxnRequest::txn() const {
  const ::znbase::storage::engine::enginepb::TxnMeta* p = txn_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.RecoverTxnRequest.txn)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::storage::engine::enginepb::TxnMeta*>(
      &::znbase::storage::engine::enginepb::_TxnMeta_default_instance_);
}
inline ::znbase::storage::engine::enginepb::TxnMeta* RecoverTxnRequest::release_txn() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RecoverTxnRequest.txn)
  
  ::znbase::storage::engine::enginepb::TxnMeta* temp = txn_;
  txn_ = NULL;
  return temp;
}
inline ::znbase::storage::engine::enginepb::TxnMeta* RecoverTxnRequest::mutable_txn() {
  
  if (txn_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::storage::engine::enginepb::TxnMeta>(GetArenaNoVirtual());
    txn_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RecoverTxnRequest.txn)
  return txn_;
}
inline void RecoverTxnRequest::set_allocated_txn(::znbase::storage::engine::enginepb::TxnMeta* txn) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(txn_);
  }
  if (txn) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      txn = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, txn, submessage_arena);
    }
    
  } else {
    
  }
  txn_ = txn;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.RecoverTxnRequest.txn)
}

// bool implicitly_committed = 3;
inline void RecoverTxnRequest::clear_implicitly_committed() {
  implicitly_committed_ = false;
}
inline bool RecoverTxnRequest::implicitly_committed() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RecoverTxnRequest.implicitly_committed)
  return implicitly_committed_;
}
inline void RecoverTxnRequest::set_implicitly_committed(bool value) {
  
  implicitly_committed_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.RecoverTxnRequest.implicitly_committed)
}

// -------------------------------------------------------------------

// RecoverTxnResponse

inline bool RecoverTxnResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void RecoverTxnResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& RecoverTxnResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& RecoverTxnResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.RecoverTxnResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* RecoverTxnResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RecoverTxnResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* RecoverTxnResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RecoverTxnResponse.header)
  return header_;
}
inline void RecoverTxnResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.RecoverTxnResponse.header)
}

inline bool RecoverTxnResponse::has_recovered_txn() const {
  return this != internal_default_instance() && recovered_txn_ != NULL;
}
inline const ::znbase::roachpb::Transaction& RecoverTxnResponse::_internal_recovered_txn() const {
  return *recovered_txn_;
}
inline const ::znbase::roachpb::Transaction& RecoverTxnResponse::recovered_txn() const {
  const ::znbase::roachpb::Transaction* p = recovered_txn_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.RecoverTxnResponse.recovered_txn)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::Transaction*>(
      &::znbase::roachpb::_Transaction_default_instance_);
}
inline ::znbase::roachpb::Transaction* RecoverTxnResponse::release_recovered_txn() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RecoverTxnResponse.recovered_txn)
  
  ::znbase::roachpb::Transaction* temp = recovered_txn_;
  recovered_txn_ = NULL;
  return temp;
}
inline ::znbase::roachpb::Transaction* RecoverTxnResponse::mutable_recovered_txn() {
  
  if (recovered_txn_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::Transaction>(GetArenaNoVirtual());
    recovered_txn_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RecoverTxnResponse.recovered_txn)
  return recovered_txn_;
}
inline void RecoverTxnResponse::set_allocated_recovered_txn(::znbase::roachpb::Transaction* recovered_txn) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(recovered_txn_);
  }
  if (recovered_txn) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      recovered_txn = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, recovered_txn, submessage_arena);
    }
    
  } else {
    
  }
  recovered_txn_ = recovered_txn;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.RecoverTxnResponse.recovered_txn)
}

// -------------------------------------------------------------------

// QueryTxnRequest

inline bool QueryTxnRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void QueryTxnRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& QueryTxnRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& QueryTxnRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.QueryTxnRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* QueryTxnRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.QueryTxnRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* QueryTxnRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.QueryTxnRequest.header)
  return header_;
}
inline void QueryTxnRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.QueryTxnRequest.header)
}

inline bool QueryTxnRequest::has_txn() const {
  return this != internal_default_instance() && txn_ != NULL;
}
inline const ::znbase::storage::engine::enginepb::TxnMeta& QueryTxnRequest::_internal_txn() const {
  return *txn_;
}
inline const ::znbase::storage::engine::enginepb::TxnMeta& QueryTxnRequest::txn() const {
  const ::znbase::storage::engine::enginepb::TxnMeta* p = txn_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.QueryTxnRequest.txn)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::storage::engine::enginepb::TxnMeta*>(
      &::znbase::storage::engine::enginepb::_TxnMeta_default_instance_);
}
inline ::znbase::storage::engine::enginepb::TxnMeta* QueryTxnRequest::release_txn() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.QueryTxnRequest.txn)
  
  ::znbase::storage::engine::enginepb::TxnMeta* temp = txn_;
  txn_ = NULL;
  return temp;
}
inline ::znbase::storage::engine::enginepb::TxnMeta* QueryTxnRequest::mutable_txn() {
  
  if (txn_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::storage::engine::enginepb::TxnMeta>(GetArenaNoVirtual());
    txn_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.QueryTxnRequest.txn)
  return txn_;
}
inline void QueryTxnRequest::set_allocated_txn(::znbase::storage::engine::enginepb::TxnMeta* txn) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(txn_);
  }
  if (txn) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      txn = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, txn, submessage_arena);
    }
    
  } else {
    
  }
  txn_ = txn;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.QueryTxnRequest.txn)
}

// bool wait_for_update = 3;
inline void QueryTxnRequest::clear_wait_for_update() {
  wait_for_update_ = false;
}
inline bool QueryTxnRequest::wait_for_update() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.QueryTxnRequest.wait_for_update)
  return wait_for_update_;
}
inline void QueryTxnRequest::set_wait_for_update(bool value) {
  
  wait_for_update_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.QueryTxnRequest.wait_for_update)
}

inline int QueryTxnRequest::known_waiting_txns_size() const {
  return known_waiting_txns_.size();
}
inline void QueryTxnRequest::clear_known_waiting_txns() {
  known_waiting_txns_.Clear();
}
inline const ::std::string& QueryTxnRequest::known_waiting_txns(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.QueryTxnRequest.known_waiting_txns)
  return known_waiting_txns_.Get(index);
}
inline ::std::string* QueryTxnRequest::mutable_known_waiting_txns(int index) {
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.QueryTxnRequest.known_waiting_txns)
  return known_waiting_txns_.Mutable(index);
}
inline void QueryTxnRequest::set_known_waiting_txns(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:znbase.roachpb.QueryTxnRequest.known_waiting_txns)
  known_waiting_txns_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void QueryTxnRequest::set_known_waiting_txns(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:znbase.roachpb.QueryTxnRequest.known_waiting_txns)
  known_waiting_txns_.Mutable(index)->assign(std::move(value));
}
#endif
inline void QueryTxnRequest::set_known_waiting_txns(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  known_waiting_txns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.QueryTxnRequest.known_waiting_txns)
}
inline void QueryTxnRequest::set_known_waiting_txns(int index, const void* value, size_t size) {
  known_waiting_txns_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.QueryTxnRequest.known_waiting_txns)
}
inline ::std::string* QueryTxnRequest::add_known_waiting_txns() {
  // @@protoc_insertion_point(field_add_mutable:znbase.roachpb.QueryTxnRequest.known_waiting_txns)
  return known_waiting_txns_.Add();
}
inline void QueryTxnRequest::add_known_waiting_txns(const ::std::string& value) {
  known_waiting_txns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:znbase.roachpb.QueryTxnRequest.known_waiting_txns)
}
#if LANG_CXX11
inline void QueryTxnRequest::add_known_waiting_txns(::std::string&& value) {
  known_waiting_txns_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:znbase.roachpb.QueryTxnRequest.known_waiting_txns)
}
#endif
inline void QueryTxnRequest::add_known_waiting_txns(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  known_waiting_txns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:znbase.roachpb.QueryTxnRequest.known_waiting_txns)
}
inline void QueryTxnRequest::add_known_waiting_txns(const void* value, size_t size) {
  known_waiting_txns_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:znbase.roachpb.QueryTxnRequest.known_waiting_txns)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
QueryTxnRequest::known_waiting_txns() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.QueryTxnRequest.known_waiting_txns)
  return known_waiting_txns_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
QueryTxnRequest::mutable_known_waiting_txns() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.QueryTxnRequest.known_waiting_txns)
  return &known_waiting_txns_;
}

// -------------------------------------------------------------------

// QueryTxnResponse

inline bool QueryTxnResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void QueryTxnResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& QueryTxnResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& QueryTxnResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.QueryTxnResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* QueryTxnResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.QueryTxnResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* QueryTxnResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.QueryTxnResponse.header)
  return header_;
}
inline void QueryTxnResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.QueryTxnResponse.header)
}

inline bool QueryTxnResponse::has_queried_txn() const {
  return this != internal_default_instance() && queried_txn_ != NULL;
}
inline const ::znbase::roachpb::Transaction& QueryTxnResponse::_internal_queried_txn() const {
  return *queried_txn_;
}
inline const ::znbase::roachpb::Transaction& QueryTxnResponse::queried_txn() const {
  const ::znbase::roachpb::Transaction* p = queried_txn_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.QueryTxnResponse.queried_txn)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::Transaction*>(
      &::znbase::roachpb::_Transaction_default_instance_);
}
inline ::znbase::roachpb::Transaction* QueryTxnResponse::release_queried_txn() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.QueryTxnResponse.queried_txn)
  
  ::znbase::roachpb::Transaction* temp = queried_txn_;
  queried_txn_ = NULL;
  return temp;
}
inline ::znbase::roachpb::Transaction* QueryTxnResponse::mutable_queried_txn() {
  
  if (queried_txn_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::Transaction>(GetArenaNoVirtual());
    queried_txn_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.QueryTxnResponse.queried_txn)
  return queried_txn_;
}
inline void QueryTxnResponse::set_allocated_queried_txn(::znbase::roachpb::Transaction* queried_txn) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(queried_txn_);
  }
  if (queried_txn) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      queried_txn = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, queried_txn, submessage_arena);
    }
    
  } else {
    
  }
  queried_txn_ = queried_txn;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.QueryTxnResponse.queried_txn)
}

inline int QueryTxnResponse::waiting_txns_size() const {
  return waiting_txns_.size();
}
inline void QueryTxnResponse::clear_waiting_txns() {
  waiting_txns_.Clear();
}
inline const ::std::string& QueryTxnResponse::waiting_txns(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.QueryTxnResponse.waiting_txns)
  return waiting_txns_.Get(index);
}
inline ::std::string* QueryTxnResponse::mutable_waiting_txns(int index) {
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.QueryTxnResponse.waiting_txns)
  return waiting_txns_.Mutable(index);
}
inline void QueryTxnResponse::set_waiting_txns(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:znbase.roachpb.QueryTxnResponse.waiting_txns)
  waiting_txns_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void QueryTxnResponse::set_waiting_txns(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:znbase.roachpb.QueryTxnResponse.waiting_txns)
  waiting_txns_.Mutable(index)->assign(std::move(value));
}
#endif
inline void QueryTxnResponse::set_waiting_txns(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  waiting_txns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.QueryTxnResponse.waiting_txns)
}
inline void QueryTxnResponse::set_waiting_txns(int index, const void* value, size_t size) {
  waiting_txns_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.QueryTxnResponse.waiting_txns)
}
inline ::std::string* QueryTxnResponse::add_waiting_txns() {
  // @@protoc_insertion_point(field_add_mutable:znbase.roachpb.QueryTxnResponse.waiting_txns)
  return waiting_txns_.Add();
}
inline void QueryTxnResponse::add_waiting_txns(const ::std::string& value) {
  waiting_txns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:znbase.roachpb.QueryTxnResponse.waiting_txns)
}
#if LANG_CXX11
inline void QueryTxnResponse::add_waiting_txns(::std::string&& value) {
  waiting_txns_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:znbase.roachpb.QueryTxnResponse.waiting_txns)
}
#endif
inline void QueryTxnResponse::add_waiting_txns(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  waiting_txns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:znbase.roachpb.QueryTxnResponse.waiting_txns)
}
inline void QueryTxnResponse::add_waiting_txns(const void* value, size_t size) {
  waiting_txns_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:znbase.roachpb.QueryTxnResponse.waiting_txns)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
QueryTxnResponse::waiting_txns() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.QueryTxnResponse.waiting_txns)
  return waiting_txns_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
QueryTxnResponse::mutable_waiting_txns() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.QueryTxnResponse.waiting_txns)
  return &waiting_txns_;
}

// -------------------------------------------------------------------

// QueryIntentRequest

inline bool QueryIntentRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void QueryIntentRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& QueryIntentRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& QueryIntentRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.QueryIntentRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* QueryIntentRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.QueryIntentRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* QueryIntentRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.QueryIntentRequest.header)
  return header_;
}
inline void QueryIntentRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.QueryIntentRequest.header)
}

inline bool QueryIntentRequest::has_txn() const {
  return this != internal_default_instance() && txn_ != NULL;
}
inline const ::znbase::storage::engine::enginepb::TxnMeta& QueryIntentRequest::_internal_txn() const {
  return *txn_;
}
inline const ::znbase::storage::engine::enginepb::TxnMeta& QueryIntentRequest::txn() const {
  const ::znbase::storage::engine::enginepb::TxnMeta* p = txn_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.QueryIntentRequest.txn)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::storage::engine::enginepb::TxnMeta*>(
      &::znbase::storage::engine::enginepb::_TxnMeta_default_instance_);
}
inline ::znbase::storage::engine::enginepb::TxnMeta* QueryIntentRequest::release_txn() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.QueryIntentRequest.txn)
  
  ::znbase::storage::engine::enginepb::TxnMeta* temp = txn_;
  txn_ = NULL;
  return temp;
}
inline ::znbase::storage::engine::enginepb::TxnMeta* QueryIntentRequest::mutable_txn() {
  
  if (txn_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::storage::engine::enginepb::TxnMeta>(GetArenaNoVirtual());
    txn_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.QueryIntentRequest.txn)
  return txn_;
}
inline void QueryIntentRequest::set_allocated_txn(::znbase::storage::engine::enginepb::TxnMeta* txn) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(txn_);
  }
  if (txn) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      txn = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, txn, submessage_arena);
    }
    
  } else {
    
  }
  txn_ = txn;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.QueryIntentRequest.txn)
}

// bool error_if_missing = 3;
inline void QueryIntentRequest::clear_error_if_missing() {
  error_if_missing_ = false;
}
inline bool QueryIntentRequest::error_if_missing() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.QueryIntentRequest.error_if_missing)
  return error_if_missing_;
}
inline void QueryIntentRequest::set_error_if_missing(bool value) {
  
  error_if_missing_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.QueryIntentRequest.error_if_missing)
}

// -------------------------------------------------------------------

// QueryIntentResponse

inline bool QueryIntentResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void QueryIntentResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& QueryIntentResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& QueryIntentResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.QueryIntentResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* QueryIntentResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.QueryIntentResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* QueryIntentResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.QueryIntentResponse.header)
  return header_;
}
inline void QueryIntentResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.QueryIntentResponse.header)
}

// bool found_intent = 2;
inline void QueryIntentResponse::clear_found_intent() {
  found_intent_ = false;
}
inline bool QueryIntentResponse::found_intent() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.QueryIntentResponse.found_intent)
  return found_intent_;
}
inline void QueryIntentResponse::set_found_intent(bool value) {
  
  found_intent_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.QueryIntentResponse.found_intent)
}

// -------------------------------------------------------------------

// ResolveIntentRequest

inline bool ResolveIntentRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ResolveIntentRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& ResolveIntentRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& ResolveIntentRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResolveIntentRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* ResolveIntentRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResolveIntentRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* ResolveIntentRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResolveIntentRequest.header)
  return header_;
}
inline void ResolveIntentRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ResolveIntentRequest.header)
}

inline bool ResolveIntentRequest::has_intent_txn() const {
  return this != internal_default_instance() && intent_txn_ != NULL;
}
inline const ::znbase::storage::engine::enginepb::TxnMeta& ResolveIntentRequest::_internal_intent_txn() const {
  return *intent_txn_;
}
inline const ::znbase::storage::engine::enginepb::TxnMeta& ResolveIntentRequest::intent_txn() const {
  const ::znbase::storage::engine::enginepb::TxnMeta* p = intent_txn_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResolveIntentRequest.intent_txn)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::storage::engine::enginepb::TxnMeta*>(
      &::znbase::storage::engine::enginepb::_TxnMeta_default_instance_);
}
inline ::znbase::storage::engine::enginepb::TxnMeta* ResolveIntentRequest::release_intent_txn() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResolveIntentRequest.intent_txn)
  
  ::znbase::storage::engine::enginepb::TxnMeta* temp = intent_txn_;
  intent_txn_ = NULL;
  return temp;
}
inline ::znbase::storage::engine::enginepb::TxnMeta* ResolveIntentRequest::mutable_intent_txn() {
  
  if (intent_txn_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::storage::engine::enginepb::TxnMeta>(GetArenaNoVirtual());
    intent_txn_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResolveIntentRequest.intent_txn)
  return intent_txn_;
}
inline void ResolveIntentRequest::set_allocated_intent_txn(::znbase::storage::engine::enginepb::TxnMeta* intent_txn) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(intent_txn_);
  }
  if (intent_txn) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      intent_txn = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, intent_txn, submessage_arena);
    }
    
  } else {
    
  }
  intent_txn_ = intent_txn;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ResolveIntentRequest.intent_txn)
}

// .znbase.roachpb.TransactionStatus status = 3;
inline void ResolveIntentRequest::clear_status() {
  status_ = 0;
}
inline ::znbase::roachpb::TransactionStatus ResolveIntentRequest::status() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResolveIntentRequest.status)
  return static_cast< ::znbase::roachpb::TransactionStatus >(status_);
}
inline void ResolveIntentRequest::set_status(::znbase::roachpb::TransactionStatus value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.ResolveIntentRequest.status)
}

// bool poison = 4;
inline void ResolveIntentRequest::clear_poison() {
  poison_ = false;
}
inline bool ResolveIntentRequest::poison() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResolveIntentRequest.poison)
  return poison_;
}
inline void ResolveIntentRequest::set_poison(bool value) {
  
  poison_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.ResolveIntentRequest.poison)
}

// bool back_fill = 6;
inline void ResolveIntentRequest::clear_back_fill() {
  back_fill_ = false;
}
inline bool ResolveIntentRequest::back_fill() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResolveIntentRequest.back_fill)
  return back_fill_;
}
inline void ResolveIntentRequest::set_back_fill(bool value) {
  
  back_fill_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.ResolveIntentRequest.back_fill)
}

inline int ResolveIntentRequest::ignored_seqnums_size() const {
  return ignored_seqnums_.size();
}
inline ::znbase::storage::engine::enginepb::IgnoredSeqNumRange* ResolveIntentRequest::mutable_ignored_seqnums(int index) {
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResolveIntentRequest.ignored_seqnums)
  return ignored_seqnums_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::znbase::storage::engine::enginepb::IgnoredSeqNumRange >*
ResolveIntentRequest::mutable_ignored_seqnums() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.ResolveIntentRequest.ignored_seqnums)
  return &ignored_seqnums_;
}
inline const ::znbase::storage::engine::enginepb::IgnoredSeqNumRange& ResolveIntentRequest::ignored_seqnums(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResolveIntentRequest.ignored_seqnums)
  return ignored_seqnums_.Get(index);
}
inline ::znbase::storage::engine::enginepb::IgnoredSeqNumRange* ResolveIntentRequest::add_ignored_seqnums() {
  // @@protoc_insertion_point(field_add:znbase.roachpb.ResolveIntentRequest.ignored_seqnums)
  return ignored_seqnums_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::znbase::storage::engine::enginepb::IgnoredSeqNumRange >&
ResolveIntentRequest::ignored_seqnums() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.ResolveIntentRequest.ignored_seqnums)
  return ignored_seqnums_;
}

// -------------------------------------------------------------------

// ResolveIntentResponse

inline bool ResolveIntentResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ResolveIntentResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& ResolveIntentResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& ResolveIntentResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResolveIntentResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* ResolveIntentResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResolveIntentResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* ResolveIntentResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResolveIntentResponse.header)
  return header_;
}
inline void ResolveIntentResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ResolveIntentResponse.header)
}

// -------------------------------------------------------------------

// ResolveIntentRangeRequest

inline bool ResolveIntentRangeRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ResolveIntentRangeRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& ResolveIntentRangeRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& ResolveIntentRangeRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResolveIntentRangeRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* ResolveIntentRangeRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResolveIntentRangeRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* ResolveIntentRangeRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResolveIntentRangeRequest.header)
  return header_;
}
inline void ResolveIntentRangeRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ResolveIntentRangeRequest.header)
}

inline bool ResolveIntentRangeRequest::has_intent_txn() const {
  return this != internal_default_instance() && intent_txn_ != NULL;
}
inline const ::znbase::storage::engine::enginepb::TxnMeta& ResolveIntentRangeRequest::_internal_intent_txn() const {
  return *intent_txn_;
}
inline const ::znbase::storage::engine::enginepb::TxnMeta& ResolveIntentRangeRequest::intent_txn() const {
  const ::znbase::storage::engine::enginepb::TxnMeta* p = intent_txn_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResolveIntentRangeRequest.intent_txn)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::storage::engine::enginepb::TxnMeta*>(
      &::znbase::storage::engine::enginepb::_TxnMeta_default_instance_);
}
inline ::znbase::storage::engine::enginepb::TxnMeta* ResolveIntentRangeRequest::release_intent_txn() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResolveIntentRangeRequest.intent_txn)
  
  ::znbase::storage::engine::enginepb::TxnMeta* temp = intent_txn_;
  intent_txn_ = NULL;
  return temp;
}
inline ::znbase::storage::engine::enginepb::TxnMeta* ResolveIntentRangeRequest::mutable_intent_txn() {
  
  if (intent_txn_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::storage::engine::enginepb::TxnMeta>(GetArenaNoVirtual());
    intent_txn_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResolveIntentRangeRequest.intent_txn)
  return intent_txn_;
}
inline void ResolveIntentRangeRequest::set_allocated_intent_txn(::znbase::storage::engine::enginepb::TxnMeta* intent_txn) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(intent_txn_);
  }
  if (intent_txn) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      intent_txn = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, intent_txn, submessage_arena);
    }
    
  } else {
    
  }
  intent_txn_ = intent_txn;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ResolveIntentRangeRequest.intent_txn)
}

// .znbase.roachpb.TransactionStatus status = 3;
inline void ResolveIntentRangeRequest::clear_status() {
  status_ = 0;
}
inline ::znbase::roachpb::TransactionStatus ResolveIntentRangeRequest::status() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResolveIntentRangeRequest.status)
  return static_cast< ::znbase::roachpb::TransactionStatus >(status_);
}
inline void ResolveIntentRangeRequest::set_status(::znbase::roachpb::TransactionStatus value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.ResolveIntentRangeRequest.status)
}

// bool poison = 4;
inline void ResolveIntentRangeRequest::clear_poison() {
  poison_ = false;
}
inline bool ResolveIntentRangeRequest::poison() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResolveIntentRangeRequest.poison)
  return poison_;
}
inline void ResolveIntentRangeRequest::set_poison(bool value) {
  
  poison_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.ResolveIntentRangeRequest.poison)
}

inline bool ResolveIntentRangeRequest::has_min_timestamp() const {
  return this != internal_default_instance() && min_timestamp_ != NULL;
}
inline const ::znbase::util::hlc::Timestamp& ResolveIntentRangeRequest::_internal_min_timestamp() const {
  return *min_timestamp_;
}
inline const ::znbase::util::hlc::Timestamp& ResolveIntentRangeRequest::min_timestamp() const {
  const ::znbase::util::hlc::Timestamp* p = min_timestamp_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResolveIntentRangeRequest.min_timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::util::hlc::Timestamp*>(
      &::znbase::util::hlc::_Timestamp_default_instance_);
}
inline ::znbase::util::hlc::Timestamp* ResolveIntentRangeRequest::release_min_timestamp() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResolveIntentRangeRequest.min_timestamp)
  
  ::znbase::util::hlc::Timestamp* temp = min_timestamp_;
  min_timestamp_ = NULL;
  return temp;
}
inline ::znbase::util::hlc::Timestamp* ResolveIntentRangeRequest::mutable_min_timestamp() {
  
  if (min_timestamp_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::util::hlc::Timestamp>(GetArenaNoVirtual());
    min_timestamp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResolveIntentRangeRequest.min_timestamp)
  return min_timestamp_;
}
inline void ResolveIntentRangeRequest::set_allocated_min_timestamp(::znbase::util::hlc::Timestamp* min_timestamp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(min_timestamp_);
  }
  if (min_timestamp) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      min_timestamp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, min_timestamp, submessage_arena);
    }
    
  } else {
    
  }
  min_timestamp_ = min_timestamp;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ResolveIntentRangeRequest.min_timestamp)
}

inline int ResolveIntentRangeRequest::ignored_seqnums_size() const {
  return ignored_seqnums_.size();
}
inline ::znbase::storage::engine::enginepb::IgnoredSeqNumRange* ResolveIntentRangeRequest::mutable_ignored_seqnums(int index) {
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResolveIntentRangeRequest.ignored_seqnums)
  return ignored_seqnums_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::znbase::storage::engine::enginepb::IgnoredSeqNumRange >*
ResolveIntentRangeRequest::mutable_ignored_seqnums() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.ResolveIntentRangeRequest.ignored_seqnums)
  return &ignored_seqnums_;
}
inline const ::znbase::storage::engine::enginepb::IgnoredSeqNumRange& ResolveIntentRangeRequest::ignored_seqnums(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResolveIntentRangeRequest.ignored_seqnums)
  return ignored_seqnums_.Get(index);
}
inline ::znbase::storage::engine::enginepb::IgnoredSeqNumRange* ResolveIntentRangeRequest::add_ignored_seqnums() {
  // @@protoc_insertion_point(field_add:znbase.roachpb.ResolveIntentRangeRequest.ignored_seqnums)
  return ignored_seqnums_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::znbase::storage::engine::enginepb::IgnoredSeqNumRange >&
ResolveIntentRangeRequest::ignored_seqnums() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.ResolveIntentRangeRequest.ignored_seqnums)
  return ignored_seqnums_;
}

// -------------------------------------------------------------------

// ResolveIntentRangeResponse

inline bool ResolveIntentRangeResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ResolveIntentRangeResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& ResolveIntentRangeResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& ResolveIntentRangeResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResolveIntentRangeResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* ResolveIntentRangeResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResolveIntentRangeResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* ResolveIntentRangeResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResolveIntentRangeResponse.header)
  return header_;
}
inline void ResolveIntentRangeResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ResolveIntentRangeResponse.header)
}

// -------------------------------------------------------------------

// MergeRequest

inline bool MergeRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void MergeRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& MergeRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& MergeRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.MergeRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* MergeRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.MergeRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* MergeRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.MergeRequest.header)
  return header_;
}
inline void MergeRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.MergeRequest.header)
}

inline bool MergeRequest::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline const ::znbase::roachpb::Value& MergeRequest::_internal_value() const {
  return *value_;
}
inline const ::znbase::roachpb::Value& MergeRequest::value() const {
  const ::znbase::roachpb::Value* p = value_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.MergeRequest.value)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::Value*>(
      &::znbase::roachpb::_Value_default_instance_);
}
inline ::znbase::roachpb::Value* MergeRequest::release_value() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.MergeRequest.value)
  
  ::znbase::roachpb::Value* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::znbase::roachpb::Value* MergeRequest::mutable_value() {
  
  if (value_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::Value>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.MergeRequest.value)
  return value_;
}
inline void MergeRequest::set_allocated_value(::znbase::roachpb::Value* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(value_);
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.MergeRequest.value)
}

// -------------------------------------------------------------------

// MergeResponse

inline bool MergeResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void MergeResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& MergeResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& MergeResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.MergeResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* MergeResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.MergeResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* MergeResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.MergeResponse.header)
  return header_;
}
inline void MergeResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.MergeResponse.header)
}

// -------------------------------------------------------------------

// TruncateLogRequest

inline bool TruncateLogRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void TruncateLogRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& TruncateLogRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& TruncateLogRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.TruncateLogRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* TruncateLogRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.TruncateLogRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* TruncateLogRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.TruncateLogRequest.header)
  return header_;
}
inline void TruncateLogRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.TruncateLogRequest.header)
}

// uint64 index = 2;
inline void TruncateLogRequest::clear_index() {
  index_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 TruncateLogRequest::index() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.TruncateLogRequest.index)
  return index_;
}
inline void TruncateLogRequest::set_index(::google::protobuf::uint64 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.TruncateLogRequest.index)
}

inline void TruncateLogRequest::clear_range_id() {
  range_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TruncateLogRequest::range_id() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.TruncateLogRequest.range_id)
  return range_id_;
}
inline void TruncateLogRequest::set_range_id(::google::protobuf::int64 value) {
  
  range_id_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.TruncateLogRequest.range_id)
}

// -------------------------------------------------------------------

// TruncateLogResponse

inline bool TruncateLogResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void TruncateLogResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& TruncateLogResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& TruncateLogResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.TruncateLogResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* TruncateLogResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.TruncateLogResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* TruncateLogResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.TruncateLogResponse.header)
  return header_;
}
inline void TruncateLogResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.TruncateLogResponse.header)
}

// -------------------------------------------------------------------

// RequestLeaseRequest

inline bool RequestLeaseRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void RequestLeaseRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& RequestLeaseRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& RequestLeaseRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestLeaseRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* RequestLeaseRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestLeaseRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* RequestLeaseRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestLeaseRequest.header)
  return header_;
}
inline void RequestLeaseRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.RequestLeaseRequest.header)
}

inline bool RequestLeaseRequest::has_lease() const {
  return this != internal_default_instance() && lease_ != NULL;
}
inline const ::znbase::roachpb::Lease& RequestLeaseRequest::_internal_lease() const {
  return *lease_;
}
inline const ::znbase::roachpb::Lease& RequestLeaseRequest::lease() const {
  const ::znbase::roachpb::Lease* p = lease_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestLeaseRequest.lease)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::Lease*>(
      &::znbase::roachpb::_Lease_default_instance_);
}
inline ::znbase::roachpb::Lease* RequestLeaseRequest::release_lease() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestLeaseRequest.lease)
  
  ::znbase::roachpb::Lease* temp = lease_;
  lease_ = NULL;
  return temp;
}
inline ::znbase::roachpb::Lease* RequestLeaseRequest::mutable_lease() {
  
  if (lease_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::Lease>(GetArenaNoVirtual());
    lease_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestLeaseRequest.lease)
  return lease_;
}
inline void RequestLeaseRequest::set_allocated_lease(::znbase::roachpb::Lease* lease) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(lease_);
  }
  if (lease) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      lease = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lease, submessage_arena);
    }
    
  } else {
    
  }
  lease_ = lease;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.RequestLeaseRequest.lease)
}

inline bool RequestLeaseRequest::has_prev_lease() const {
  return this != internal_default_instance() && prev_lease_ != NULL;
}
inline const ::znbase::roachpb::Lease& RequestLeaseRequest::_internal_prev_lease() const {
  return *prev_lease_;
}
inline const ::znbase::roachpb::Lease& RequestLeaseRequest::prev_lease() const {
  const ::znbase::roachpb::Lease* p = prev_lease_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestLeaseRequest.prev_lease)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::Lease*>(
      &::znbase::roachpb::_Lease_default_instance_);
}
inline ::znbase::roachpb::Lease* RequestLeaseRequest::release_prev_lease() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestLeaseRequest.prev_lease)
  
  ::znbase::roachpb::Lease* temp = prev_lease_;
  prev_lease_ = NULL;
  return temp;
}
inline ::znbase::roachpb::Lease* RequestLeaseRequest::mutable_prev_lease() {
  
  if (prev_lease_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::Lease>(GetArenaNoVirtual());
    prev_lease_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestLeaseRequest.prev_lease)
  return prev_lease_;
}
inline void RequestLeaseRequest::set_allocated_prev_lease(::znbase::roachpb::Lease* prev_lease) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(prev_lease_);
  }
  if (prev_lease) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      prev_lease = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, prev_lease, submessage_arena);
    }
    
  } else {
    
  }
  prev_lease_ = prev_lease;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.RequestLeaseRequest.prev_lease)
}

inline bool RequestLeaseRequest::has_min_proposed_ts() const {
  return this != internal_default_instance() && min_proposed_ts_ != NULL;
}
inline const ::znbase::util::hlc::Timestamp& RequestLeaseRequest::_internal_min_proposed_ts() const {
  return *min_proposed_ts_;
}
inline const ::znbase::util::hlc::Timestamp& RequestLeaseRequest::min_proposed_ts() const {
  const ::znbase::util::hlc::Timestamp* p = min_proposed_ts_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestLeaseRequest.min_proposed_ts)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::util::hlc::Timestamp*>(
      &::znbase::util::hlc::_Timestamp_default_instance_);
}
inline ::znbase::util::hlc::Timestamp* RequestLeaseRequest::release_min_proposed_ts() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestLeaseRequest.min_proposed_ts)
  
  ::znbase::util::hlc::Timestamp* temp = min_proposed_ts_;
  min_proposed_ts_ = NULL;
  return temp;
}
inline ::znbase::util::hlc::Timestamp* RequestLeaseRequest::mutable_min_proposed_ts() {
  
  if (min_proposed_ts_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::util::hlc::Timestamp>(GetArenaNoVirtual());
    min_proposed_ts_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestLeaseRequest.min_proposed_ts)
  return min_proposed_ts_;
}
inline void RequestLeaseRequest::set_allocated_min_proposed_ts(::znbase::util::hlc::Timestamp* min_proposed_ts) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(min_proposed_ts_);
  }
  if (min_proposed_ts) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      min_proposed_ts = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, min_proposed_ts, submessage_arena);
    }
    
  } else {
    
  }
  min_proposed_ts_ = min_proposed_ts;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.RequestLeaseRequest.min_proposed_ts)
}

// -------------------------------------------------------------------

// TransferLeaseRequest

inline bool TransferLeaseRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void TransferLeaseRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& TransferLeaseRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& TransferLeaseRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.TransferLeaseRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* TransferLeaseRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.TransferLeaseRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* TransferLeaseRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.TransferLeaseRequest.header)
  return header_;
}
inline void TransferLeaseRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.TransferLeaseRequest.header)
}

inline bool TransferLeaseRequest::has_lease() const {
  return this != internal_default_instance() && lease_ != NULL;
}
inline const ::znbase::roachpb::Lease& TransferLeaseRequest::_internal_lease() const {
  return *lease_;
}
inline const ::znbase::roachpb::Lease& TransferLeaseRequest::lease() const {
  const ::znbase::roachpb::Lease* p = lease_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.TransferLeaseRequest.lease)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::Lease*>(
      &::znbase::roachpb::_Lease_default_instance_);
}
inline ::znbase::roachpb::Lease* TransferLeaseRequest::release_lease() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.TransferLeaseRequest.lease)
  
  ::znbase::roachpb::Lease* temp = lease_;
  lease_ = NULL;
  return temp;
}
inline ::znbase::roachpb::Lease* TransferLeaseRequest::mutable_lease() {
  
  if (lease_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::Lease>(GetArenaNoVirtual());
    lease_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.TransferLeaseRequest.lease)
  return lease_;
}
inline void TransferLeaseRequest::set_allocated_lease(::znbase::roachpb::Lease* lease) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(lease_);
  }
  if (lease) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      lease = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lease, submessage_arena);
    }
    
  } else {
    
  }
  lease_ = lease;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.TransferLeaseRequest.lease)
}

inline bool TransferLeaseRequest::has_prev_lease() const {
  return this != internal_default_instance() && prev_lease_ != NULL;
}
inline const ::znbase::roachpb::Lease& TransferLeaseRequest::_internal_prev_lease() const {
  return *prev_lease_;
}
inline const ::znbase::roachpb::Lease& TransferLeaseRequest::prev_lease() const {
  const ::znbase::roachpb::Lease* p = prev_lease_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.TransferLeaseRequest.prev_lease)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::Lease*>(
      &::znbase::roachpb::_Lease_default_instance_);
}
inline ::znbase::roachpb::Lease* TransferLeaseRequest::release_prev_lease() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.TransferLeaseRequest.prev_lease)
  
  ::znbase::roachpb::Lease* temp = prev_lease_;
  prev_lease_ = NULL;
  return temp;
}
inline ::znbase::roachpb::Lease* TransferLeaseRequest::mutable_prev_lease() {
  
  if (prev_lease_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::Lease>(GetArenaNoVirtual());
    prev_lease_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.TransferLeaseRequest.prev_lease)
  return prev_lease_;
}
inline void TransferLeaseRequest::set_allocated_prev_lease(::znbase::roachpb::Lease* prev_lease) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(prev_lease_);
  }
  if (prev_lease) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      prev_lease = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, prev_lease, submessage_arena);
    }
    
  } else {
    
  }
  prev_lease_ = prev_lease;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.TransferLeaseRequest.prev_lease)
}

// -------------------------------------------------------------------

// LeaseInfoRequest

inline bool LeaseInfoRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void LeaseInfoRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& LeaseInfoRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& LeaseInfoRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.LeaseInfoRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* LeaseInfoRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.LeaseInfoRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* LeaseInfoRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.LeaseInfoRequest.header)
  return header_;
}
inline void LeaseInfoRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.LeaseInfoRequest.header)
}

// -------------------------------------------------------------------

// LeaseInfoResponse

inline bool LeaseInfoResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void LeaseInfoResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& LeaseInfoResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& LeaseInfoResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.LeaseInfoResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* LeaseInfoResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.LeaseInfoResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* LeaseInfoResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.LeaseInfoResponse.header)
  return header_;
}
inline void LeaseInfoResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.LeaseInfoResponse.header)
}

inline bool LeaseInfoResponse::has_lease() const {
  return this != internal_default_instance() && lease_ != NULL;
}
inline const ::znbase::roachpb::Lease& LeaseInfoResponse::_internal_lease() const {
  return *lease_;
}
inline const ::znbase::roachpb::Lease& LeaseInfoResponse::lease() const {
  const ::znbase::roachpb::Lease* p = lease_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.LeaseInfoResponse.lease)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::Lease*>(
      &::znbase::roachpb::_Lease_default_instance_);
}
inline ::znbase::roachpb::Lease* LeaseInfoResponse::release_lease() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.LeaseInfoResponse.lease)
  
  ::znbase::roachpb::Lease* temp = lease_;
  lease_ = NULL;
  return temp;
}
inline ::znbase::roachpb::Lease* LeaseInfoResponse::mutable_lease() {
  
  if (lease_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::Lease>(GetArenaNoVirtual());
    lease_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.LeaseInfoResponse.lease)
  return lease_;
}
inline void LeaseInfoResponse::set_allocated_lease(::znbase::roachpb::Lease* lease) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(lease_);
  }
  if (lease) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      lease = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lease, submessage_arena);
    }
    
  } else {
    
  }
  lease_ = lease;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.LeaseInfoResponse.lease)
}

// -------------------------------------------------------------------

// RequestLeaseResponse

inline bool RequestLeaseResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void RequestLeaseResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& RequestLeaseResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& RequestLeaseResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestLeaseResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* RequestLeaseResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestLeaseResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* RequestLeaseResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestLeaseResponse.header)
  return header_;
}
inline void RequestLeaseResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.RequestLeaseResponse.header)
}

// -------------------------------------------------------------------

// ComputeChecksumRequest

inline bool ComputeChecksumRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ComputeChecksumRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& ComputeChecksumRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& ComputeChecksumRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.ComputeChecksumRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* ComputeChecksumRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ComputeChecksumRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* ComputeChecksumRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ComputeChecksumRequest.header)
  return header_;
}
inline void ComputeChecksumRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ComputeChecksumRequest.header)
}

// uint32 version = 2;
inline void ComputeChecksumRequest::clear_version() {
  version_ = 0u;
}
inline ::google::protobuf::uint32 ComputeChecksumRequest::version() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ComputeChecksumRequest.version)
  return version_;
}
inline void ComputeChecksumRequest::set_version(::google::protobuf::uint32 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.ComputeChecksumRequest.version)
}

// bool snapshot = 4;
inline void ComputeChecksumRequest::clear_snapshot() {
  snapshot_ = false;
}
inline bool ComputeChecksumRequest::snapshot() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ComputeChecksumRequest.snapshot)
  return snapshot_;
}
inline void ComputeChecksumRequest::set_snapshot(bool value) {
  
  snapshot_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.ComputeChecksumRequest.snapshot)
}

// .znbase.roachpb.ChecksumMode mode = 5;
inline void ComputeChecksumRequest::clear_mode() {
  mode_ = 0;
}
inline ::znbase::roachpb::ChecksumMode ComputeChecksumRequest::mode() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ComputeChecksumRequest.mode)
  return static_cast< ::znbase::roachpb::ChecksumMode >(mode_);
}
inline void ComputeChecksumRequest::set_mode(::znbase::roachpb::ChecksumMode value) {
  
  mode_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.ComputeChecksumRequest.mode)
}

// bool checkpoint = 6;
inline void ComputeChecksumRequest::clear_checkpoint() {
  checkpoint_ = false;
}
inline bool ComputeChecksumRequest::checkpoint() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ComputeChecksumRequest.checkpoint)
  return checkpoint_;
}
inline void ComputeChecksumRequest::set_checkpoint(bool value) {
  
  checkpoint_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.ComputeChecksumRequest.checkpoint)
}

// -------------------------------------------------------------------

// ComputeChecksumResponse

inline bool ComputeChecksumResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ComputeChecksumResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& ComputeChecksumResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& ComputeChecksumResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.ComputeChecksumResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* ComputeChecksumResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ComputeChecksumResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* ComputeChecksumResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ComputeChecksumResponse.header)
  return header_;
}
inline void ComputeChecksumResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ComputeChecksumResponse.header)
}

inline void ComputeChecksumResponse::clear_checksum_id() {
  checksum_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ComputeChecksumResponse::checksum_id() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ComputeChecksumResponse.checksum_id)
  return checksum_id_.GetNoArena();
}
inline void ComputeChecksumResponse::set_checksum_id(const ::std::string& value) {
  
  checksum_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.ComputeChecksumResponse.checksum_id)
}
#if LANG_CXX11
inline void ComputeChecksumResponse::set_checksum_id(::std::string&& value) {
  
  checksum_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.ComputeChecksumResponse.checksum_id)
}
#endif
inline void ComputeChecksumResponse::set_checksum_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  checksum_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.ComputeChecksumResponse.checksum_id)
}
inline void ComputeChecksumResponse::set_checksum_id(const void* value, size_t size) {
  
  checksum_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.ComputeChecksumResponse.checksum_id)
}
inline ::std::string* ComputeChecksumResponse::mutable_checksum_id() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ComputeChecksumResponse.checksum_id)
  return checksum_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ComputeChecksumResponse::release_checksum_id() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ComputeChecksumResponse.checksum_id)
  
  return checksum_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ComputeChecksumResponse::set_allocated_checksum_id(::std::string* checksum_id) {
  if (checksum_id != NULL) {
    
  } else {
    
  }
  checksum_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), checksum_id);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ComputeChecksumResponse.checksum_id)
}

// -------------------------------------------------------------------

// ExportStorage_LocalFilePath

// string path = 1;
inline void ExportStorage_LocalFilePath::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExportStorage_LocalFilePath::path() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportStorage.LocalFilePath.path)
  return path_.GetNoArena();
}
inline void ExportStorage_LocalFilePath::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.ExportStorage.LocalFilePath.path)
}
#if LANG_CXX11
inline void ExportStorage_LocalFilePath::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.ExportStorage.LocalFilePath.path)
}
#endif
inline void ExportStorage_LocalFilePath::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.ExportStorage.LocalFilePath.path)
}
inline void ExportStorage_LocalFilePath::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.ExportStorage.LocalFilePath.path)
}
inline ::std::string* ExportStorage_LocalFilePath::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ExportStorage.LocalFilePath.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExportStorage_LocalFilePath::release_path() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ExportStorage.LocalFilePath.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExportStorage_LocalFilePath::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ExportStorage.LocalFilePath.path)
}

inline void ExportStorage_LocalFilePath::clear_node_id() {
  node_id_ = 0u;
}
inline ::google::protobuf::uint32 ExportStorage_LocalFilePath::node_id() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportStorage.LocalFilePath.node_id)
  return node_id_;
}
inline void ExportStorage_LocalFilePath::set_node_id(::google::protobuf::uint32 value) {
  
  node_id_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.ExportStorage.LocalFilePath.node_id)
}

// -------------------------------------------------------------------

// ExportStorage_Http

// string baseUri = 1;
inline void ExportStorage_Http::clear_baseuri() {
  baseuri_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExportStorage_Http::baseuri() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportStorage.Http.baseUri)
  return baseuri_.GetNoArena();
}
inline void ExportStorage_Http::set_baseuri(const ::std::string& value) {
  
  baseuri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.ExportStorage.Http.baseUri)
}
#if LANG_CXX11
inline void ExportStorage_Http::set_baseuri(::std::string&& value) {
  
  baseuri_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.ExportStorage.Http.baseUri)
}
#endif
inline void ExportStorage_Http::set_baseuri(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  baseuri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.ExportStorage.Http.baseUri)
}
inline void ExportStorage_Http::set_baseuri(const char* value, size_t size) {
  
  baseuri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.ExportStorage.Http.baseUri)
}
inline ::std::string* ExportStorage_Http::mutable_baseuri() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ExportStorage.Http.baseUri)
  return baseuri_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExportStorage_Http::release_baseuri() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ExportStorage.Http.baseUri)
  
  return baseuri_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExportStorage_Http::set_allocated_baseuri(::std::string* baseuri) {
  if (baseuri != NULL) {
    
  } else {
    
  }
  baseuri_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), baseuri);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ExportStorage.Http.baseUri)
}

// -------------------------------------------------------------------

// ExportStorage_S3

// string bucket = 1;
inline void ExportStorage_S3::clear_bucket() {
  bucket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExportStorage_S3::bucket() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportStorage.S3.bucket)
  return bucket_.GetNoArena();
}
inline void ExportStorage_S3::set_bucket(const ::std::string& value) {
  
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.ExportStorage.S3.bucket)
}
#if LANG_CXX11
inline void ExportStorage_S3::set_bucket(::std::string&& value) {
  
  bucket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.ExportStorage.S3.bucket)
}
#endif
inline void ExportStorage_S3::set_bucket(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.ExportStorage.S3.bucket)
}
inline void ExportStorage_S3::set_bucket(const char* value, size_t size) {
  
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.ExportStorage.S3.bucket)
}
inline ::std::string* ExportStorage_S3::mutable_bucket() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ExportStorage.S3.bucket)
  return bucket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExportStorage_S3::release_bucket() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ExportStorage.S3.bucket)
  
  return bucket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExportStorage_S3::set_allocated_bucket(::std::string* bucket) {
  if (bucket != NULL) {
    
  } else {
    
  }
  bucket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bucket);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ExportStorage.S3.bucket)
}

// string prefix = 2;
inline void ExportStorage_S3::clear_prefix() {
  prefix_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExportStorage_S3::prefix() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportStorage.S3.prefix)
  return prefix_.GetNoArena();
}
inline void ExportStorage_S3::set_prefix(const ::std::string& value) {
  
  prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.ExportStorage.S3.prefix)
}
#if LANG_CXX11
inline void ExportStorage_S3::set_prefix(::std::string&& value) {
  
  prefix_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.ExportStorage.S3.prefix)
}
#endif
inline void ExportStorage_S3::set_prefix(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.ExportStorage.S3.prefix)
}
inline void ExportStorage_S3::set_prefix(const char* value, size_t size) {
  
  prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.ExportStorage.S3.prefix)
}
inline ::std::string* ExportStorage_S3::mutable_prefix() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ExportStorage.S3.prefix)
  return prefix_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExportStorage_S3::release_prefix() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ExportStorage.S3.prefix)
  
  return prefix_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExportStorage_S3::set_allocated_prefix(::std::string* prefix) {
  if (prefix != NULL) {
    
  } else {
    
  }
  prefix_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), prefix);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ExportStorage.S3.prefix)
}

// string access_key = 3;
inline void ExportStorage_S3::clear_access_key() {
  access_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExportStorage_S3::access_key() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportStorage.S3.access_key)
  return access_key_.GetNoArena();
}
inline void ExportStorage_S3::set_access_key(const ::std::string& value) {
  
  access_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.ExportStorage.S3.access_key)
}
#if LANG_CXX11
inline void ExportStorage_S3::set_access_key(::std::string&& value) {
  
  access_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.ExportStorage.S3.access_key)
}
#endif
inline void ExportStorage_S3::set_access_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  access_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.ExportStorage.S3.access_key)
}
inline void ExportStorage_S3::set_access_key(const char* value, size_t size) {
  
  access_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.ExportStorage.S3.access_key)
}
inline ::std::string* ExportStorage_S3::mutable_access_key() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ExportStorage.S3.access_key)
  return access_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExportStorage_S3::release_access_key() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ExportStorage.S3.access_key)
  
  return access_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExportStorage_S3::set_allocated_access_key(::std::string* access_key) {
  if (access_key != NULL) {
    
  } else {
    
  }
  access_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), access_key);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ExportStorage.S3.access_key)
}

// string secret = 4;
inline void ExportStorage_S3::clear_secret() {
  secret_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExportStorage_S3::secret() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportStorage.S3.secret)
  return secret_.GetNoArena();
}
inline void ExportStorage_S3::set_secret(const ::std::string& value) {
  
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.ExportStorage.S3.secret)
}
#if LANG_CXX11
inline void ExportStorage_S3::set_secret(::std::string&& value) {
  
  secret_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.ExportStorage.S3.secret)
}
#endif
inline void ExportStorage_S3::set_secret(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.ExportStorage.S3.secret)
}
inline void ExportStorage_S3::set_secret(const char* value, size_t size) {
  
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.ExportStorage.S3.secret)
}
inline ::std::string* ExportStorage_S3::mutable_secret() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ExportStorage.S3.secret)
  return secret_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExportStorage_S3::release_secret() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ExportStorage.S3.secret)
  
  return secret_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExportStorage_S3::set_allocated_secret(::std::string* secret) {
  if (secret != NULL) {
    
  } else {
    
  }
  secret_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), secret);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ExportStorage.S3.secret)
}

// string temp_token = 5;
inline void ExportStorage_S3::clear_temp_token() {
  temp_token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExportStorage_S3::temp_token() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportStorage.S3.temp_token)
  return temp_token_.GetNoArena();
}
inline void ExportStorage_S3::set_temp_token(const ::std::string& value) {
  
  temp_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.ExportStorage.S3.temp_token)
}
#if LANG_CXX11
inline void ExportStorage_S3::set_temp_token(::std::string&& value) {
  
  temp_token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.ExportStorage.S3.temp_token)
}
#endif
inline void ExportStorage_S3::set_temp_token(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  temp_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.ExportStorage.S3.temp_token)
}
inline void ExportStorage_S3::set_temp_token(const char* value, size_t size) {
  
  temp_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.ExportStorage.S3.temp_token)
}
inline ::std::string* ExportStorage_S3::mutable_temp_token() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ExportStorage.S3.temp_token)
  return temp_token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExportStorage_S3::release_temp_token() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ExportStorage.S3.temp_token)
  
  return temp_token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExportStorage_S3::set_allocated_temp_token(::std::string* temp_token) {
  if (temp_token != NULL) {
    
  } else {
    
  }
  temp_token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), temp_token);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ExportStorage.S3.temp_token)
}

// string endpoint = 6;
inline void ExportStorage_S3::clear_endpoint() {
  endpoint_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExportStorage_S3::endpoint() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportStorage.S3.endpoint)
  return endpoint_.GetNoArena();
}
inline void ExportStorage_S3::set_endpoint(const ::std::string& value) {
  
  endpoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.ExportStorage.S3.endpoint)
}
#if LANG_CXX11
inline void ExportStorage_S3::set_endpoint(::std::string&& value) {
  
  endpoint_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.ExportStorage.S3.endpoint)
}
#endif
inline void ExportStorage_S3::set_endpoint(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  endpoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.ExportStorage.S3.endpoint)
}
inline void ExportStorage_S3::set_endpoint(const char* value, size_t size) {
  
  endpoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.ExportStorage.S3.endpoint)
}
inline ::std::string* ExportStorage_S3::mutable_endpoint() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ExportStorage.S3.endpoint)
  return endpoint_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExportStorage_S3::release_endpoint() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ExportStorage.S3.endpoint)
  
  return endpoint_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExportStorage_S3::set_allocated_endpoint(::std::string* endpoint) {
  if (endpoint != NULL) {
    
  } else {
    
  }
  endpoint_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), endpoint);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ExportStorage.S3.endpoint)
}

// string region = 7;
inline void ExportStorage_S3::clear_region() {
  region_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExportStorage_S3::region() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportStorage.S3.region)
  return region_.GetNoArena();
}
inline void ExportStorage_S3::set_region(const ::std::string& value) {
  
  region_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.ExportStorage.S3.region)
}
#if LANG_CXX11
inline void ExportStorage_S3::set_region(::std::string&& value) {
  
  region_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.ExportStorage.S3.region)
}
#endif
inline void ExportStorage_S3::set_region(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  region_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.ExportStorage.S3.region)
}
inline void ExportStorage_S3::set_region(const char* value, size_t size) {
  
  region_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.ExportStorage.S3.region)
}
inline ::std::string* ExportStorage_S3::mutable_region() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ExportStorage.S3.region)
  return region_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExportStorage_S3::release_region() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ExportStorage.S3.region)
  
  return region_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExportStorage_S3::set_allocated_region(::std::string* region) {
  if (region != NULL) {
    
  } else {
    
  }
  region_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), region);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ExportStorage.S3.region)
}

// -------------------------------------------------------------------

// ExportStorage_GCS

// string bucket = 1;
inline void ExportStorage_GCS::clear_bucket() {
  bucket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExportStorage_GCS::bucket() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportStorage.GCS.bucket)
  return bucket_.GetNoArena();
}
inline void ExportStorage_GCS::set_bucket(const ::std::string& value) {
  
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.ExportStorage.GCS.bucket)
}
#if LANG_CXX11
inline void ExportStorage_GCS::set_bucket(::std::string&& value) {
  
  bucket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.ExportStorage.GCS.bucket)
}
#endif
inline void ExportStorage_GCS::set_bucket(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.ExportStorage.GCS.bucket)
}
inline void ExportStorage_GCS::set_bucket(const char* value, size_t size) {
  
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.ExportStorage.GCS.bucket)
}
inline ::std::string* ExportStorage_GCS::mutable_bucket() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ExportStorage.GCS.bucket)
  return bucket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExportStorage_GCS::release_bucket() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ExportStorage.GCS.bucket)
  
  return bucket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExportStorage_GCS::set_allocated_bucket(::std::string* bucket) {
  if (bucket != NULL) {
    
  } else {
    
  }
  bucket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bucket);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ExportStorage.GCS.bucket)
}

// string prefix = 2;
inline void ExportStorage_GCS::clear_prefix() {
  prefix_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExportStorage_GCS::prefix() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportStorage.GCS.prefix)
  return prefix_.GetNoArena();
}
inline void ExportStorage_GCS::set_prefix(const ::std::string& value) {
  
  prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.ExportStorage.GCS.prefix)
}
#if LANG_CXX11
inline void ExportStorage_GCS::set_prefix(::std::string&& value) {
  
  prefix_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.ExportStorage.GCS.prefix)
}
#endif
inline void ExportStorage_GCS::set_prefix(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.ExportStorage.GCS.prefix)
}
inline void ExportStorage_GCS::set_prefix(const char* value, size_t size) {
  
  prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.ExportStorage.GCS.prefix)
}
inline ::std::string* ExportStorage_GCS::mutable_prefix() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ExportStorage.GCS.prefix)
  return prefix_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExportStorage_GCS::release_prefix() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ExportStorage.GCS.prefix)
  
  return prefix_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExportStorage_GCS::set_allocated_prefix(::std::string* prefix) {
  if (prefix != NULL) {
    
  } else {
    
  }
  prefix_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), prefix);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ExportStorage.GCS.prefix)
}

// string auth = 3;
inline void ExportStorage_GCS::clear_auth() {
  auth_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExportStorage_GCS::auth() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportStorage.GCS.auth)
  return auth_.GetNoArena();
}
inline void ExportStorage_GCS::set_auth(const ::std::string& value) {
  
  auth_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.ExportStorage.GCS.auth)
}
#if LANG_CXX11
inline void ExportStorage_GCS::set_auth(::std::string&& value) {
  
  auth_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.ExportStorage.GCS.auth)
}
#endif
inline void ExportStorage_GCS::set_auth(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  auth_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.ExportStorage.GCS.auth)
}
inline void ExportStorage_GCS::set_auth(const char* value, size_t size) {
  
  auth_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.ExportStorage.GCS.auth)
}
inline ::std::string* ExportStorage_GCS::mutable_auth() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ExportStorage.GCS.auth)
  return auth_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExportStorage_GCS::release_auth() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ExportStorage.GCS.auth)
  
  return auth_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExportStorage_GCS::set_allocated_auth(::std::string* auth) {
  if (auth != NULL) {
    
  } else {
    
  }
  auth_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), auth);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ExportStorage.GCS.auth)
}

// string billing_project = 4;
inline void ExportStorage_GCS::clear_billing_project() {
  billing_project_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExportStorage_GCS::billing_project() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportStorage.GCS.billing_project)
  return billing_project_.GetNoArena();
}
inline void ExportStorage_GCS::set_billing_project(const ::std::string& value) {
  
  billing_project_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.ExportStorage.GCS.billing_project)
}
#if LANG_CXX11
inline void ExportStorage_GCS::set_billing_project(::std::string&& value) {
  
  billing_project_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.ExportStorage.GCS.billing_project)
}
#endif
inline void ExportStorage_GCS::set_billing_project(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  billing_project_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.ExportStorage.GCS.billing_project)
}
inline void ExportStorage_GCS::set_billing_project(const char* value, size_t size) {
  
  billing_project_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.ExportStorage.GCS.billing_project)
}
inline ::std::string* ExportStorage_GCS::mutable_billing_project() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ExportStorage.GCS.billing_project)
  return billing_project_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExportStorage_GCS::release_billing_project() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ExportStorage.GCS.billing_project)
  
  return billing_project_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExportStorage_GCS::set_allocated_billing_project(::std::string* billing_project) {
  if (billing_project != NULL) {
    
  } else {
    
  }
  billing_project_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), billing_project);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ExportStorage.GCS.billing_project)
}

// string credentials = 5;
inline void ExportStorage_GCS::clear_credentials() {
  credentials_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExportStorage_GCS::credentials() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportStorage.GCS.credentials)
  return credentials_.GetNoArena();
}
inline void ExportStorage_GCS::set_credentials(const ::std::string& value) {
  
  credentials_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.ExportStorage.GCS.credentials)
}
#if LANG_CXX11
inline void ExportStorage_GCS::set_credentials(::std::string&& value) {
  
  credentials_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.ExportStorage.GCS.credentials)
}
#endif
inline void ExportStorage_GCS::set_credentials(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  credentials_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.ExportStorage.GCS.credentials)
}
inline void ExportStorage_GCS::set_credentials(const char* value, size_t size) {
  
  credentials_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.ExportStorage.GCS.credentials)
}
inline ::std::string* ExportStorage_GCS::mutable_credentials() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ExportStorage.GCS.credentials)
  return credentials_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExportStorage_GCS::release_credentials() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ExportStorage.GCS.credentials)
  
  return credentials_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExportStorage_GCS::set_allocated_credentials(::std::string* credentials) {
  if (credentials != NULL) {
    
  } else {
    
  }
  credentials_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), credentials);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ExportStorage.GCS.credentials)
}

// -------------------------------------------------------------------

// ExportStorage_Azure

// string container = 1;
inline void ExportStorage_Azure::clear_container() {
  container_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExportStorage_Azure::container() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportStorage.Azure.container)
  return container_.GetNoArena();
}
inline void ExportStorage_Azure::set_container(const ::std::string& value) {
  
  container_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.ExportStorage.Azure.container)
}
#if LANG_CXX11
inline void ExportStorage_Azure::set_container(::std::string&& value) {
  
  container_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.ExportStorage.Azure.container)
}
#endif
inline void ExportStorage_Azure::set_container(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  container_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.ExportStorage.Azure.container)
}
inline void ExportStorage_Azure::set_container(const char* value, size_t size) {
  
  container_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.ExportStorage.Azure.container)
}
inline ::std::string* ExportStorage_Azure::mutable_container() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ExportStorage.Azure.container)
  return container_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExportStorage_Azure::release_container() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ExportStorage.Azure.container)
  
  return container_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExportStorage_Azure::set_allocated_container(::std::string* container) {
  if (container != NULL) {
    
  } else {
    
  }
  container_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), container);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ExportStorage.Azure.container)
}

// string prefix = 2;
inline void ExportStorage_Azure::clear_prefix() {
  prefix_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExportStorage_Azure::prefix() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportStorage.Azure.prefix)
  return prefix_.GetNoArena();
}
inline void ExportStorage_Azure::set_prefix(const ::std::string& value) {
  
  prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.ExportStorage.Azure.prefix)
}
#if LANG_CXX11
inline void ExportStorage_Azure::set_prefix(::std::string&& value) {
  
  prefix_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.ExportStorage.Azure.prefix)
}
#endif
inline void ExportStorage_Azure::set_prefix(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.ExportStorage.Azure.prefix)
}
inline void ExportStorage_Azure::set_prefix(const char* value, size_t size) {
  
  prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.ExportStorage.Azure.prefix)
}
inline ::std::string* ExportStorage_Azure::mutable_prefix() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ExportStorage.Azure.prefix)
  return prefix_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExportStorage_Azure::release_prefix() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ExportStorage.Azure.prefix)
  
  return prefix_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExportStorage_Azure::set_allocated_prefix(::std::string* prefix) {
  if (prefix != NULL) {
    
  } else {
    
  }
  prefix_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), prefix);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ExportStorage.Azure.prefix)
}

// string account_name = 3;
inline void ExportStorage_Azure::clear_account_name() {
  account_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExportStorage_Azure::account_name() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportStorage.Azure.account_name)
  return account_name_.GetNoArena();
}
inline void ExportStorage_Azure::set_account_name(const ::std::string& value) {
  
  account_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.ExportStorage.Azure.account_name)
}
#if LANG_CXX11
inline void ExportStorage_Azure::set_account_name(::std::string&& value) {
  
  account_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.ExportStorage.Azure.account_name)
}
#endif
inline void ExportStorage_Azure::set_account_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  account_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.ExportStorage.Azure.account_name)
}
inline void ExportStorage_Azure::set_account_name(const char* value, size_t size) {
  
  account_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.ExportStorage.Azure.account_name)
}
inline ::std::string* ExportStorage_Azure::mutable_account_name() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ExportStorage.Azure.account_name)
  return account_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExportStorage_Azure::release_account_name() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ExportStorage.Azure.account_name)
  
  return account_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExportStorage_Azure::set_allocated_account_name(::std::string* account_name) {
  if (account_name != NULL) {
    
  } else {
    
  }
  account_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account_name);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ExportStorage.Azure.account_name)
}

// string account_key = 4;
inline void ExportStorage_Azure::clear_account_key() {
  account_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExportStorage_Azure::account_key() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportStorage.Azure.account_key)
  return account_key_.GetNoArena();
}
inline void ExportStorage_Azure::set_account_key(const ::std::string& value) {
  
  account_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.ExportStorage.Azure.account_key)
}
#if LANG_CXX11
inline void ExportStorage_Azure::set_account_key(::std::string&& value) {
  
  account_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.ExportStorage.Azure.account_key)
}
#endif
inline void ExportStorage_Azure::set_account_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  account_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.ExportStorage.Azure.account_key)
}
inline void ExportStorage_Azure::set_account_key(const char* value, size_t size) {
  
  account_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.ExportStorage.Azure.account_key)
}
inline ::std::string* ExportStorage_Azure::mutable_account_key() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ExportStorage.Azure.account_key)
  return account_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExportStorage_Azure::release_account_key() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ExportStorage.Azure.account_key)
  
  return account_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExportStorage_Azure::set_allocated_account_key(::std::string* account_key) {
  if (account_key != NULL) {
    
  } else {
    
  }
  account_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account_key);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ExportStorage.Azure.account_key)
}

// -------------------------------------------------------------------

// ExportStorage_Workload

// string generator = 1;
inline void ExportStorage_Workload::clear_generator() {
  generator_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExportStorage_Workload::generator() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportStorage.Workload.generator)
  return generator_.GetNoArena();
}
inline void ExportStorage_Workload::set_generator(const ::std::string& value) {
  
  generator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.ExportStorage.Workload.generator)
}
#if LANG_CXX11
inline void ExportStorage_Workload::set_generator(::std::string&& value) {
  
  generator_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.ExportStorage.Workload.generator)
}
#endif
inline void ExportStorage_Workload::set_generator(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  generator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.ExportStorage.Workload.generator)
}
inline void ExportStorage_Workload::set_generator(const char* value, size_t size) {
  
  generator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.ExportStorage.Workload.generator)
}
inline ::std::string* ExportStorage_Workload::mutable_generator() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ExportStorage.Workload.generator)
  return generator_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExportStorage_Workload::release_generator() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ExportStorage.Workload.generator)
  
  return generator_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExportStorage_Workload::set_allocated_generator(::std::string* generator) {
  if (generator != NULL) {
    
  } else {
    
  }
  generator_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), generator);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ExportStorage.Workload.generator)
}

// string version = 2;
inline void ExportStorage_Workload::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExportStorage_Workload::version() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportStorage.Workload.version)
  return version_.GetNoArena();
}
inline void ExportStorage_Workload::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.ExportStorage.Workload.version)
}
#if LANG_CXX11
inline void ExportStorage_Workload::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.ExportStorage.Workload.version)
}
#endif
inline void ExportStorage_Workload::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.ExportStorage.Workload.version)
}
inline void ExportStorage_Workload::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.ExportStorage.Workload.version)
}
inline ::std::string* ExportStorage_Workload::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ExportStorage.Workload.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExportStorage_Workload::release_version() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ExportStorage.Workload.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExportStorage_Workload::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ExportStorage.Workload.version)
}

// string table = 3;
inline void ExportStorage_Workload::clear_table() {
  table_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExportStorage_Workload::table() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportStorage.Workload.table)
  return table_.GetNoArena();
}
inline void ExportStorage_Workload::set_table(const ::std::string& value) {
  
  table_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.ExportStorage.Workload.table)
}
#if LANG_CXX11
inline void ExportStorage_Workload::set_table(::std::string&& value) {
  
  table_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.ExportStorage.Workload.table)
}
#endif
inline void ExportStorage_Workload::set_table(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  table_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.ExportStorage.Workload.table)
}
inline void ExportStorage_Workload::set_table(const char* value, size_t size) {
  
  table_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.ExportStorage.Workload.table)
}
inline ::std::string* ExportStorage_Workload::mutable_table() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ExportStorage.Workload.table)
  return table_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExportStorage_Workload::release_table() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ExportStorage.Workload.table)
  
  return table_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExportStorage_Workload::set_allocated_table(::std::string* table) {
  if (table != NULL) {
    
  } else {
    
  }
  table_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), table);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ExportStorage.Workload.table)
}

// repeated string flags = 4;
inline int ExportStorage_Workload::flags_size() const {
  return flags_.size();
}
inline void ExportStorage_Workload::clear_flags() {
  flags_.Clear();
}
inline const ::std::string& ExportStorage_Workload::flags(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportStorage.Workload.flags)
  return flags_.Get(index);
}
inline ::std::string* ExportStorage_Workload::mutable_flags(int index) {
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ExportStorage.Workload.flags)
  return flags_.Mutable(index);
}
inline void ExportStorage_Workload::set_flags(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:znbase.roachpb.ExportStorage.Workload.flags)
  flags_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ExportStorage_Workload::set_flags(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:znbase.roachpb.ExportStorage.Workload.flags)
  flags_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ExportStorage_Workload::set_flags(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  flags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.ExportStorage.Workload.flags)
}
inline void ExportStorage_Workload::set_flags(int index, const char* value, size_t size) {
  flags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.ExportStorage.Workload.flags)
}
inline ::std::string* ExportStorage_Workload::add_flags() {
  // @@protoc_insertion_point(field_add_mutable:znbase.roachpb.ExportStorage.Workload.flags)
  return flags_.Add();
}
inline void ExportStorage_Workload::add_flags(const ::std::string& value) {
  flags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:znbase.roachpb.ExportStorage.Workload.flags)
}
#if LANG_CXX11
inline void ExportStorage_Workload::add_flags(::std::string&& value) {
  flags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:znbase.roachpb.ExportStorage.Workload.flags)
}
#endif
inline void ExportStorage_Workload::add_flags(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  flags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:znbase.roachpb.ExportStorage.Workload.flags)
}
inline void ExportStorage_Workload::add_flags(const char* value, size_t size) {
  flags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:znbase.roachpb.ExportStorage.Workload.flags)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ExportStorage_Workload::flags() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.ExportStorage.Workload.flags)
  return flags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ExportStorage_Workload::mutable_flags() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.ExportStorage.Workload.flags)
  return &flags_;
}

// string format = 5;
inline void ExportStorage_Workload::clear_format() {
  format_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExportStorage_Workload::format() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportStorage.Workload.format)
  return format_.GetNoArena();
}
inline void ExportStorage_Workload::set_format(const ::std::string& value) {
  
  format_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.ExportStorage.Workload.format)
}
#if LANG_CXX11
inline void ExportStorage_Workload::set_format(::std::string&& value) {
  
  format_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.ExportStorage.Workload.format)
}
#endif
inline void ExportStorage_Workload::set_format(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  format_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.ExportStorage.Workload.format)
}
inline void ExportStorage_Workload::set_format(const char* value, size_t size) {
  
  format_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.ExportStorage.Workload.format)
}
inline ::std::string* ExportStorage_Workload::mutable_format() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ExportStorage.Workload.format)
  return format_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExportStorage_Workload::release_format() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ExportStorage.Workload.format)
  
  return format_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExportStorage_Workload::set_allocated_format(::std::string* format) {
  if (format != NULL) {
    
  } else {
    
  }
  format_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), format);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ExportStorage.Workload.format)
}

// int64 batch_begin = 6;
inline void ExportStorage_Workload::clear_batch_begin() {
  batch_begin_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ExportStorage_Workload::batch_begin() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportStorage.Workload.batch_begin)
  return batch_begin_;
}
inline void ExportStorage_Workload::set_batch_begin(::google::protobuf::int64 value) {
  
  batch_begin_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.ExportStorage.Workload.batch_begin)
}

// int64 batch_end = 7;
inline void ExportStorage_Workload::clear_batch_end() {
  batch_end_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ExportStorage_Workload::batch_end() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportStorage.Workload.batch_end)
  return batch_end_;
}
inline void ExportStorage_Workload::set_batch_end(::google::protobuf::int64 value) {
  
  batch_end_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.ExportStorage.Workload.batch_end)
}

// -------------------------------------------------------------------

// ExportStorage

// .znbase.roachpb.ExportStorageProvider provider = 1;
inline void ExportStorage::clear_provider() {
  provider_ = 0;
}
inline ::znbase::roachpb::ExportStorageProvider ExportStorage::provider() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportStorage.provider)
  return static_cast< ::znbase::roachpb::ExportStorageProvider >(provider_);
}
inline void ExportStorage::set_provider(::znbase::roachpb::ExportStorageProvider value) {
  
  provider_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.ExportStorage.provider)
}

inline bool ExportStorage::has_localfile() const {
  return this != internal_default_instance() && localfile_ != NULL;
}
inline void ExportStorage::clear_localfile() {
  if (GetArenaNoVirtual() == NULL && localfile_ != NULL) {
    delete localfile_;
  }
  localfile_ = NULL;
}
inline const ::znbase::roachpb::ExportStorage_LocalFilePath& ExportStorage::_internal_localfile() const {
  return *localfile_;
}
inline const ::znbase::roachpb::ExportStorage_LocalFilePath& ExportStorage::localfile() const {
  const ::znbase::roachpb::ExportStorage_LocalFilePath* p = localfile_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportStorage.LocalFile)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ExportStorage_LocalFilePath*>(
      &::znbase::roachpb::_ExportStorage_LocalFilePath_default_instance_);
}
inline ::znbase::roachpb::ExportStorage_LocalFilePath* ExportStorage::release_localfile() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ExportStorage.LocalFile)
  
  ::znbase::roachpb::ExportStorage_LocalFilePath* temp = localfile_;
  localfile_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ExportStorage_LocalFilePath* ExportStorage::mutable_localfile() {
  
  if (localfile_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ExportStorage_LocalFilePath>(GetArenaNoVirtual());
    localfile_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ExportStorage.LocalFile)
  return localfile_;
}
inline void ExportStorage::set_allocated_localfile(::znbase::roachpb::ExportStorage_LocalFilePath* localfile) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete localfile_;
  }
  if (localfile) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      localfile = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, localfile, submessage_arena);
    }
    
  } else {
    
  }
  localfile_ = localfile;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ExportStorage.LocalFile)
}

inline bool ExportStorage::has_httppath() const {
  return this != internal_default_instance() && httppath_ != NULL;
}
inline void ExportStorage::clear_httppath() {
  if (GetArenaNoVirtual() == NULL && httppath_ != NULL) {
    delete httppath_;
  }
  httppath_ = NULL;
}
inline const ::znbase::roachpb::ExportStorage_Http& ExportStorage::_internal_httppath() const {
  return *httppath_;
}
inline const ::znbase::roachpb::ExportStorage_Http& ExportStorage::httppath() const {
  const ::znbase::roachpb::ExportStorage_Http* p = httppath_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportStorage.HttpPath)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ExportStorage_Http*>(
      &::znbase::roachpb::_ExportStorage_Http_default_instance_);
}
inline ::znbase::roachpb::ExportStorage_Http* ExportStorage::release_httppath() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ExportStorage.HttpPath)
  
  ::znbase::roachpb::ExportStorage_Http* temp = httppath_;
  httppath_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ExportStorage_Http* ExportStorage::mutable_httppath() {
  
  if (httppath_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ExportStorage_Http>(GetArenaNoVirtual());
    httppath_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ExportStorage.HttpPath)
  return httppath_;
}
inline void ExportStorage::set_allocated_httppath(::znbase::roachpb::ExportStorage_Http* httppath) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete httppath_;
  }
  if (httppath) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      httppath = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, httppath, submessage_arena);
    }
    
  } else {
    
  }
  httppath_ = httppath;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ExportStorage.HttpPath)
}

// .znbase.roachpb.ExportStorage.GCS GoogleCloudConfig = 4;
inline bool ExportStorage::has_googlecloudconfig() const {
  return this != internal_default_instance() && googlecloudconfig_ != NULL;
}
inline void ExportStorage::clear_googlecloudconfig() {
  if (GetArenaNoVirtual() == NULL && googlecloudconfig_ != NULL) {
    delete googlecloudconfig_;
  }
  googlecloudconfig_ = NULL;
}
inline const ::znbase::roachpb::ExportStorage_GCS& ExportStorage::_internal_googlecloudconfig() const {
  return *googlecloudconfig_;
}
inline const ::znbase::roachpb::ExportStorage_GCS& ExportStorage::googlecloudconfig() const {
  const ::znbase::roachpb::ExportStorage_GCS* p = googlecloudconfig_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportStorage.GoogleCloudConfig)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ExportStorage_GCS*>(
      &::znbase::roachpb::_ExportStorage_GCS_default_instance_);
}
inline ::znbase::roachpb::ExportStorage_GCS* ExportStorage::release_googlecloudconfig() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ExportStorage.GoogleCloudConfig)
  
  ::znbase::roachpb::ExportStorage_GCS* temp = googlecloudconfig_;
  googlecloudconfig_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ExportStorage_GCS* ExportStorage::mutable_googlecloudconfig() {
  
  if (googlecloudconfig_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ExportStorage_GCS>(GetArenaNoVirtual());
    googlecloudconfig_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ExportStorage.GoogleCloudConfig)
  return googlecloudconfig_;
}
inline void ExportStorage::set_allocated_googlecloudconfig(::znbase::roachpb::ExportStorage_GCS* googlecloudconfig) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete googlecloudconfig_;
  }
  if (googlecloudconfig) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      googlecloudconfig = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, googlecloudconfig, submessage_arena);
    }
    
  } else {
    
  }
  googlecloudconfig_ = googlecloudconfig;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ExportStorage.GoogleCloudConfig)
}

// .znbase.roachpb.ExportStorage.S3 S3Config = 5;
inline bool ExportStorage::has_s3config() const {
  return this != internal_default_instance() && s3config_ != NULL;
}
inline void ExportStorage::clear_s3config() {
  if (GetArenaNoVirtual() == NULL && s3config_ != NULL) {
    delete s3config_;
  }
  s3config_ = NULL;
}
inline const ::znbase::roachpb::ExportStorage_S3& ExportStorage::_internal_s3config() const {
  return *s3config_;
}
inline const ::znbase::roachpb::ExportStorage_S3& ExportStorage::s3config() const {
  const ::znbase::roachpb::ExportStorage_S3* p = s3config_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportStorage.S3Config)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ExportStorage_S3*>(
      &::znbase::roachpb::_ExportStorage_S3_default_instance_);
}
inline ::znbase::roachpb::ExportStorage_S3* ExportStorage::release_s3config() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ExportStorage.S3Config)
  
  ::znbase::roachpb::ExportStorage_S3* temp = s3config_;
  s3config_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ExportStorage_S3* ExportStorage::mutable_s3config() {
  
  if (s3config_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ExportStorage_S3>(GetArenaNoVirtual());
    s3config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ExportStorage.S3Config)
  return s3config_;
}
inline void ExportStorage::set_allocated_s3config(::znbase::roachpb::ExportStorage_S3* s3config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete s3config_;
  }
  if (s3config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      s3config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, s3config, submessage_arena);
    }
    
  } else {
    
  }
  s3config_ = s3config;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ExportStorage.S3Config)
}

// .znbase.roachpb.ExportStorage.Azure AzureConfig = 6;
inline bool ExportStorage::has_azureconfig() const {
  return this != internal_default_instance() && azureconfig_ != NULL;
}
inline void ExportStorage::clear_azureconfig() {
  if (GetArenaNoVirtual() == NULL && azureconfig_ != NULL) {
    delete azureconfig_;
  }
  azureconfig_ = NULL;
}
inline const ::znbase::roachpb::ExportStorage_Azure& ExportStorage::_internal_azureconfig() const {
  return *azureconfig_;
}
inline const ::znbase::roachpb::ExportStorage_Azure& ExportStorage::azureconfig() const {
  const ::znbase::roachpb::ExportStorage_Azure* p = azureconfig_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportStorage.AzureConfig)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ExportStorage_Azure*>(
      &::znbase::roachpb::_ExportStorage_Azure_default_instance_);
}
inline ::znbase::roachpb::ExportStorage_Azure* ExportStorage::release_azureconfig() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ExportStorage.AzureConfig)
  
  ::znbase::roachpb::ExportStorage_Azure* temp = azureconfig_;
  azureconfig_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ExportStorage_Azure* ExportStorage::mutable_azureconfig() {
  
  if (azureconfig_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ExportStorage_Azure>(GetArenaNoVirtual());
    azureconfig_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ExportStorage.AzureConfig)
  return azureconfig_;
}
inline void ExportStorage::set_allocated_azureconfig(::znbase::roachpb::ExportStorage_Azure* azureconfig) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete azureconfig_;
  }
  if (azureconfig) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      azureconfig = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, azureconfig, submessage_arena);
    }
    
  } else {
    
  }
  azureconfig_ = azureconfig;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ExportStorage.AzureConfig)
}

// .znbase.roachpb.ExportStorage.Workload WorkloadConfig = 7;
inline bool ExportStorage::has_workloadconfig() const {
  return this != internal_default_instance() && workloadconfig_ != NULL;
}
inline void ExportStorage::clear_workloadconfig() {
  if (GetArenaNoVirtual() == NULL && workloadconfig_ != NULL) {
    delete workloadconfig_;
  }
  workloadconfig_ = NULL;
}
inline const ::znbase::roachpb::ExportStorage_Workload& ExportStorage::_internal_workloadconfig() const {
  return *workloadconfig_;
}
inline const ::znbase::roachpb::ExportStorage_Workload& ExportStorage::workloadconfig() const {
  const ::znbase::roachpb::ExportStorage_Workload* p = workloadconfig_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportStorage.WorkloadConfig)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ExportStorage_Workload*>(
      &::znbase::roachpb::_ExportStorage_Workload_default_instance_);
}
inline ::znbase::roachpb::ExportStorage_Workload* ExportStorage::release_workloadconfig() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ExportStorage.WorkloadConfig)
  
  ::znbase::roachpb::ExportStorage_Workload* temp = workloadconfig_;
  workloadconfig_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ExportStorage_Workload* ExportStorage::mutable_workloadconfig() {
  
  if (workloadconfig_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ExportStorage_Workload>(GetArenaNoVirtual());
    workloadconfig_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ExportStorage.WorkloadConfig)
  return workloadconfig_;
}
inline void ExportStorage::set_allocated_workloadconfig(::znbase::roachpb::ExportStorage_Workload* workloadconfig) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete workloadconfig_;
  }
  if (workloadconfig) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      workloadconfig = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, workloadconfig, submessage_arena);
    }
    
  } else {
    
  }
  workloadconfig_ = workloadconfig;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ExportStorage.WorkloadConfig)
}

// -------------------------------------------------------------------

// DumpSink_LocalFilePath

// string path = 1;
inline void DumpSink_LocalFilePath::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DumpSink_LocalFilePath::path() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.LocalFilePath.path)
  return path_.GetNoArena();
}
inline void DumpSink_LocalFilePath::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpSink.LocalFilePath.path)
}
#if LANG_CXX11
inline void DumpSink_LocalFilePath::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.DumpSink.LocalFilePath.path)
}
#endif
inline void DumpSink_LocalFilePath::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.DumpSink.LocalFilePath.path)
}
inline void DumpSink_LocalFilePath::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.DumpSink.LocalFilePath.path)
}
inline ::std::string* DumpSink_LocalFilePath::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpSink.LocalFilePath.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DumpSink_LocalFilePath::release_path() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpSink.LocalFilePath.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DumpSink_LocalFilePath::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpSink.LocalFilePath.path)
}

inline void DumpSink_LocalFilePath::clear_node_id() {
  node_id_ = 0u;
}
inline ::google::protobuf::uint32 DumpSink_LocalFilePath::node_id() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.LocalFilePath.node_id)
  return node_id_;
}
inline void DumpSink_LocalFilePath::set_node_id(::google::protobuf::uint32 value) {
  
  node_id_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpSink.LocalFilePath.node_id)
}

// -------------------------------------------------------------------

// DumpSink_Http

// string baseUri = 1;
inline void DumpSink_Http::clear_baseuri() {
  baseuri_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DumpSink_Http::baseuri() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.Http.baseUri)
  return baseuri_.GetNoArena();
}
inline void DumpSink_Http::set_baseuri(const ::std::string& value) {
  
  baseuri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpSink.Http.baseUri)
}
#if LANG_CXX11
inline void DumpSink_Http::set_baseuri(::std::string&& value) {
  
  baseuri_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.DumpSink.Http.baseUri)
}
#endif
inline void DumpSink_Http::set_baseuri(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  baseuri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.DumpSink.Http.baseUri)
}
inline void DumpSink_Http::set_baseuri(const char* value, size_t size) {
  
  baseuri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.DumpSink.Http.baseUri)
}
inline ::std::string* DumpSink_Http::mutable_baseuri() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpSink.Http.baseUri)
  return baseuri_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DumpSink_Http::release_baseuri() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpSink.Http.baseUri)
  
  return baseuri_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DumpSink_Http::set_allocated_baseuri(::std::string* baseuri) {
  if (baseuri != NULL) {
    
  } else {
    
  }
  baseuri_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), baseuri);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpSink.Http.baseUri)
}

// string header = 2;
inline void DumpSink_Http::clear_header() {
  header_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DumpSink_Http::header() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.Http.header)
  return header_.GetNoArena();
}
inline void DumpSink_Http::set_header(const ::std::string& value) {
  
  header_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpSink.Http.header)
}
#if LANG_CXX11
inline void DumpSink_Http::set_header(::std::string&& value) {
  
  header_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.DumpSink.Http.header)
}
#endif
inline void DumpSink_Http::set_header(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  header_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.DumpSink.Http.header)
}
inline void DumpSink_Http::set_header(const char* value, size_t size) {
  
  header_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.DumpSink.Http.header)
}
inline ::std::string* DumpSink_Http::mutable_header() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpSink.Http.header)
  return header_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DumpSink_Http::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpSink.Http.header)
  
  return header_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DumpSink_Http::set_allocated_header(::std::string* header) {
  if (header != NULL) {
    
  } else {
    
  }
  header_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), header);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpSink.Http.header)
}

// -------------------------------------------------------------------

// DumpSink_S3

// string bucket = 1;
inline void DumpSink_S3::clear_bucket() {
  bucket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DumpSink_S3::bucket() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.S3.bucket)
  return bucket_.GetNoArena();
}
inline void DumpSink_S3::set_bucket(const ::std::string& value) {
  
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpSink.S3.bucket)
}
#if LANG_CXX11
inline void DumpSink_S3::set_bucket(::std::string&& value) {
  
  bucket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.DumpSink.S3.bucket)
}
#endif
inline void DumpSink_S3::set_bucket(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.DumpSink.S3.bucket)
}
inline void DumpSink_S3::set_bucket(const char* value, size_t size) {
  
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.DumpSink.S3.bucket)
}
inline ::std::string* DumpSink_S3::mutable_bucket() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpSink.S3.bucket)
  return bucket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DumpSink_S3::release_bucket() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpSink.S3.bucket)
  
  return bucket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DumpSink_S3::set_allocated_bucket(::std::string* bucket) {
  if (bucket != NULL) {
    
  } else {
    
  }
  bucket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bucket);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpSink.S3.bucket)
}

// string prefix = 2;
inline void DumpSink_S3::clear_prefix() {
  prefix_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DumpSink_S3::prefix() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.S3.prefix)
  return prefix_.GetNoArena();
}
inline void DumpSink_S3::set_prefix(const ::std::string& value) {
  
  prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpSink.S3.prefix)
}
#if LANG_CXX11
inline void DumpSink_S3::set_prefix(::std::string&& value) {
  
  prefix_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.DumpSink.S3.prefix)
}
#endif
inline void DumpSink_S3::set_prefix(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.DumpSink.S3.prefix)
}
inline void DumpSink_S3::set_prefix(const char* value, size_t size) {
  
  prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.DumpSink.S3.prefix)
}
inline ::std::string* DumpSink_S3::mutable_prefix() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpSink.S3.prefix)
  return prefix_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DumpSink_S3::release_prefix() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpSink.S3.prefix)
  
  return prefix_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DumpSink_S3::set_allocated_prefix(::std::string* prefix) {
  if (prefix != NULL) {
    
  } else {
    
  }
  prefix_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), prefix);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpSink.S3.prefix)
}

// string access_key = 3;
inline void DumpSink_S3::clear_access_key() {
  access_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DumpSink_S3::access_key() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.S3.access_key)
  return access_key_.GetNoArena();
}
inline void DumpSink_S3::set_access_key(const ::std::string& value) {
  
  access_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpSink.S3.access_key)
}
#if LANG_CXX11
inline void DumpSink_S3::set_access_key(::std::string&& value) {
  
  access_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.DumpSink.S3.access_key)
}
#endif
inline void DumpSink_S3::set_access_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  access_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.DumpSink.S3.access_key)
}
inline void DumpSink_S3::set_access_key(const char* value, size_t size) {
  
  access_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.DumpSink.S3.access_key)
}
inline ::std::string* DumpSink_S3::mutable_access_key() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpSink.S3.access_key)
  return access_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DumpSink_S3::release_access_key() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpSink.S3.access_key)
  
  return access_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DumpSink_S3::set_allocated_access_key(::std::string* access_key) {
  if (access_key != NULL) {
    
  } else {
    
  }
  access_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), access_key);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpSink.S3.access_key)
}

// string secret = 4;
inline void DumpSink_S3::clear_secret() {
  secret_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DumpSink_S3::secret() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.S3.secret)
  return secret_.GetNoArena();
}
inline void DumpSink_S3::set_secret(const ::std::string& value) {
  
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpSink.S3.secret)
}
#if LANG_CXX11
inline void DumpSink_S3::set_secret(::std::string&& value) {
  
  secret_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.DumpSink.S3.secret)
}
#endif
inline void DumpSink_S3::set_secret(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.DumpSink.S3.secret)
}
inline void DumpSink_S3::set_secret(const char* value, size_t size) {
  
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.DumpSink.S3.secret)
}
inline ::std::string* DumpSink_S3::mutable_secret() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpSink.S3.secret)
  return secret_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DumpSink_S3::release_secret() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpSink.S3.secret)
  
  return secret_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DumpSink_S3::set_allocated_secret(::std::string* secret) {
  if (secret != NULL) {
    
  } else {
    
  }
  secret_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), secret);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpSink.S3.secret)
}

// string temp_token = 5;
inline void DumpSink_S3::clear_temp_token() {
  temp_token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DumpSink_S3::temp_token() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.S3.temp_token)
  return temp_token_.GetNoArena();
}
inline void DumpSink_S3::set_temp_token(const ::std::string& value) {
  
  temp_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpSink.S3.temp_token)
}
#if LANG_CXX11
inline void DumpSink_S3::set_temp_token(::std::string&& value) {
  
  temp_token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.DumpSink.S3.temp_token)
}
#endif
inline void DumpSink_S3::set_temp_token(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  temp_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.DumpSink.S3.temp_token)
}
inline void DumpSink_S3::set_temp_token(const char* value, size_t size) {
  
  temp_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.DumpSink.S3.temp_token)
}
inline ::std::string* DumpSink_S3::mutable_temp_token() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpSink.S3.temp_token)
  return temp_token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DumpSink_S3::release_temp_token() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpSink.S3.temp_token)
  
  return temp_token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DumpSink_S3::set_allocated_temp_token(::std::string* temp_token) {
  if (temp_token != NULL) {
    
  } else {
    
  }
  temp_token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), temp_token);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpSink.S3.temp_token)
}

// string endpoint = 6;
inline void DumpSink_S3::clear_endpoint() {
  endpoint_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DumpSink_S3::endpoint() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.S3.endpoint)
  return endpoint_.GetNoArena();
}
inline void DumpSink_S3::set_endpoint(const ::std::string& value) {
  
  endpoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpSink.S3.endpoint)
}
#if LANG_CXX11
inline void DumpSink_S3::set_endpoint(::std::string&& value) {
  
  endpoint_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.DumpSink.S3.endpoint)
}
#endif
inline void DumpSink_S3::set_endpoint(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  endpoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.DumpSink.S3.endpoint)
}
inline void DumpSink_S3::set_endpoint(const char* value, size_t size) {
  
  endpoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.DumpSink.S3.endpoint)
}
inline ::std::string* DumpSink_S3::mutable_endpoint() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpSink.S3.endpoint)
  return endpoint_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DumpSink_S3::release_endpoint() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpSink.S3.endpoint)
  
  return endpoint_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DumpSink_S3::set_allocated_endpoint(::std::string* endpoint) {
  if (endpoint != NULL) {
    
  } else {
    
  }
  endpoint_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), endpoint);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpSink.S3.endpoint)
}

// string region = 7;
inline void DumpSink_S3::clear_region() {
  region_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DumpSink_S3::region() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.S3.region)
  return region_.GetNoArena();
}
inline void DumpSink_S3::set_region(const ::std::string& value) {
  
  region_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpSink.S3.region)
}
#if LANG_CXX11
inline void DumpSink_S3::set_region(::std::string&& value) {
  
  region_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.DumpSink.S3.region)
}
#endif
inline void DumpSink_S3::set_region(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  region_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.DumpSink.S3.region)
}
inline void DumpSink_S3::set_region(const char* value, size_t size) {
  
  region_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.DumpSink.S3.region)
}
inline ::std::string* DumpSink_S3::mutable_region() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpSink.S3.region)
  return region_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DumpSink_S3::release_region() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpSink.S3.region)
  
  return region_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DumpSink_S3::set_allocated_region(::std::string* region) {
  if (region != NULL) {
    
  } else {
    
  }
  region_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), region);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpSink.S3.region)
}

// -------------------------------------------------------------------

// DumpSink_HDFS

// string host = 1;
inline void DumpSink_HDFS::clear_host() {
  host_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DumpSink_HDFS::host() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.HDFS.host)
  return host_.GetNoArena();
}
inline void DumpSink_HDFS::set_host(const ::std::string& value) {
  
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpSink.HDFS.host)
}
#if LANG_CXX11
inline void DumpSink_HDFS::set_host(::std::string&& value) {
  
  host_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.DumpSink.HDFS.host)
}
#endif
inline void DumpSink_HDFS::set_host(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.DumpSink.HDFS.host)
}
inline void DumpSink_HDFS::set_host(const char* value, size_t size) {
  
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.DumpSink.HDFS.host)
}
inline ::std::string* DumpSink_HDFS::mutable_host() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpSink.HDFS.host)
  return host_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DumpSink_HDFS::release_host() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpSink.HDFS.host)
  
  return host_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DumpSink_HDFS::set_allocated_host(::std::string* host) {
  if (host != NULL) {
    
  } else {
    
  }
  host_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), host);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpSink.HDFS.host)
}

// string path = 2;
inline void DumpSink_HDFS::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DumpSink_HDFS::path() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.HDFS.path)
  return path_.GetNoArena();
}
inline void DumpSink_HDFS::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpSink.HDFS.path)
}
#if LANG_CXX11
inline void DumpSink_HDFS::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.DumpSink.HDFS.path)
}
#endif
inline void DumpSink_HDFS::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.DumpSink.HDFS.path)
}
inline void DumpSink_HDFS::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.DumpSink.HDFS.path)
}
inline ::std::string* DumpSink_HDFS::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpSink.HDFS.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DumpSink_HDFS::release_path() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpSink.HDFS.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DumpSink_HDFS::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpSink.HDFS.path)
}

// string username = 3;
inline void DumpSink_HDFS::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DumpSink_HDFS::username() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.HDFS.username)
  return username_.GetNoArena();
}
inline void DumpSink_HDFS::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpSink.HDFS.username)
}
#if LANG_CXX11
inline void DumpSink_HDFS::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.DumpSink.HDFS.username)
}
#endif
inline void DumpSink_HDFS::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.DumpSink.HDFS.username)
}
inline void DumpSink_HDFS::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.DumpSink.HDFS.username)
}
inline ::std::string* DumpSink_HDFS::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpSink.HDFS.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DumpSink_HDFS::release_username() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpSink.HDFS.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DumpSink_HDFS::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpSink.HDFS.username)
}

// string krb5Conf = 4;
inline void DumpSink_HDFS::clear_krb5conf() {
  krb5conf_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DumpSink_HDFS::krb5conf() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.HDFS.krb5Conf)
  return krb5conf_.GetNoArena();
}
inline void DumpSink_HDFS::set_krb5conf(const ::std::string& value) {
  
  krb5conf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpSink.HDFS.krb5Conf)
}
#if LANG_CXX11
inline void DumpSink_HDFS::set_krb5conf(::std::string&& value) {
  
  krb5conf_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.DumpSink.HDFS.krb5Conf)
}
#endif
inline void DumpSink_HDFS::set_krb5conf(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  krb5conf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.DumpSink.HDFS.krb5Conf)
}
inline void DumpSink_HDFS::set_krb5conf(const char* value, size_t size) {
  
  krb5conf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.DumpSink.HDFS.krb5Conf)
}
inline ::std::string* DumpSink_HDFS::mutable_krb5conf() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpSink.HDFS.krb5Conf)
  return krb5conf_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DumpSink_HDFS::release_krb5conf() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpSink.HDFS.krb5Conf)
  
  return krb5conf_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DumpSink_HDFS::set_allocated_krb5conf(::std::string* krb5conf) {
  if (krb5conf != NULL) {
    
  } else {
    
  }
  krb5conf_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), krb5conf);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpSink.HDFS.krb5Conf)
}

// string realm = 5;
inline void DumpSink_HDFS::clear_realm() {
  realm_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DumpSink_HDFS::realm() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.HDFS.realm)
  return realm_.GetNoArena();
}
inline void DumpSink_HDFS::set_realm(const ::std::string& value) {
  
  realm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpSink.HDFS.realm)
}
#if LANG_CXX11
inline void DumpSink_HDFS::set_realm(::std::string&& value) {
  
  realm_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.DumpSink.HDFS.realm)
}
#endif
inline void DumpSink_HDFS::set_realm(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  realm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.DumpSink.HDFS.realm)
}
inline void DumpSink_HDFS::set_realm(const char* value, size_t size) {
  
  realm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.DumpSink.HDFS.realm)
}
inline ::std::string* DumpSink_HDFS::mutable_realm() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpSink.HDFS.realm)
  return realm_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DumpSink_HDFS::release_realm() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpSink.HDFS.realm)
  
  return realm_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DumpSink_HDFS::set_allocated_realm(::std::string* realm) {
  if (realm != NULL) {
    
  } else {
    
  }
  realm_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), realm);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpSink.HDFS.realm)
}

// string password = 6;
inline void DumpSink_HDFS::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DumpSink_HDFS::password() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.HDFS.password)
  return password_.GetNoArena();
}
inline void DumpSink_HDFS::set_password(const ::std::string& value) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpSink.HDFS.password)
}
#if LANG_CXX11
inline void DumpSink_HDFS::set_password(::std::string&& value) {
  
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.DumpSink.HDFS.password)
}
#endif
inline void DumpSink_HDFS::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.DumpSink.HDFS.password)
}
inline void DumpSink_HDFS::set_password(const char* value, size_t size) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.DumpSink.HDFS.password)
}
inline ::std::string* DumpSink_HDFS::mutable_password() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpSink.HDFS.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DumpSink_HDFS::release_password() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpSink.HDFS.password)
  
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DumpSink_HDFS::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    
  } else {
    
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpSink.HDFS.password)
}

// string namenodePrincipal = 7;
inline void DumpSink_HDFS::clear_namenodeprincipal() {
  namenodeprincipal_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DumpSink_HDFS::namenodeprincipal() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.HDFS.namenodePrincipal)
  return namenodeprincipal_.GetNoArena();
}
inline void DumpSink_HDFS::set_namenodeprincipal(const ::std::string& value) {
  
  namenodeprincipal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpSink.HDFS.namenodePrincipal)
}
#if LANG_CXX11
inline void DumpSink_HDFS::set_namenodeprincipal(::std::string&& value) {
  
  namenodeprincipal_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.DumpSink.HDFS.namenodePrincipal)
}
#endif
inline void DumpSink_HDFS::set_namenodeprincipal(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  namenodeprincipal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.DumpSink.HDFS.namenodePrincipal)
}
inline void DumpSink_HDFS::set_namenodeprincipal(const char* value, size_t size) {
  
  namenodeprincipal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.DumpSink.HDFS.namenodePrincipal)
}
inline ::std::string* DumpSink_HDFS::mutable_namenodeprincipal() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpSink.HDFS.namenodePrincipal)
  return namenodeprincipal_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DumpSink_HDFS::release_namenodeprincipal() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpSink.HDFS.namenodePrincipal)
  
  return namenodeprincipal_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DumpSink_HDFS::set_allocated_namenodeprincipal(::std::string* namenodeprincipal) {
  if (namenodeprincipal != NULL) {
    
  } else {
    
  }
  namenodeprincipal_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), namenodeprincipal);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpSink.HDFS.namenodePrincipal)
}

// string hdfsConfigs = 8;
inline void DumpSink_HDFS::clear_hdfsconfigs() {
  hdfsconfigs_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DumpSink_HDFS::hdfsconfigs() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.HDFS.hdfsConfigs)
  return hdfsconfigs_.GetNoArena();
}
inline void DumpSink_HDFS::set_hdfsconfigs(const ::std::string& value) {
  
  hdfsconfigs_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpSink.HDFS.hdfsConfigs)
}
#if LANG_CXX11
inline void DumpSink_HDFS::set_hdfsconfigs(::std::string&& value) {
  
  hdfsconfigs_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.DumpSink.HDFS.hdfsConfigs)
}
#endif
inline void DumpSink_HDFS::set_hdfsconfigs(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hdfsconfigs_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.DumpSink.HDFS.hdfsConfigs)
}
inline void DumpSink_HDFS::set_hdfsconfigs(const char* value, size_t size) {
  
  hdfsconfigs_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.DumpSink.HDFS.hdfsConfigs)
}
inline ::std::string* DumpSink_HDFS::mutable_hdfsconfigs() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpSink.HDFS.hdfsConfigs)
  return hdfsconfigs_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DumpSink_HDFS::release_hdfsconfigs() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpSink.HDFS.hdfsConfigs)
  
  return hdfsconfigs_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DumpSink_HDFS::set_allocated_hdfsconfigs(::std::string* hdfsconfigs) {
  if (hdfsconfigs != NULL) {
    
  } else {
    
  }
  hdfsconfigs_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hdfsconfigs);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpSink.HDFS.hdfsConfigs)
}

// -------------------------------------------------------------------

// DumpSink_KAFKA

// string kafkaServer = 1;
inline void DumpSink_KAFKA::clear_kafkaserver() {
  kafkaserver_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DumpSink_KAFKA::kafkaserver() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.KAFKA.kafkaServer)
  return kafkaserver_.GetNoArena();
}
inline void DumpSink_KAFKA::set_kafkaserver(const ::std::string& value) {
  
  kafkaserver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpSink.KAFKA.kafkaServer)
}
#if LANG_CXX11
inline void DumpSink_KAFKA::set_kafkaserver(::std::string&& value) {
  
  kafkaserver_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.DumpSink.KAFKA.kafkaServer)
}
#endif
inline void DumpSink_KAFKA::set_kafkaserver(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  kafkaserver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.DumpSink.KAFKA.kafkaServer)
}
inline void DumpSink_KAFKA::set_kafkaserver(const char* value, size_t size) {
  
  kafkaserver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.DumpSink.KAFKA.kafkaServer)
}
inline ::std::string* DumpSink_KAFKA::mutable_kafkaserver() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpSink.KAFKA.kafkaServer)
  return kafkaserver_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DumpSink_KAFKA::release_kafkaserver() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpSink.KAFKA.kafkaServer)
  
  return kafkaserver_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DumpSink_KAFKA::set_allocated_kafkaserver(::std::string* kafkaserver) {
  if (kafkaserver != NULL) {
    
  } else {
    
  }
  kafkaserver_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), kafkaserver);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpSink.KAFKA.kafkaServer)
}

// string topic = 2;
inline void DumpSink_KAFKA::clear_topic() {
  topic_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DumpSink_KAFKA::topic() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.KAFKA.topic)
  return topic_.GetNoArena();
}
inline void DumpSink_KAFKA::set_topic(const ::std::string& value) {
  
  topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpSink.KAFKA.topic)
}
#if LANG_CXX11
inline void DumpSink_KAFKA::set_topic(::std::string&& value) {
  
  topic_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.DumpSink.KAFKA.topic)
}
#endif
inline void DumpSink_KAFKA::set_topic(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.DumpSink.KAFKA.topic)
}
inline void DumpSink_KAFKA::set_topic(const char* value, size_t size) {
  
  topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.DumpSink.KAFKA.topic)
}
inline ::std::string* DumpSink_KAFKA::mutable_topic() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpSink.KAFKA.topic)
  return topic_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DumpSink_KAFKA::release_topic() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpSink.KAFKA.topic)
  
  return topic_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DumpSink_KAFKA::set_allocated_topic(::std::string* topic) {
  if (topic != NULL) {
    
  } else {
    
  }
  topic_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpSink.KAFKA.topic)
}

// string krb5Conf = 3;
inline void DumpSink_KAFKA::clear_krb5conf() {
  krb5conf_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DumpSink_KAFKA::krb5conf() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.KAFKA.krb5Conf)
  return krb5conf_.GetNoArena();
}
inline void DumpSink_KAFKA::set_krb5conf(const ::std::string& value) {
  
  krb5conf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpSink.KAFKA.krb5Conf)
}
#if LANG_CXX11
inline void DumpSink_KAFKA::set_krb5conf(::std::string&& value) {
  
  krb5conf_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.DumpSink.KAFKA.krb5Conf)
}
#endif
inline void DumpSink_KAFKA::set_krb5conf(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  krb5conf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.DumpSink.KAFKA.krb5Conf)
}
inline void DumpSink_KAFKA::set_krb5conf(const char* value, size_t size) {
  
  krb5conf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.DumpSink.KAFKA.krb5Conf)
}
inline ::std::string* DumpSink_KAFKA::mutable_krb5conf() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpSink.KAFKA.krb5Conf)
  return krb5conf_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DumpSink_KAFKA::release_krb5conf() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpSink.KAFKA.krb5Conf)
  
  return krb5conf_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DumpSink_KAFKA::set_allocated_krb5conf(::std::string* krb5conf) {
  if (krb5conf != NULL) {
    
  } else {
    
  }
  krb5conf_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), krb5conf);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpSink.KAFKA.krb5Conf)
}

// string keytab = 4;
inline void DumpSink_KAFKA::clear_keytab() {
  keytab_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DumpSink_KAFKA::keytab() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.KAFKA.keytab)
  return keytab_.GetNoArena();
}
inline void DumpSink_KAFKA::set_keytab(const ::std::string& value) {
  
  keytab_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpSink.KAFKA.keytab)
}
#if LANG_CXX11
inline void DumpSink_KAFKA::set_keytab(::std::string&& value) {
  
  keytab_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.DumpSink.KAFKA.keytab)
}
#endif
inline void DumpSink_KAFKA::set_keytab(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  keytab_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.DumpSink.KAFKA.keytab)
}
inline void DumpSink_KAFKA::set_keytab(const char* value, size_t size) {
  
  keytab_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.DumpSink.KAFKA.keytab)
}
inline ::std::string* DumpSink_KAFKA::mutable_keytab() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpSink.KAFKA.keytab)
  return keytab_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DumpSink_KAFKA::release_keytab() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpSink.KAFKA.keytab)
  
  return keytab_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DumpSink_KAFKA::set_allocated_keytab(::std::string* keytab) {
  if (keytab != NULL) {
    
  } else {
    
  }
  keytab_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), keytab);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpSink.KAFKA.keytab)
}

// -------------------------------------------------------------------

// DumpSink_GCS

// string bucket = 1;
inline void DumpSink_GCS::clear_bucket() {
  bucket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DumpSink_GCS::bucket() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.GCS.bucket)
  return bucket_.GetNoArena();
}
inline void DumpSink_GCS::set_bucket(const ::std::string& value) {
  
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpSink.GCS.bucket)
}
#if LANG_CXX11
inline void DumpSink_GCS::set_bucket(::std::string&& value) {
  
  bucket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.DumpSink.GCS.bucket)
}
#endif
inline void DumpSink_GCS::set_bucket(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.DumpSink.GCS.bucket)
}
inline void DumpSink_GCS::set_bucket(const char* value, size_t size) {
  
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.DumpSink.GCS.bucket)
}
inline ::std::string* DumpSink_GCS::mutable_bucket() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpSink.GCS.bucket)
  return bucket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DumpSink_GCS::release_bucket() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpSink.GCS.bucket)
  
  return bucket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DumpSink_GCS::set_allocated_bucket(::std::string* bucket) {
  if (bucket != NULL) {
    
  } else {
    
  }
  bucket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bucket);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpSink.GCS.bucket)
}

// string prefix = 2;
inline void DumpSink_GCS::clear_prefix() {
  prefix_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DumpSink_GCS::prefix() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.GCS.prefix)
  return prefix_.GetNoArena();
}
inline void DumpSink_GCS::set_prefix(const ::std::string& value) {
  
  prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpSink.GCS.prefix)
}
#if LANG_CXX11
inline void DumpSink_GCS::set_prefix(::std::string&& value) {
  
  prefix_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.DumpSink.GCS.prefix)
}
#endif
inline void DumpSink_GCS::set_prefix(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.DumpSink.GCS.prefix)
}
inline void DumpSink_GCS::set_prefix(const char* value, size_t size) {
  
  prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.DumpSink.GCS.prefix)
}
inline ::std::string* DumpSink_GCS::mutable_prefix() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpSink.GCS.prefix)
  return prefix_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DumpSink_GCS::release_prefix() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpSink.GCS.prefix)
  
  return prefix_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DumpSink_GCS::set_allocated_prefix(::std::string* prefix) {
  if (prefix != NULL) {
    
  } else {
    
  }
  prefix_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), prefix);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpSink.GCS.prefix)
}

// string auth = 3;
inline void DumpSink_GCS::clear_auth() {
  auth_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DumpSink_GCS::auth() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.GCS.auth)
  return auth_.GetNoArena();
}
inline void DumpSink_GCS::set_auth(const ::std::string& value) {
  
  auth_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpSink.GCS.auth)
}
#if LANG_CXX11
inline void DumpSink_GCS::set_auth(::std::string&& value) {
  
  auth_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.DumpSink.GCS.auth)
}
#endif
inline void DumpSink_GCS::set_auth(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  auth_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.DumpSink.GCS.auth)
}
inline void DumpSink_GCS::set_auth(const char* value, size_t size) {
  
  auth_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.DumpSink.GCS.auth)
}
inline ::std::string* DumpSink_GCS::mutable_auth() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpSink.GCS.auth)
  return auth_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DumpSink_GCS::release_auth() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpSink.GCS.auth)
  
  return auth_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DumpSink_GCS::set_allocated_auth(::std::string* auth) {
  if (auth != NULL) {
    
  } else {
    
  }
  auth_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), auth);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpSink.GCS.auth)
}

// string billing_project = 4;
inline void DumpSink_GCS::clear_billing_project() {
  billing_project_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DumpSink_GCS::billing_project() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.GCS.billing_project)
  return billing_project_.GetNoArena();
}
inline void DumpSink_GCS::set_billing_project(const ::std::string& value) {
  
  billing_project_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpSink.GCS.billing_project)
}
#if LANG_CXX11
inline void DumpSink_GCS::set_billing_project(::std::string&& value) {
  
  billing_project_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.DumpSink.GCS.billing_project)
}
#endif
inline void DumpSink_GCS::set_billing_project(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  billing_project_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.DumpSink.GCS.billing_project)
}
inline void DumpSink_GCS::set_billing_project(const char* value, size_t size) {
  
  billing_project_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.DumpSink.GCS.billing_project)
}
inline ::std::string* DumpSink_GCS::mutable_billing_project() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpSink.GCS.billing_project)
  return billing_project_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DumpSink_GCS::release_billing_project() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpSink.GCS.billing_project)
  
  return billing_project_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DumpSink_GCS::set_allocated_billing_project(::std::string* billing_project) {
  if (billing_project != NULL) {
    
  } else {
    
  }
  billing_project_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), billing_project);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpSink.GCS.billing_project)
}

// string credentials = 5;
inline void DumpSink_GCS::clear_credentials() {
  credentials_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DumpSink_GCS::credentials() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.GCS.credentials)
  return credentials_.GetNoArena();
}
inline void DumpSink_GCS::set_credentials(const ::std::string& value) {
  
  credentials_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpSink.GCS.credentials)
}
#if LANG_CXX11
inline void DumpSink_GCS::set_credentials(::std::string&& value) {
  
  credentials_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.DumpSink.GCS.credentials)
}
#endif
inline void DumpSink_GCS::set_credentials(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  credentials_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.DumpSink.GCS.credentials)
}
inline void DumpSink_GCS::set_credentials(const char* value, size_t size) {
  
  credentials_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.DumpSink.GCS.credentials)
}
inline ::std::string* DumpSink_GCS::mutable_credentials() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpSink.GCS.credentials)
  return credentials_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DumpSink_GCS::release_credentials() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpSink.GCS.credentials)
  
  return credentials_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DumpSink_GCS::set_allocated_credentials(::std::string* credentials) {
  if (credentials != NULL) {
    
  } else {
    
  }
  credentials_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), credentials);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpSink.GCS.credentials)
}

// -------------------------------------------------------------------

// DumpSink_Azure

// string container = 1;
inline void DumpSink_Azure::clear_container() {
  container_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DumpSink_Azure::container() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.Azure.container)
  return container_.GetNoArena();
}
inline void DumpSink_Azure::set_container(const ::std::string& value) {
  
  container_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpSink.Azure.container)
}
#if LANG_CXX11
inline void DumpSink_Azure::set_container(::std::string&& value) {
  
  container_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.DumpSink.Azure.container)
}
#endif
inline void DumpSink_Azure::set_container(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  container_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.DumpSink.Azure.container)
}
inline void DumpSink_Azure::set_container(const char* value, size_t size) {
  
  container_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.DumpSink.Azure.container)
}
inline ::std::string* DumpSink_Azure::mutable_container() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpSink.Azure.container)
  return container_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DumpSink_Azure::release_container() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpSink.Azure.container)
  
  return container_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DumpSink_Azure::set_allocated_container(::std::string* container) {
  if (container != NULL) {
    
  } else {
    
  }
  container_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), container);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpSink.Azure.container)
}

// string prefix = 2;
inline void DumpSink_Azure::clear_prefix() {
  prefix_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DumpSink_Azure::prefix() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.Azure.prefix)
  return prefix_.GetNoArena();
}
inline void DumpSink_Azure::set_prefix(const ::std::string& value) {
  
  prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpSink.Azure.prefix)
}
#if LANG_CXX11
inline void DumpSink_Azure::set_prefix(::std::string&& value) {
  
  prefix_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.DumpSink.Azure.prefix)
}
#endif
inline void DumpSink_Azure::set_prefix(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.DumpSink.Azure.prefix)
}
inline void DumpSink_Azure::set_prefix(const char* value, size_t size) {
  
  prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.DumpSink.Azure.prefix)
}
inline ::std::string* DumpSink_Azure::mutable_prefix() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpSink.Azure.prefix)
  return prefix_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DumpSink_Azure::release_prefix() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpSink.Azure.prefix)
  
  return prefix_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DumpSink_Azure::set_allocated_prefix(::std::string* prefix) {
  if (prefix != NULL) {
    
  } else {
    
  }
  prefix_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), prefix);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpSink.Azure.prefix)
}

// string account_name = 3;
inline void DumpSink_Azure::clear_account_name() {
  account_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DumpSink_Azure::account_name() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.Azure.account_name)
  return account_name_.GetNoArena();
}
inline void DumpSink_Azure::set_account_name(const ::std::string& value) {
  
  account_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpSink.Azure.account_name)
}
#if LANG_CXX11
inline void DumpSink_Azure::set_account_name(::std::string&& value) {
  
  account_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.DumpSink.Azure.account_name)
}
#endif
inline void DumpSink_Azure::set_account_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  account_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.DumpSink.Azure.account_name)
}
inline void DumpSink_Azure::set_account_name(const char* value, size_t size) {
  
  account_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.DumpSink.Azure.account_name)
}
inline ::std::string* DumpSink_Azure::mutable_account_name() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpSink.Azure.account_name)
  return account_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DumpSink_Azure::release_account_name() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpSink.Azure.account_name)
  
  return account_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DumpSink_Azure::set_allocated_account_name(::std::string* account_name) {
  if (account_name != NULL) {
    
  } else {
    
  }
  account_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account_name);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpSink.Azure.account_name)
}

// string account_key = 4;
inline void DumpSink_Azure::clear_account_key() {
  account_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DumpSink_Azure::account_key() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.Azure.account_key)
  return account_key_.GetNoArena();
}
inline void DumpSink_Azure::set_account_key(const ::std::string& value) {
  
  account_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpSink.Azure.account_key)
}
#if LANG_CXX11
inline void DumpSink_Azure::set_account_key(::std::string&& value) {
  
  account_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.DumpSink.Azure.account_key)
}
#endif
inline void DumpSink_Azure::set_account_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  account_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.DumpSink.Azure.account_key)
}
inline void DumpSink_Azure::set_account_key(const char* value, size_t size) {
  
  account_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.DumpSink.Azure.account_key)
}
inline ::std::string* DumpSink_Azure::mutable_account_key() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpSink.Azure.account_key)
  return account_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DumpSink_Azure::release_account_key() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpSink.Azure.account_key)
  
  return account_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DumpSink_Azure::set_allocated_account_key(::std::string* account_key) {
  if (account_key != NULL) {
    
  } else {
    
  }
  account_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account_key);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpSink.Azure.account_key)
}

// -------------------------------------------------------------------

// DumpSink_Workload

// string generator = 1;
inline void DumpSink_Workload::clear_generator() {
  generator_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DumpSink_Workload::generator() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.Workload.generator)
  return generator_.GetNoArena();
}
inline void DumpSink_Workload::set_generator(const ::std::string& value) {
  
  generator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpSink.Workload.generator)
}
#if LANG_CXX11
inline void DumpSink_Workload::set_generator(::std::string&& value) {
  
  generator_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.DumpSink.Workload.generator)
}
#endif
inline void DumpSink_Workload::set_generator(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  generator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.DumpSink.Workload.generator)
}
inline void DumpSink_Workload::set_generator(const char* value, size_t size) {
  
  generator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.DumpSink.Workload.generator)
}
inline ::std::string* DumpSink_Workload::mutable_generator() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpSink.Workload.generator)
  return generator_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DumpSink_Workload::release_generator() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpSink.Workload.generator)
  
  return generator_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DumpSink_Workload::set_allocated_generator(::std::string* generator) {
  if (generator != NULL) {
    
  } else {
    
  }
  generator_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), generator);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpSink.Workload.generator)
}

// string version = 2;
inline void DumpSink_Workload::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DumpSink_Workload::version() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.Workload.version)
  return version_.GetNoArena();
}
inline void DumpSink_Workload::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpSink.Workload.version)
}
#if LANG_CXX11
inline void DumpSink_Workload::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.DumpSink.Workload.version)
}
#endif
inline void DumpSink_Workload::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.DumpSink.Workload.version)
}
inline void DumpSink_Workload::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.DumpSink.Workload.version)
}
inline ::std::string* DumpSink_Workload::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpSink.Workload.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DumpSink_Workload::release_version() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpSink.Workload.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DumpSink_Workload::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpSink.Workload.version)
}

// string table = 3;
inline void DumpSink_Workload::clear_table() {
  table_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DumpSink_Workload::table() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.Workload.table)
  return table_.GetNoArena();
}
inline void DumpSink_Workload::set_table(const ::std::string& value) {
  
  table_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpSink.Workload.table)
}
#if LANG_CXX11
inline void DumpSink_Workload::set_table(::std::string&& value) {
  
  table_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.DumpSink.Workload.table)
}
#endif
inline void DumpSink_Workload::set_table(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  table_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.DumpSink.Workload.table)
}
inline void DumpSink_Workload::set_table(const char* value, size_t size) {
  
  table_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.DumpSink.Workload.table)
}
inline ::std::string* DumpSink_Workload::mutable_table() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpSink.Workload.table)
  return table_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DumpSink_Workload::release_table() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpSink.Workload.table)
  
  return table_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DumpSink_Workload::set_allocated_table(::std::string* table) {
  if (table != NULL) {
    
  } else {
    
  }
  table_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), table);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpSink.Workload.table)
}

// repeated string flags = 4;
inline int DumpSink_Workload::flags_size() const {
  return flags_.size();
}
inline void DumpSink_Workload::clear_flags() {
  flags_.Clear();
}
inline const ::std::string& DumpSink_Workload::flags(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.Workload.flags)
  return flags_.Get(index);
}
inline ::std::string* DumpSink_Workload::mutable_flags(int index) {
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpSink.Workload.flags)
  return flags_.Mutable(index);
}
inline void DumpSink_Workload::set_flags(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpSink.Workload.flags)
  flags_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void DumpSink_Workload::set_flags(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpSink.Workload.flags)
  flags_.Mutable(index)->assign(std::move(value));
}
#endif
inline void DumpSink_Workload::set_flags(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  flags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.DumpSink.Workload.flags)
}
inline void DumpSink_Workload::set_flags(int index, const char* value, size_t size) {
  flags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.DumpSink.Workload.flags)
}
inline ::std::string* DumpSink_Workload::add_flags() {
  // @@protoc_insertion_point(field_add_mutable:znbase.roachpb.DumpSink.Workload.flags)
  return flags_.Add();
}
inline void DumpSink_Workload::add_flags(const ::std::string& value) {
  flags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:znbase.roachpb.DumpSink.Workload.flags)
}
#if LANG_CXX11
inline void DumpSink_Workload::add_flags(::std::string&& value) {
  flags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:znbase.roachpb.DumpSink.Workload.flags)
}
#endif
inline void DumpSink_Workload::add_flags(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  flags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:znbase.roachpb.DumpSink.Workload.flags)
}
inline void DumpSink_Workload::add_flags(const char* value, size_t size) {
  flags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:znbase.roachpb.DumpSink.Workload.flags)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DumpSink_Workload::flags() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.DumpSink.Workload.flags)
  return flags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DumpSink_Workload::mutable_flags() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.DumpSink.Workload.flags)
  return &flags_;
}

// string format = 5;
inline void DumpSink_Workload::clear_format() {
  format_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DumpSink_Workload::format() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.Workload.format)
  return format_.GetNoArena();
}
inline void DumpSink_Workload::set_format(const ::std::string& value) {
  
  format_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpSink.Workload.format)
}
#if LANG_CXX11
inline void DumpSink_Workload::set_format(::std::string&& value) {
  
  format_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.DumpSink.Workload.format)
}
#endif
inline void DumpSink_Workload::set_format(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  format_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.DumpSink.Workload.format)
}
inline void DumpSink_Workload::set_format(const char* value, size_t size) {
  
  format_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.DumpSink.Workload.format)
}
inline ::std::string* DumpSink_Workload::mutable_format() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpSink.Workload.format)
  return format_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DumpSink_Workload::release_format() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpSink.Workload.format)
  
  return format_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DumpSink_Workload::set_allocated_format(::std::string* format) {
  if (format != NULL) {
    
  } else {
    
  }
  format_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), format);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpSink.Workload.format)
}

// int64 batch_begin = 6;
inline void DumpSink_Workload::clear_batch_begin() {
  batch_begin_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 DumpSink_Workload::batch_begin() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.Workload.batch_begin)
  return batch_begin_;
}
inline void DumpSink_Workload::set_batch_begin(::google::protobuf::int64 value) {
  
  batch_begin_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpSink.Workload.batch_begin)
}

// int64 batch_end = 7;
inline void DumpSink_Workload::clear_batch_end() {
  batch_end_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 DumpSink_Workload::batch_end() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.Workload.batch_end)
  return batch_end_;
}
inline void DumpSink_Workload::set_batch_end(::google::protobuf::int64 value) {
  
  batch_end_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpSink.Workload.batch_end)
}

// -------------------------------------------------------------------

// DumpSink

// .znbase.roachpb.ExportStorageProvider provider = 1;
inline void DumpSink::clear_provider() {
  provider_ = 0;
}
inline ::znbase::roachpb::ExportStorageProvider DumpSink::provider() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.provider)
  return static_cast< ::znbase::roachpb::ExportStorageProvider >(provider_);
}
inline void DumpSink::set_provider(::znbase::roachpb::ExportStorageProvider value) {
  
  provider_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpSink.provider)
}

inline bool DumpSink::has_localfile() const {
  return this != internal_default_instance() && localfile_ != NULL;
}
inline void DumpSink::clear_localfile() {
  if (GetArenaNoVirtual() == NULL && localfile_ != NULL) {
    delete localfile_;
  }
  localfile_ = NULL;
}
inline const ::znbase::roachpb::DumpSink_LocalFilePath& DumpSink::_internal_localfile() const {
  return *localfile_;
}
inline const ::znbase::roachpb::DumpSink_LocalFilePath& DumpSink::localfile() const {
  const ::znbase::roachpb::DumpSink_LocalFilePath* p = localfile_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.LocalFile)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::DumpSink_LocalFilePath*>(
      &::znbase::roachpb::_DumpSink_LocalFilePath_default_instance_);
}
inline ::znbase::roachpb::DumpSink_LocalFilePath* DumpSink::release_localfile() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpSink.LocalFile)
  
  ::znbase::roachpb::DumpSink_LocalFilePath* temp = localfile_;
  localfile_ = NULL;
  return temp;
}
inline ::znbase::roachpb::DumpSink_LocalFilePath* DumpSink::mutable_localfile() {
  
  if (localfile_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::DumpSink_LocalFilePath>(GetArenaNoVirtual());
    localfile_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpSink.LocalFile)
  return localfile_;
}
inline void DumpSink::set_allocated_localfile(::znbase::roachpb::DumpSink_LocalFilePath* localfile) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete localfile_;
  }
  if (localfile) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      localfile = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, localfile, submessage_arena);
    }
    
  } else {
    
  }
  localfile_ = localfile;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpSink.LocalFile)
}

inline bool DumpSink::has_httppath() const {
  return this != internal_default_instance() && httppath_ != NULL;
}
inline void DumpSink::clear_httppath() {
  if (GetArenaNoVirtual() == NULL && httppath_ != NULL) {
    delete httppath_;
  }
  httppath_ = NULL;
}
inline const ::znbase::roachpb::DumpSink_Http& DumpSink::_internal_httppath() const {
  return *httppath_;
}
inline const ::znbase::roachpb::DumpSink_Http& DumpSink::httppath() const {
  const ::znbase::roachpb::DumpSink_Http* p = httppath_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.HttpPath)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::DumpSink_Http*>(
      &::znbase::roachpb::_DumpSink_Http_default_instance_);
}
inline ::znbase::roachpb::DumpSink_Http* DumpSink::release_httppath() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpSink.HttpPath)
  
  ::znbase::roachpb::DumpSink_Http* temp = httppath_;
  httppath_ = NULL;
  return temp;
}
inline ::znbase::roachpb::DumpSink_Http* DumpSink::mutable_httppath() {
  
  if (httppath_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::DumpSink_Http>(GetArenaNoVirtual());
    httppath_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpSink.HttpPath)
  return httppath_;
}
inline void DumpSink::set_allocated_httppath(::znbase::roachpb::DumpSink_Http* httppath) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete httppath_;
  }
  if (httppath) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      httppath = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, httppath, submessage_arena);
    }
    
  } else {
    
  }
  httppath_ = httppath;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpSink.HttpPath)
}

// .znbase.roachpb.DumpSink.S3 S3Config = 4;
inline bool DumpSink::has_s3config() const {
  return this != internal_default_instance() && s3config_ != NULL;
}
inline void DumpSink::clear_s3config() {
  if (GetArenaNoVirtual() == NULL && s3config_ != NULL) {
    delete s3config_;
  }
  s3config_ = NULL;
}
inline const ::znbase::roachpb::DumpSink_S3& DumpSink::_internal_s3config() const {
  return *s3config_;
}
inline const ::znbase::roachpb::DumpSink_S3& DumpSink::s3config() const {
  const ::znbase::roachpb::DumpSink_S3* p = s3config_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.S3Config)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::DumpSink_S3*>(
      &::znbase::roachpb::_DumpSink_S3_default_instance_);
}
inline ::znbase::roachpb::DumpSink_S3* DumpSink::release_s3config() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpSink.S3Config)
  
  ::znbase::roachpb::DumpSink_S3* temp = s3config_;
  s3config_ = NULL;
  return temp;
}
inline ::znbase::roachpb::DumpSink_S3* DumpSink::mutable_s3config() {
  
  if (s3config_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::DumpSink_S3>(GetArenaNoVirtual());
    s3config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpSink.S3Config)
  return s3config_;
}
inline void DumpSink::set_allocated_s3config(::znbase::roachpb::DumpSink_S3* s3config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete s3config_;
  }
  if (s3config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      s3config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, s3config, submessage_arena);
    }
    
  } else {
    
  }
  s3config_ = s3config;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpSink.S3Config)
}

// .znbase.roachpb.DumpSink.HDFS HdfsConfig = 5;
inline bool DumpSink::has_hdfsconfig() const {
  return this != internal_default_instance() && hdfsconfig_ != NULL;
}
inline void DumpSink::clear_hdfsconfig() {
  if (GetArenaNoVirtual() == NULL && hdfsconfig_ != NULL) {
    delete hdfsconfig_;
  }
  hdfsconfig_ = NULL;
}
inline const ::znbase::roachpb::DumpSink_HDFS& DumpSink::_internal_hdfsconfig() const {
  return *hdfsconfig_;
}
inline const ::znbase::roachpb::DumpSink_HDFS& DumpSink::hdfsconfig() const {
  const ::znbase::roachpb::DumpSink_HDFS* p = hdfsconfig_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.HdfsConfig)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::DumpSink_HDFS*>(
      &::znbase::roachpb::_DumpSink_HDFS_default_instance_);
}
inline ::znbase::roachpb::DumpSink_HDFS* DumpSink::release_hdfsconfig() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpSink.HdfsConfig)
  
  ::znbase::roachpb::DumpSink_HDFS* temp = hdfsconfig_;
  hdfsconfig_ = NULL;
  return temp;
}
inline ::znbase::roachpb::DumpSink_HDFS* DumpSink::mutable_hdfsconfig() {
  
  if (hdfsconfig_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::DumpSink_HDFS>(GetArenaNoVirtual());
    hdfsconfig_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpSink.HdfsConfig)
  return hdfsconfig_;
}
inline void DumpSink::set_allocated_hdfsconfig(::znbase::roachpb::DumpSink_HDFS* hdfsconfig) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete hdfsconfig_;
  }
  if (hdfsconfig) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      hdfsconfig = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, hdfsconfig, submessage_arena);
    }
    
  } else {
    
  }
  hdfsconfig_ = hdfsconfig;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpSink.HdfsConfig)
}

// .znbase.roachpb.DumpSink.KAFKA KafkaConfig = 6;
inline bool DumpSink::has_kafkaconfig() const {
  return this != internal_default_instance() && kafkaconfig_ != NULL;
}
inline void DumpSink::clear_kafkaconfig() {
  if (GetArenaNoVirtual() == NULL && kafkaconfig_ != NULL) {
    delete kafkaconfig_;
  }
  kafkaconfig_ = NULL;
}
inline const ::znbase::roachpb::DumpSink_KAFKA& DumpSink::_internal_kafkaconfig() const {
  return *kafkaconfig_;
}
inline const ::znbase::roachpb::DumpSink_KAFKA& DumpSink::kafkaconfig() const {
  const ::znbase::roachpb::DumpSink_KAFKA* p = kafkaconfig_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.KafkaConfig)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::DumpSink_KAFKA*>(
      &::znbase::roachpb::_DumpSink_KAFKA_default_instance_);
}
inline ::znbase::roachpb::DumpSink_KAFKA* DumpSink::release_kafkaconfig() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpSink.KafkaConfig)
  
  ::znbase::roachpb::DumpSink_KAFKA* temp = kafkaconfig_;
  kafkaconfig_ = NULL;
  return temp;
}
inline ::znbase::roachpb::DumpSink_KAFKA* DumpSink::mutable_kafkaconfig() {
  
  if (kafkaconfig_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::DumpSink_KAFKA>(GetArenaNoVirtual());
    kafkaconfig_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpSink.KafkaConfig)
  return kafkaconfig_;
}
inline void DumpSink::set_allocated_kafkaconfig(::znbase::roachpb::DumpSink_KAFKA* kafkaconfig) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete kafkaconfig_;
  }
  if (kafkaconfig) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      kafkaconfig = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, kafkaconfig, submessage_arena);
    }
    
  } else {
    
  }
  kafkaconfig_ = kafkaconfig;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpSink.KafkaConfig)
}

// .znbase.roachpb.DumpSink.GCS GoogleCloudConfig = 7;
inline bool DumpSink::has_googlecloudconfig() const {
  return this != internal_default_instance() && googlecloudconfig_ != NULL;
}
inline void DumpSink::clear_googlecloudconfig() {
  if (GetArenaNoVirtual() == NULL && googlecloudconfig_ != NULL) {
    delete googlecloudconfig_;
  }
  googlecloudconfig_ = NULL;
}
inline const ::znbase::roachpb::DumpSink_GCS& DumpSink::_internal_googlecloudconfig() const {
  return *googlecloudconfig_;
}
inline const ::znbase::roachpb::DumpSink_GCS& DumpSink::googlecloudconfig() const {
  const ::znbase::roachpb::DumpSink_GCS* p = googlecloudconfig_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.GoogleCloudConfig)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::DumpSink_GCS*>(
      &::znbase::roachpb::_DumpSink_GCS_default_instance_);
}
inline ::znbase::roachpb::DumpSink_GCS* DumpSink::release_googlecloudconfig() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpSink.GoogleCloudConfig)
  
  ::znbase::roachpb::DumpSink_GCS* temp = googlecloudconfig_;
  googlecloudconfig_ = NULL;
  return temp;
}
inline ::znbase::roachpb::DumpSink_GCS* DumpSink::mutable_googlecloudconfig() {
  
  if (googlecloudconfig_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::DumpSink_GCS>(GetArenaNoVirtual());
    googlecloudconfig_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpSink.GoogleCloudConfig)
  return googlecloudconfig_;
}
inline void DumpSink::set_allocated_googlecloudconfig(::znbase::roachpb::DumpSink_GCS* googlecloudconfig) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete googlecloudconfig_;
  }
  if (googlecloudconfig) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      googlecloudconfig = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, googlecloudconfig, submessage_arena);
    }
    
  } else {
    
  }
  googlecloudconfig_ = googlecloudconfig;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpSink.GoogleCloudConfig)
}

// .znbase.roachpb.DumpSink.Azure AzureConfig = 8;
inline bool DumpSink::has_azureconfig() const {
  return this != internal_default_instance() && azureconfig_ != NULL;
}
inline void DumpSink::clear_azureconfig() {
  if (GetArenaNoVirtual() == NULL && azureconfig_ != NULL) {
    delete azureconfig_;
  }
  azureconfig_ = NULL;
}
inline const ::znbase::roachpb::DumpSink_Azure& DumpSink::_internal_azureconfig() const {
  return *azureconfig_;
}
inline const ::znbase::roachpb::DumpSink_Azure& DumpSink::azureconfig() const {
  const ::znbase::roachpb::DumpSink_Azure* p = azureconfig_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.AzureConfig)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::DumpSink_Azure*>(
      &::znbase::roachpb::_DumpSink_Azure_default_instance_);
}
inline ::znbase::roachpb::DumpSink_Azure* DumpSink::release_azureconfig() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpSink.AzureConfig)
  
  ::znbase::roachpb::DumpSink_Azure* temp = azureconfig_;
  azureconfig_ = NULL;
  return temp;
}
inline ::znbase::roachpb::DumpSink_Azure* DumpSink::mutable_azureconfig() {
  
  if (azureconfig_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::DumpSink_Azure>(GetArenaNoVirtual());
    azureconfig_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpSink.AzureConfig)
  return azureconfig_;
}
inline void DumpSink::set_allocated_azureconfig(::znbase::roachpb::DumpSink_Azure* azureconfig) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete azureconfig_;
  }
  if (azureconfig) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      azureconfig = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, azureconfig, submessage_arena);
    }
    
  } else {
    
  }
  azureconfig_ = azureconfig;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpSink.AzureConfig)
}

// .znbase.roachpb.DumpSink.Workload WorkloadConfig = 9;
inline bool DumpSink::has_workloadconfig() const {
  return this != internal_default_instance() && workloadconfig_ != NULL;
}
inline void DumpSink::clear_workloadconfig() {
  if (GetArenaNoVirtual() == NULL && workloadconfig_ != NULL) {
    delete workloadconfig_;
  }
  workloadconfig_ = NULL;
}
inline const ::znbase::roachpb::DumpSink_Workload& DumpSink::_internal_workloadconfig() const {
  return *workloadconfig_;
}
inline const ::znbase::roachpb::DumpSink_Workload& DumpSink::workloadconfig() const {
  const ::znbase::roachpb::DumpSink_Workload* p = workloadconfig_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpSink.WorkloadConfig)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::DumpSink_Workload*>(
      &::znbase::roachpb::_DumpSink_Workload_default_instance_);
}
inline ::znbase::roachpb::DumpSink_Workload* DumpSink::release_workloadconfig() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpSink.WorkloadConfig)
  
  ::znbase::roachpb::DumpSink_Workload* temp = workloadconfig_;
  workloadconfig_ = NULL;
  return temp;
}
inline ::znbase::roachpb::DumpSink_Workload* DumpSink::mutable_workloadconfig() {
  
  if (workloadconfig_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::DumpSink_Workload>(GetArenaNoVirtual());
    workloadconfig_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpSink.WorkloadConfig)
  return workloadconfig_;
}
inline void DumpSink::set_allocated_workloadconfig(::znbase::roachpb::DumpSink_Workload* workloadconfig) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete workloadconfig_;
  }
  if (workloadconfig) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      workloadconfig = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, workloadconfig, submessage_arena);
    }
    
  } else {
    
  }
  workloadconfig_ = workloadconfig;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpSink.WorkloadConfig)
}

// -------------------------------------------------------------------

// WriteBatchRequest

inline bool WriteBatchRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void WriteBatchRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& WriteBatchRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& WriteBatchRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.WriteBatchRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* WriteBatchRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.WriteBatchRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* WriteBatchRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.WriteBatchRequest.header)
  return header_;
}
inline void WriteBatchRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.WriteBatchRequest.header)
}

inline bool WriteBatchRequest::has_data_span() const {
  return this != internal_default_instance() && data_span_ != NULL;
}
inline const ::znbase::roachpb::Span& WriteBatchRequest::_internal_data_span() const {
  return *data_span_;
}
inline const ::znbase::roachpb::Span& WriteBatchRequest::data_span() const {
  const ::znbase::roachpb::Span* p = data_span_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.WriteBatchRequest.data_span)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::Span*>(
      &::znbase::roachpb::_Span_default_instance_);
}
inline ::znbase::roachpb::Span* WriteBatchRequest::release_data_span() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.WriteBatchRequest.data_span)
  
  ::znbase::roachpb::Span* temp = data_span_;
  data_span_ = NULL;
  return temp;
}
inline ::znbase::roachpb::Span* WriteBatchRequest::mutable_data_span() {
  
  if (data_span_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::Span>(GetArenaNoVirtual());
    data_span_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.WriteBatchRequest.data_span)
  return data_span_;
}
inline void WriteBatchRequest::set_allocated_data_span(::znbase::roachpb::Span* data_span) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(data_span_);
  }
  if (data_span) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      data_span = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, data_span, submessage_arena);
    }
    
  } else {
    
  }
  data_span_ = data_span;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.WriteBatchRequest.data_span)
}

// bytes data = 3;
inline void WriteBatchRequest::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WriteBatchRequest::data() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.WriteBatchRequest.data)
  return data_.GetNoArena();
}
inline void WriteBatchRequest::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.WriteBatchRequest.data)
}
#if LANG_CXX11
inline void WriteBatchRequest::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.WriteBatchRequest.data)
}
#endif
inline void WriteBatchRequest::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.WriteBatchRequest.data)
}
inline void WriteBatchRequest::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.WriteBatchRequest.data)
}
inline ::std::string* WriteBatchRequest::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.WriteBatchRequest.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WriteBatchRequest::release_data() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.WriteBatchRequest.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WriteBatchRequest::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.WriteBatchRequest.data)
}

// -------------------------------------------------------------------

// WriteBatchResponse

inline bool WriteBatchResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void WriteBatchResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& WriteBatchResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& WriteBatchResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.WriteBatchResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* WriteBatchResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.WriteBatchResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* WriteBatchResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.WriteBatchResponse.header)
  return header_;
}
inline void WriteBatchResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.WriteBatchResponse.header)
}

// -------------------------------------------------------------------

// FileEncryptionOptions

// bytes key = 1;
inline void FileEncryptionOptions::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileEncryptionOptions::key() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.FileEncryptionOptions.key)
  return key_.GetNoArena();
}
inline void FileEncryptionOptions::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.FileEncryptionOptions.key)
}
#if LANG_CXX11
inline void FileEncryptionOptions::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.FileEncryptionOptions.key)
}
#endif
inline void FileEncryptionOptions::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.FileEncryptionOptions.key)
}
inline void FileEncryptionOptions::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.FileEncryptionOptions.key)
}
inline ::std::string* FileEncryptionOptions::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.FileEncryptionOptions.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileEncryptionOptions::release_key() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.FileEncryptionOptions.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileEncryptionOptions::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.FileEncryptionOptions.key)
}

// -------------------------------------------------------------------

// ExportRequest

inline bool ExportRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ExportRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& ExportRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& ExportRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* ExportRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ExportRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* ExportRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ExportRequest.header)
  return header_;
}
inline void ExportRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ExportRequest.header)
}

inline bool ExportRequest::has_storage() const {
  return this != internal_default_instance() && storage_ != NULL;
}
inline void ExportRequest::clear_storage() {
  if (GetArenaNoVirtual() == NULL && storage_ != NULL) {
    delete storage_;
  }
  storage_ = NULL;
}
inline const ::znbase::roachpb::ExportStorage& ExportRequest::_internal_storage() const {
  return *storage_;
}
inline const ::znbase::roachpb::ExportStorage& ExportRequest::storage() const {
  const ::znbase::roachpb::ExportStorage* p = storage_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportRequest.storage)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ExportStorage*>(
      &::znbase::roachpb::_ExportStorage_default_instance_);
}
inline ::znbase::roachpb::ExportStorage* ExportRequest::release_storage() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ExportRequest.storage)
  
  ::znbase::roachpb::ExportStorage* temp = storage_;
  storage_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ExportStorage* ExportRequest::mutable_storage() {
  
  if (storage_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ExportStorage>(GetArenaNoVirtual());
    storage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ExportRequest.storage)
  return storage_;
}
inline void ExportRequest::set_allocated_storage(::znbase::roachpb::ExportStorage* storage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete storage_;
  }
  if (storage) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      storage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, storage, submessage_arena);
    }
    
  } else {
    
  }
  storage_ = storage;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ExportRequest.storage)
}

inline bool ExportRequest::has_start_time() const {
  return this != internal_default_instance() && start_time_ != NULL;
}
inline const ::znbase::util::hlc::Timestamp& ExportRequest::_internal_start_time() const {
  return *start_time_;
}
inline const ::znbase::util::hlc::Timestamp& ExportRequest::start_time() const {
  const ::znbase::util::hlc::Timestamp* p = start_time_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportRequest.start_time)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::util::hlc::Timestamp*>(
      &::znbase::util::hlc::_Timestamp_default_instance_);
}
inline ::znbase::util::hlc::Timestamp* ExportRequest::release_start_time() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ExportRequest.start_time)
  
  ::znbase::util::hlc::Timestamp* temp = start_time_;
  start_time_ = NULL;
  return temp;
}
inline ::znbase::util::hlc::Timestamp* ExportRequest::mutable_start_time() {
  
  if (start_time_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::util::hlc::Timestamp>(GetArenaNoVirtual());
    start_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ExportRequest.start_time)
  return start_time_;
}
inline void ExportRequest::set_allocated_start_time(::znbase::util::hlc::Timestamp* start_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(start_time_);
  }
  if (start_time) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      start_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, start_time, submessage_arena);
    }
    
  } else {
    
  }
  start_time_ = start_time;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ExportRequest.start_time)
}

inline void ExportRequest::clear_mvcc_filter() {
  mvcc_filter_ = 0;
}
inline ::znbase::roachpb::MVCCFilter ExportRequest::mvcc_filter() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportRequest.mvcc_filter)
  return static_cast< ::znbase::roachpb::MVCCFilter >(mvcc_filter_);
}
inline void ExportRequest::set_mvcc_filter(::znbase::roachpb::MVCCFilter value) {
  
  mvcc_filter_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.ExportRequest.mvcc_filter)
}

inline void ExportRequest::clear_return_sst() {
  return_sst_ = false;
}
inline bool ExportRequest::return_sst() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportRequest.return_sst)
  return return_sst_;
}
inline void ExportRequest::set_return_sst(bool value) {
  
  return_sst_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.ExportRequest.return_sst)
}

// bool omit_checksum = 6;
inline void ExportRequest::clear_omit_checksum() {
  omit_checksum_ = false;
}
inline bool ExportRequest::omit_checksum() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportRequest.omit_checksum)
  return omit_checksum_;
}
inline void ExportRequest::set_omit_checksum(bool value) {
  
  omit_checksum_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.ExportRequest.omit_checksum)
}

// bool enable_time_bound_iterator_optimization = 7;
inline void ExportRequest::clear_enable_time_bound_iterator_optimization() {
  enable_time_bound_iterator_optimization_ = false;
}
inline bool ExportRequest::enable_time_bound_iterator_optimization() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportRequest.enable_time_bound_iterator_optimization)
  return enable_time_bound_iterator_optimization_;
}
inline void ExportRequest::set_enable_time_bound_iterator_optimization(bool value) {
  
  enable_time_bound_iterator_optimization_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.ExportRequest.enable_time_bound_iterator_optimization)
}

// .znbase.roachpb.FileEncryptionOptions encryption = 9;
inline bool ExportRequest::has_encryption() const {
  return this != internal_default_instance() && encryption_ != NULL;
}
inline void ExportRequest::clear_encryption() {
  if (GetArenaNoVirtual() == NULL && encryption_ != NULL) {
    delete encryption_;
  }
  encryption_ = NULL;
}
inline const ::znbase::roachpb::FileEncryptionOptions& ExportRequest::_internal_encryption() const {
  return *encryption_;
}
inline const ::znbase::roachpb::FileEncryptionOptions& ExportRequest::encryption() const {
  const ::znbase::roachpb::FileEncryptionOptions* p = encryption_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportRequest.encryption)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::FileEncryptionOptions*>(
      &::znbase::roachpb::_FileEncryptionOptions_default_instance_);
}
inline ::znbase::roachpb::FileEncryptionOptions* ExportRequest::release_encryption() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ExportRequest.encryption)
  
  ::znbase::roachpb::FileEncryptionOptions* temp = encryption_;
  encryption_ = NULL;
  return temp;
}
inline ::znbase::roachpb::FileEncryptionOptions* ExportRequest::mutable_encryption() {
  
  if (encryption_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::FileEncryptionOptions>(GetArenaNoVirtual());
    encryption_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ExportRequest.encryption)
  return encryption_;
}
inline void ExportRequest::set_allocated_encryption(::znbase::roachpb::FileEncryptionOptions* encryption) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete encryption_;
  }
  if (encryption) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      encryption = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, encryption, submessage_arena);
    }
    
  } else {
    
  }
  encryption_ = encryption;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ExportRequest.encryption)
}

// -------------------------------------------------------------------

// RevertRequest

inline bool RevertRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void RevertRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& RevertRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& RevertRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.RevertRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* RevertRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RevertRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* RevertRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RevertRequest.header)
  return header_;
}
inline void RevertRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.RevertRequest.header)
}

inline bool RevertRequest::has_snapshot_time() const {
  return this != internal_default_instance() && snapshot_time_ != NULL;
}
inline const ::znbase::util::hlc::Timestamp& RevertRequest::_internal_snapshot_time() const {
  return *snapshot_time_;
}
inline const ::znbase::util::hlc::Timestamp& RevertRequest::snapshot_time() const {
  const ::znbase::util::hlc::Timestamp* p = snapshot_time_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.RevertRequest.snapshot_time)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::util::hlc::Timestamp*>(
      &::znbase::util::hlc::_Timestamp_default_instance_);
}
inline ::znbase::util::hlc::Timestamp* RevertRequest::release_snapshot_time() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RevertRequest.snapshot_time)
  
  ::znbase::util::hlc::Timestamp* temp = snapshot_time_;
  snapshot_time_ = NULL;
  return temp;
}
inline ::znbase::util::hlc::Timestamp* RevertRequest::mutable_snapshot_time() {
  
  if (snapshot_time_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::util::hlc::Timestamp>(GetArenaNoVirtual());
    snapshot_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RevertRequest.snapshot_time)
  return snapshot_time_;
}
inline void RevertRequest::set_allocated_snapshot_time(::znbase::util::hlc::Timestamp* snapshot_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(snapshot_time_);
  }
  if (snapshot_time) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      snapshot_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, snapshot_time, submessage_arena);
    }
    
  } else {
    
  }
  snapshot_time_ = snapshot_time;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.RevertRequest.snapshot_time)
}

// bool return_keys = 3;
inline void RevertRequest::clear_return_keys() {
  return_keys_ = false;
}
inline bool RevertRequest::return_keys() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RevertRequest.return_keys)
  return return_keys_;
}
inline void RevertRequest::set_return_keys(bool value) {
  
  return_keys_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.RevertRequest.return_keys)
}

inline int RevertRequest::clearintents_size() const {
  return clearintents_.size();
}
inline ::znbase::roachpb::Intent* RevertRequest::mutable_clearintents(int index) {
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RevertRequest.clearIntents)
  return clearintents_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::Intent >*
RevertRequest::mutable_clearintents() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.RevertRequest.clearIntents)
  return &clearintents_;
}
inline const ::znbase::roachpb::Intent& RevertRequest::clearintents(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RevertRequest.clearIntents)
  return clearintents_.Get(index);
}
inline ::znbase::roachpb::Intent* RevertRequest::add_clearintents() {
  // @@protoc_insertion_point(field_add:znbase.roachpb.RevertRequest.clearIntents)
  return clearintents_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::Intent >&
RevertRequest::clearintents() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.RevertRequest.clearIntents)
  return clearintents_;
}

// -------------------------------------------------------------------

// RevertResponse

inline bool RevertResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void RevertResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& RevertResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& RevertResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.RevertResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* RevertResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RevertResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* RevertResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RevertResponse.header)
  return header_;
}
inline void RevertResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.RevertResponse.header)
}

// int64 reverted = 2;
inline void RevertResponse::clear_reverted() {
  reverted_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 RevertResponse::reverted() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RevertResponse.reverted)
  return reverted_;
}
inline void RevertResponse::set_reverted(::google::protobuf::int64 value) {
  
  reverted_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.RevertResponse.reverted)
}

inline int RevertResponse::keys_size() const {
  return keys_.size();
}
inline void RevertResponse::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& RevertResponse::keys(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RevertResponse.keys)
  return keys_.Get(index);
}
inline ::std::string* RevertResponse::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RevertResponse.keys)
  return keys_.Mutable(index);
}
inline void RevertResponse::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:znbase.roachpb.RevertResponse.keys)
  keys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void RevertResponse::set_keys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:znbase.roachpb.RevertResponse.keys)
  keys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void RevertResponse::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.RevertResponse.keys)
}
inline void RevertResponse::set_keys(int index, const void* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.RevertResponse.keys)
}
inline ::std::string* RevertResponse::add_keys() {
  // @@protoc_insertion_point(field_add_mutable:znbase.roachpb.RevertResponse.keys)
  return keys_.Add();
}
inline void RevertResponse::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:znbase.roachpb.RevertResponse.keys)
}
#if LANG_CXX11
inline void RevertResponse::add_keys(::std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:znbase.roachpb.RevertResponse.keys)
}
#endif
inline void RevertResponse::add_keys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:znbase.roachpb.RevertResponse.keys)
}
inline void RevertResponse::add_keys(const void* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:znbase.roachpb.RevertResponse.keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RevertResponse::keys() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.RevertResponse.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RevertResponse::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.RevertResponse.keys)
  return &keys_;
}

inline int RevertResponse::unknownintents_size() const {
  return unknownintents_.size();
}
inline ::znbase::roachpb::Intent* RevertResponse::mutable_unknownintents(int index) {
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RevertResponse.unknownIntents)
  return unknownintents_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::Intent >*
RevertResponse::mutable_unknownintents() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.RevertResponse.unknownIntents)
  return &unknownintents_;
}
inline const ::znbase::roachpb::Intent& RevertResponse::unknownintents(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RevertResponse.unknownIntents)
  return unknownintents_.Get(index);
}
inline ::znbase::roachpb::Intent* RevertResponse::add_unknownintents() {
  // @@protoc_insertion_point(field_add:znbase.roachpb.RevertResponse.unknownIntents)
  return unknownintents_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::Intent >&
RevertResponse::unknownintents() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.RevertResponse.unknownIntents)
  return unknownintents_;
}

// -------------------------------------------------------------------

// ClearIntentRequest

inline bool ClearIntentRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ClearIntentRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& ClearIntentRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& ClearIntentRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.ClearIntentRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* ClearIntentRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ClearIntentRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* ClearIntentRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ClearIntentRequest.header)
  return header_;
}
inline void ClearIntentRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ClearIntentRequest.header)
}

// bool return_keys = 2;
inline void ClearIntentRequest::clear_return_keys() {
  return_keys_ = false;
}
inline bool ClearIntentRequest::return_keys() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ClearIntentRequest.return_keys)
  return return_keys_;
}
inline void ClearIntentRequest::set_return_keys(bool value) {
  
  return_keys_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.ClearIntentRequest.return_keys)
}

inline int ClearIntentRequest::clearintents_size() const {
  return clearintents_.size();
}
inline ::znbase::roachpb::Intent* ClearIntentRequest::mutable_clearintents(int index) {
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ClearIntentRequest.clearIntents)
  return clearintents_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::Intent >*
ClearIntentRequest::mutable_clearintents() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.ClearIntentRequest.clearIntents)
  return &clearintents_;
}
inline const ::znbase::roachpb::Intent& ClearIntentRequest::clearintents(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ClearIntentRequest.clearIntents)
  return clearintents_.Get(index);
}
inline ::znbase::roachpb::Intent* ClearIntentRequest::add_clearintents() {
  // @@protoc_insertion_point(field_add:znbase.roachpb.ClearIntentRequest.clearIntents)
  return clearintents_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::Intent >&
ClearIntentRequest::clearintents() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.ClearIntentRequest.clearIntents)
  return clearintents_;
}

// -------------------------------------------------------------------

// ClearIntentResponse

inline bool ClearIntentResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ClearIntentResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& ClearIntentResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& ClearIntentResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.ClearIntentResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* ClearIntentResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ClearIntentResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* ClearIntentResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ClearIntentResponse.header)
  return header_;
}
inline void ClearIntentResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ClearIntentResponse.header)
}

// int64 reverted = 2;
inline void ClearIntentResponse::clear_reverted() {
  reverted_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ClearIntentResponse::reverted() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ClearIntentResponse.reverted)
  return reverted_;
}
inline void ClearIntentResponse::set_reverted(::google::protobuf::int64 value) {
  
  reverted_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.ClearIntentResponse.reverted)
}

inline int ClearIntentResponse::keys_size() const {
  return keys_.size();
}
inline void ClearIntentResponse::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& ClearIntentResponse::keys(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ClearIntentResponse.keys)
  return keys_.Get(index);
}
inline ::std::string* ClearIntentResponse::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ClearIntentResponse.keys)
  return keys_.Mutable(index);
}
inline void ClearIntentResponse::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:znbase.roachpb.ClearIntentResponse.keys)
  keys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ClearIntentResponse::set_keys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:znbase.roachpb.ClearIntentResponse.keys)
  keys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ClearIntentResponse::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.ClearIntentResponse.keys)
}
inline void ClearIntentResponse::set_keys(int index, const void* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.ClearIntentResponse.keys)
}
inline ::std::string* ClearIntentResponse::add_keys() {
  // @@protoc_insertion_point(field_add_mutable:znbase.roachpb.ClearIntentResponse.keys)
  return keys_.Add();
}
inline void ClearIntentResponse::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:znbase.roachpb.ClearIntentResponse.keys)
}
#if LANG_CXX11
inline void ClearIntentResponse::add_keys(::std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:znbase.roachpb.ClearIntentResponse.keys)
}
#endif
inline void ClearIntentResponse::add_keys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:znbase.roachpb.ClearIntentResponse.keys)
}
inline void ClearIntentResponse::add_keys(const void* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:znbase.roachpb.ClearIntentResponse.keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ClearIntentResponse::keys() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.ClearIntentResponse.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ClearIntentResponse::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.ClearIntentResponse.keys)
  return &keys_;
}

inline int ClearIntentResponse::unknownintents_size() const {
  return unknownintents_.size();
}
inline ::znbase::roachpb::Intent* ClearIntentResponse::mutable_unknownintents(int index) {
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ClearIntentResponse.unknownIntents)
  return unknownintents_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::Intent >*
ClearIntentResponse::mutable_unknownintents() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.ClearIntentResponse.unknownIntents)
  return &unknownintents_;
}
inline const ::znbase::roachpb::Intent& ClearIntentResponse::unknownintents(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ClearIntentResponse.unknownIntents)
  return unknownintents_.Get(index);
}
inline ::znbase::roachpb::Intent* ClearIntentResponse::add_unknownintents() {
  // @@protoc_insertion_point(field_add:znbase.roachpb.ClearIntentResponse.unknownIntents)
  return unknownintents_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::Intent >&
ClearIntentResponse::unknownintents() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.ClearIntentResponse.unknownIntents)
  return unknownintents_;
}

// -------------------------------------------------------------------

// DumpRequest

inline bool DumpRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DumpRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& DumpRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& DumpRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* DumpRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* DumpRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpRequest.header)
  return header_;
}
inline void DumpRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpRequest.header)
}

inline bool DumpRequest::has_sink() const {
  return this != internal_default_instance() && sink_ != NULL;
}
inline void DumpRequest::clear_sink() {
  if (GetArenaNoVirtual() == NULL && sink_ != NULL) {
    delete sink_;
  }
  sink_ = NULL;
}
inline const ::znbase::roachpb::DumpSink& DumpRequest::_internal_sink() const {
  return *sink_;
}
inline const ::znbase::roachpb::DumpSink& DumpRequest::sink() const {
  const ::znbase::roachpb::DumpSink* p = sink_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpRequest.sink)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::DumpSink*>(
      &::znbase::roachpb::_DumpSink_default_instance_);
}
inline ::znbase::roachpb::DumpSink* DumpRequest::release_sink() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpRequest.sink)
  
  ::znbase::roachpb::DumpSink* temp = sink_;
  sink_ = NULL;
  return temp;
}
inline ::znbase::roachpb::DumpSink* DumpRequest::mutable_sink() {
  
  if (sink_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::DumpSink>(GetArenaNoVirtual());
    sink_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpRequest.sink)
  return sink_;
}
inline void DumpRequest::set_allocated_sink(::znbase::roachpb::DumpSink* sink) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sink_;
  }
  if (sink) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sink = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sink, submessage_arena);
    }
    
  } else {
    
  }
  sink_ = sink;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpRequest.sink)
}

inline bool DumpRequest::has_start_time() const {
  return this != internal_default_instance() && start_time_ != NULL;
}
inline const ::znbase::util::hlc::Timestamp& DumpRequest::_internal_start_time() const {
  return *start_time_;
}
inline const ::znbase::util::hlc::Timestamp& DumpRequest::start_time() const {
  const ::znbase::util::hlc::Timestamp* p = start_time_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpRequest.start_time)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::util::hlc::Timestamp*>(
      &::znbase::util::hlc::_Timestamp_default_instance_);
}
inline ::znbase::util::hlc::Timestamp* DumpRequest::release_start_time() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpRequest.start_time)
  
  ::znbase::util::hlc::Timestamp* temp = start_time_;
  start_time_ = NULL;
  return temp;
}
inline ::znbase::util::hlc::Timestamp* DumpRequest::mutable_start_time() {
  
  if (start_time_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::util::hlc::Timestamp>(GetArenaNoVirtual());
    start_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpRequest.start_time)
  return start_time_;
}
inline void DumpRequest::set_allocated_start_time(::znbase::util::hlc::Timestamp* start_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(start_time_);
  }
  if (start_time) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      start_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, start_time, submessage_arena);
    }
    
  } else {
    
  }
  start_time_ = start_time;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpRequest.start_time)
}

inline void DumpRequest::clear_mvcc_filter() {
  mvcc_filter_ = 0;
}
inline ::znbase::roachpb::MVCCFilter DumpRequest::mvcc_filter() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpRequest.mvcc_filter)
  return static_cast< ::znbase::roachpb::MVCCFilter >(mvcc_filter_);
}
inline void DumpRequest::set_mvcc_filter(::znbase::roachpb::MVCCFilter value) {
  
  mvcc_filter_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpRequest.mvcc_filter)
}

inline void DumpRequest::clear_return_sst() {
  return_sst_ = false;
}
inline bool DumpRequest::return_sst() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpRequest.return_sst)
  return return_sst_;
}
inline void DumpRequest::set_return_sst(bool value) {
  
  return_sst_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpRequest.return_sst)
}

// bool omit_checksum = 6;
inline void DumpRequest::clear_omit_checksum() {
  omit_checksum_ = false;
}
inline bool DumpRequest::omit_checksum() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpRequest.omit_checksum)
  return omit_checksum_;
}
inline void DumpRequest::set_omit_checksum(bool value) {
  
  omit_checksum_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpRequest.omit_checksum)
}

// bool enable_time_bound_iterator_optimization = 7;
inline void DumpRequest::clear_enable_time_bound_iterator_optimization() {
  enable_time_bound_iterator_optimization_ = false;
}
inline bool DumpRequest::enable_time_bound_iterator_optimization() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpRequest.enable_time_bound_iterator_optimization)
  return enable_time_bound_iterator_optimization_;
}
inline void DumpRequest::set_enable_time_bound_iterator_optimization(bool value) {
  
  enable_time_bound_iterator_optimization_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpRequest.enable_time_bound_iterator_optimization)
}

// .znbase.roachpb.FileEncryptionOptions encryption = 9;
inline bool DumpRequest::has_encryption() const {
  return this != internal_default_instance() && encryption_ != NULL;
}
inline void DumpRequest::clear_encryption() {
  if (GetArenaNoVirtual() == NULL && encryption_ != NULL) {
    delete encryption_;
  }
  encryption_ = NULL;
}
inline const ::znbase::roachpb::FileEncryptionOptions& DumpRequest::_internal_encryption() const {
  return *encryption_;
}
inline const ::znbase::roachpb::FileEncryptionOptions& DumpRequest::encryption() const {
  const ::znbase::roachpb::FileEncryptionOptions* p = encryption_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpRequest.encryption)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::FileEncryptionOptions*>(
      &::znbase::roachpb::_FileEncryptionOptions_default_instance_);
}
inline ::znbase::roachpb::FileEncryptionOptions* DumpRequest::release_encryption() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpRequest.encryption)
  
  ::znbase::roachpb::FileEncryptionOptions* temp = encryption_;
  encryption_ = NULL;
  return temp;
}
inline ::znbase::roachpb::FileEncryptionOptions* DumpRequest::mutable_encryption() {
  
  if (encryption_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::FileEncryptionOptions>(GetArenaNoVirtual());
    encryption_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpRequest.encryption)
  return encryption_;
}
inline void DumpRequest::set_allocated_encryption(::znbase::roachpb::FileEncryptionOptions* encryption) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete encryption_;
  }
  if (encryption) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      encryption = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, encryption, submessage_arena);
    }
    
  } else {
    
  }
  encryption_ = encryption;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpRequest.encryption)
}

// .znbase.roachpb.FileCompression compression_codec = 10;
inline void DumpRequest::clear_compression_codec() {
  compression_codec_ = 0;
}
inline ::znbase::roachpb::FileCompression DumpRequest::compression_codec() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpRequest.compression_codec)
  return static_cast< ::znbase::roachpb::FileCompression >(compression_codec_);
}
inline void DumpRequest::set_compression_codec(::znbase::roachpb::FileCompression value) {
  
  compression_codec_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpRequest.compression_codec)
}

// string http_header = 11;
inline void DumpRequest::clear_http_header() {
  http_header_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DumpRequest::http_header() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpRequest.http_header)
  return http_header_.GetNoArena();
}
inline void DumpRequest::set_http_header(const ::std::string& value) {
  
  http_header_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpRequest.http_header)
}
#if LANG_CXX11
inline void DumpRequest::set_http_header(::std::string&& value) {
  
  http_header_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.DumpRequest.http_header)
}
#endif
inline void DumpRequest::set_http_header(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  http_header_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.DumpRequest.http_header)
}
inline void DumpRequest::set_http_header(const char* value, size_t size) {
  
  http_header_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.DumpRequest.http_header)
}
inline ::std::string* DumpRequest::mutable_http_header() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpRequest.http_header)
  return http_header_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DumpRequest::release_http_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpRequest.http_header)
  
  return http_header_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DumpRequest::set_allocated_http_header(::std::string* http_header) {
  if (http_header != NULL) {
    
  } else {
    
  }
  http_header_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), http_header);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpRequest.http_header)
}

// -------------------------------------------------------------------

// Result

inline void Result::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Result::key() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.Result.key)
  return key_.GetNoArena();
}
inline void Result::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.Result.key)
}
#if LANG_CXX11
inline void Result::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.Result.key)
}
#endif
inline void Result::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.Result.key)
}
inline void Result::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.Result.key)
}
inline ::std::string* Result::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.Result.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Result::release_key() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.Result.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Result::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.Result.key)
}

// bool remove = 2;
inline void Result::clear_remove() {
  remove_ = false;
}
inline bool Result::remove() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.Result.remove)
  return remove_;
}
inline void Result::set_remove(bool value) {
  
  remove_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.Result.remove)
}

// -------------------------------------------------------------------

// DumpOnlineRequest

inline bool DumpOnlineRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DumpOnlineRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& DumpOnlineRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& DumpOnlineRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpOnlineRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* DumpOnlineRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpOnlineRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* DumpOnlineRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpOnlineRequest.header)
  return header_;
}
inline void DumpOnlineRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpOnlineRequest.header)
}

inline bool DumpOnlineRequest::has_sink() const {
  return this != internal_default_instance() && sink_ != NULL;
}
inline void DumpOnlineRequest::clear_sink() {
  if (GetArenaNoVirtual() == NULL && sink_ != NULL) {
    delete sink_;
  }
  sink_ = NULL;
}
inline const ::znbase::roachpb::DumpSink& DumpOnlineRequest::_internal_sink() const {
  return *sink_;
}
inline const ::znbase::roachpb::DumpSink& DumpOnlineRequest::sink() const {
  const ::znbase::roachpb::DumpSink* p = sink_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpOnlineRequest.sink)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::DumpSink*>(
      &::znbase::roachpb::_DumpSink_default_instance_);
}
inline ::znbase::roachpb::DumpSink* DumpOnlineRequest::release_sink() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpOnlineRequest.sink)
  
  ::znbase::roachpb::DumpSink* temp = sink_;
  sink_ = NULL;
  return temp;
}
inline ::znbase::roachpb::DumpSink* DumpOnlineRequest::mutable_sink() {
  
  if (sink_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::DumpSink>(GetArenaNoVirtual());
    sink_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpOnlineRequest.sink)
  return sink_;
}
inline void DumpOnlineRequest::set_allocated_sink(::znbase::roachpb::DumpSink* sink) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sink_;
  }
  if (sink) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sink = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sink, submessage_arena);
    }
    
  } else {
    
  }
  sink_ = sink;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpOnlineRequest.sink)
}

inline bool DumpOnlineRequest::has_start_time() const {
  return this != internal_default_instance() && start_time_ != NULL;
}
inline const ::znbase::util::hlc::Timestamp& DumpOnlineRequest::_internal_start_time() const {
  return *start_time_;
}
inline const ::znbase::util::hlc::Timestamp& DumpOnlineRequest::start_time() const {
  const ::znbase::util::hlc::Timestamp* p = start_time_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpOnlineRequest.start_time)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::util::hlc::Timestamp*>(
      &::znbase::util::hlc::_Timestamp_default_instance_);
}
inline ::znbase::util::hlc::Timestamp* DumpOnlineRequest::release_start_time() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpOnlineRequest.start_time)
  
  ::znbase::util::hlc::Timestamp* temp = start_time_;
  start_time_ = NULL;
  return temp;
}
inline ::znbase::util::hlc::Timestamp* DumpOnlineRequest::mutable_start_time() {
  
  if (start_time_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::util::hlc::Timestamp>(GetArenaNoVirtual());
    start_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpOnlineRequest.start_time)
  return start_time_;
}
inline void DumpOnlineRequest::set_allocated_start_time(::znbase::util::hlc::Timestamp* start_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(start_time_);
  }
  if (start_time) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      start_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, start_time, submessage_arena);
    }
    
  } else {
    
  }
  start_time_ = start_time;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpOnlineRequest.start_time)
}

inline void DumpOnlineRequest::clear_mvcc_filter() {
  mvcc_filter_ = 0;
}
inline ::znbase::roachpb::MVCCFilter DumpOnlineRequest::mvcc_filter() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpOnlineRequest.mvcc_filter)
  return static_cast< ::znbase::roachpb::MVCCFilter >(mvcc_filter_);
}
inline void DumpOnlineRequest::set_mvcc_filter(::znbase::roachpb::MVCCFilter value) {
  
  mvcc_filter_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpOnlineRequest.mvcc_filter)
}

inline void DumpOnlineRequest::clear_return_sst() {
  return_sst_ = false;
}
inline bool DumpOnlineRequest::return_sst() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpOnlineRequest.return_sst)
  return return_sst_;
}
inline void DumpOnlineRequest::set_return_sst(bool value) {
  
  return_sst_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpOnlineRequest.return_sst)
}

// bool omit_checksum = 6;
inline void DumpOnlineRequest::clear_omit_checksum() {
  omit_checksum_ = false;
}
inline bool DumpOnlineRequest::omit_checksum() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpOnlineRequest.omit_checksum)
  return omit_checksum_;
}
inline void DumpOnlineRequest::set_omit_checksum(bool value) {
  
  omit_checksum_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpOnlineRequest.omit_checksum)
}

// bool enable_time_bound_iterator_optimization = 7;
inline void DumpOnlineRequest::clear_enable_time_bound_iterator_optimization() {
  enable_time_bound_iterator_optimization_ = false;
}
inline bool DumpOnlineRequest::enable_time_bound_iterator_optimization() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpOnlineRequest.enable_time_bound_iterator_optimization)
  return enable_time_bound_iterator_optimization_;
}
inline void DumpOnlineRequest::set_enable_time_bound_iterator_optimization(bool value) {
  
  enable_time_bound_iterator_optimization_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpOnlineRequest.enable_time_bound_iterator_optimization)
}

// .znbase.roachpb.FileEncryptionOptions encryption = 9;
inline bool DumpOnlineRequest::has_encryption() const {
  return this != internal_default_instance() && encryption_ != NULL;
}
inline void DumpOnlineRequest::clear_encryption() {
  if (GetArenaNoVirtual() == NULL && encryption_ != NULL) {
    delete encryption_;
  }
  encryption_ = NULL;
}
inline const ::znbase::roachpb::FileEncryptionOptions& DumpOnlineRequest::_internal_encryption() const {
  return *encryption_;
}
inline const ::znbase::roachpb::FileEncryptionOptions& DumpOnlineRequest::encryption() const {
  const ::znbase::roachpb::FileEncryptionOptions* p = encryption_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpOnlineRequest.encryption)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::FileEncryptionOptions*>(
      &::znbase::roachpb::_FileEncryptionOptions_default_instance_);
}
inline ::znbase::roachpb::FileEncryptionOptions* DumpOnlineRequest::release_encryption() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpOnlineRequest.encryption)
  
  ::znbase::roachpb::FileEncryptionOptions* temp = encryption_;
  encryption_ = NULL;
  return temp;
}
inline ::znbase::roachpb::FileEncryptionOptions* DumpOnlineRequest::mutable_encryption() {
  
  if (encryption_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::FileEncryptionOptions>(GetArenaNoVirtual());
    encryption_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpOnlineRequest.encryption)
  return encryption_;
}
inline void DumpOnlineRequest::set_allocated_encryption(::znbase::roachpb::FileEncryptionOptions* encryption) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete encryption_;
  }
  if (encryption) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      encryption = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, encryption, submessage_arena);
    }
    
  } else {
    
  }
  encryption_ = encryption;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpOnlineRequest.encryption)
}

// .znbase.roachpb.FileCompression compression_codec = 10;
inline void DumpOnlineRequest::clear_compression_codec() {
  compression_codec_ = 0;
}
inline ::znbase::roachpb::FileCompression DumpOnlineRequest::compression_codec() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpOnlineRequest.compression_codec)
  return static_cast< ::znbase::roachpb::FileCompression >(compression_codec_);
}
inline void DumpOnlineRequest::set_compression_codec(::znbase::roachpb::FileCompression value) {
  
  compression_codec_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpOnlineRequest.compression_codec)
}

// bool seekTime = 11;
inline void DumpOnlineRequest::clear_seektime() {
  seektime_ = false;
}
inline bool DumpOnlineRequest::seektime() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpOnlineRequest.seekTime)
  return seektime_;
}
inline void DumpOnlineRequest::set_seektime(bool value) {
  
  seektime_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpOnlineRequest.seekTime)
}

inline int DumpOnlineRequest::results_size() const {
  return results_.size();
}
inline void DumpOnlineRequest::clear_results() {
  results_.Clear();
}
inline ::znbase::roachpb::Result* DumpOnlineRequest::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpOnlineRequest.Results)
  return results_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::Result >*
DumpOnlineRequest::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.DumpOnlineRequest.Results)
  return &results_;
}
inline const ::znbase::roachpb::Result& DumpOnlineRequest::results(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpOnlineRequest.Results)
  return results_.Get(index);
}
inline ::znbase::roachpb::Result* DumpOnlineRequest::add_results() {
  // @@protoc_insertion_point(field_add:znbase.roachpb.DumpOnlineRequest.Results)
  return results_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::Result >&
DumpOnlineRequest::results() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.DumpOnlineRequest.Results)
  return results_;
}

// int64 job_id = 14;
inline void DumpOnlineRequest::clear_job_id() {
  job_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 DumpOnlineRequest::job_id() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpOnlineRequest.job_id)
  return job_id_;
}
inline void DumpOnlineRequest::set_job_id(::google::protobuf::int64 value) {
  
  job_id_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpOnlineRequest.job_id)
}

// -------------------------------------------------------------------

// DumpOnlineResponse_File

inline bool DumpOnlineResponse_File::has_span() const {
  return this != internal_default_instance() && span_ != NULL;
}
inline const ::znbase::roachpb::Span& DumpOnlineResponse_File::_internal_span() const {
  return *span_;
}
inline const ::znbase::roachpb::Span& DumpOnlineResponse_File::span() const {
  const ::znbase::roachpb::Span* p = span_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpOnlineResponse.File.span)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::Span*>(
      &::znbase::roachpb::_Span_default_instance_);
}
inline ::znbase::roachpb::Span* DumpOnlineResponse_File::release_span() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpOnlineResponse.File.span)
  
  ::znbase::roachpb::Span* temp = span_;
  span_ = NULL;
  return temp;
}
inline ::znbase::roachpb::Span* DumpOnlineResponse_File::mutable_span() {
  
  if (span_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::Span>(GetArenaNoVirtual());
    span_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpOnlineResponse.File.span)
  return span_;
}
inline void DumpOnlineResponse_File::set_allocated_span(::znbase::roachpb::Span* span) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(span_);
  }
  if (span) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      span = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, span, submessage_arena);
    }
    
  } else {
    
  }
  span_ = span;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpOnlineResponse.File.span)
}

// string path = 2;
inline void DumpOnlineResponse_File::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DumpOnlineResponse_File::path() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpOnlineResponse.File.path)
  return path_.GetNoArena();
}
inline void DumpOnlineResponse_File::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpOnlineResponse.File.path)
}
#if LANG_CXX11
inline void DumpOnlineResponse_File::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.DumpOnlineResponse.File.path)
}
#endif
inline void DumpOnlineResponse_File::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.DumpOnlineResponse.File.path)
}
inline void DumpOnlineResponse_File::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.DumpOnlineResponse.File.path)
}
inline ::std::string* DumpOnlineResponse_File::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpOnlineResponse.File.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DumpOnlineResponse_File::release_path() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpOnlineResponse.File.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DumpOnlineResponse_File::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpOnlineResponse.File.path)
}

// bytes sha512 = 5;
inline void DumpOnlineResponse_File::clear_sha512() {
  sha512_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DumpOnlineResponse_File::sha512() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpOnlineResponse.File.sha512)
  return sha512_.GetNoArena();
}
inline void DumpOnlineResponse_File::set_sha512(const ::std::string& value) {
  
  sha512_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpOnlineResponse.File.sha512)
}
#if LANG_CXX11
inline void DumpOnlineResponse_File::set_sha512(::std::string&& value) {
  
  sha512_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.DumpOnlineResponse.File.sha512)
}
#endif
inline void DumpOnlineResponse_File::set_sha512(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sha512_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.DumpOnlineResponse.File.sha512)
}
inline void DumpOnlineResponse_File::set_sha512(const void* value, size_t size) {
  
  sha512_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.DumpOnlineResponse.File.sha512)
}
inline ::std::string* DumpOnlineResponse_File::mutable_sha512() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpOnlineResponse.File.sha512)
  return sha512_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DumpOnlineResponse_File::release_sha512() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpOnlineResponse.File.sha512)
  
  return sha512_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DumpOnlineResponse_File::set_allocated_sha512(::std::string* sha512) {
  if (sha512 != NULL) {
    
  } else {
    
  }
  sha512_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sha512);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpOnlineResponse.File.sha512)
}

inline bool DumpOnlineResponse_File::has_dumped() const {
  return this != internal_default_instance() && dumped_ != NULL;
}
inline void DumpOnlineResponse_File::clear_dumped() {
  if (GetArenaNoVirtual() == NULL && dumped_ != NULL) {
    delete dumped_;
  }
  dumped_ = NULL;
}
inline const ::znbase::roachpb::BulkOpSummary& DumpOnlineResponse_File::_internal_dumped() const {
  return *dumped_;
}
inline const ::znbase::roachpb::BulkOpSummary& DumpOnlineResponse_File::dumped() const {
  const ::znbase::roachpb::BulkOpSummary* p = dumped_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpOnlineResponse.File.dumped)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::BulkOpSummary*>(
      &::znbase::roachpb::_BulkOpSummary_default_instance_);
}
inline ::znbase::roachpb::BulkOpSummary* DumpOnlineResponse_File::release_dumped() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpOnlineResponse.File.dumped)
  
  ::znbase::roachpb::BulkOpSummary* temp = dumped_;
  dumped_ = NULL;
  return temp;
}
inline ::znbase::roachpb::BulkOpSummary* DumpOnlineResponse_File::mutable_dumped() {
  
  if (dumped_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::BulkOpSummary>(GetArenaNoVirtual());
    dumped_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpOnlineResponse.File.dumped)
  return dumped_;
}
inline void DumpOnlineResponse_File::set_allocated_dumped(::znbase::roachpb::BulkOpSummary* dumped) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete dumped_;
  }
  if (dumped) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      dumped = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dumped, submessage_arena);
    }
    
  } else {
    
  }
  dumped_ = dumped;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpOnlineResponse.File.dumped)
}

inline void DumpOnlineResponse_File::clear_sst() {
  sst_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DumpOnlineResponse_File::sst() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpOnlineResponse.File.sst)
  return sst_.GetNoArena();
}
inline void DumpOnlineResponse_File::set_sst(const ::std::string& value) {
  
  sst_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpOnlineResponse.File.sst)
}
#if LANG_CXX11
inline void DumpOnlineResponse_File::set_sst(::std::string&& value) {
  
  sst_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.DumpOnlineResponse.File.sst)
}
#endif
inline void DumpOnlineResponse_File::set_sst(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sst_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.DumpOnlineResponse.File.sst)
}
inline void DumpOnlineResponse_File::set_sst(const void* value, size_t size) {
  
  sst_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.DumpOnlineResponse.File.sst)
}
inline ::std::string* DumpOnlineResponse_File::mutable_sst() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpOnlineResponse.File.sst)
  return sst_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DumpOnlineResponse_File::release_sst() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpOnlineResponse.File.sst)
  
  return sst_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DumpOnlineResponse_File::set_allocated_sst(::std::string* sst) {
  if (sst != NULL) {
    
  } else {
    
  }
  sst_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sst);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpOnlineResponse.File.sst)
}

// -------------------------------------------------------------------

// DumpOnlineResponse_Files

inline int DumpOnlineResponse_Files::files_size() const {
  return files_.size();
}
inline void DumpOnlineResponse_Files::clear_files() {
  files_.Clear();
}
inline ::znbase::roachpb::DumpOnlineResponse_File* DumpOnlineResponse_Files::mutable_files(int index) {
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpOnlineResponse.Files.files)
  return files_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::DumpOnlineResponse_File >*
DumpOnlineResponse_Files::mutable_files() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.DumpOnlineResponse.Files.files)
  return &files_;
}
inline const ::znbase::roachpb::DumpOnlineResponse_File& DumpOnlineResponse_Files::files(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpOnlineResponse.Files.files)
  return files_.Get(index);
}
inline ::znbase::roachpb::DumpOnlineResponse_File* DumpOnlineResponse_Files::add_files() {
  // @@protoc_insertion_point(field_add:znbase.roachpb.DumpOnlineResponse.Files.files)
  return files_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::DumpOnlineResponse_File >&
DumpOnlineResponse_Files::files() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.DumpOnlineResponse.Files.files)
  return files_;
}

// -------------------------------------------------------------------

// DumpOnlineResponse

inline bool DumpOnlineResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DumpOnlineResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& DumpOnlineResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& DumpOnlineResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpOnlineResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* DumpOnlineResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpOnlineResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* DumpOnlineResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpOnlineResponse.header)
  return header_;
}
inline void DumpOnlineResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpOnlineResponse.header)
}

inline int DumpOnlineResponse::files_size() const {
  return files_.size();
}
inline void DumpOnlineResponse::clear_files() {
  files_.Clear();
}
inline ::znbase::roachpb::DumpOnlineResponse_File* DumpOnlineResponse::mutable_files(int index) {
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpOnlineResponse.files)
  return files_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::DumpOnlineResponse_File >*
DumpOnlineResponse::mutable_files() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.DumpOnlineResponse.files)
  return &files_;
}
inline const ::znbase::roachpb::DumpOnlineResponse_File& DumpOnlineResponse::files(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpOnlineResponse.files)
  return files_.Get(index);
}
inline ::znbase::roachpb::DumpOnlineResponse_File* DumpOnlineResponse::add_files() {
  // @@protoc_insertion_point(field_add:znbase.roachpb.DumpOnlineResponse.files)
  return files_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::DumpOnlineResponse_File >&
DumpOnlineResponse::files() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.DumpOnlineResponse.files)
  return files_;
}

inline bool DumpOnlineResponse::has_start_time() const {
  return this != internal_default_instance() && start_time_ != NULL;
}
inline const ::znbase::util::hlc::Timestamp& DumpOnlineResponse::_internal_start_time() const {
  return *start_time_;
}
inline const ::znbase::util::hlc::Timestamp& DumpOnlineResponse::start_time() const {
  const ::znbase::util::hlc::Timestamp* p = start_time_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpOnlineResponse.start_time)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::util::hlc::Timestamp*>(
      &::znbase::util::hlc::_Timestamp_default_instance_);
}
inline ::znbase::util::hlc::Timestamp* DumpOnlineResponse::release_start_time() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpOnlineResponse.start_time)
  
  ::znbase::util::hlc::Timestamp* temp = start_time_;
  start_time_ = NULL;
  return temp;
}
inline ::znbase::util::hlc::Timestamp* DumpOnlineResponse::mutable_start_time() {
  
  if (start_time_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::util::hlc::Timestamp>(GetArenaNoVirtual());
    start_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpOnlineResponse.start_time)
  return start_time_;
}
inline void DumpOnlineResponse::set_allocated_start_time(::znbase::util::hlc::Timestamp* start_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(start_time_);
  }
  if (start_time) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      start_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, start_time, submessage_arena);
    }
    
  } else {
    
  }
  start_time_ = start_time;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpOnlineResponse.start_time)
}

inline bool DumpOnlineResponse::has_min_time() const {
  return this != internal_default_instance() && min_time_ != NULL;
}
inline const ::znbase::util::hlc::Timestamp& DumpOnlineResponse::_internal_min_time() const {
  return *min_time_;
}
inline const ::znbase::util::hlc::Timestamp& DumpOnlineResponse::min_time() const {
  const ::znbase::util::hlc::Timestamp* p = min_time_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpOnlineResponse.min_time)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::util::hlc::Timestamp*>(
      &::znbase::util::hlc::_Timestamp_default_instance_);
}
inline ::znbase::util::hlc::Timestamp* DumpOnlineResponse::release_min_time() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpOnlineResponse.min_time)
  
  ::znbase::util::hlc::Timestamp* temp = min_time_;
  min_time_ = NULL;
  return temp;
}
inline ::znbase::util::hlc::Timestamp* DumpOnlineResponse::mutable_min_time() {
  
  if (min_time_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::util::hlc::Timestamp>(GetArenaNoVirtual());
    min_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpOnlineResponse.min_time)
  return min_time_;
}
inline void DumpOnlineResponse::set_allocated_min_time(::znbase::util::hlc::Timestamp* min_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(min_time_);
  }
  if (min_time) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      min_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, min_time, submessage_arena);
    }
    
  } else {
    
  }
  min_time_ = min_time;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpOnlineResponse.min_time)
}

// -------------------------------------------------------------------

// BulkOpSummary

// int64 data_size = 1;
inline void BulkOpSummary::clear_data_size() {
  data_size_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 BulkOpSummary::data_size() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.BulkOpSummary.data_size)
  return data_size_;
}
inline void BulkOpSummary::set_data_size(::google::protobuf::int64 value) {
  
  data_size_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.BulkOpSummary.data_size)
}

// int64 rows = 2;
inline void BulkOpSummary::clear_rows() {
  rows_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 BulkOpSummary::rows() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.BulkOpSummary.rows)
  return rows_;
}
inline void BulkOpSummary::set_rows(::google::protobuf::int64 value) {
  
  rows_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.BulkOpSummary.rows)
}

// int64 index_entries = 3;
inline void BulkOpSummary::clear_index_entries() {
  index_entries_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 BulkOpSummary::index_entries() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.BulkOpSummary.index_entries)
  return index_entries_;
}
inline void BulkOpSummary::set_index_entries(::google::protobuf::int64 value) {
  
  index_entries_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.BulkOpSummary.index_entries)
}

// int64 system_records = 4;
inline void BulkOpSummary::clear_system_records() {
  system_records_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 BulkOpSummary::system_records() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.BulkOpSummary.system_records)
  return system_records_;
}
inline void BulkOpSummary::set_system_records(::google::protobuf::int64 value) {
  
  system_records_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.BulkOpSummary.system_records)
}

// .znbase.roachpb.FileEncryptionOptions encryption = 7;
inline bool BulkOpSummary::has_encryption() const {
  return this != internal_default_instance() && encryption_ != NULL;
}
inline void BulkOpSummary::clear_encryption() {
  if (GetArenaNoVirtual() == NULL && encryption_ != NULL) {
    delete encryption_;
  }
  encryption_ = NULL;
}
inline const ::znbase::roachpb::FileEncryptionOptions& BulkOpSummary::_internal_encryption() const {
  return *encryption_;
}
inline const ::znbase::roachpb::FileEncryptionOptions& BulkOpSummary::encryption() const {
  const ::znbase::roachpb::FileEncryptionOptions* p = encryption_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.BulkOpSummary.encryption)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::FileEncryptionOptions*>(
      &::znbase::roachpb::_FileEncryptionOptions_default_instance_);
}
inline ::znbase::roachpb::FileEncryptionOptions* BulkOpSummary::release_encryption() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.BulkOpSummary.encryption)
  
  ::znbase::roachpb::FileEncryptionOptions* temp = encryption_;
  encryption_ = NULL;
  return temp;
}
inline ::znbase::roachpb::FileEncryptionOptions* BulkOpSummary::mutable_encryption() {
  
  if (encryption_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::FileEncryptionOptions>(GetArenaNoVirtual());
    encryption_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.BulkOpSummary.encryption)
  return encryption_;
}
inline void BulkOpSummary::set_allocated_encryption(::znbase::roachpb::FileEncryptionOptions* encryption) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete encryption_;
  }
  if (encryption) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      encryption = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, encryption, submessage_arena);
    }
    
  } else {
    
  }
  encryption_ = encryption;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.BulkOpSummary.encryption)
}

// -------------------------------------------------------------------

// ExportResponse_File

inline bool ExportResponse_File::has_span() const {
  return this != internal_default_instance() && span_ != NULL;
}
inline const ::znbase::roachpb::Span& ExportResponse_File::_internal_span() const {
  return *span_;
}
inline const ::znbase::roachpb::Span& ExportResponse_File::span() const {
  const ::znbase::roachpb::Span* p = span_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportResponse.File.span)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::Span*>(
      &::znbase::roachpb::_Span_default_instance_);
}
inline ::znbase::roachpb::Span* ExportResponse_File::release_span() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ExportResponse.File.span)
  
  ::znbase::roachpb::Span* temp = span_;
  span_ = NULL;
  return temp;
}
inline ::znbase::roachpb::Span* ExportResponse_File::mutable_span() {
  
  if (span_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::Span>(GetArenaNoVirtual());
    span_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ExportResponse.File.span)
  return span_;
}
inline void ExportResponse_File::set_allocated_span(::znbase::roachpb::Span* span) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(span_);
  }
  if (span) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      span = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, span, submessage_arena);
    }
    
  } else {
    
  }
  span_ = span;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ExportResponse.File.span)
}

// string path = 2;
inline void ExportResponse_File::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExportResponse_File::path() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportResponse.File.path)
  return path_.GetNoArena();
}
inline void ExportResponse_File::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.ExportResponse.File.path)
}
#if LANG_CXX11
inline void ExportResponse_File::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.ExportResponse.File.path)
}
#endif
inline void ExportResponse_File::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.ExportResponse.File.path)
}
inline void ExportResponse_File::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.ExportResponse.File.path)
}
inline ::std::string* ExportResponse_File::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ExportResponse.File.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExportResponse_File::release_path() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ExportResponse.File.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExportResponse_File::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ExportResponse.File.path)
}

// bytes sha512 = 5;
inline void ExportResponse_File::clear_sha512() {
  sha512_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExportResponse_File::sha512() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportResponse.File.sha512)
  return sha512_.GetNoArena();
}
inline void ExportResponse_File::set_sha512(const ::std::string& value) {
  
  sha512_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.ExportResponse.File.sha512)
}
#if LANG_CXX11
inline void ExportResponse_File::set_sha512(::std::string&& value) {
  
  sha512_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.ExportResponse.File.sha512)
}
#endif
inline void ExportResponse_File::set_sha512(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sha512_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.ExportResponse.File.sha512)
}
inline void ExportResponse_File::set_sha512(const void* value, size_t size) {
  
  sha512_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.ExportResponse.File.sha512)
}
inline ::std::string* ExportResponse_File::mutable_sha512() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ExportResponse.File.sha512)
  return sha512_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExportResponse_File::release_sha512() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ExportResponse.File.sha512)
  
  return sha512_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExportResponse_File::set_allocated_sha512(::std::string* sha512) {
  if (sha512 != NULL) {
    
  } else {
    
  }
  sha512_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sha512);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ExportResponse.File.sha512)
}

inline bool ExportResponse_File::has_exported() const {
  return this != internal_default_instance() && exported_ != NULL;
}
inline void ExportResponse_File::clear_exported() {
  if (GetArenaNoVirtual() == NULL && exported_ != NULL) {
    delete exported_;
  }
  exported_ = NULL;
}
inline const ::znbase::roachpb::BulkOpSummary& ExportResponse_File::_internal_exported() const {
  return *exported_;
}
inline const ::znbase::roachpb::BulkOpSummary& ExportResponse_File::exported() const {
  const ::znbase::roachpb::BulkOpSummary* p = exported_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportResponse.File.exported)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::BulkOpSummary*>(
      &::znbase::roachpb::_BulkOpSummary_default_instance_);
}
inline ::znbase::roachpb::BulkOpSummary* ExportResponse_File::release_exported() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ExportResponse.File.exported)
  
  ::znbase::roachpb::BulkOpSummary* temp = exported_;
  exported_ = NULL;
  return temp;
}
inline ::znbase::roachpb::BulkOpSummary* ExportResponse_File::mutable_exported() {
  
  if (exported_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::BulkOpSummary>(GetArenaNoVirtual());
    exported_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ExportResponse.File.exported)
  return exported_;
}
inline void ExportResponse_File::set_allocated_exported(::znbase::roachpb::BulkOpSummary* exported) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete exported_;
  }
  if (exported) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      exported = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, exported, submessage_arena);
    }
    
  } else {
    
  }
  exported_ = exported;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ExportResponse.File.exported)
}

inline void ExportResponse_File::clear_sst() {
  sst_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExportResponse_File::sst() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportResponse.File.sst)
  return sst_.GetNoArena();
}
inline void ExportResponse_File::set_sst(const ::std::string& value) {
  
  sst_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.ExportResponse.File.sst)
}
#if LANG_CXX11
inline void ExportResponse_File::set_sst(::std::string&& value) {
  
  sst_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.ExportResponse.File.sst)
}
#endif
inline void ExportResponse_File::set_sst(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sst_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.ExportResponse.File.sst)
}
inline void ExportResponse_File::set_sst(const void* value, size_t size) {
  
  sst_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.ExportResponse.File.sst)
}
inline ::std::string* ExportResponse_File::mutable_sst() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ExportResponse.File.sst)
  return sst_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExportResponse_File::release_sst() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ExportResponse.File.sst)
  
  return sst_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExportResponse_File::set_allocated_sst(::std::string* sst) {
  if (sst != NULL) {
    
  } else {
    
  }
  sst_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sst);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ExportResponse.File.sst)
}

// -------------------------------------------------------------------

// ExportResponse

inline bool ExportResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ExportResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& ExportResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& ExportResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* ExportResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ExportResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* ExportResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ExportResponse.header)
  return header_;
}
inline void ExportResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ExportResponse.header)
}

inline int ExportResponse::files_size() const {
  return files_.size();
}
inline void ExportResponse::clear_files() {
  files_.Clear();
}
inline ::znbase::roachpb::ExportResponse_File* ExportResponse::mutable_files(int index) {
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ExportResponse.files)
  return files_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::ExportResponse_File >*
ExportResponse::mutable_files() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.ExportResponse.files)
  return &files_;
}
inline const ::znbase::roachpb::ExportResponse_File& ExportResponse::files(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportResponse.files)
  return files_.Get(index);
}
inline ::znbase::roachpb::ExportResponse_File* ExportResponse::add_files() {
  // @@protoc_insertion_point(field_add:znbase.roachpb.ExportResponse.files)
  return files_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::ExportResponse_File >&
ExportResponse::files() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.ExportResponse.files)
  return files_;
}

inline bool ExportResponse::has_start_time() const {
  return this != internal_default_instance() && start_time_ != NULL;
}
inline const ::znbase::util::hlc::Timestamp& ExportResponse::_internal_start_time() const {
  return *start_time_;
}
inline const ::znbase::util::hlc::Timestamp& ExportResponse::start_time() const {
  const ::znbase::util::hlc::Timestamp* p = start_time_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.ExportResponse.start_time)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::util::hlc::Timestamp*>(
      &::znbase::util::hlc::_Timestamp_default_instance_);
}
inline ::znbase::util::hlc::Timestamp* ExportResponse::release_start_time() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ExportResponse.start_time)
  
  ::znbase::util::hlc::Timestamp* temp = start_time_;
  start_time_ = NULL;
  return temp;
}
inline ::znbase::util::hlc::Timestamp* ExportResponse::mutable_start_time() {
  
  if (start_time_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::util::hlc::Timestamp>(GetArenaNoVirtual());
    start_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ExportResponse.start_time)
  return start_time_;
}
inline void ExportResponse::set_allocated_start_time(::znbase::util::hlc::Timestamp* start_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(start_time_);
  }
  if (start_time) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      start_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, start_time, submessage_arena);
    }
    
  } else {
    
  }
  start_time_ = start_time;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ExportResponse.start_time)
}

// -------------------------------------------------------------------

// DumpResponse_File

inline bool DumpResponse_File::has_span() const {
  return this != internal_default_instance() && span_ != NULL;
}
inline const ::znbase::roachpb::Span& DumpResponse_File::_internal_span() const {
  return *span_;
}
inline const ::znbase::roachpb::Span& DumpResponse_File::span() const {
  const ::znbase::roachpb::Span* p = span_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpResponse.File.span)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::Span*>(
      &::znbase::roachpb::_Span_default_instance_);
}
inline ::znbase::roachpb::Span* DumpResponse_File::release_span() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpResponse.File.span)
  
  ::znbase::roachpb::Span* temp = span_;
  span_ = NULL;
  return temp;
}
inline ::znbase::roachpb::Span* DumpResponse_File::mutable_span() {
  
  if (span_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::Span>(GetArenaNoVirtual());
    span_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpResponse.File.span)
  return span_;
}
inline void DumpResponse_File::set_allocated_span(::znbase::roachpb::Span* span) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(span_);
  }
  if (span) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      span = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, span, submessage_arena);
    }
    
  } else {
    
  }
  span_ = span;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpResponse.File.span)
}

// string path = 2;
inline void DumpResponse_File::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DumpResponse_File::path() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpResponse.File.path)
  return path_.GetNoArena();
}
inline void DumpResponse_File::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpResponse.File.path)
}
#if LANG_CXX11
inline void DumpResponse_File::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.DumpResponse.File.path)
}
#endif
inline void DumpResponse_File::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.DumpResponse.File.path)
}
inline void DumpResponse_File::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.DumpResponse.File.path)
}
inline ::std::string* DumpResponse_File::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpResponse.File.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DumpResponse_File::release_path() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpResponse.File.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DumpResponse_File::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpResponse.File.path)
}

// bytes sha512 = 5;
inline void DumpResponse_File::clear_sha512() {
  sha512_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DumpResponse_File::sha512() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpResponse.File.sha512)
  return sha512_.GetNoArena();
}
inline void DumpResponse_File::set_sha512(const ::std::string& value) {
  
  sha512_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpResponse.File.sha512)
}
#if LANG_CXX11
inline void DumpResponse_File::set_sha512(::std::string&& value) {
  
  sha512_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.DumpResponse.File.sha512)
}
#endif
inline void DumpResponse_File::set_sha512(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sha512_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.DumpResponse.File.sha512)
}
inline void DumpResponse_File::set_sha512(const void* value, size_t size) {
  
  sha512_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.DumpResponse.File.sha512)
}
inline ::std::string* DumpResponse_File::mutable_sha512() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpResponse.File.sha512)
  return sha512_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DumpResponse_File::release_sha512() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpResponse.File.sha512)
  
  return sha512_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DumpResponse_File::set_allocated_sha512(::std::string* sha512) {
  if (sha512 != NULL) {
    
  } else {
    
  }
  sha512_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sha512);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpResponse.File.sha512)
}

inline bool DumpResponse_File::has_dumped() const {
  return this != internal_default_instance() && dumped_ != NULL;
}
inline void DumpResponse_File::clear_dumped() {
  if (GetArenaNoVirtual() == NULL && dumped_ != NULL) {
    delete dumped_;
  }
  dumped_ = NULL;
}
inline const ::znbase::roachpb::BulkOpSummary& DumpResponse_File::_internal_dumped() const {
  return *dumped_;
}
inline const ::znbase::roachpb::BulkOpSummary& DumpResponse_File::dumped() const {
  const ::znbase::roachpb::BulkOpSummary* p = dumped_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpResponse.File.dumped)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::BulkOpSummary*>(
      &::znbase::roachpb::_BulkOpSummary_default_instance_);
}
inline ::znbase::roachpb::BulkOpSummary* DumpResponse_File::release_dumped() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpResponse.File.dumped)
  
  ::znbase::roachpb::BulkOpSummary* temp = dumped_;
  dumped_ = NULL;
  return temp;
}
inline ::znbase::roachpb::BulkOpSummary* DumpResponse_File::mutable_dumped() {
  
  if (dumped_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::BulkOpSummary>(GetArenaNoVirtual());
    dumped_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpResponse.File.dumped)
  return dumped_;
}
inline void DumpResponse_File::set_allocated_dumped(::znbase::roachpb::BulkOpSummary* dumped) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete dumped_;
  }
  if (dumped) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      dumped = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dumped, submessage_arena);
    }
    
  } else {
    
  }
  dumped_ = dumped;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpResponse.File.dumped)
}

inline void DumpResponse_File::clear_sst() {
  sst_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DumpResponse_File::sst() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpResponse.File.sst)
  return sst_.GetNoArena();
}
inline void DumpResponse_File::set_sst(const ::std::string& value) {
  
  sst_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.DumpResponse.File.sst)
}
#if LANG_CXX11
inline void DumpResponse_File::set_sst(::std::string&& value) {
  
  sst_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.DumpResponse.File.sst)
}
#endif
inline void DumpResponse_File::set_sst(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sst_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.DumpResponse.File.sst)
}
inline void DumpResponse_File::set_sst(const void* value, size_t size) {
  
  sst_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.DumpResponse.File.sst)
}
inline ::std::string* DumpResponse_File::mutable_sst() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpResponse.File.sst)
  return sst_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DumpResponse_File::release_sst() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpResponse.File.sst)
  
  return sst_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DumpResponse_File::set_allocated_sst(::std::string* sst) {
  if (sst != NULL) {
    
  } else {
    
  }
  sst_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sst);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpResponse.File.sst)
}

// -------------------------------------------------------------------

// DumpResponse

inline bool DumpResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DumpResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& DumpResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& DumpResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* DumpResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* DumpResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpResponse.header)
  return header_;
}
inline void DumpResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpResponse.header)
}

inline int DumpResponse::files_size() const {
  return files_.size();
}
inline void DumpResponse::clear_files() {
  files_.Clear();
}
inline ::znbase::roachpb::DumpResponse_File* DumpResponse::mutable_files(int index) {
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpResponse.files)
  return files_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::DumpResponse_File >*
DumpResponse::mutable_files() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.DumpResponse.files)
  return &files_;
}
inline const ::znbase::roachpb::DumpResponse_File& DumpResponse::files(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpResponse.files)
  return files_.Get(index);
}
inline ::znbase::roachpb::DumpResponse_File* DumpResponse::add_files() {
  // @@protoc_insertion_point(field_add:znbase.roachpb.DumpResponse.files)
  return files_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::DumpResponse_File >&
DumpResponse::files() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.DumpResponse.files)
  return files_;
}

inline bool DumpResponse::has_start_time() const {
  return this != internal_default_instance() && start_time_ != NULL;
}
inline const ::znbase::util::hlc::Timestamp& DumpResponse::_internal_start_time() const {
  return *start_time_;
}
inline const ::znbase::util::hlc::Timestamp& DumpResponse::start_time() const {
  const ::znbase::util::hlc::Timestamp* p = start_time_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.DumpResponse.start_time)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::util::hlc::Timestamp*>(
      &::znbase::util::hlc::_Timestamp_default_instance_);
}
inline ::znbase::util::hlc::Timestamp* DumpResponse::release_start_time() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.DumpResponse.start_time)
  
  ::znbase::util::hlc::Timestamp* temp = start_time_;
  start_time_ = NULL;
  return temp;
}
inline ::znbase::util::hlc::Timestamp* DumpResponse::mutable_start_time() {
  
  if (start_time_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::util::hlc::Timestamp>(GetArenaNoVirtual());
    start_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.DumpResponse.start_time)
  return start_time_;
}
inline void DumpResponse::set_allocated_start_time(::znbase::util::hlc::Timestamp* start_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(start_time_);
  }
  if (start_time) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      start_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, start_time, submessage_arena);
    }
    
  } else {
    
  }
  start_time_ = start_time;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.DumpResponse.start_time)
}

// -------------------------------------------------------------------

// ImportRequest_File

inline bool ImportRequest_File::has_dir() const {
  return this != internal_default_instance() && dir_ != NULL;
}
inline void ImportRequest_File::clear_dir() {
  if (GetArenaNoVirtual() == NULL && dir_ != NULL) {
    delete dir_;
  }
  dir_ = NULL;
}
inline const ::znbase::roachpb::ExportStorage& ImportRequest_File::_internal_dir() const {
  return *dir_;
}
inline const ::znbase::roachpb::ExportStorage& ImportRequest_File::dir() const {
  const ::znbase::roachpb::ExportStorage* p = dir_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.ImportRequest.File.dir)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ExportStorage*>(
      &::znbase::roachpb::_ExportStorage_default_instance_);
}
inline ::znbase::roachpb::ExportStorage* ImportRequest_File::release_dir() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ImportRequest.File.dir)
  
  ::znbase::roachpb::ExportStorage* temp = dir_;
  dir_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ExportStorage* ImportRequest_File::mutable_dir() {
  
  if (dir_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ExportStorage>(GetArenaNoVirtual());
    dir_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ImportRequest.File.dir)
  return dir_;
}
inline void ImportRequest_File::set_allocated_dir(::znbase::roachpb::ExportStorage* dir) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete dir_;
  }
  if (dir) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      dir = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dir, submessage_arena);
    }
    
  } else {
    
  }
  dir_ = dir;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ImportRequest.File.dir)
}

// string path = 2;
inline void ImportRequest_File::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ImportRequest_File::path() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ImportRequest.File.path)
  return path_.GetNoArena();
}
inline void ImportRequest_File::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.ImportRequest.File.path)
}
#if LANG_CXX11
inline void ImportRequest_File::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.ImportRequest.File.path)
}
#endif
inline void ImportRequest_File::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.ImportRequest.File.path)
}
inline void ImportRequest_File::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.ImportRequest.File.path)
}
inline ::std::string* ImportRequest_File::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ImportRequest.File.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImportRequest_File::release_path() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ImportRequest.File.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImportRequest_File::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ImportRequest.File.path)
}

// bytes sha512 = 4;
inline void ImportRequest_File::clear_sha512() {
  sha512_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ImportRequest_File::sha512() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ImportRequest.File.sha512)
  return sha512_.GetNoArena();
}
inline void ImportRequest_File::set_sha512(const ::std::string& value) {
  
  sha512_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.ImportRequest.File.sha512)
}
#if LANG_CXX11
inline void ImportRequest_File::set_sha512(::std::string&& value) {
  
  sha512_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.ImportRequest.File.sha512)
}
#endif
inline void ImportRequest_File::set_sha512(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sha512_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.ImportRequest.File.sha512)
}
inline void ImportRequest_File::set_sha512(const void* value, size_t size) {
  
  sha512_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.ImportRequest.File.sha512)
}
inline ::std::string* ImportRequest_File::mutable_sha512() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ImportRequest.File.sha512)
  return sha512_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImportRequest_File::release_sha512() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ImportRequest.File.sha512)
  
  return sha512_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImportRequest_File::set_allocated_sha512(::std::string* sha512) {
  if (sha512 != NULL) {
    
  } else {
    
  }
  sha512_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sha512);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ImportRequest.File.sha512)
}

// -------------------------------------------------------------------

// ImportRequest_TableRekey

inline void ImportRequest_TableRekey::clear_old_id() {
  old_id_ = 0u;
}
inline ::google::protobuf::uint32 ImportRequest_TableRekey::old_id() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ImportRequest.TableRekey.old_id)
  return old_id_;
}
inline void ImportRequest_TableRekey::set_old_id(::google::protobuf::uint32 value) {
  
  old_id_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.ImportRequest.TableRekey.old_id)
}

// bytes new_desc = 2;
inline void ImportRequest_TableRekey::clear_new_desc() {
  new_desc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ImportRequest_TableRekey::new_desc() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ImportRequest.TableRekey.new_desc)
  return new_desc_.GetNoArena();
}
inline void ImportRequest_TableRekey::set_new_desc(const ::std::string& value) {
  
  new_desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.ImportRequest.TableRekey.new_desc)
}
#if LANG_CXX11
inline void ImportRequest_TableRekey::set_new_desc(::std::string&& value) {
  
  new_desc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.ImportRequest.TableRekey.new_desc)
}
#endif
inline void ImportRequest_TableRekey::set_new_desc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  new_desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.ImportRequest.TableRekey.new_desc)
}
inline void ImportRequest_TableRekey::set_new_desc(const void* value, size_t size) {
  
  new_desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.ImportRequest.TableRekey.new_desc)
}
inline ::std::string* ImportRequest_TableRekey::mutable_new_desc() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ImportRequest.TableRekey.new_desc)
  return new_desc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImportRequest_TableRekey::release_new_desc() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ImportRequest.TableRekey.new_desc)
  
  return new_desc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImportRequest_TableRekey::set_allocated_new_desc(::std::string* new_desc) {
  if (new_desc != NULL) {
    
  } else {
    
  }
  new_desc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), new_desc);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ImportRequest.TableRekey.new_desc)
}

// -------------------------------------------------------------------

// ImportRequest

inline bool ImportRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ImportRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& ImportRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& ImportRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.ImportRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* ImportRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ImportRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* ImportRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ImportRequest.header)
  return header_;
}
inline void ImportRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ImportRequest.header)
}

inline int ImportRequest::files_size() const {
  return files_.size();
}
inline void ImportRequest::clear_files() {
  files_.Clear();
}
inline ::znbase::roachpb::ImportRequest_File* ImportRequest::mutable_files(int index) {
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ImportRequest.files)
  return files_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::ImportRequest_File >*
ImportRequest::mutable_files() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.ImportRequest.files)
  return &files_;
}
inline const ::znbase::roachpb::ImportRequest_File& ImportRequest::files(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ImportRequest.files)
  return files_.Get(index);
}
inline ::znbase::roachpb::ImportRequest_File* ImportRequest::add_files() {
  // @@protoc_insertion_point(field_add:znbase.roachpb.ImportRequest.files)
  return files_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::ImportRequest_File >&
ImportRequest::files() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.ImportRequest.files)
  return files_;
}

inline bool ImportRequest::has_data_span() const {
  return this != internal_default_instance() && data_span_ != NULL;
}
inline const ::znbase::roachpb::Span& ImportRequest::_internal_data_span() const {
  return *data_span_;
}
inline const ::znbase::roachpb::Span& ImportRequest::data_span() const {
  const ::znbase::roachpb::Span* p = data_span_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.ImportRequest.data_span)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::Span*>(
      &::znbase::roachpb::_Span_default_instance_);
}
inline ::znbase::roachpb::Span* ImportRequest::release_data_span() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ImportRequest.data_span)
  
  ::znbase::roachpb::Span* temp = data_span_;
  data_span_ = NULL;
  return temp;
}
inline ::znbase::roachpb::Span* ImportRequest::mutable_data_span() {
  
  if (data_span_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::Span>(GetArenaNoVirtual());
    data_span_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ImportRequest.data_span)
  return data_span_;
}
inline void ImportRequest::set_allocated_data_span(::znbase::roachpb::Span* data_span) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(data_span_);
  }
  if (data_span) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      data_span = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, data_span, submessage_arena);
    }
    
  } else {
    
  }
  data_span_ = data_span;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ImportRequest.data_span)
}

inline bool ImportRequest::has_end_time() const {
  return this != internal_default_instance() && end_time_ != NULL;
}
inline const ::znbase::util::hlc::Timestamp& ImportRequest::_internal_end_time() const {
  return *end_time_;
}
inline const ::znbase::util::hlc::Timestamp& ImportRequest::end_time() const {
  const ::znbase::util::hlc::Timestamp* p = end_time_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.ImportRequest.end_time)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::util::hlc::Timestamp*>(
      &::znbase::util::hlc::_Timestamp_default_instance_);
}
inline ::znbase::util::hlc::Timestamp* ImportRequest::release_end_time() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ImportRequest.end_time)
  
  ::znbase::util::hlc::Timestamp* temp = end_time_;
  end_time_ = NULL;
  return temp;
}
inline ::znbase::util::hlc::Timestamp* ImportRequest::mutable_end_time() {
  
  if (end_time_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::util::hlc::Timestamp>(GetArenaNoVirtual());
    end_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ImportRequest.end_time)
  return end_time_;
}
inline void ImportRequest::set_allocated_end_time(::znbase::util::hlc::Timestamp* end_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(end_time_);
  }
  if (end_time) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      end_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, end_time, submessage_arena);
    }
    
  } else {
    
  }
  end_time_ = end_time;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ImportRequest.end_time)
}

inline int ImportRequest::rekeys_size() const {
  return rekeys_.size();
}
inline void ImportRequest::clear_rekeys() {
  rekeys_.Clear();
}
inline ::znbase::roachpb::ImportRequest_TableRekey* ImportRequest::mutable_rekeys(int index) {
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ImportRequest.rekeys)
  return rekeys_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::ImportRequest_TableRekey >*
ImportRequest::mutable_rekeys() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.ImportRequest.rekeys)
  return &rekeys_;
}
inline const ::znbase::roachpb::ImportRequest_TableRekey& ImportRequest::rekeys(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ImportRequest.rekeys)
  return rekeys_.Get(index);
}
inline ::znbase::roachpb::ImportRequest_TableRekey* ImportRequest::add_rekeys() {
  // @@protoc_insertion_point(field_add:znbase.roachpb.ImportRequest.rekeys)
  return rekeys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::ImportRequest_TableRekey >&
ImportRequest::rekeys() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.ImportRequest.rekeys)
  return rekeys_;
}

// .znbase.roachpb.FileEncryptionOptions encryption = 12;
inline bool ImportRequest::has_encryption() const {
  return this != internal_default_instance() && encryption_ != NULL;
}
inline void ImportRequest::clear_encryption() {
  if (GetArenaNoVirtual() == NULL && encryption_ != NULL) {
    delete encryption_;
  }
  encryption_ = NULL;
}
inline const ::znbase::roachpb::FileEncryptionOptions& ImportRequest::_internal_encryption() const {
  return *encryption_;
}
inline const ::znbase::roachpb::FileEncryptionOptions& ImportRequest::encryption() const {
  const ::znbase::roachpb::FileEncryptionOptions* p = encryption_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.ImportRequest.encryption)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::FileEncryptionOptions*>(
      &::znbase::roachpb::_FileEncryptionOptions_default_instance_);
}
inline ::znbase::roachpb::FileEncryptionOptions* ImportRequest::release_encryption() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ImportRequest.encryption)
  
  ::znbase::roachpb::FileEncryptionOptions* temp = encryption_;
  encryption_ = NULL;
  return temp;
}
inline ::znbase::roachpb::FileEncryptionOptions* ImportRequest::mutable_encryption() {
  
  if (encryption_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::FileEncryptionOptions>(GetArenaNoVirtual());
    encryption_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ImportRequest.encryption)
  return encryption_;
}
inline void ImportRequest::set_allocated_encryption(::znbase::roachpb::FileEncryptionOptions* encryption) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete encryption_;
  }
  if (encryption) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      encryption = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, encryption, submessage_arena);
    }
    
  } else {
    
  }
  encryption_ = encryption;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ImportRequest.encryption)
}

// -------------------------------------------------------------------

// ImportResponse

inline bool ImportResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ImportResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& ImportResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& ImportResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.ImportResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* ImportResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ImportResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* ImportResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ImportResponse.header)
  return header_;
}
inline void ImportResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ImportResponse.header)
}

inline bool ImportResponse::has_imported() const {
  return this != internal_default_instance() && imported_ != NULL;
}
inline void ImportResponse::clear_imported() {
  if (GetArenaNoVirtual() == NULL && imported_ != NULL) {
    delete imported_;
  }
  imported_ = NULL;
}
inline const ::znbase::roachpb::BulkOpSummary& ImportResponse::_internal_imported() const {
  return *imported_;
}
inline const ::znbase::roachpb::BulkOpSummary& ImportResponse::imported() const {
  const ::znbase::roachpb::BulkOpSummary* p = imported_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.ImportResponse.imported)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::BulkOpSummary*>(
      &::znbase::roachpb::_BulkOpSummary_default_instance_);
}
inline ::znbase::roachpb::BulkOpSummary* ImportResponse::release_imported() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ImportResponse.imported)
  
  ::znbase::roachpb::BulkOpSummary* temp = imported_;
  imported_ = NULL;
  return temp;
}
inline ::znbase::roachpb::BulkOpSummary* ImportResponse::mutable_imported() {
  
  if (imported_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::BulkOpSummary>(GetArenaNoVirtual());
    imported_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ImportResponse.imported)
  return imported_;
}
inline void ImportResponse::set_allocated_imported(::znbase::roachpb::BulkOpSummary* imported) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete imported_;
  }
  if (imported) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      imported = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, imported, submessage_arena);
    }
    
  } else {
    
  }
  imported_ = imported;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.ImportResponse.imported)
}

// -------------------------------------------------------------------

// LoadRequest_File

inline bool LoadRequest_File::has_dir() const {
  return this != internal_default_instance() && dir_ != NULL;
}
inline void LoadRequest_File::clear_dir() {
  if (GetArenaNoVirtual() == NULL && dir_ != NULL) {
    delete dir_;
  }
  dir_ = NULL;
}
inline const ::znbase::roachpb::DumpSink& LoadRequest_File::_internal_dir() const {
  return *dir_;
}
inline const ::znbase::roachpb::DumpSink& LoadRequest_File::dir() const {
  const ::znbase::roachpb::DumpSink* p = dir_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.LoadRequest.File.dir)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::DumpSink*>(
      &::znbase::roachpb::_DumpSink_default_instance_);
}
inline ::znbase::roachpb::DumpSink* LoadRequest_File::release_dir() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.LoadRequest.File.dir)
  
  ::znbase::roachpb::DumpSink* temp = dir_;
  dir_ = NULL;
  return temp;
}
inline ::znbase::roachpb::DumpSink* LoadRequest_File::mutable_dir() {
  
  if (dir_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::DumpSink>(GetArenaNoVirtual());
    dir_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.LoadRequest.File.dir)
  return dir_;
}
inline void LoadRequest_File::set_allocated_dir(::znbase::roachpb::DumpSink* dir) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete dir_;
  }
  if (dir) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      dir = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dir, submessage_arena);
    }
    
  } else {
    
  }
  dir_ = dir;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.LoadRequest.File.dir)
}

// string path = 2;
inline void LoadRequest_File::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoadRequest_File::path() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.LoadRequest.File.path)
  return path_.GetNoArena();
}
inline void LoadRequest_File::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.LoadRequest.File.path)
}
#if LANG_CXX11
inline void LoadRequest_File::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.LoadRequest.File.path)
}
#endif
inline void LoadRequest_File::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.LoadRequest.File.path)
}
inline void LoadRequest_File::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.LoadRequest.File.path)
}
inline ::std::string* LoadRequest_File::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.LoadRequest.File.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoadRequest_File::release_path() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.LoadRequest.File.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoadRequest_File::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.LoadRequest.File.path)
}

// bytes sha512 = 4;
inline void LoadRequest_File::clear_sha512() {
  sha512_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoadRequest_File::sha512() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.LoadRequest.File.sha512)
  return sha512_.GetNoArena();
}
inline void LoadRequest_File::set_sha512(const ::std::string& value) {
  
  sha512_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.LoadRequest.File.sha512)
}
#if LANG_CXX11
inline void LoadRequest_File::set_sha512(::std::string&& value) {
  
  sha512_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.LoadRequest.File.sha512)
}
#endif
inline void LoadRequest_File::set_sha512(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sha512_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.LoadRequest.File.sha512)
}
inline void LoadRequest_File::set_sha512(const void* value, size_t size) {
  
  sha512_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.LoadRequest.File.sha512)
}
inline ::std::string* LoadRequest_File::mutable_sha512() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.LoadRequest.File.sha512)
  return sha512_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoadRequest_File::release_sha512() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.LoadRequest.File.sha512)
  
  return sha512_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoadRequest_File::set_allocated_sha512(::std::string* sha512) {
  if (sha512 != NULL) {
    
  } else {
    
  }
  sha512_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sha512);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.LoadRequest.File.sha512)
}

// -------------------------------------------------------------------

// LoadRequest_TableRekey

inline void LoadRequest_TableRekey::clear_old_id() {
  old_id_ = 0u;
}
inline ::google::protobuf::uint32 LoadRequest_TableRekey::old_id() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.LoadRequest.TableRekey.old_id)
  return old_id_;
}
inline void LoadRequest_TableRekey::set_old_id(::google::protobuf::uint32 value) {
  
  old_id_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.LoadRequest.TableRekey.old_id)
}

// bytes new_desc = 2;
inline void LoadRequest_TableRekey::clear_new_desc() {
  new_desc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoadRequest_TableRekey::new_desc() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.LoadRequest.TableRekey.new_desc)
  return new_desc_.GetNoArena();
}
inline void LoadRequest_TableRekey::set_new_desc(const ::std::string& value) {
  
  new_desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.LoadRequest.TableRekey.new_desc)
}
#if LANG_CXX11
inline void LoadRequest_TableRekey::set_new_desc(::std::string&& value) {
  
  new_desc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.LoadRequest.TableRekey.new_desc)
}
#endif
inline void LoadRequest_TableRekey::set_new_desc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  new_desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.LoadRequest.TableRekey.new_desc)
}
inline void LoadRequest_TableRekey::set_new_desc(const void* value, size_t size) {
  
  new_desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.LoadRequest.TableRekey.new_desc)
}
inline ::std::string* LoadRequest_TableRekey::mutable_new_desc() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.LoadRequest.TableRekey.new_desc)
  return new_desc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoadRequest_TableRekey::release_new_desc() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.LoadRequest.TableRekey.new_desc)
  
  return new_desc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoadRequest_TableRekey::set_allocated_new_desc(::std::string* new_desc) {
  if (new_desc != NULL) {
    
  } else {
    
  }
  new_desc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), new_desc);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.LoadRequest.TableRekey.new_desc)
}

// -------------------------------------------------------------------

// LoadRequest

inline bool LoadRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void LoadRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& LoadRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& LoadRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.LoadRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* LoadRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.LoadRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* LoadRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.LoadRequest.header)
  return header_;
}
inline void LoadRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.LoadRequest.header)
}

inline int LoadRequest::files_size() const {
  return files_.size();
}
inline void LoadRequest::clear_files() {
  files_.Clear();
}
inline ::znbase::roachpb::LoadRequest_File* LoadRequest::mutable_files(int index) {
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.LoadRequest.files)
  return files_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::LoadRequest_File >*
LoadRequest::mutable_files() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.LoadRequest.files)
  return &files_;
}
inline const ::znbase::roachpb::LoadRequest_File& LoadRequest::files(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.LoadRequest.files)
  return files_.Get(index);
}
inline ::znbase::roachpb::LoadRequest_File* LoadRequest::add_files() {
  // @@protoc_insertion_point(field_add:znbase.roachpb.LoadRequest.files)
  return files_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::LoadRequest_File >&
LoadRequest::files() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.LoadRequest.files)
  return files_;
}

inline bool LoadRequest::has_data_span() const {
  return this != internal_default_instance() && data_span_ != NULL;
}
inline const ::znbase::roachpb::Span& LoadRequest::_internal_data_span() const {
  return *data_span_;
}
inline const ::znbase::roachpb::Span& LoadRequest::data_span() const {
  const ::znbase::roachpb::Span* p = data_span_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.LoadRequest.data_span)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::Span*>(
      &::znbase::roachpb::_Span_default_instance_);
}
inline ::znbase::roachpb::Span* LoadRequest::release_data_span() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.LoadRequest.data_span)
  
  ::znbase::roachpb::Span* temp = data_span_;
  data_span_ = NULL;
  return temp;
}
inline ::znbase::roachpb::Span* LoadRequest::mutable_data_span() {
  
  if (data_span_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::Span>(GetArenaNoVirtual());
    data_span_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.LoadRequest.data_span)
  return data_span_;
}
inline void LoadRequest::set_allocated_data_span(::znbase::roachpb::Span* data_span) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(data_span_);
  }
  if (data_span) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      data_span = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, data_span, submessage_arena);
    }
    
  } else {
    
  }
  data_span_ = data_span;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.LoadRequest.data_span)
}

inline bool LoadRequest::has_end_time() const {
  return this != internal_default_instance() && end_time_ != NULL;
}
inline const ::znbase::util::hlc::Timestamp& LoadRequest::_internal_end_time() const {
  return *end_time_;
}
inline const ::znbase::util::hlc::Timestamp& LoadRequest::end_time() const {
  const ::znbase::util::hlc::Timestamp* p = end_time_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.LoadRequest.end_time)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::util::hlc::Timestamp*>(
      &::znbase::util::hlc::_Timestamp_default_instance_);
}
inline ::znbase::util::hlc::Timestamp* LoadRequest::release_end_time() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.LoadRequest.end_time)
  
  ::znbase::util::hlc::Timestamp* temp = end_time_;
  end_time_ = NULL;
  return temp;
}
inline ::znbase::util::hlc::Timestamp* LoadRequest::mutable_end_time() {
  
  if (end_time_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::util::hlc::Timestamp>(GetArenaNoVirtual());
    end_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.LoadRequest.end_time)
  return end_time_;
}
inline void LoadRequest::set_allocated_end_time(::znbase::util::hlc::Timestamp* end_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(end_time_);
  }
  if (end_time) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      end_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, end_time, submessage_arena);
    }
    
  } else {
    
  }
  end_time_ = end_time;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.LoadRequest.end_time)
}

inline int LoadRequest::rekeys_size() const {
  return rekeys_.size();
}
inline void LoadRequest::clear_rekeys() {
  rekeys_.Clear();
}
inline ::znbase::roachpb::LoadRequest_TableRekey* LoadRequest::mutable_rekeys(int index) {
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.LoadRequest.rekeys)
  return rekeys_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::LoadRequest_TableRekey >*
LoadRequest::mutable_rekeys() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.LoadRequest.rekeys)
  return &rekeys_;
}
inline const ::znbase::roachpb::LoadRequest_TableRekey& LoadRequest::rekeys(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.LoadRequest.rekeys)
  return rekeys_.Get(index);
}
inline ::znbase::roachpb::LoadRequest_TableRekey* LoadRequest::add_rekeys() {
  // @@protoc_insertion_point(field_add:znbase.roachpb.LoadRequest.rekeys)
  return rekeys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::LoadRequest_TableRekey >&
LoadRequest::rekeys() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.LoadRequest.rekeys)
  return rekeys_;
}

// .znbase.roachpb.FileEncryptionOptions encryption = 12;
inline bool LoadRequest::has_encryption() const {
  return this != internal_default_instance() && encryption_ != NULL;
}
inline void LoadRequest::clear_encryption() {
  if (GetArenaNoVirtual() == NULL && encryption_ != NULL) {
    delete encryption_;
  }
  encryption_ = NULL;
}
inline const ::znbase::roachpb::FileEncryptionOptions& LoadRequest::_internal_encryption() const {
  return *encryption_;
}
inline const ::znbase::roachpb::FileEncryptionOptions& LoadRequest::encryption() const {
  const ::znbase::roachpb::FileEncryptionOptions* p = encryption_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.LoadRequest.encryption)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::FileEncryptionOptions*>(
      &::znbase::roachpb::_FileEncryptionOptions_default_instance_);
}
inline ::znbase::roachpb::FileEncryptionOptions* LoadRequest::release_encryption() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.LoadRequest.encryption)
  
  ::znbase::roachpb::FileEncryptionOptions* temp = encryption_;
  encryption_ = NULL;
  return temp;
}
inline ::znbase::roachpb::FileEncryptionOptions* LoadRequest::mutable_encryption() {
  
  if (encryption_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::FileEncryptionOptions>(GetArenaNoVirtual());
    encryption_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.LoadRequest.encryption)
  return encryption_;
}
inline void LoadRequest::set_allocated_encryption(::znbase::roachpb::FileEncryptionOptions* encryption) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete encryption_;
  }
  if (encryption) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      encryption = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, encryption, submessage_arena);
    }
    
  } else {
    
  }
  encryption_ = encryption;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.LoadRequest.encryption)
}

// string http_header = 13;
inline void LoadRequest::clear_http_header() {
  http_header_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoadRequest::http_header() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.LoadRequest.http_header)
  return http_header_.GetNoArena();
}
inline void LoadRequest::set_http_header(const ::std::string& value) {
  
  http_header_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.LoadRequest.http_header)
}
#if LANG_CXX11
inline void LoadRequest::set_http_header(::std::string&& value) {
  
  http_header_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.LoadRequest.http_header)
}
#endif
inline void LoadRequest::set_http_header(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  http_header_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.LoadRequest.http_header)
}
inline void LoadRequest::set_http_header(const char* value, size_t size) {
  
  http_header_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.LoadRequest.http_header)
}
inline ::std::string* LoadRequest::mutable_http_header() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.LoadRequest.http_header)
  return http_header_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoadRequest::release_http_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.LoadRequest.http_header)
  
  return http_header_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoadRequest::set_allocated_http_header(::std::string* http_header) {
  if (http_header != NULL) {
    
  } else {
    
  }
  http_header_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), http_header);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.LoadRequest.http_header)
}

// -------------------------------------------------------------------

// LoadResponse

inline bool LoadResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void LoadResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& LoadResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& LoadResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.LoadResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* LoadResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.LoadResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* LoadResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.LoadResponse.header)
  return header_;
}
inline void LoadResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.LoadResponse.header)
}

inline bool LoadResponse::has_loaded() const {
  return this != internal_default_instance() && loaded_ != NULL;
}
inline void LoadResponse::clear_loaded() {
  if (GetArenaNoVirtual() == NULL && loaded_ != NULL) {
    delete loaded_;
  }
  loaded_ = NULL;
}
inline const ::znbase::roachpb::BulkOpSummary& LoadResponse::_internal_loaded() const {
  return *loaded_;
}
inline const ::znbase::roachpb::BulkOpSummary& LoadResponse::loaded() const {
  const ::znbase::roachpb::BulkOpSummary* p = loaded_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.LoadResponse.loaded)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::BulkOpSummary*>(
      &::znbase::roachpb::_BulkOpSummary_default_instance_);
}
inline ::znbase::roachpb::BulkOpSummary* LoadResponse::release_loaded() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.LoadResponse.loaded)
  
  ::znbase::roachpb::BulkOpSummary* temp = loaded_;
  loaded_ = NULL;
  return temp;
}
inline ::znbase::roachpb::BulkOpSummary* LoadResponse::mutable_loaded() {
  
  if (loaded_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::BulkOpSummary>(GetArenaNoVirtual());
    loaded_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.LoadResponse.loaded)
  return loaded_;
}
inline void LoadResponse::set_allocated_loaded(::znbase::roachpb::BulkOpSummary* loaded) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete loaded_;
  }
  if (loaded) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      loaded = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, loaded, submessage_arena);
    }
    
  } else {
    
  }
  loaded_ = loaded;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.LoadResponse.loaded)
}

// -------------------------------------------------------------------

// AdminScatterRequest

inline bool AdminScatterRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void AdminScatterRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& AdminScatterRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& AdminScatterRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.AdminScatterRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* AdminScatterRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.AdminScatterRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* AdminScatterRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.AdminScatterRequest.header)
  return header_;
}
inline void AdminScatterRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.AdminScatterRequest.header)
}

// bool randomize_leases = 2;
inline void AdminScatterRequest::clear_randomize_leases() {
  randomize_leases_ = false;
}
inline bool AdminScatterRequest::randomize_leases() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.AdminScatterRequest.randomize_leases)
  return randomize_leases_;
}
inline void AdminScatterRequest::set_randomize_leases(bool value) {
  
  randomize_leases_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.AdminScatterRequest.randomize_leases)
}

// -------------------------------------------------------------------

// AdminScatterResponse_Range

inline bool AdminScatterResponse_Range::has_span() const {
  return this != internal_default_instance() && span_ != NULL;
}
inline const ::znbase::roachpb::Span& AdminScatterResponse_Range::_internal_span() const {
  return *span_;
}
inline const ::znbase::roachpb::Span& AdminScatterResponse_Range::span() const {
  const ::znbase::roachpb::Span* p = span_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.AdminScatterResponse.Range.span)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::Span*>(
      &::znbase::roachpb::_Span_default_instance_);
}
inline ::znbase::roachpb::Span* AdminScatterResponse_Range::release_span() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.AdminScatterResponse.Range.span)
  
  ::znbase::roachpb::Span* temp = span_;
  span_ = NULL;
  return temp;
}
inline ::znbase::roachpb::Span* AdminScatterResponse_Range::mutable_span() {
  
  if (span_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::Span>(GetArenaNoVirtual());
    span_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.AdminScatterResponse.Range.span)
  return span_;
}
inline void AdminScatterResponse_Range::set_allocated_span(::znbase::roachpb::Span* span) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(span_);
  }
  if (span) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      span = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, span, submessage_arena);
    }
    
  } else {
    
  }
  span_ = span;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.AdminScatterResponse.Range.span)
}

// -------------------------------------------------------------------

// AdminScatterResponse

inline bool AdminScatterResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void AdminScatterResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& AdminScatterResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& AdminScatterResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.AdminScatterResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* AdminScatterResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.AdminScatterResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* AdminScatterResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.AdminScatterResponse.header)
  return header_;
}
inline void AdminScatterResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.AdminScatterResponse.header)
}

inline int AdminScatterResponse::ranges_size() const {
  return ranges_.size();
}
inline void AdminScatterResponse::clear_ranges() {
  ranges_.Clear();
}
inline ::znbase::roachpb::AdminScatterResponse_Range* AdminScatterResponse::mutable_ranges(int index) {
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.AdminScatterResponse.ranges)
  return ranges_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::AdminScatterResponse_Range >*
AdminScatterResponse::mutable_ranges() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.AdminScatterResponse.ranges)
  return &ranges_;
}
inline const ::znbase::roachpb::AdminScatterResponse_Range& AdminScatterResponse::ranges(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.AdminScatterResponse.ranges)
  return ranges_.Get(index);
}
inline ::znbase::roachpb::AdminScatterResponse_Range* AdminScatterResponse::add_ranges() {
  // @@protoc_insertion_point(field_add:znbase.roachpb.AdminScatterResponse.ranges)
  return ranges_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::AdminScatterResponse_Range >&
AdminScatterResponse::ranges() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.AdminScatterResponse.ranges)
  return ranges_;
}

// -------------------------------------------------------------------

// AddSSTableRequest

inline bool AddSSTableRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void AddSSTableRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& AddSSTableRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& AddSSTableRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.AddSSTableRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* AddSSTableRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.AddSSTableRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* AddSSTableRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.AddSSTableRequest.header)
  return header_;
}
inline void AddSSTableRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.AddSSTableRequest.header)
}

// bytes data = 2;
inline void AddSSTableRequest::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AddSSTableRequest::data() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.AddSSTableRequest.data)
  return data_.GetNoArena();
}
inline void AddSSTableRequest::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.AddSSTableRequest.data)
}
#if LANG_CXX11
inline void AddSSTableRequest::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.AddSSTableRequest.data)
}
#endif
inline void AddSSTableRequest::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.AddSSTableRequest.data)
}
inline void AddSSTableRequest::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.AddSSTableRequest.data)
}
inline ::std::string* AddSSTableRequest::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.AddSSTableRequest.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AddSSTableRequest::release_data() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.AddSSTableRequest.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AddSSTableRequest::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.AddSSTableRequest.data)
}

// bool disallow_shadowing = 3;
inline void AddSSTableRequest::clear_disallow_shadowing() {
  disallow_shadowing_ = false;
}
inline bool AddSSTableRequest::disallow_shadowing() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.AddSSTableRequest.disallow_shadowing)
  return disallow_shadowing_;
}
inline void AddSSTableRequest::set_disallow_shadowing(bool value) {
  
  disallow_shadowing_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.AddSSTableRequest.disallow_shadowing)
}

inline bool AddSSTableRequest::has_mvcc_stats() const {
  return this != internal_default_instance() && mvcc_stats_ != NULL;
}
inline const ::znbase::storage::engine::enginepb::MVCCStats& AddSSTableRequest::_internal_mvcc_stats() const {
  return *mvcc_stats_;
}
inline const ::znbase::storage::engine::enginepb::MVCCStats& AddSSTableRequest::mvcc_stats() const {
  const ::znbase::storage::engine::enginepb::MVCCStats* p = mvcc_stats_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.AddSSTableRequest.mvcc_stats)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::storage::engine::enginepb::MVCCStats*>(
      &::znbase::storage::engine::enginepb::_MVCCStats_default_instance_);
}
inline ::znbase::storage::engine::enginepb::MVCCStats* AddSSTableRequest::release_mvcc_stats() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.AddSSTableRequest.mvcc_stats)
  
  ::znbase::storage::engine::enginepb::MVCCStats* temp = mvcc_stats_;
  mvcc_stats_ = NULL;
  return temp;
}
inline ::znbase::storage::engine::enginepb::MVCCStats* AddSSTableRequest::mutable_mvcc_stats() {
  
  if (mvcc_stats_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::storage::engine::enginepb::MVCCStats>(GetArenaNoVirtual());
    mvcc_stats_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.AddSSTableRequest.mvcc_stats)
  return mvcc_stats_;
}
inline void AddSSTableRequest::set_allocated_mvcc_stats(::znbase::storage::engine::enginepb::MVCCStats* mvcc_stats) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(mvcc_stats_);
  }
  if (mvcc_stats) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      mvcc_stats = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, mvcc_stats, submessage_arena);
    }
    
  } else {
    
  }
  mvcc_stats_ = mvcc_stats;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.AddSSTableRequest.mvcc_stats)
}

// bool ingest_as_writes = 5;
inline void AddSSTableRequest::clear_ingest_as_writes() {
  ingest_as_writes_ = false;
}
inline bool AddSSTableRequest::ingest_as_writes() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.AddSSTableRequest.ingest_as_writes)
  return ingest_as_writes_;
}
inline void AddSSTableRequest::set_ingest_as_writes(bool value) {
  
  ingest_as_writes_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.AddSSTableRequest.ingest_as_writes)
}

// -------------------------------------------------------------------

// AddSSTableResponse

inline bool AddSSTableResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void AddSSTableResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& AddSSTableResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& AddSSTableResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.AddSSTableResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* AddSSTableResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.AddSSTableResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* AddSSTableResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.AddSSTableResponse.header)
  return header_;
}
inline void AddSSTableResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.AddSSTableResponse.header)
}

// -------------------------------------------------------------------

// RefreshRequest

inline bool RefreshRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void RefreshRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& RefreshRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& RefreshRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.RefreshRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* RefreshRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RefreshRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* RefreshRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RefreshRequest.header)
  return header_;
}
inline void RefreshRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.RefreshRequest.header)
}

inline bool RefreshRequest::has_refresh_from() const {
  return this != internal_default_instance() && refresh_from_ != NULL;
}
inline const ::znbase::util::hlc::Timestamp& RefreshRequest::_internal_refresh_from() const {
  return *refresh_from_;
}
inline const ::znbase::util::hlc::Timestamp& RefreshRequest::refresh_from() const {
  const ::znbase::util::hlc::Timestamp* p = refresh_from_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.RefreshRequest.refresh_from)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::util::hlc::Timestamp*>(
      &::znbase::util::hlc::_Timestamp_default_instance_);
}
inline ::znbase::util::hlc::Timestamp* RefreshRequest::release_refresh_from() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RefreshRequest.refresh_from)
  
  ::znbase::util::hlc::Timestamp* temp = refresh_from_;
  refresh_from_ = NULL;
  return temp;
}
inline ::znbase::util::hlc::Timestamp* RefreshRequest::mutable_refresh_from() {
  
  if (refresh_from_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::util::hlc::Timestamp>(GetArenaNoVirtual());
    refresh_from_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RefreshRequest.refresh_from)
  return refresh_from_;
}
inline void RefreshRequest::set_allocated_refresh_from(::znbase::util::hlc::Timestamp* refresh_from) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(refresh_from_);
  }
  if (refresh_from) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      refresh_from = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, refresh_from, submessage_arena);
    }
    
  } else {
    
  }
  refresh_from_ = refresh_from;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.RefreshRequest.refresh_from)
}

// -------------------------------------------------------------------

// RefreshResponse

inline bool RefreshResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void RefreshResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& RefreshResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& RefreshResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.RefreshResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* RefreshResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RefreshResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* RefreshResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RefreshResponse.header)
  return header_;
}
inline void RefreshResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.RefreshResponse.header)
}

// -------------------------------------------------------------------

// RefreshRangeRequest

inline bool RefreshRangeRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void RefreshRangeRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& RefreshRangeRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& RefreshRangeRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.RefreshRangeRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* RefreshRangeRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RefreshRangeRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* RefreshRangeRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RefreshRangeRequest.header)
  return header_;
}
inline void RefreshRangeRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.RefreshRangeRequest.header)
}

inline bool RefreshRangeRequest::has_refresh_from() const {
  return this != internal_default_instance() && refresh_from_ != NULL;
}
inline const ::znbase::util::hlc::Timestamp& RefreshRangeRequest::_internal_refresh_from() const {
  return *refresh_from_;
}
inline const ::znbase::util::hlc::Timestamp& RefreshRangeRequest::refresh_from() const {
  const ::znbase::util::hlc::Timestamp* p = refresh_from_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.RefreshRangeRequest.refresh_from)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::util::hlc::Timestamp*>(
      &::znbase::util::hlc::_Timestamp_default_instance_);
}
inline ::znbase::util::hlc::Timestamp* RefreshRangeRequest::release_refresh_from() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RefreshRangeRequest.refresh_from)
  
  ::znbase::util::hlc::Timestamp* temp = refresh_from_;
  refresh_from_ = NULL;
  return temp;
}
inline ::znbase::util::hlc::Timestamp* RefreshRangeRequest::mutable_refresh_from() {
  
  if (refresh_from_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::util::hlc::Timestamp>(GetArenaNoVirtual());
    refresh_from_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RefreshRangeRequest.refresh_from)
  return refresh_from_;
}
inline void RefreshRangeRequest::set_allocated_refresh_from(::znbase::util::hlc::Timestamp* refresh_from) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(refresh_from_);
  }
  if (refresh_from) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      refresh_from = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, refresh_from, submessage_arena);
    }
    
  } else {
    
  }
  refresh_from_ = refresh_from;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.RefreshRangeRequest.refresh_from)
}

// -------------------------------------------------------------------

// RefreshRangeResponse

inline bool RefreshRangeResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void RefreshRangeResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& RefreshRangeResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& RefreshRangeResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.RefreshRangeResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* RefreshRangeResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RefreshRangeResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* RefreshRangeResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RefreshRangeResponse.header)
  return header_;
}
inline void RefreshRangeResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.RefreshRangeResponse.header)
}

// -------------------------------------------------------------------

// SubsumeRequest

inline bool SubsumeRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void SubsumeRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& SubsumeRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& SubsumeRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.SubsumeRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* SubsumeRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.SubsumeRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* SubsumeRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.SubsumeRequest.header)
  return header_;
}
inline void SubsumeRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.SubsumeRequest.header)
}

inline bool SubsumeRequest::has_left_range() const {
  return this != internal_default_instance() && left_range_ != NULL;
}
inline const ::znbase::roachpb::RangeDescriptor& SubsumeRequest::_internal_left_range() const {
  return *left_range_;
}
inline const ::znbase::roachpb::RangeDescriptor& SubsumeRequest::left_range() const {
  const ::znbase::roachpb::RangeDescriptor* p = left_range_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.SubsumeRequest.left_range)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RangeDescriptor*>(
      &::znbase::roachpb::_RangeDescriptor_default_instance_);
}
inline ::znbase::roachpb::RangeDescriptor* SubsumeRequest::release_left_range() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.SubsumeRequest.left_range)
  
  ::znbase::roachpb::RangeDescriptor* temp = left_range_;
  left_range_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RangeDescriptor* SubsumeRequest::mutable_left_range() {
  
  if (left_range_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RangeDescriptor>(GetArenaNoVirtual());
    left_range_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.SubsumeRequest.left_range)
  return left_range_;
}
inline void SubsumeRequest::set_allocated_left_range(::znbase::roachpb::RangeDescriptor* left_range) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(left_range_);
  }
  if (left_range) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      left_range = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, left_range, submessage_arena);
    }
    
  } else {
    
  }
  left_range_ = left_range;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.SubsumeRequest.left_range)
}

// -------------------------------------------------------------------

// SubsumeResponse

inline bool SubsumeResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void SubsumeResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& SubsumeResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& SubsumeResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.SubsumeResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* SubsumeResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.SubsumeResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* SubsumeResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.SubsumeResponse.header)
  return header_;
}
inline void SubsumeResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.SubsumeResponse.header)
}

inline bool SubsumeResponse::has_mvcc_stats() const {
  return this != internal_default_instance() && mvcc_stats_ != NULL;
}
inline const ::znbase::storage::engine::enginepb::MVCCStats& SubsumeResponse::_internal_mvcc_stats() const {
  return *mvcc_stats_;
}
inline const ::znbase::storage::engine::enginepb::MVCCStats& SubsumeResponse::mvcc_stats() const {
  const ::znbase::storage::engine::enginepb::MVCCStats* p = mvcc_stats_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.SubsumeResponse.mvcc_stats)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::storage::engine::enginepb::MVCCStats*>(
      &::znbase::storage::engine::enginepb::_MVCCStats_default_instance_);
}
inline ::znbase::storage::engine::enginepb::MVCCStats* SubsumeResponse::release_mvcc_stats() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.SubsumeResponse.mvcc_stats)
  
  ::znbase::storage::engine::enginepb::MVCCStats* temp = mvcc_stats_;
  mvcc_stats_ = NULL;
  return temp;
}
inline ::znbase::storage::engine::enginepb::MVCCStats* SubsumeResponse::mutable_mvcc_stats() {
  
  if (mvcc_stats_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::storage::engine::enginepb::MVCCStats>(GetArenaNoVirtual());
    mvcc_stats_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.SubsumeResponse.mvcc_stats)
  return mvcc_stats_;
}
inline void SubsumeResponse::set_allocated_mvcc_stats(::znbase::storage::engine::enginepb::MVCCStats* mvcc_stats) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(mvcc_stats_);
  }
  if (mvcc_stats) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      mvcc_stats = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, mvcc_stats, submessage_arena);
    }
    
  } else {
    
  }
  mvcc_stats_ = mvcc_stats;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.SubsumeResponse.mvcc_stats)
}

// uint64 lease_applied_index = 4;
inline void SubsumeResponse::clear_lease_applied_index() {
  lease_applied_index_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 SubsumeResponse::lease_applied_index() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.SubsumeResponse.lease_applied_index)
  return lease_applied_index_;
}
inline void SubsumeResponse::set_lease_applied_index(::google::protobuf::uint64 value) {
  
  lease_applied_index_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.SubsumeResponse.lease_applied_index)
}

inline bool SubsumeResponse::has_freeze_start() const {
  return this != internal_default_instance() && freeze_start_ != NULL;
}
inline const ::znbase::util::hlc::Timestamp& SubsumeResponse::_internal_freeze_start() const {
  return *freeze_start_;
}
inline const ::znbase::util::hlc::Timestamp& SubsumeResponse::freeze_start() const {
  const ::znbase::util::hlc::Timestamp* p = freeze_start_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.SubsumeResponse.freeze_start)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::util::hlc::Timestamp*>(
      &::znbase::util::hlc::_Timestamp_default_instance_);
}
inline ::znbase::util::hlc::Timestamp* SubsumeResponse::release_freeze_start() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.SubsumeResponse.freeze_start)
  
  ::znbase::util::hlc::Timestamp* temp = freeze_start_;
  freeze_start_ = NULL;
  return temp;
}
inline ::znbase::util::hlc::Timestamp* SubsumeResponse::mutable_freeze_start() {
  
  if (freeze_start_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::util::hlc::Timestamp>(GetArenaNoVirtual());
    freeze_start_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.SubsumeResponse.freeze_start)
  return freeze_start_;
}
inline void SubsumeResponse::set_allocated_freeze_start(::znbase::util::hlc::Timestamp* freeze_start) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(freeze_start_);
  }
  if (freeze_start) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      freeze_start = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, freeze_start, submessage_arena);
    }
    
  } else {
    
  }
  freeze_start_ = freeze_start;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.SubsumeResponse.freeze_start)
}

// -------------------------------------------------------------------

// RangeStatsRequest

inline bool RangeStatsRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void RangeStatsRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& RangeStatsRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& RangeStatsRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.RangeStatsRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* RangeStatsRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RangeStatsRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* RangeStatsRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RangeStatsRequest.header)
  return header_;
}
inline void RangeStatsRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.RangeStatsRequest.header)
}

// -------------------------------------------------------------------

// RangeStatsResponse

inline bool RangeStatsResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void RangeStatsResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& RangeStatsResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& RangeStatsResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.RangeStatsResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* RangeStatsResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RangeStatsResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* RangeStatsResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RangeStatsResponse.header)
  return header_;
}
inline void RangeStatsResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.RangeStatsResponse.header)
}

inline bool RangeStatsResponse::has_mvcc_stats() const {
  return this != internal_default_instance() && mvcc_stats_ != NULL;
}
inline const ::znbase::storage::engine::enginepb::MVCCStats& RangeStatsResponse::_internal_mvcc_stats() const {
  return *mvcc_stats_;
}
inline const ::znbase::storage::engine::enginepb::MVCCStats& RangeStatsResponse::mvcc_stats() const {
  const ::znbase::storage::engine::enginepb::MVCCStats* p = mvcc_stats_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.RangeStatsResponse.mvcc_stats)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::storage::engine::enginepb::MVCCStats*>(
      &::znbase::storage::engine::enginepb::_MVCCStats_default_instance_);
}
inline ::znbase::storage::engine::enginepb::MVCCStats* RangeStatsResponse::release_mvcc_stats() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RangeStatsResponse.mvcc_stats)
  
  ::znbase::storage::engine::enginepb::MVCCStats* temp = mvcc_stats_;
  mvcc_stats_ = NULL;
  return temp;
}
inline ::znbase::storage::engine::enginepb::MVCCStats* RangeStatsResponse::mutable_mvcc_stats() {
  
  if (mvcc_stats_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::storage::engine::enginepb::MVCCStats>(GetArenaNoVirtual());
    mvcc_stats_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RangeStatsResponse.mvcc_stats)
  return mvcc_stats_;
}
inline void RangeStatsResponse::set_allocated_mvcc_stats(::znbase::storage::engine::enginepb::MVCCStats* mvcc_stats) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(mvcc_stats_);
  }
  if (mvcc_stats) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      mvcc_stats = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, mvcc_stats, submessage_arena);
    }
    
  } else {
    
  }
  mvcc_stats_ = mvcc_stats;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.RangeStatsResponse.mvcc_stats)
}

// double queries_per_second = 3;
inline void RangeStatsResponse::clear_queries_per_second() {
  queries_per_second_ = 0;
}
inline double RangeStatsResponse::queries_per_second() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RangeStatsResponse.queries_per_second)
  return queries_per_second_;
}
inline void RangeStatsResponse::set_queries_per_second(double value) {
  
  queries_per_second_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.RangeStatsResponse.queries_per_second)
}

// -------------------------------------------------------------------

// RequestUnion

// .znbase.roachpb.GetRequest get = 1;
inline bool RequestUnion::has_get() const {
  return value_case() == kGet;
}
inline void RequestUnion::set_has_get() {
  _oneof_case_[0] = kGet;
}
inline void RequestUnion::clear_get() {
  if (has_get()) {
    delete value_.get_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::GetRequest& RequestUnion::_internal_get() const {
  return *value_.get_;
}
inline ::znbase::roachpb::GetRequest* RequestUnion::release_get() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.get)
  if (has_get()) {
    clear_has_value();
      ::znbase::roachpb::GetRequest* temp = value_.get_;
    value_.get_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::GetRequest& RequestUnion::get() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.get)
  return has_get()
      ? *value_.get_
      : *reinterpret_cast< ::znbase::roachpb::GetRequest*>(&::znbase::roachpb::_GetRequest_default_instance_);
}
inline ::znbase::roachpb::GetRequest* RequestUnion::mutable_get() {
  if (!has_get()) {
    clear_value();
    set_has_get();
    value_.get_ = CreateMaybeMessage< ::znbase::roachpb::GetRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.get)
  return value_.get_;
}

// .znbase.roachpb.PutRequest put = 2;
inline bool RequestUnion::has_put() const {
  return value_case() == kPut;
}
inline void RequestUnion::set_has_put() {
  _oneof_case_[0] = kPut;
}
inline void RequestUnion::clear_put() {
  if (has_put()) {
    delete value_.put_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::PutRequest& RequestUnion::_internal_put() const {
  return *value_.put_;
}
inline ::znbase::roachpb::PutRequest* RequestUnion::release_put() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.put)
  if (has_put()) {
    clear_has_value();
      ::znbase::roachpb::PutRequest* temp = value_.put_;
    value_.put_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::PutRequest& RequestUnion::put() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.put)
  return has_put()
      ? *value_.put_
      : *reinterpret_cast< ::znbase::roachpb::PutRequest*>(&::znbase::roachpb::_PutRequest_default_instance_);
}
inline ::znbase::roachpb::PutRequest* RequestUnion::mutable_put() {
  if (!has_put()) {
    clear_value();
    set_has_put();
    value_.put_ = CreateMaybeMessage< ::znbase::roachpb::PutRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.put)
  return value_.put_;
}

// .znbase.roachpb.ConditionalPutRequest conditional_put = 3;
inline bool RequestUnion::has_conditional_put() const {
  return value_case() == kConditionalPut;
}
inline void RequestUnion::set_has_conditional_put() {
  _oneof_case_[0] = kConditionalPut;
}
inline void RequestUnion::clear_conditional_put() {
  if (has_conditional_put()) {
    delete value_.conditional_put_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::ConditionalPutRequest& RequestUnion::_internal_conditional_put() const {
  return *value_.conditional_put_;
}
inline ::znbase::roachpb::ConditionalPutRequest* RequestUnion::release_conditional_put() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.conditional_put)
  if (has_conditional_put()) {
    clear_has_value();
      ::znbase::roachpb::ConditionalPutRequest* temp = value_.conditional_put_;
    value_.conditional_put_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::ConditionalPutRequest& RequestUnion::conditional_put() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.conditional_put)
  return has_conditional_put()
      ? *value_.conditional_put_
      : *reinterpret_cast< ::znbase::roachpb::ConditionalPutRequest*>(&::znbase::roachpb::_ConditionalPutRequest_default_instance_);
}
inline ::znbase::roachpb::ConditionalPutRequest* RequestUnion::mutable_conditional_put() {
  if (!has_conditional_put()) {
    clear_value();
    set_has_conditional_put();
    value_.conditional_put_ = CreateMaybeMessage< ::znbase::roachpb::ConditionalPutRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.conditional_put)
  return value_.conditional_put_;
}

// .znbase.roachpb.IncrementRequest increment = 4;
inline bool RequestUnion::has_increment() const {
  return value_case() == kIncrement;
}
inline void RequestUnion::set_has_increment() {
  _oneof_case_[0] = kIncrement;
}
inline void RequestUnion::clear_increment() {
  if (has_increment()) {
    delete value_.increment_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::IncrementRequest& RequestUnion::_internal_increment() const {
  return *value_.increment_;
}
inline ::znbase::roachpb::IncrementRequest* RequestUnion::release_increment() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.increment)
  if (has_increment()) {
    clear_has_value();
      ::znbase::roachpb::IncrementRequest* temp = value_.increment_;
    value_.increment_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::IncrementRequest& RequestUnion::increment() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.increment)
  return has_increment()
      ? *value_.increment_
      : *reinterpret_cast< ::znbase::roachpb::IncrementRequest*>(&::znbase::roachpb::_IncrementRequest_default_instance_);
}
inline ::znbase::roachpb::IncrementRequest* RequestUnion::mutable_increment() {
  if (!has_increment()) {
    clear_value();
    set_has_increment();
    value_.increment_ = CreateMaybeMessage< ::znbase::roachpb::IncrementRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.increment)
  return value_.increment_;
}

// .znbase.roachpb.DeleteRequest delete = 5;
inline bool RequestUnion::has_delete_() const {
  return value_case() == kDelete;
}
inline void RequestUnion::set_has_delete_() {
  _oneof_case_[0] = kDelete;
}
inline void RequestUnion::clear_delete_() {
  if (has_delete_()) {
    delete value_.delete__;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::DeleteRequest& RequestUnion::_internal_delete_() const {
  return *value_.delete__;
}
inline ::znbase::roachpb::DeleteRequest* RequestUnion::release_delete_() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.delete)
  if (has_delete_()) {
    clear_has_value();
      ::znbase::roachpb::DeleteRequest* temp = value_.delete__;
    value_.delete__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::DeleteRequest& RequestUnion::delete_() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.delete)
  return has_delete_()
      ? *value_.delete__
      : *reinterpret_cast< ::znbase::roachpb::DeleteRequest*>(&::znbase::roachpb::_DeleteRequest_default_instance_);
}
inline ::znbase::roachpb::DeleteRequest* RequestUnion::mutable_delete_() {
  if (!has_delete_()) {
    clear_value();
    set_has_delete_();
    value_.delete__ = CreateMaybeMessage< ::znbase::roachpb::DeleteRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.delete)
  return value_.delete__;
}

// .znbase.roachpb.DeleteRangeRequest delete_range = 6;
inline bool RequestUnion::has_delete_range() const {
  return value_case() == kDeleteRange;
}
inline void RequestUnion::set_has_delete_range() {
  _oneof_case_[0] = kDeleteRange;
}
inline void RequestUnion::clear_delete_range() {
  if (has_delete_range()) {
    delete value_.delete_range_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::DeleteRangeRequest& RequestUnion::_internal_delete_range() const {
  return *value_.delete_range_;
}
inline ::znbase::roachpb::DeleteRangeRequest* RequestUnion::release_delete_range() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.delete_range)
  if (has_delete_range()) {
    clear_has_value();
      ::znbase::roachpb::DeleteRangeRequest* temp = value_.delete_range_;
    value_.delete_range_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::DeleteRangeRequest& RequestUnion::delete_range() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.delete_range)
  return has_delete_range()
      ? *value_.delete_range_
      : *reinterpret_cast< ::znbase::roachpb::DeleteRangeRequest*>(&::znbase::roachpb::_DeleteRangeRequest_default_instance_);
}
inline ::znbase::roachpb::DeleteRangeRequest* RequestUnion::mutable_delete_range() {
  if (!has_delete_range()) {
    clear_value();
    set_has_delete_range();
    value_.delete_range_ = CreateMaybeMessage< ::znbase::roachpb::DeleteRangeRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.delete_range)
  return value_.delete_range_;
}

// .znbase.roachpb.ClearRangeRequest clear_range = 38;
inline bool RequestUnion::has_clear_range() const {
  return value_case() == kClearRange;
}
inline void RequestUnion::set_has_clear_range() {
  _oneof_case_[0] = kClearRange;
}
inline void RequestUnion::clear_clear_range() {
  if (has_clear_range()) {
    delete value_.clear_range_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::ClearRangeRequest& RequestUnion::_internal_clear_range() const {
  return *value_.clear_range_;
}
inline ::znbase::roachpb::ClearRangeRequest* RequestUnion::release_clear_range() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.clear_range)
  if (has_clear_range()) {
    clear_has_value();
      ::znbase::roachpb::ClearRangeRequest* temp = value_.clear_range_;
    value_.clear_range_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::ClearRangeRequest& RequestUnion::clear_range() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.clear_range)
  return has_clear_range()
      ? *value_.clear_range_
      : *reinterpret_cast< ::znbase::roachpb::ClearRangeRequest*>(&::znbase::roachpb::_ClearRangeRequest_default_instance_);
}
inline ::znbase::roachpb::ClearRangeRequest* RequestUnion::mutable_clear_range() {
  if (!has_clear_range()) {
    clear_value();
    set_has_clear_range();
    value_.clear_range_ = CreateMaybeMessage< ::znbase::roachpb::ClearRangeRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.clear_range)
  return value_.clear_range_;
}

// .znbase.roachpb.RevertRangeRequest revert_range = 51;
inline bool RequestUnion::has_revert_range() const {
  return value_case() == kRevertRange;
}
inline void RequestUnion::set_has_revert_range() {
  _oneof_case_[0] = kRevertRange;
}
inline void RequestUnion::clear_revert_range() {
  if (has_revert_range()) {
    delete value_.revert_range_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::RevertRangeRequest& RequestUnion::_internal_revert_range() const {
  return *value_.revert_range_;
}
inline ::znbase::roachpb::RevertRangeRequest* RequestUnion::release_revert_range() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.revert_range)
  if (has_revert_range()) {
    clear_has_value();
      ::znbase::roachpb::RevertRangeRequest* temp = value_.revert_range_;
    value_.revert_range_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::RevertRangeRequest& RequestUnion::revert_range() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.revert_range)
  return has_revert_range()
      ? *value_.revert_range_
      : *reinterpret_cast< ::znbase::roachpb::RevertRangeRequest*>(&::znbase::roachpb::_RevertRangeRequest_default_instance_);
}
inline ::znbase::roachpb::RevertRangeRequest* RequestUnion::mutable_revert_range() {
  if (!has_revert_range()) {
    clear_value();
    set_has_revert_range();
    value_.revert_range_ = CreateMaybeMessage< ::znbase::roachpb::RevertRangeRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.revert_range)
  return value_.revert_range_;
}

// .znbase.roachpb.ScanRequest scan = 7;
inline bool RequestUnion::has_scan() const {
  return value_case() == kScan;
}
inline void RequestUnion::set_has_scan() {
  _oneof_case_[0] = kScan;
}
inline void RequestUnion::clear_scan() {
  if (has_scan()) {
    delete value_.scan_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::ScanRequest& RequestUnion::_internal_scan() const {
  return *value_.scan_;
}
inline ::znbase::roachpb::ScanRequest* RequestUnion::release_scan() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.scan)
  if (has_scan()) {
    clear_has_value();
      ::znbase::roachpb::ScanRequest* temp = value_.scan_;
    value_.scan_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::ScanRequest& RequestUnion::scan() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.scan)
  return has_scan()
      ? *value_.scan_
      : *reinterpret_cast< ::znbase::roachpb::ScanRequest*>(&::znbase::roachpb::_ScanRequest_default_instance_);
}
inline ::znbase::roachpb::ScanRequest* RequestUnion::mutable_scan() {
  if (!has_scan()) {
    clear_value();
    set_has_scan();
    value_.scan_ = CreateMaybeMessage< ::znbase::roachpb::ScanRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.scan)
  return value_.scan_;
}

// .znbase.roachpb.EndTransactionRequest end_transaction = 9;
inline bool RequestUnion::has_end_transaction() const {
  return value_case() == kEndTransaction;
}
inline void RequestUnion::set_has_end_transaction() {
  _oneof_case_[0] = kEndTransaction;
}
inline void RequestUnion::clear_end_transaction() {
  if (has_end_transaction()) {
    delete value_.end_transaction_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::EndTransactionRequest& RequestUnion::_internal_end_transaction() const {
  return *value_.end_transaction_;
}
inline ::znbase::roachpb::EndTransactionRequest* RequestUnion::release_end_transaction() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.end_transaction)
  if (has_end_transaction()) {
    clear_has_value();
      ::znbase::roachpb::EndTransactionRequest* temp = value_.end_transaction_;
    value_.end_transaction_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::EndTransactionRequest& RequestUnion::end_transaction() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.end_transaction)
  return has_end_transaction()
      ? *value_.end_transaction_
      : *reinterpret_cast< ::znbase::roachpb::EndTransactionRequest*>(&::znbase::roachpb::_EndTransactionRequest_default_instance_);
}
inline ::znbase::roachpb::EndTransactionRequest* RequestUnion::mutable_end_transaction() {
  if (!has_end_transaction()) {
    clear_value();
    set_has_end_transaction();
    value_.end_transaction_ = CreateMaybeMessage< ::znbase::roachpb::EndTransactionRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.end_transaction)
  return value_.end_transaction_;
}

// .znbase.roachpb.AdminSplitRequest admin_split = 10;
inline bool RequestUnion::has_admin_split() const {
  return value_case() == kAdminSplit;
}
inline void RequestUnion::set_has_admin_split() {
  _oneof_case_[0] = kAdminSplit;
}
inline void RequestUnion::clear_admin_split() {
  if (has_admin_split()) {
    delete value_.admin_split_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::AdminSplitRequest& RequestUnion::_internal_admin_split() const {
  return *value_.admin_split_;
}
inline ::znbase::roachpb::AdminSplitRequest* RequestUnion::release_admin_split() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.admin_split)
  if (has_admin_split()) {
    clear_has_value();
      ::znbase::roachpb::AdminSplitRequest* temp = value_.admin_split_;
    value_.admin_split_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::AdminSplitRequest& RequestUnion::admin_split() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.admin_split)
  return has_admin_split()
      ? *value_.admin_split_
      : *reinterpret_cast< ::znbase::roachpb::AdminSplitRequest*>(&::znbase::roachpb::_AdminSplitRequest_default_instance_);
}
inline ::znbase::roachpb::AdminSplitRequest* RequestUnion::mutable_admin_split() {
  if (!has_admin_split()) {
    clear_value();
    set_has_admin_split();
    value_.admin_split_ = CreateMaybeMessage< ::znbase::roachpb::AdminSplitRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.admin_split)
  return value_.admin_split_;
}

// .znbase.roachpb.AdminMergeRequest admin_merge = 11;
inline bool RequestUnion::has_admin_merge() const {
  return value_case() == kAdminMerge;
}
inline void RequestUnion::set_has_admin_merge() {
  _oneof_case_[0] = kAdminMerge;
}
inline void RequestUnion::clear_admin_merge() {
  if (has_admin_merge()) {
    delete value_.admin_merge_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::AdminMergeRequest& RequestUnion::_internal_admin_merge() const {
  return *value_.admin_merge_;
}
inline ::znbase::roachpb::AdminMergeRequest* RequestUnion::release_admin_merge() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.admin_merge)
  if (has_admin_merge()) {
    clear_has_value();
      ::znbase::roachpb::AdminMergeRequest* temp = value_.admin_merge_;
    value_.admin_merge_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::AdminMergeRequest& RequestUnion::admin_merge() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.admin_merge)
  return has_admin_merge()
      ? *value_.admin_merge_
      : *reinterpret_cast< ::znbase::roachpb::AdminMergeRequest*>(&::znbase::roachpb::_AdminMergeRequest_default_instance_);
}
inline ::znbase::roachpb::AdminMergeRequest* RequestUnion::mutable_admin_merge() {
  if (!has_admin_merge()) {
    clear_value();
    set_has_admin_merge();
    value_.admin_merge_ = CreateMaybeMessage< ::znbase::roachpb::AdminMergeRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.admin_merge)
  return value_.admin_merge_;
}

// .znbase.roachpb.AdminTransferLeaseRequest admin_transfer_lease = 29;
inline bool RequestUnion::has_admin_transfer_lease() const {
  return value_case() == kAdminTransferLease;
}
inline void RequestUnion::set_has_admin_transfer_lease() {
  _oneof_case_[0] = kAdminTransferLease;
}
inline void RequestUnion::clear_admin_transfer_lease() {
  if (has_admin_transfer_lease()) {
    delete value_.admin_transfer_lease_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::AdminTransferLeaseRequest& RequestUnion::_internal_admin_transfer_lease() const {
  return *value_.admin_transfer_lease_;
}
inline ::znbase::roachpb::AdminTransferLeaseRequest* RequestUnion::release_admin_transfer_lease() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.admin_transfer_lease)
  if (has_admin_transfer_lease()) {
    clear_has_value();
      ::znbase::roachpb::AdminTransferLeaseRequest* temp = value_.admin_transfer_lease_;
    value_.admin_transfer_lease_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::AdminTransferLeaseRequest& RequestUnion::admin_transfer_lease() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.admin_transfer_lease)
  return has_admin_transfer_lease()
      ? *value_.admin_transfer_lease_
      : *reinterpret_cast< ::znbase::roachpb::AdminTransferLeaseRequest*>(&::znbase::roachpb::_AdminTransferLeaseRequest_default_instance_);
}
inline ::znbase::roachpb::AdminTransferLeaseRequest* RequestUnion::mutable_admin_transfer_lease() {
  if (!has_admin_transfer_lease()) {
    clear_value();
    set_has_admin_transfer_lease();
    value_.admin_transfer_lease_ = CreateMaybeMessage< ::znbase::roachpb::AdminTransferLeaseRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.admin_transfer_lease)
  return value_.admin_transfer_lease_;
}

// .znbase.roachpb.AdminChangeReplicasRequest admin_change_replicas = 35;
inline bool RequestUnion::has_admin_change_replicas() const {
  return value_case() == kAdminChangeReplicas;
}
inline void RequestUnion::set_has_admin_change_replicas() {
  _oneof_case_[0] = kAdminChangeReplicas;
}
inline void RequestUnion::clear_admin_change_replicas() {
  if (has_admin_change_replicas()) {
    delete value_.admin_change_replicas_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::AdminChangeReplicasRequest& RequestUnion::_internal_admin_change_replicas() const {
  return *value_.admin_change_replicas_;
}
inline ::znbase::roachpb::AdminChangeReplicasRequest* RequestUnion::release_admin_change_replicas() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.admin_change_replicas)
  if (has_admin_change_replicas()) {
    clear_has_value();
      ::znbase::roachpb::AdminChangeReplicasRequest* temp = value_.admin_change_replicas_;
    value_.admin_change_replicas_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::AdminChangeReplicasRequest& RequestUnion::admin_change_replicas() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.admin_change_replicas)
  return has_admin_change_replicas()
      ? *value_.admin_change_replicas_
      : *reinterpret_cast< ::znbase::roachpb::AdminChangeReplicasRequest*>(&::znbase::roachpb::_AdminChangeReplicasRequest_default_instance_);
}
inline ::znbase::roachpb::AdminChangeReplicasRequest* RequestUnion::mutable_admin_change_replicas() {
  if (!has_admin_change_replicas()) {
    clear_value();
    set_has_admin_change_replicas();
    value_.admin_change_replicas_ = CreateMaybeMessage< ::znbase::roachpb::AdminChangeReplicasRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.admin_change_replicas)
  return value_.admin_change_replicas_;
}

// .znbase.roachpb.AdminRelocateRangeRequest admin_relocate_range = 45;
inline bool RequestUnion::has_admin_relocate_range() const {
  return value_case() == kAdminRelocateRange;
}
inline void RequestUnion::set_has_admin_relocate_range() {
  _oneof_case_[0] = kAdminRelocateRange;
}
inline void RequestUnion::clear_admin_relocate_range() {
  if (has_admin_relocate_range()) {
    delete value_.admin_relocate_range_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::AdminRelocateRangeRequest& RequestUnion::_internal_admin_relocate_range() const {
  return *value_.admin_relocate_range_;
}
inline ::znbase::roachpb::AdminRelocateRangeRequest* RequestUnion::release_admin_relocate_range() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.admin_relocate_range)
  if (has_admin_relocate_range()) {
    clear_has_value();
      ::znbase::roachpb::AdminRelocateRangeRequest* temp = value_.admin_relocate_range_;
    value_.admin_relocate_range_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::AdminRelocateRangeRequest& RequestUnion::admin_relocate_range() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.admin_relocate_range)
  return has_admin_relocate_range()
      ? *value_.admin_relocate_range_
      : *reinterpret_cast< ::znbase::roachpb::AdminRelocateRangeRequest*>(&::znbase::roachpb::_AdminRelocateRangeRequest_default_instance_);
}
inline ::znbase::roachpb::AdminRelocateRangeRequest* RequestUnion::mutable_admin_relocate_range() {
  if (!has_admin_relocate_range()) {
    clear_value();
    set_has_admin_relocate_range();
    value_.admin_relocate_range_ = CreateMaybeMessage< ::znbase::roachpb::AdminRelocateRangeRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.admin_relocate_range)
  return value_.admin_relocate_range_;
}

// .znbase.roachpb.HeartbeatTxnRequest heartbeat_txn = 12;
inline bool RequestUnion::has_heartbeat_txn() const {
  return value_case() == kHeartbeatTxn;
}
inline void RequestUnion::set_has_heartbeat_txn() {
  _oneof_case_[0] = kHeartbeatTxn;
}
inline void RequestUnion::clear_heartbeat_txn() {
  if (has_heartbeat_txn()) {
    delete value_.heartbeat_txn_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::HeartbeatTxnRequest& RequestUnion::_internal_heartbeat_txn() const {
  return *value_.heartbeat_txn_;
}
inline ::znbase::roachpb::HeartbeatTxnRequest* RequestUnion::release_heartbeat_txn() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.heartbeat_txn)
  if (has_heartbeat_txn()) {
    clear_has_value();
      ::znbase::roachpb::HeartbeatTxnRequest* temp = value_.heartbeat_txn_;
    value_.heartbeat_txn_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::HeartbeatTxnRequest& RequestUnion::heartbeat_txn() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.heartbeat_txn)
  return has_heartbeat_txn()
      ? *value_.heartbeat_txn_
      : *reinterpret_cast< ::znbase::roachpb::HeartbeatTxnRequest*>(&::znbase::roachpb::_HeartbeatTxnRequest_default_instance_);
}
inline ::znbase::roachpb::HeartbeatTxnRequest* RequestUnion::mutable_heartbeat_txn() {
  if (!has_heartbeat_txn()) {
    clear_value();
    set_has_heartbeat_txn();
    value_.heartbeat_txn_ = CreateMaybeMessage< ::znbase::roachpb::HeartbeatTxnRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.heartbeat_txn)
  return value_.heartbeat_txn_;
}

// .znbase.roachpb.GCRequest gc = 13;
inline bool RequestUnion::has_gc() const {
  return value_case() == kGc;
}
inline void RequestUnion::set_has_gc() {
  _oneof_case_[0] = kGc;
}
inline void RequestUnion::clear_gc() {
  if (has_gc()) {
    delete value_.gc_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::GCRequest& RequestUnion::_internal_gc() const {
  return *value_.gc_;
}
inline ::znbase::roachpb::GCRequest* RequestUnion::release_gc() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.gc)
  if (has_gc()) {
    clear_has_value();
      ::znbase::roachpb::GCRequest* temp = value_.gc_;
    value_.gc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::GCRequest& RequestUnion::gc() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.gc)
  return has_gc()
      ? *value_.gc_
      : *reinterpret_cast< ::znbase::roachpb::GCRequest*>(&::znbase::roachpb::_GCRequest_default_instance_);
}
inline ::znbase::roachpb::GCRequest* RequestUnion::mutable_gc() {
  if (!has_gc()) {
    clear_value();
    set_has_gc();
    value_.gc_ = CreateMaybeMessage< ::znbase::roachpb::GCRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.gc)
  return value_.gc_;
}

// .znbase.roachpb.PushTxnRequest push_txn = 14;
inline bool RequestUnion::has_push_txn() const {
  return value_case() == kPushTxn;
}
inline void RequestUnion::set_has_push_txn() {
  _oneof_case_[0] = kPushTxn;
}
inline void RequestUnion::clear_push_txn() {
  if (has_push_txn()) {
    delete value_.push_txn_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::PushTxnRequest& RequestUnion::_internal_push_txn() const {
  return *value_.push_txn_;
}
inline ::znbase::roachpb::PushTxnRequest* RequestUnion::release_push_txn() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.push_txn)
  if (has_push_txn()) {
    clear_has_value();
      ::znbase::roachpb::PushTxnRequest* temp = value_.push_txn_;
    value_.push_txn_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::PushTxnRequest& RequestUnion::push_txn() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.push_txn)
  return has_push_txn()
      ? *value_.push_txn_
      : *reinterpret_cast< ::znbase::roachpb::PushTxnRequest*>(&::znbase::roachpb::_PushTxnRequest_default_instance_);
}
inline ::znbase::roachpb::PushTxnRequest* RequestUnion::mutable_push_txn() {
  if (!has_push_txn()) {
    clear_value();
    set_has_push_txn();
    value_.push_txn_ = CreateMaybeMessage< ::znbase::roachpb::PushTxnRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.push_txn)
  return value_.push_txn_;
}

// .znbase.roachpb.RecoverTxnRequest recover_txn = 46;
inline bool RequestUnion::has_recover_txn() const {
  return value_case() == kRecoverTxn;
}
inline void RequestUnion::set_has_recover_txn() {
  _oneof_case_[0] = kRecoverTxn;
}
inline void RequestUnion::clear_recover_txn() {
  if (has_recover_txn()) {
    delete value_.recover_txn_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::RecoverTxnRequest& RequestUnion::_internal_recover_txn() const {
  return *value_.recover_txn_;
}
inline ::znbase::roachpb::RecoverTxnRequest* RequestUnion::release_recover_txn() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.recover_txn)
  if (has_recover_txn()) {
    clear_has_value();
      ::znbase::roachpb::RecoverTxnRequest* temp = value_.recover_txn_;
    value_.recover_txn_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::RecoverTxnRequest& RequestUnion::recover_txn() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.recover_txn)
  return has_recover_txn()
      ? *value_.recover_txn_
      : *reinterpret_cast< ::znbase::roachpb::RecoverTxnRequest*>(&::znbase::roachpb::_RecoverTxnRequest_default_instance_);
}
inline ::znbase::roachpb::RecoverTxnRequest* RequestUnion::mutable_recover_txn() {
  if (!has_recover_txn()) {
    clear_value();
    set_has_recover_txn();
    value_.recover_txn_ = CreateMaybeMessage< ::znbase::roachpb::RecoverTxnRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.recover_txn)
  return value_.recover_txn_;
}

// .znbase.roachpb.ResolveIntentRequest resolve_intent = 16;
inline bool RequestUnion::has_resolve_intent() const {
  return value_case() == kResolveIntent;
}
inline void RequestUnion::set_has_resolve_intent() {
  _oneof_case_[0] = kResolveIntent;
}
inline void RequestUnion::clear_resolve_intent() {
  if (has_resolve_intent()) {
    delete value_.resolve_intent_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::ResolveIntentRequest& RequestUnion::_internal_resolve_intent() const {
  return *value_.resolve_intent_;
}
inline ::znbase::roachpb::ResolveIntentRequest* RequestUnion::release_resolve_intent() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.resolve_intent)
  if (has_resolve_intent()) {
    clear_has_value();
      ::znbase::roachpb::ResolveIntentRequest* temp = value_.resolve_intent_;
    value_.resolve_intent_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::ResolveIntentRequest& RequestUnion::resolve_intent() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.resolve_intent)
  return has_resolve_intent()
      ? *value_.resolve_intent_
      : *reinterpret_cast< ::znbase::roachpb::ResolveIntentRequest*>(&::znbase::roachpb::_ResolveIntentRequest_default_instance_);
}
inline ::znbase::roachpb::ResolveIntentRequest* RequestUnion::mutable_resolve_intent() {
  if (!has_resolve_intent()) {
    clear_value();
    set_has_resolve_intent();
    value_.resolve_intent_ = CreateMaybeMessage< ::znbase::roachpb::ResolveIntentRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.resolve_intent)
  return value_.resolve_intent_;
}

// .znbase.roachpb.ResolveIntentRangeRequest resolve_intent_range = 17;
inline bool RequestUnion::has_resolve_intent_range() const {
  return value_case() == kResolveIntentRange;
}
inline void RequestUnion::set_has_resolve_intent_range() {
  _oneof_case_[0] = kResolveIntentRange;
}
inline void RequestUnion::clear_resolve_intent_range() {
  if (has_resolve_intent_range()) {
    delete value_.resolve_intent_range_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::ResolveIntentRangeRequest& RequestUnion::_internal_resolve_intent_range() const {
  return *value_.resolve_intent_range_;
}
inline ::znbase::roachpb::ResolveIntentRangeRequest* RequestUnion::release_resolve_intent_range() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.resolve_intent_range)
  if (has_resolve_intent_range()) {
    clear_has_value();
      ::znbase::roachpb::ResolveIntentRangeRequest* temp = value_.resolve_intent_range_;
    value_.resolve_intent_range_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::ResolveIntentRangeRequest& RequestUnion::resolve_intent_range() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.resolve_intent_range)
  return has_resolve_intent_range()
      ? *value_.resolve_intent_range_
      : *reinterpret_cast< ::znbase::roachpb::ResolveIntentRangeRequest*>(&::znbase::roachpb::_ResolveIntentRangeRequest_default_instance_);
}
inline ::znbase::roachpb::ResolveIntentRangeRequest* RequestUnion::mutable_resolve_intent_range() {
  if (!has_resolve_intent_range()) {
    clear_value();
    set_has_resolve_intent_range();
    value_.resolve_intent_range_ = CreateMaybeMessage< ::znbase::roachpb::ResolveIntentRangeRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.resolve_intent_range)
  return value_.resolve_intent_range_;
}

// .znbase.roachpb.MergeRequest merge = 18;
inline bool RequestUnion::has_merge() const {
  return value_case() == kMerge;
}
inline void RequestUnion::set_has_merge() {
  _oneof_case_[0] = kMerge;
}
inline void RequestUnion::clear_merge() {
  if (has_merge()) {
    delete value_.merge_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::MergeRequest& RequestUnion::_internal_merge() const {
  return *value_.merge_;
}
inline ::znbase::roachpb::MergeRequest* RequestUnion::release_merge() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.merge)
  if (has_merge()) {
    clear_has_value();
      ::znbase::roachpb::MergeRequest* temp = value_.merge_;
    value_.merge_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::MergeRequest& RequestUnion::merge() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.merge)
  return has_merge()
      ? *value_.merge_
      : *reinterpret_cast< ::znbase::roachpb::MergeRequest*>(&::znbase::roachpb::_MergeRequest_default_instance_);
}
inline ::znbase::roachpb::MergeRequest* RequestUnion::mutable_merge() {
  if (!has_merge()) {
    clear_value();
    set_has_merge();
    value_.merge_ = CreateMaybeMessage< ::znbase::roachpb::MergeRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.merge)
  return value_.merge_;
}

// .znbase.roachpb.TruncateLogRequest truncate_log = 19;
inline bool RequestUnion::has_truncate_log() const {
  return value_case() == kTruncateLog;
}
inline void RequestUnion::set_has_truncate_log() {
  _oneof_case_[0] = kTruncateLog;
}
inline void RequestUnion::clear_truncate_log() {
  if (has_truncate_log()) {
    delete value_.truncate_log_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::TruncateLogRequest& RequestUnion::_internal_truncate_log() const {
  return *value_.truncate_log_;
}
inline ::znbase::roachpb::TruncateLogRequest* RequestUnion::release_truncate_log() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.truncate_log)
  if (has_truncate_log()) {
    clear_has_value();
      ::znbase::roachpb::TruncateLogRequest* temp = value_.truncate_log_;
    value_.truncate_log_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::TruncateLogRequest& RequestUnion::truncate_log() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.truncate_log)
  return has_truncate_log()
      ? *value_.truncate_log_
      : *reinterpret_cast< ::znbase::roachpb::TruncateLogRequest*>(&::znbase::roachpb::_TruncateLogRequest_default_instance_);
}
inline ::znbase::roachpb::TruncateLogRequest* RequestUnion::mutable_truncate_log() {
  if (!has_truncate_log()) {
    clear_value();
    set_has_truncate_log();
    value_.truncate_log_ = CreateMaybeMessage< ::znbase::roachpb::TruncateLogRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.truncate_log)
  return value_.truncate_log_;
}

// .znbase.roachpb.RequestLeaseRequest request_lease = 20;
inline bool RequestUnion::has_request_lease() const {
  return value_case() == kRequestLease;
}
inline void RequestUnion::set_has_request_lease() {
  _oneof_case_[0] = kRequestLease;
}
inline void RequestUnion::clear_request_lease() {
  if (has_request_lease()) {
    delete value_.request_lease_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::RequestLeaseRequest& RequestUnion::_internal_request_lease() const {
  return *value_.request_lease_;
}
inline ::znbase::roachpb::RequestLeaseRequest* RequestUnion::release_request_lease() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.request_lease)
  if (has_request_lease()) {
    clear_has_value();
      ::znbase::roachpb::RequestLeaseRequest* temp = value_.request_lease_;
    value_.request_lease_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::RequestLeaseRequest& RequestUnion::request_lease() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.request_lease)
  return has_request_lease()
      ? *value_.request_lease_
      : *reinterpret_cast< ::znbase::roachpb::RequestLeaseRequest*>(&::znbase::roachpb::_RequestLeaseRequest_default_instance_);
}
inline ::znbase::roachpb::RequestLeaseRequest* RequestUnion::mutable_request_lease() {
  if (!has_request_lease()) {
    clear_value();
    set_has_request_lease();
    value_.request_lease_ = CreateMaybeMessage< ::znbase::roachpb::RequestLeaseRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.request_lease)
  return value_.request_lease_;
}

// .znbase.roachpb.ReverseScanRequest reverse_scan = 21;
inline bool RequestUnion::has_reverse_scan() const {
  return value_case() == kReverseScan;
}
inline void RequestUnion::set_has_reverse_scan() {
  _oneof_case_[0] = kReverseScan;
}
inline void RequestUnion::clear_reverse_scan() {
  if (has_reverse_scan()) {
    delete value_.reverse_scan_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::ReverseScanRequest& RequestUnion::_internal_reverse_scan() const {
  return *value_.reverse_scan_;
}
inline ::znbase::roachpb::ReverseScanRequest* RequestUnion::release_reverse_scan() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.reverse_scan)
  if (has_reverse_scan()) {
    clear_has_value();
      ::znbase::roachpb::ReverseScanRequest* temp = value_.reverse_scan_;
    value_.reverse_scan_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::ReverseScanRequest& RequestUnion::reverse_scan() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.reverse_scan)
  return has_reverse_scan()
      ? *value_.reverse_scan_
      : *reinterpret_cast< ::znbase::roachpb::ReverseScanRequest*>(&::znbase::roachpb::_ReverseScanRequest_default_instance_);
}
inline ::znbase::roachpb::ReverseScanRequest* RequestUnion::mutable_reverse_scan() {
  if (!has_reverse_scan()) {
    clear_value();
    set_has_reverse_scan();
    value_.reverse_scan_ = CreateMaybeMessage< ::znbase::roachpb::ReverseScanRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.reverse_scan)
  return value_.reverse_scan_;
}

// .znbase.roachpb.ComputeChecksumRequest compute_checksum = 22;
inline bool RequestUnion::has_compute_checksum() const {
  return value_case() == kComputeChecksum;
}
inline void RequestUnion::set_has_compute_checksum() {
  _oneof_case_[0] = kComputeChecksum;
}
inline void RequestUnion::clear_compute_checksum() {
  if (has_compute_checksum()) {
    delete value_.compute_checksum_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::ComputeChecksumRequest& RequestUnion::_internal_compute_checksum() const {
  return *value_.compute_checksum_;
}
inline ::znbase::roachpb::ComputeChecksumRequest* RequestUnion::release_compute_checksum() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.compute_checksum)
  if (has_compute_checksum()) {
    clear_has_value();
      ::znbase::roachpb::ComputeChecksumRequest* temp = value_.compute_checksum_;
    value_.compute_checksum_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::ComputeChecksumRequest& RequestUnion::compute_checksum() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.compute_checksum)
  return has_compute_checksum()
      ? *value_.compute_checksum_
      : *reinterpret_cast< ::znbase::roachpb::ComputeChecksumRequest*>(&::znbase::roachpb::_ComputeChecksumRequest_default_instance_);
}
inline ::znbase::roachpb::ComputeChecksumRequest* RequestUnion::mutable_compute_checksum() {
  if (!has_compute_checksum()) {
    clear_value();
    set_has_compute_checksum();
    value_.compute_checksum_ = CreateMaybeMessage< ::znbase::roachpb::ComputeChecksumRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.compute_checksum)
  return value_.compute_checksum_;
}

// .znbase.roachpb.CheckConsistencyRequest check_consistency = 24;
inline bool RequestUnion::has_check_consistency() const {
  return value_case() == kCheckConsistency;
}
inline void RequestUnion::set_has_check_consistency() {
  _oneof_case_[0] = kCheckConsistency;
}
inline void RequestUnion::clear_check_consistency() {
  if (has_check_consistency()) {
    delete value_.check_consistency_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::CheckConsistencyRequest& RequestUnion::_internal_check_consistency() const {
  return *value_.check_consistency_;
}
inline ::znbase::roachpb::CheckConsistencyRequest* RequestUnion::release_check_consistency() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.check_consistency)
  if (has_check_consistency()) {
    clear_has_value();
      ::znbase::roachpb::CheckConsistencyRequest* temp = value_.check_consistency_;
    value_.check_consistency_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::CheckConsistencyRequest& RequestUnion::check_consistency() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.check_consistency)
  return has_check_consistency()
      ? *value_.check_consistency_
      : *reinterpret_cast< ::znbase::roachpb::CheckConsistencyRequest*>(&::znbase::roachpb::_CheckConsistencyRequest_default_instance_);
}
inline ::znbase::roachpb::CheckConsistencyRequest* RequestUnion::mutable_check_consistency() {
  if (!has_check_consistency()) {
    clear_value();
    set_has_check_consistency();
    value_.check_consistency_ = CreateMaybeMessage< ::znbase::roachpb::CheckConsistencyRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.check_consistency)
  return value_.check_consistency_;
}

// .znbase.roachpb.InitPutRequest init_put = 26;
inline bool RequestUnion::has_init_put() const {
  return value_case() == kInitPut;
}
inline void RequestUnion::set_has_init_put() {
  _oneof_case_[0] = kInitPut;
}
inline void RequestUnion::clear_init_put() {
  if (has_init_put()) {
    delete value_.init_put_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::InitPutRequest& RequestUnion::_internal_init_put() const {
  return *value_.init_put_;
}
inline ::znbase::roachpb::InitPutRequest* RequestUnion::release_init_put() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.init_put)
  if (has_init_put()) {
    clear_has_value();
      ::znbase::roachpb::InitPutRequest* temp = value_.init_put_;
    value_.init_put_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::InitPutRequest& RequestUnion::init_put() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.init_put)
  return has_init_put()
      ? *value_.init_put_
      : *reinterpret_cast< ::znbase::roachpb::InitPutRequest*>(&::znbase::roachpb::_InitPutRequest_default_instance_);
}
inline ::znbase::roachpb::InitPutRequest* RequestUnion::mutable_init_put() {
  if (!has_init_put()) {
    clear_value();
    set_has_init_put();
    value_.init_put_ = CreateMaybeMessage< ::znbase::roachpb::InitPutRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.init_put)
  return value_.init_put_;
}

// .znbase.roachpb.TransferLeaseRequest transfer_lease = 28;
inline bool RequestUnion::has_transfer_lease() const {
  return value_case() == kTransferLease;
}
inline void RequestUnion::set_has_transfer_lease() {
  _oneof_case_[0] = kTransferLease;
}
inline void RequestUnion::clear_transfer_lease() {
  if (has_transfer_lease()) {
    delete value_.transfer_lease_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::TransferLeaseRequest& RequestUnion::_internal_transfer_lease() const {
  return *value_.transfer_lease_;
}
inline ::znbase::roachpb::TransferLeaseRequest* RequestUnion::release_transfer_lease() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.transfer_lease)
  if (has_transfer_lease()) {
    clear_has_value();
      ::znbase::roachpb::TransferLeaseRequest* temp = value_.transfer_lease_;
    value_.transfer_lease_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::TransferLeaseRequest& RequestUnion::transfer_lease() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.transfer_lease)
  return has_transfer_lease()
      ? *value_.transfer_lease_
      : *reinterpret_cast< ::znbase::roachpb::TransferLeaseRequest*>(&::znbase::roachpb::_TransferLeaseRequest_default_instance_);
}
inline ::znbase::roachpb::TransferLeaseRequest* RequestUnion::mutable_transfer_lease() {
  if (!has_transfer_lease()) {
    clear_value();
    set_has_transfer_lease();
    value_.transfer_lease_ = CreateMaybeMessage< ::znbase::roachpb::TransferLeaseRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.transfer_lease)
  return value_.transfer_lease_;
}

// .znbase.roachpb.LeaseInfoRequest lease_info = 30;
inline bool RequestUnion::has_lease_info() const {
  return value_case() == kLeaseInfo;
}
inline void RequestUnion::set_has_lease_info() {
  _oneof_case_[0] = kLeaseInfo;
}
inline void RequestUnion::clear_lease_info() {
  if (has_lease_info()) {
    delete value_.lease_info_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::LeaseInfoRequest& RequestUnion::_internal_lease_info() const {
  return *value_.lease_info_;
}
inline ::znbase::roachpb::LeaseInfoRequest* RequestUnion::release_lease_info() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.lease_info)
  if (has_lease_info()) {
    clear_has_value();
      ::znbase::roachpb::LeaseInfoRequest* temp = value_.lease_info_;
    value_.lease_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::LeaseInfoRequest& RequestUnion::lease_info() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.lease_info)
  return has_lease_info()
      ? *value_.lease_info_
      : *reinterpret_cast< ::znbase::roachpb::LeaseInfoRequest*>(&::znbase::roachpb::_LeaseInfoRequest_default_instance_);
}
inline ::znbase::roachpb::LeaseInfoRequest* RequestUnion::mutable_lease_info() {
  if (!has_lease_info()) {
    clear_value();
    set_has_lease_info();
    value_.lease_info_ = CreateMaybeMessage< ::znbase::roachpb::LeaseInfoRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.lease_info)
  return value_.lease_info_;
}

// .znbase.roachpb.WriteBatchRequest write_batch = 31;
inline bool RequestUnion::has_write_batch() const {
  return value_case() == kWriteBatch;
}
inline void RequestUnion::set_has_write_batch() {
  _oneof_case_[0] = kWriteBatch;
}
inline void RequestUnion::clear_write_batch() {
  if (has_write_batch()) {
    delete value_.write_batch_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::WriteBatchRequest& RequestUnion::_internal_write_batch() const {
  return *value_.write_batch_;
}
inline ::znbase::roachpb::WriteBatchRequest* RequestUnion::release_write_batch() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.write_batch)
  if (has_write_batch()) {
    clear_has_value();
      ::znbase::roachpb::WriteBatchRequest* temp = value_.write_batch_;
    value_.write_batch_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::WriteBatchRequest& RequestUnion::write_batch() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.write_batch)
  return has_write_batch()
      ? *value_.write_batch_
      : *reinterpret_cast< ::znbase::roachpb::WriteBatchRequest*>(&::znbase::roachpb::_WriteBatchRequest_default_instance_);
}
inline ::znbase::roachpb::WriteBatchRequest* RequestUnion::mutable_write_batch() {
  if (!has_write_batch()) {
    clear_value();
    set_has_write_batch();
    value_.write_batch_ = CreateMaybeMessage< ::znbase::roachpb::WriteBatchRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.write_batch)
  return value_.write_batch_;
}

// .znbase.roachpb.ExportRequest export = 32;
inline bool RequestUnion::has_export_() const {
  return value_case() == kExport;
}
inline void RequestUnion::set_has_export_() {
  _oneof_case_[0] = kExport;
}
inline void RequestUnion::clear_export_() {
  if (has_export_()) {
    delete value_.export__;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::ExportRequest& RequestUnion::_internal_export_() const {
  return *value_.export__;
}
inline ::znbase::roachpb::ExportRequest* RequestUnion::release_export_() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.export)
  if (has_export_()) {
    clear_has_value();
      ::znbase::roachpb::ExportRequest* temp = value_.export__;
    value_.export__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::ExportRequest& RequestUnion::export_() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.export)
  return has_export_()
      ? *value_.export__
      : *reinterpret_cast< ::znbase::roachpb::ExportRequest*>(&::znbase::roachpb::_ExportRequest_default_instance_);
}
inline ::znbase::roachpb::ExportRequest* RequestUnion::mutable_export_() {
  if (!has_export_()) {
    clear_value();
    set_has_export_();
    value_.export__ = CreateMaybeMessage< ::znbase::roachpb::ExportRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.export)
  return value_.export__;
}

// .znbase.roachpb.ImportRequest import = 34;
inline bool RequestUnion::has_import() const {
  return value_case() == kImport;
}
inline void RequestUnion::set_has_import() {
  _oneof_case_[0] = kImport;
}
inline void RequestUnion::clear_import() {
  if (has_import()) {
    delete value_.import_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::ImportRequest& RequestUnion::_internal_import() const {
  return *value_.import_;
}
inline ::znbase::roachpb::ImportRequest* RequestUnion::release_import() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.import)
  if (has_import()) {
    clear_has_value();
      ::znbase::roachpb::ImportRequest* temp = value_.import_;
    value_.import_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::ImportRequest& RequestUnion::import() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.import)
  return has_import()
      ? *value_.import_
      : *reinterpret_cast< ::znbase::roachpb::ImportRequest*>(&::znbase::roachpb::_ImportRequest_default_instance_);
}
inline ::znbase::roachpb::ImportRequest* RequestUnion::mutable_import() {
  if (!has_import()) {
    clear_value();
    set_has_import();
    value_.import_ = CreateMaybeMessage< ::znbase::roachpb::ImportRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.import)
  return value_.import_;
}

// .znbase.roachpb.QueryTxnRequest query_txn = 33;
inline bool RequestUnion::has_query_txn() const {
  return value_case() == kQueryTxn;
}
inline void RequestUnion::set_has_query_txn() {
  _oneof_case_[0] = kQueryTxn;
}
inline void RequestUnion::clear_query_txn() {
  if (has_query_txn()) {
    delete value_.query_txn_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::QueryTxnRequest& RequestUnion::_internal_query_txn() const {
  return *value_.query_txn_;
}
inline ::znbase::roachpb::QueryTxnRequest* RequestUnion::release_query_txn() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.query_txn)
  if (has_query_txn()) {
    clear_has_value();
      ::znbase::roachpb::QueryTxnRequest* temp = value_.query_txn_;
    value_.query_txn_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::QueryTxnRequest& RequestUnion::query_txn() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.query_txn)
  return has_query_txn()
      ? *value_.query_txn_
      : *reinterpret_cast< ::znbase::roachpb::QueryTxnRequest*>(&::znbase::roachpb::_QueryTxnRequest_default_instance_);
}
inline ::znbase::roachpb::QueryTxnRequest* RequestUnion::mutable_query_txn() {
  if (!has_query_txn()) {
    clear_value();
    set_has_query_txn();
    value_.query_txn_ = CreateMaybeMessage< ::znbase::roachpb::QueryTxnRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.query_txn)
  return value_.query_txn_;
}

// .znbase.roachpb.QueryIntentRequest query_intent = 42;
inline bool RequestUnion::has_query_intent() const {
  return value_case() == kQueryIntent;
}
inline void RequestUnion::set_has_query_intent() {
  _oneof_case_[0] = kQueryIntent;
}
inline void RequestUnion::clear_query_intent() {
  if (has_query_intent()) {
    delete value_.query_intent_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::QueryIntentRequest& RequestUnion::_internal_query_intent() const {
  return *value_.query_intent_;
}
inline ::znbase::roachpb::QueryIntentRequest* RequestUnion::release_query_intent() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.query_intent)
  if (has_query_intent()) {
    clear_has_value();
      ::znbase::roachpb::QueryIntentRequest* temp = value_.query_intent_;
    value_.query_intent_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::QueryIntentRequest& RequestUnion::query_intent() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.query_intent)
  return has_query_intent()
      ? *value_.query_intent_
      : *reinterpret_cast< ::znbase::roachpb::QueryIntentRequest*>(&::znbase::roachpb::_QueryIntentRequest_default_instance_);
}
inline ::znbase::roachpb::QueryIntentRequest* RequestUnion::mutable_query_intent() {
  if (!has_query_intent()) {
    clear_value();
    set_has_query_intent();
    value_.query_intent_ = CreateMaybeMessage< ::znbase::roachpb::QueryIntentRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.query_intent)
  return value_.query_intent_;
}

// .znbase.roachpb.AdminScatterRequest admin_scatter = 36;
inline bool RequestUnion::has_admin_scatter() const {
  return value_case() == kAdminScatter;
}
inline void RequestUnion::set_has_admin_scatter() {
  _oneof_case_[0] = kAdminScatter;
}
inline void RequestUnion::clear_admin_scatter() {
  if (has_admin_scatter()) {
    delete value_.admin_scatter_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::AdminScatterRequest& RequestUnion::_internal_admin_scatter() const {
  return *value_.admin_scatter_;
}
inline ::znbase::roachpb::AdminScatterRequest* RequestUnion::release_admin_scatter() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.admin_scatter)
  if (has_admin_scatter()) {
    clear_has_value();
      ::znbase::roachpb::AdminScatterRequest* temp = value_.admin_scatter_;
    value_.admin_scatter_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::AdminScatterRequest& RequestUnion::admin_scatter() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.admin_scatter)
  return has_admin_scatter()
      ? *value_.admin_scatter_
      : *reinterpret_cast< ::znbase::roachpb::AdminScatterRequest*>(&::znbase::roachpb::_AdminScatterRequest_default_instance_);
}
inline ::znbase::roachpb::AdminScatterRequest* RequestUnion::mutable_admin_scatter() {
  if (!has_admin_scatter()) {
    clear_value();
    set_has_admin_scatter();
    value_.admin_scatter_ = CreateMaybeMessage< ::znbase::roachpb::AdminScatterRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.admin_scatter)
  return value_.admin_scatter_;
}

// .znbase.roachpb.AddSSTableRequest add_sstable = 37;
inline bool RequestUnion::has_add_sstable() const {
  return value_case() == kAddSstable;
}
inline void RequestUnion::set_has_add_sstable() {
  _oneof_case_[0] = kAddSstable;
}
inline void RequestUnion::clear_add_sstable() {
  if (has_add_sstable()) {
    delete value_.add_sstable_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::AddSSTableRequest& RequestUnion::_internal_add_sstable() const {
  return *value_.add_sstable_;
}
inline ::znbase::roachpb::AddSSTableRequest* RequestUnion::release_add_sstable() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.add_sstable)
  if (has_add_sstable()) {
    clear_has_value();
      ::znbase::roachpb::AddSSTableRequest* temp = value_.add_sstable_;
    value_.add_sstable_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::AddSSTableRequest& RequestUnion::add_sstable() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.add_sstable)
  return has_add_sstable()
      ? *value_.add_sstable_
      : *reinterpret_cast< ::znbase::roachpb::AddSSTableRequest*>(&::znbase::roachpb::_AddSSTableRequest_default_instance_);
}
inline ::znbase::roachpb::AddSSTableRequest* RequestUnion::mutable_add_sstable() {
  if (!has_add_sstable()) {
    clear_value();
    set_has_add_sstable();
    value_.add_sstable_ = CreateMaybeMessage< ::znbase::roachpb::AddSSTableRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.add_sstable)
  return value_.add_sstable_;
}

// .znbase.roachpb.RecomputeStatsRequest recompute_stats = 39;
inline bool RequestUnion::has_recompute_stats() const {
  return value_case() == kRecomputeStats;
}
inline void RequestUnion::set_has_recompute_stats() {
  _oneof_case_[0] = kRecomputeStats;
}
inline void RequestUnion::clear_recompute_stats() {
  if (has_recompute_stats()) {
    delete value_.recompute_stats_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::RecomputeStatsRequest& RequestUnion::_internal_recompute_stats() const {
  return *value_.recompute_stats_;
}
inline ::znbase::roachpb::RecomputeStatsRequest* RequestUnion::release_recompute_stats() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.recompute_stats)
  if (has_recompute_stats()) {
    clear_has_value();
      ::znbase::roachpb::RecomputeStatsRequest* temp = value_.recompute_stats_;
    value_.recompute_stats_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::RecomputeStatsRequest& RequestUnion::recompute_stats() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.recompute_stats)
  return has_recompute_stats()
      ? *value_.recompute_stats_
      : *reinterpret_cast< ::znbase::roachpb::RecomputeStatsRequest*>(&::znbase::roachpb::_RecomputeStatsRequest_default_instance_);
}
inline ::znbase::roachpb::RecomputeStatsRequest* RequestUnion::mutable_recompute_stats() {
  if (!has_recompute_stats()) {
    clear_value();
    set_has_recompute_stats();
    value_.recompute_stats_ = CreateMaybeMessage< ::znbase::roachpb::RecomputeStatsRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.recompute_stats)
  return value_.recompute_stats_;
}

// .znbase.roachpb.RefreshRequest refresh = 40;
inline bool RequestUnion::has_refresh() const {
  return value_case() == kRefresh;
}
inline void RequestUnion::set_has_refresh() {
  _oneof_case_[0] = kRefresh;
}
inline void RequestUnion::clear_refresh() {
  if (has_refresh()) {
    delete value_.refresh_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::RefreshRequest& RequestUnion::_internal_refresh() const {
  return *value_.refresh_;
}
inline ::znbase::roachpb::RefreshRequest* RequestUnion::release_refresh() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.refresh)
  if (has_refresh()) {
    clear_has_value();
      ::znbase::roachpb::RefreshRequest* temp = value_.refresh_;
    value_.refresh_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::RefreshRequest& RequestUnion::refresh() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.refresh)
  return has_refresh()
      ? *value_.refresh_
      : *reinterpret_cast< ::znbase::roachpb::RefreshRequest*>(&::znbase::roachpb::_RefreshRequest_default_instance_);
}
inline ::znbase::roachpb::RefreshRequest* RequestUnion::mutable_refresh() {
  if (!has_refresh()) {
    clear_value();
    set_has_refresh();
    value_.refresh_ = CreateMaybeMessage< ::znbase::roachpb::RefreshRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.refresh)
  return value_.refresh_;
}

// .znbase.roachpb.RefreshRangeRequest refresh_range = 41;
inline bool RequestUnion::has_refresh_range() const {
  return value_case() == kRefreshRange;
}
inline void RequestUnion::set_has_refresh_range() {
  _oneof_case_[0] = kRefreshRange;
}
inline void RequestUnion::clear_refresh_range() {
  if (has_refresh_range()) {
    delete value_.refresh_range_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::RefreshRangeRequest& RequestUnion::_internal_refresh_range() const {
  return *value_.refresh_range_;
}
inline ::znbase::roachpb::RefreshRangeRequest* RequestUnion::release_refresh_range() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.refresh_range)
  if (has_refresh_range()) {
    clear_has_value();
      ::znbase::roachpb::RefreshRangeRequest* temp = value_.refresh_range_;
    value_.refresh_range_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::RefreshRangeRequest& RequestUnion::refresh_range() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.refresh_range)
  return has_refresh_range()
      ? *value_.refresh_range_
      : *reinterpret_cast< ::znbase::roachpb::RefreshRangeRequest*>(&::znbase::roachpb::_RefreshRangeRequest_default_instance_);
}
inline ::znbase::roachpb::RefreshRangeRequest* RequestUnion::mutable_refresh_range() {
  if (!has_refresh_range()) {
    clear_value();
    set_has_refresh_range();
    value_.refresh_range_ = CreateMaybeMessage< ::znbase::roachpb::RefreshRangeRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.refresh_range)
  return value_.refresh_range_;
}

// .znbase.roachpb.SubsumeRequest subsume = 43;
inline bool RequestUnion::has_subsume() const {
  return value_case() == kSubsume;
}
inline void RequestUnion::set_has_subsume() {
  _oneof_case_[0] = kSubsume;
}
inline void RequestUnion::clear_subsume() {
  if (has_subsume()) {
    delete value_.subsume_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::SubsumeRequest& RequestUnion::_internal_subsume() const {
  return *value_.subsume_;
}
inline ::znbase::roachpb::SubsumeRequest* RequestUnion::release_subsume() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.subsume)
  if (has_subsume()) {
    clear_has_value();
      ::znbase::roachpb::SubsumeRequest* temp = value_.subsume_;
    value_.subsume_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::SubsumeRequest& RequestUnion::subsume() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.subsume)
  return has_subsume()
      ? *value_.subsume_
      : *reinterpret_cast< ::znbase::roachpb::SubsumeRequest*>(&::znbase::roachpb::_SubsumeRequest_default_instance_);
}
inline ::znbase::roachpb::SubsumeRequest* RequestUnion::mutable_subsume() {
  if (!has_subsume()) {
    clear_value();
    set_has_subsume();
    value_.subsume_ = CreateMaybeMessage< ::znbase::roachpb::SubsumeRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.subsume)
  return value_.subsume_;
}

// .znbase.roachpb.RangeStatsRequest range_stats = 44;
inline bool RequestUnion::has_range_stats() const {
  return value_case() == kRangeStats;
}
inline void RequestUnion::set_has_range_stats() {
  _oneof_case_[0] = kRangeStats;
}
inline void RequestUnion::clear_range_stats() {
  if (has_range_stats()) {
    delete value_.range_stats_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::RangeStatsRequest& RequestUnion::_internal_range_stats() const {
  return *value_.range_stats_;
}
inline ::znbase::roachpb::RangeStatsRequest* RequestUnion::release_range_stats() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.range_stats)
  if (has_range_stats()) {
    clear_has_value();
      ::znbase::roachpb::RangeStatsRequest* temp = value_.range_stats_;
    value_.range_stats_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::RangeStatsRequest& RequestUnion::range_stats() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.range_stats)
  return has_range_stats()
      ? *value_.range_stats_
      : *reinterpret_cast< ::znbase::roachpb::RangeStatsRequest*>(&::znbase::roachpb::_RangeStatsRequest_default_instance_);
}
inline ::znbase::roachpb::RangeStatsRequest* RequestUnion::mutable_range_stats() {
  if (!has_range_stats()) {
    clear_value();
    set_has_range_stats();
    value_.range_stats_ = CreateMaybeMessage< ::znbase::roachpb::RangeStatsRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.range_stats)
  return value_.range_stats_;
}

// .znbase.roachpb.RevertRequest revert = 48;
inline bool RequestUnion::has_revert() const {
  return value_case() == kRevert;
}
inline void RequestUnion::set_has_revert() {
  _oneof_case_[0] = kRevert;
}
inline void RequestUnion::clear_revert() {
  if (has_revert()) {
    delete value_.revert_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::RevertRequest& RequestUnion::_internal_revert() const {
  return *value_.revert_;
}
inline ::znbase::roachpb::RevertRequest* RequestUnion::release_revert() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.revert)
  if (has_revert()) {
    clear_has_value();
      ::znbase::roachpb::RevertRequest* temp = value_.revert_;
    value_.revert_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::RevertRequest& RequestUnion::revert() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.revert)
  return has_revert()
      ? *value_.revert_
      : *reinterpret_cast< ::znbase::roachpb::RevertRequest*>(&::znbase::roachpb::_RevertRequest_default_instance_);
}
inline ::znbase::roachpb::RevertRequest* RequestUnion::mutable_revert() {
  if (!has_revert()) {
    clear_value();
    set_has_revert();
    value_.revert_ = CreateMaybeMessage< ::znbase::roachpb::RevertRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.revert)
  return value_.revert_;
}

// .znbase.roachpb.DumpRequest dump = 49;
inline bool RequestUnion::has_dump() const {
  return value_case() == kDump;
}
inline void RequestUnion::set_has_dump() {
  _oneof_case_[0] = kDump;
}
inline void RequestUnion::clear_dump() {
  if (has_dump()) {
    delete value_.dump_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::DumpRequest& RequestUnion::_internal_dump() const {
  return *value_.dump_;
}
inline ::znbase::roachpb::DumpRequest* RequestUnion::release_dump() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.dump)
  if (has_dump()) {
    clear_has_value();
      ::znbase::roachpb::DumpRequest* temp = value_.dump_;
    value_.dump_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::DumpRequest& RequestUnion::dump() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.dump)
  return has_dump()
      ? *value_.dump_
      : *reinterpret_cast< ::znbase::roachpb::DumpRequest*>(&::znbase::roachpb::_DumpRequest_default_instance_);
}
inline ::znbase::roachpb::DumpRequest* RequestUnion::mutable_dump() {
  if (!has_dump()) {
    clear_value();
    set_has_dump();
    value_.dump_ = CreateMaybeMessage< ::znbase::roachpb::DumpRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.dump)
  return value_.dump_;
}

// .znbase.roachpb.DumpOnlineRequest dump_online = 50;
inline bool RequestUnion::has_dump_online() const {
  return value_case() == kDumpOnline;
}
inline void RequestUnion::set_has_dump_online() {
  _oneof_case_[0] = kDumpOnline;
}
inline void RequestUnion::clear_dump_online() {
  if (has_dump_online()) {
    delete value_.dump_online_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::DumpOnlineRequest& RequestUnion::_internal_dump_online() const {
  return *value_.dump_online_;
}
inline ::znbase::roachpb::DumpOnlineRequest* RequestUnion::release_dump_online() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.dump_online)
  if (has_dump_online()) {
    clear_has_value();
      ::znbase::roachpb::DumpOnlineRequest* temp = value_.dump_online_;
    value_.dump_online_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::DumpOnlineRequest& RequestUnion::dump_online() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.dump_online)
  return has_dump_online()
      ? *value_.dump_online_
      : *reinterpret_cast< ::znbase::roachpb::DumpOnlineRequest*>(&::znbase::roachpb::_DumpOnlineRequest_default_instance_);
}
inline ::znbase::roachpb::DumpOnlineRequest* RequestUnion::mutable_dump_online() {
  if (!has_dump_online()) {
    clear_value();
    set_has_dump_online();
    value_.dump_online_ = CreateMaybeMessage< ::znbase::roachpb::DumpOnlineRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.dump_online)
  return value_.dump_online_;
}

// .znbase.roachpb.LoadRequest load = 47;
inline bool RequestUnion::has_load() const {
  return value_case() == kLoad;
}
inline void RequestUnion::set_has_load() {
  _oneof_case_[0] = kLoad;
}
inline void RequestUnion::clear_load() {
  if (has_load()) {
    delete value_.load_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::LoadRequest& RequestUnion::_internal_load() const {
  return *value_.load_;
}
inline ::znbase::roachpb::LoadRequest* RequestUnion::release_load() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.load)
  if (has_load()) {
    clear_has_value();
      ::znbase::roachpb::LoadRequest* temp = value_.load_;
    value_.load_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::LoadRequest& RequestUnion::load() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.load)
  return has_load()
      ? *value_.load_
      : *reinterpret_cast< ::znbase::roachpb::LoadRequest*>(&::znbase::roachpb::_LoadRequest_default_instance_);
}
inline ::znbase::roachpb::LoadRequest* RequestUnion::mutable_load() {
  if (!has_load()) {
    clear_value();
    set_has_load();
    value_.load_ = CreateMaybeMessage< ::znbase::roachpb::LoadRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.load)
  return value_.load_;
}

// .znbase.roachpb.ClearIntentRequest clear_intent = 52;
inline bool RequestUnion::has_clear_intent() const {
  return value_case() == kClearIntent;
}
inline void RequestUnion::set_has_clear_intent() {
  _oneof_case_[0] = kClearIntent;
}
inline void RequestUnion::clear_clear_intent() {
  if (has_clear_intent()) {
    delete value_.clear_intent_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::ClearIntentRequest& RequestUnion::_internal_clear_intent() const {
  return *value_.clear_intent_;
}
inline ::znbase::roachpb::ClearIntentRequest* RequestUnion::release_clear_intent() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.clear_intent)
  if (has_clear_intent()) {
    clear_has_value();
      ::znbase::roachpb::ClearIntentRequest* temp = value_.clear_intent_;
    value_.clear_intent_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::ClearIntentRequest& RequestUnion::clear_intent() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.clear_intent)
  return has_clear_intent()
      ? *value_.clear_intent_
      : *reinterpret_cast< ::znbase::roachpb::ClearIntentRequest*>(&::znbase::roachpb::_ClearIntentRequest_default_instance_);
}
inline ::znbase::roachpb::ClearIntentRequest* RequestUnion::mutable_clear_intent() {
  if (!has_clear_intent()) {
    clear_value();
    set_has_clear_intent();
    value_.clear_intent_ = CreateMaybeMessage< ::znbase::roachpb::ClearIntentRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.clear_intent)
  return value_.clear_intent_;
}

// .znbase.roachpb.QueryLockRequest query_lock = 53;
inline bool RequestUnion::has_query_lock() const {
  return value_case() == kQueryLock;
}
inline void RequestUnion::set_has_query_lock() {
  _oneof_case_[0] = kQueryLock;
}
inline void RequestUnion::clear_query_lock() {
  if (has_query_lock()) {
    delete value_.query_lock_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::QueryLockRequest& RequestUnion::_internal_query_lock() const {
  return *value_.query_lock_;
}
inline ::znbase::roachpb::QueryLockRequest* RequestUnion::release_query_lock() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.query_lock)
  if (has_query_lock()) {
    clear_has_value();
      ::znbase::roachpb::QueryLockRequest* temp = value_.query_lock_;
    value_.query_lock_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::QueryLockRequest& RequestUnion::query_lock() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.query_lock)
  return has_query_lock()
      ? *value_.query_lock_
      : *reinterpret_cast< ::znbase::roachpb::QueryLockRequest*>(&::znbase::roachpb::_QueryLockRequest_default_instance_);
}
inline ::znbase::roachpb::QueryLockRequest* RequestUnion::mutable_query_lock() {
  if (!has_query_lock()) {
    clear_value();
    set_has_query_lock();
    value_.query_lock_ = CreateMaybeMessage< ::znbase::roachpb::QueryLockRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.query_lock)
  return value_.query_lock_;
}

// .znbase.roachpb.VecScanRequest vec_scan = 54;
inline bool RequestUnion::has_vec_scan() const {
  return value_case() == kVecScan;
}
inline void RequestUnion::set_has_vec_scan() {
  _oneof_case_[0] = kVecScan;
}
inline void RequestUnion::clear_vec_scan() {
  if (has_vec_scan()) {
    delete value_.vec_scan_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::VecScanRequest& RequestUnion::_internal_vec_scan() const {
  return *value_.vec_scan_;
}
inline ::znbase::roachpb::VecScanRequest* RequestUnion::release_vec_scan() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RequestUnion.vec_scan)
  if (has_vec_scan()) {
    clear_has_value();
      ::znbase::roachpb::VecScanRequest* temp = value_.vec_scan_;
    value_.vec_scan_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::VecScanRequest& RequestUnion::vec_scan() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RequestUnion.vec_scan)
  return has_vec_scan()
      ? *value_.vec_scan_
      : *reinterpret_cast< ::znbase::roachpb::VecScanRequest*>(&::znbase::roachpb::_VecScanRequest_default_instance_);
}
inline ::znbase::roachpb::VecScanRequest* RequestUnion::mutable_vec_scan() {
  if (!has_vec_scan()) {
    clear_value();
    set_has_vec_scan();
    value_.vec_scan_ = CreateMaybeMessage< ::znbase::roachpb::VecScanRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RequestUnion.vec_scan)
  return value_.vec_scan_;
}

inline bool RequestUnion::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void RequestUnion::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline RequestUnion::ValueCase RequestUnion::value_case() const {
  return RequestUnion::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ResponseUnion

// .znbase.roachpb.GetResponse get = 1;
inline bool ResponseUnion::has_get() const {
  return value_case() == kGet;
}
inline void ResponseUnion::set_has_get() {
  _oneof_case_[0] = kGet;
}
inline void ResponseUnion::clear_get() {
  if (has_get()) {
    delete value_.get_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::GetResponse& ResponseUnion::_internal_get() const {
  return *value_.get_;
}
inline ::znbase::roachpb::GetResponse* ResponseUnion::release_get() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.get)
  if (has_get()) {
    clear_has_value();
      ::znbase::roachpb::GetResponse* temp = value_.get_;
    value_.get_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::GetResponse& ResponseUnion::get() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.get)
  return has_get()
      ? *value_.get_
      : *reinterpret_cast< ::znbase::roachpb::GetResponse*>(&::znbase::roachpb::_GetResponse_default_instance_);
}
inline ::znbase::roachpb::GetResponse* ResponseUnion::mutable_get() {
  if (!has_get()) {
    clear_value();
    set_has_get();
    value_.get_ = CreateMaybeMessage< ::znbase::roachpb::GetResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.get)
  return value_.get_;
}

// .znbase.roachpb.PutResponse put = 2;
inline bool ResponseUnion::has_put() const {
  return value_case() == kPut;
}
inline void ResponseUnion::set_has_put() {
  _oneof_case_[0] = kPut;
}
inline void ResponseUnion::clear_put() {
  if (has_put()) {
    delete value_.put_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::PutResponse& ResponseUnion::_internal_put() const {
  return *value_.put_;
}
inline ::znbase::roachpb::PutResponse* ResponseUnion::release_put() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.put)
  if (has_put()) {
    clear_has_value();
      ::znbase::roachpb::PutResponse* temp = value_.put_;
    value_.put_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::PutResponse& ResponseUnion::put() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.put)
  return has_put()
      ? *value_.put_
      : *reinterpret_cast< ::znbase::roachpb::PutResponse*>(&::znbase::roachpb::_PutResponse_default_instance_);
}
inline ::znbase::roachpb::PutResponse* ResponseUnion::mutable_put() {
  if (!has_put()) {
    clear_value();
    set_has_put();
    value_.put_ = CreateMaybeMessage< ::znbase::roachpb::PutResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.put)
  return value_.put_;
}

// .znbase.roachpb.ConditionalPutResponse conditional_put = 3;
inline bool ResponseUnion::has_conditional_put() const {
  return value_case() == kConditionalPut;
}
inline void ResponseUnion::set_has_conditional_put() {
  _oneof_case_[0] = kConditionalPut;
}
inline void ResponseUnion::clear_conditional_put() {
  if (has_conditional_put()) {
    delete value_.conditional_put_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::ConditionalPutResponse& ResponseUnion::_internal_conditional_put() const {
  return *value_.conditional_put_;
}
inline ::znbase::roachpb::ConditionalPutResponse* ResponseUnion::release_conditional_put() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.conditional_put)
  if (has_conditional_put()) {
    clear_has_value();
      ::znbase::roachpb::ConditionalPutResponse* temp = value_.conditional_put_;
    value_.conditional_put_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::ConditionalPutResponse& ResponseUnion::conditional_put() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.conditional_put)
  return has_conditional_put()
      ? *value_.conditional_put_
      : *reinterpret_cast< ::znbase::roachpb::ConditionalPutResponse*>(&::znbase::roachpb::_ConditionalPutResponse_default_instance_);
}
inline ::znbase::roachpb::ConditionalPutResponse* ResponseUnion::mutable_conditional_put() {
  if (!has_conditional_put()) {
    clear_value();
    set_has_conditional_put();
    value_.conditional_put_ = CreateMaybeMessage< ::znbase::roachpb::ConditionalPutResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.conditional_put)
  return value_.conditional_put_;
}

// .znbase.roachpb.IncrementResponse increment = 4;
inline bool ResponseUnion::has_increment() const {
  return value_case() == kIncrement;
}
inline void ResponseUnion::set_has_increment() {
  _oneof_case_[0] = kIncrement;
}
inline void ResponseUnion::clear_increment() {
  if (has_increment()) {
    delete value_.increment_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::IncrementResponse& ResponseUnion::_internal_increment() const {
  return *value_.increment_;
}
inline ::znbase::roachpb::IncrementResponse* ResponseUnion::release_increment() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.increment)
  if (has_increment()) {
    clear_has_value();
      ::znbase::roachpb::IncrementResponse* temp = value_.increment_;
    value_.increment_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::IncrementResponse& ResponseUnion::increment() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.increment)
  return has_increment()
      ? *value_.increment_
      : *reinterpret_cast< ::znbase::roachpb::IncrementResponse*>(&::znbase::roachpb::_IncrementResponse_default_instance_);
}
inline ::znbase::roachpb::IncrementResponse* ResponseUnion::mutable_increment() {
  if (!has_increment()) {
    clear_value();
    set_has_increment();
    value_.increment_ = CreateMaybeMessage< ::znbase::roachpb::IncrementResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.increment)
  return value_.increment_;
}

// .znbase.roachpb.DeleteResponse delete = 5;
inline bool ResponseUnion::has_delete_() const {
  return value_case() == kDelete;
}
inline void ResponseUnion::set_has_delete_() {
  _oneof_case_[0] = kDelete;
}
inline void ResponseUnion::clear_delete_() {
  if (has_delete_()) {
    delete value_.delete__;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::DeleteResponse& ResponseUnion::_internal_delete_() const {
  return *value_.delete__;
}
inline ::znbase::roachpb::DeleteResponse* ResponseUnion::release_delete_() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.delete)
  if (has_delete_()) {
    clear_has_value();
      ::znbase::roachpb::DeleteResponse* temp = value_.delete__;
    value_.delete__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::DeleteResponse& ResponseUnion::delete_() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.delete)
  return has_delete_()
      ? *value_.delete__
      : *reinterpret_cast< ::znbase::roachpb::DeleteResponse*>(&::znbase::roachpb::_DeleteResponse_default_instance_);
}
inline ::znbase::roachpb::DeleteResponse* ResponseUnion::mutable_delete_() {
  if (!has_delete_()) {
    clear_value();
    set_has_delete_();
    value_.delete__ = CreateMaybeMessage< ::znbase::roachpb::DeleteResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.delete)
  return value_.delete__;
}

// .znbase.roachpb.DeleteRangeResponse delete_range = 6;
inline bool ResponseUnion::has_delete_range() const {
  return value_case() == kDeleteRange;
}
inline void ResponseUnion::set_has_delete_range() {
  _oneof_case_[0] = kDeleteRange;
}
inline void ResponseUnion::clear_delete_range() {
  if (has_delete_range()) {
    delete value_.delete_range_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::DeleteRangeResponse& ResponseUnion::_internal_delete_range() const {
  return *value_.delete_range_;
}
inline ::znbase::roachpb::DeleteRangeResponse* ResponseUnion::release_delete_range() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.delete_range)
  if (has_delete_range()) {
    clear_has_value();
      ::znbase::roachpb::DeleteRangeResponse* temp = value_.delete_range_;
    value_.delete_range_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::DeleteRangeResponse& ResponseUnion::delete_range() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.delete_range)
  return has_delete_range()
      ? *value_.delete_range_
      : *reinterpret_cast< ::znbase::roachpb::DeleteRangeResponse*>(&::znbase::roachpb::_DeleteRangeResponse_default_instance_);
}
inline ::znbase::roachpb::DeleteRangeResponse* ResponseUnion::mutable_delete_range() {
  if (!has_delete_range()) {
    clear_value();
    set_has_delete_range();
    value_.delete_range_ = CreateMaybeMessage< ::znbase::roachpb::DeleteRangeResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.delete_range)
  return value_.delete_range_;
}

// .znbase.roachpb.ClearRangeResponse clear_range = 38;
inline bool ResponseUnion::has_clear_range() const {
  return value_case() == kClearRange;
}
inline void ResponseUnion::set_has_clear_range() {
  _oneof_case_[0] = kClearRange;
}
inline void ResponseUnion::clear_clear_range() {
  if (has_clear_range()) {
    delete value_.clear_range_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::ClearRangeResponse& ResponseUnion::_internal_clear_range() const {
  return *value_.clear_range_;
}
inline ::znbase::roachpb::ClearRangeResponse* ResponseUnion::release_clear_range() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.clear_range)
  if (has_clear_range()) {
    clear_has_value();
      ::znbase::roachpb::ClearRangeResponse* temp = value_.clear_range_;
    value_.clear_range_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::ClearRangeResponse& ResponseUnion::clear_range() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.clear_range)
  return has_clear_range()
      ? *value_.clear_range_
      : *reinterpret_cast< ::znbase::roachpb::ClearRangeResponse*>(&::znbase::roachpb::_ClearRangeResponse_default_instance_);
}
inline ::znbase::roachpb::ClearRangeResponse* ResponseUnion::mutable_clear_range() {
  if (!has_clear_range()) {
    clear_value();
    set_has_clear_range();
    value_.clear_range_ = CreateMaybeMessage< ::znbase::roachpb::ClearRangeResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.clear_range)
  return value_.clear_range_;
}

// .znbase.roachpb.RevertRangeResponse revert_range = 51;
inline bool ResponseUnion::has_revert_range() const {
  return value_case() == kRevertRange;
}
inline void ResponseUnion::set_has_revert_range() {
  _oneof_case_[0] = kRevertRange;
}
inline void ResponseUnion::clear_revert_range() {
  if (has_revert_range()) {
    delete value_.revert_range_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::RevertRangeResponse& ResponseUnion::_internal_revert_range() const {
  return *value_.revert_range_;
}
inline ::znbase::roachpb::RevertRangeResponse* ResponseUnion::release_revert_range() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.revert_range)
  if (has_revert_range()) {
    clear_has_value();
      ::znbase::roachpb::RevertRangeResponse* temp = value_.revert_range_;
    value_.revert_range_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::RevertRangeResponse& ResponseUnion::revert_range() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.revert_range)
  return has_revert_range()
      ? *value_.revert_range_
      : *reinterpret_cast< ::znbase::roachpb::RevertRangeResponse*>(&::znbase::roachpb::_RevertRangeResponse_default_instance_);
}
inline ::znbase::roachpb::RevertRangeResponse* ResponseUnion::mutable_revert_range() {
  if (!has_revert_range()) {
    clear_value();
    set_has_revert_range();
    value_.revert_range_ = CreateMaybeMessage< ::znbase::roachpb::RevertRangeResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.revert_range)
  return value_.revert_range_;
}

// .znbase.roachpb.ScanResponse scan = 7;
inline bool ResponseUnion::has_scan() const {
  return value_case() == kScan;
}
inline void ResponseUnion::set_has_scan() {
  _oneof_case_[0] = kScan;
}
inline void ResponseUnion::clear_scan() {
  if (has_scan()) {
    delete value_.scan_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::ScanResponse& ResponseUnion::_internal_scan() const {
  return *value_.scan_;
}
inline ::znbase::roachpb::ScanResponse* ResponseUnion::release_scan() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.scan)
  if (has_scan()) {
    clear_has_value();
      ::znbase::roachpb::ScanResponse* temp = value_.scan_;
    value_.scan_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::ScanResponse& ResponseUnion::scan() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.scan)
  return has_scan()
      ? *value_.scan_
      : *reinterpret_cast< ::znbase::roachpb::ScanResponse*>(&::znbase::roachpb::_ScanResponse_default_instance_);
}
inline ::znbase::roachpb::ScanResponse* ResponseUnion::mutable_scan() {
  if (!has_scan()) {
    clear_value();
    set_has_scan();
    value_.scan_ = CreateMaybeMessage< ::znbase::roachpb::ScanResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.scan)
  return value_.scan_;
}

// .znbase.roachpb.EndTransactionResponse end_transaction = 9;
inline bool ResponseUnion::has_end_transaction() const {
  return value_case() == kEndTransaction;
}
inline void ResponseUnion::set_has_end_transaction() {
  _oneof_case_[0] = kEndTransaction;
}
inline void ResponseUnion::clear_end_transaction() {
  if (has_end_transaction()) {
    delete value_.end_transaction_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::EndTransactionResponse& ResponseUnion::_internal_end_transaction() const {
  return *value_.end_transaction_;
}
inline ::znbase::roachpb::EndTransactionResponse* ResponseUnion::release_end_transaction() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.end_transaction)
  if (has_end_transaction()) {
    clear_has_value();
      ::znbase::roachpb::EndTransactionResponse* temp = value_.end_transaction_;
    value_.end_transaction_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::EndTransactionResponse& ResponseUnion::end_transaction() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.end_transaction)
  return has_end_transaction()
      ? *value_.end_transaction_
      : *reinterpret_cast< ::znbase::roachpb::EndTransactionResponse*>(&::znbase::roachpb::_EndTransactionResponse_default_instance_);
}
inline ::znbase::roachpb::EndTransactionResponse* ResponseUnion::mutable_end_transaction() {
  if (!has_end_transaction()) {
    clear_value();
    set_has_end_transaction();
    value_.end_transaction_ = CreateMaybeMessage< ::znbase::roachpb::EndTransactionResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.end_transaction)
  return value_.end_transaction_;
}

// .znbase.roachpb.AdminSplitResponse admin_split = 10;
inline bool ResponseUnion::has_admin_split() const {
  return value_case() == kAdminSplit;
}
inline void ResponseUnion::set_has_admin_split() {
  _oneof_case_[0] = kAdminSplit;
}
inline void ResponseUnion::clear_admin_split() {
  if (has_admin_split()) {
    delete value_.admin_split_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::AdminSplitResponse& ResponseUnion::_internal_admin_split() const {
  return *value_.admin_split_;
}
inline ::znbase::roachpb::AdminSplitResponse* ResponseUnion::release_admin_split() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.admin_split)
  if (has_admin_split()) {
    clear_has_value();
      ::znbase::roachpb::AdminSplitResponse* temp = value_.admin_split_;
    value_.admin_split_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::AdminSplitResponse& ResponseUnion::admin_split() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.admin_split)
  return has_admin_split()
      ? *value_.admin_split_
      : *reinterpret_cast< ::znbase::roachpb::AdminSplitResponse*>(&::znbase::roachpb::_AdminSplitResponse_default_instance_);
}
inline ::znbase::roachpb::AdminSplitResponse* ResponseUnion::mutable_admin_split() {
  if (!has_admin_split()) {
    clear_value();
    set_has_admin_split();
    value_.admin_split_ = CreateMaybeMessage< ::znbase::roachpb::AdminSplitResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.admin_split)
  return value_.admin_split_;
}

// .znbase.roachpb.AdminMergeResponse admin_merge = 11;
inline bool ResponseUnion::has_admin_merge() const {
  return value_case() == kAdminMerge;
}
inline void ResponseUnion::set_has_admin_merge() {
  _oneof_case_[0] = kAdminMerge;
}
inline void ResponseUnion::clear_admin_merge() {
  if (has_admin_merge()) {
    delete value_.admin_merge_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::AdminMergeResponse& ResponseUnion::_internal_admin_merge() const {
  return *value_.admin_merge_;
}
inline ::znbase::roachpb::AdminMergeResponse* ResponseUnion::release_admin_merge() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.admin_merge)
  if (has_admin_merge()) {
    clear_has_value();
      ::znbase::roachpb::AdminMergeResponse* temp = value_.admin_merge_;
    value_.admin_merge_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::AdminMergeResponse& ResponseUnion::admin_merge() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.admin_merge)
  return has_admin_merge()
      ? *value_.admin_merge_
      : *reinterpret_cast< ::znbase::roachpb::AdminMergeResponse*>(&::znbase::roachpb::_AdminMergeResponse_default_instance_);
}
inline ::znbase::roachpb::AdminMergeResponse* ResponseUnion::mutable_admin_merge() {
  if (!has_admin_merge()) {
    clear_value();
    set_has_admin_merge();
    value_.admin_merge_ = CreateMaybeMessage< ::znbase::roachpb::AdminMergeResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.admin_merge)
  return value_.admin_merge_;
}

// .znbase.roachpb.AdminTransferLeaseResponse admin_transfer_lease = 29;
inline bool ResponseUnion::has_admin_transfer_lease() const {
  return value_case() == kAdminTransferLease;
}
inline void ResponseUnion::set_has_admin_transfer_lease() {
  _oneof_case_[0] = kAdminTransferLease;
}
inline void ResponseUnion::clear_admin_transfer_lease() {
  if (has_admin_transfer_lease()) {
    delete value_.admin_transfer_lease_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::AdminTransferLeaseResponse& ResponseUnion::_internal_admin_transfer_lease() const {
  return *value_.admin_transfer_lease_;
}
inline ::znbase::roachpb::AdminTransferLeaseResponse* ResponseUnion::release_admin_transfer_lease() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.admin_transfer_lease)
  if (has_admin_transfer_lease()) {
    clear_has_value();
      ::znbase::roachpb::AdminTransferLeaseResponse* temp = value_.admin_transfer_lease_;
    value_.admin_transfer_lease_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::AdminTransferLeaseResponse& ResponseUnion::admin_transfer_lease() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.admin_transfer_lease)
  return has_admin_transfer_lease()
      ? *value_.admin_transfer_lease_
      : *reinterpret_cast< ::znbase::roachpb::AdminTransferLeaseResponse*>(&::znbase::roachpb::_AdminTransferLeaseResponse_default_instance_);
}
inline ::znbase::roachpb::AdminTransferLeaseResponse* ResponseUnion::mutable_admin_transfer_lease() {
  if (!has_admin_transfer_lease()) {
    clear_value();
    set_has_admin_transfer_lease();
    value_.admin_transfer_lease_ = CreateMaybeMessage< ::znbase::roachpb::AdminTransferLeaseResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.admin_transfer_lease)
  return value_.admin_transfer_lease_;
}

// .znbase.roachpb.AdminChangeReplicasResponse admin_change_replicas = 35;
inline bool ResponseUnion::has_admin_change_replicas() const {
  return value_case() == kAdminChangeReplicas;
}
inline void ResponseUnion::set_has_admin_change_replicas() {
  _oneof_case_[0] = kAdminChangeReplicas;
}
inline void ResponseUnion::clear_admin_change_replicas() {
  if (has_admin_change_replicas()) {
    delete value_.admin_change_replicas_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::AdminChangeReplicasResponse& ResponseUnion::_internal_admin_change_replicas() const {
  return *value_.admin_change_replicas_;
}
inline ::znbase::roachpb::AdminChangeReplicasResponse* ResponseUnion::release_admin_change_replicas() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.admin_change_replicas)
  if (has_admin_change_replicas()) {
    clear_has_value();
      ::znbase::roachpb::AdminChangeReplicasResponse* temp = value_.admin_change_replicas_;
    value_.admin_change_replicas_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::AdminChangeReplicasResponse& ResponseUnion::admin_change_replicas() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.admin_change_replicas)
  return has_admin_change_replicas()
      ? *value_.admin_change_replicas_
      : *reinterpret_cast< ::znbase::roachpb::AdminChangeReplicasResponse*>(&::znbase::roachpb::_AdminChangeReplicasResponse_default_instance_);
}
inline ::znbase::roachpb::AdminChangeReplicasResponse* ResponseUnion::mutable_admin_change_replicas() {
  if (!has_admin_change_replicas()) {
    clear_value();
    set_has_admin_change_replicas();
    value_.admin_change_replicas_ = CreateMaybeMessage< ::znbase::roachpb::AdminChangeReplicasResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.admin_change_replicas)
  return value_.admin_change_replicas_;
}

// .znbase.roachpb.AdminRelocateRangeResponse admin_relocate_range = 45;
inline bool ResponseUnion::has_admin_relocate_range() const {
  return value_case() == kAdminRelocateRange;
}
inline void ResponseUnion::set_has_admin_relocate_range() {
  _oneof_case_[0] = kAdminRelocateRange;
}
inline void ResponseUnion::clear_admin_relocate_range() {
  if (has_admin_relocate_range()) {
    delete value_.admin_relocate_range_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::AdminRelocateRangeResponse& ResponseUnion::_internal_admin_relocate_range() const {
  return *value_.admin_relocate_range_;
}
inline ::znbase::roachpb::AdminRelocateRangeResponse* ResponseUnion::release_admin_relocate_range() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.admin_relocate_range)
  if (has_admin_relocate_range()) {
    clear_has_value();
      ::znbase::roachpb::AdminRelocateRangeResponse* temp = value_.admin_relocate_range_;
    value_.admin_relocate_range_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::AdminRelocateRangeResponse& ResponseUnion::admin_relocate_range() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.admin_relocate_range)
  return has_admin_relocate_range()
      ? *value_.admin_relocate_range_
      : *reinterpret_cast< ::znbase::roachpb::AdminRelocateRangeResponse*>(&::znbase::roachpb::_AdminRelocateRangeResponse_default_instance_);
}
inline ::znbase::roachpb::AdminRelocateRangeResponse* ResponseUnion::mutable_admin_relocate_range() {
  if (!has_admin_relocate_range()) {
    clear_value();
    set_has_admin_relocate_range();
    value_.admin_relocate_range_ = CreateMaybeMessage< ::znbase::roachpb::AdminRelocateRangeResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.admin_relocate_range)
  return value_.admin_relocate_range_;
}

// .znbase.roachpb.HeartbeatTxnResponse heartbeat_txn = 12;
inline bool ResponseUnion::has_heartbeat_txn() const {
  return value_case() == kHeartbeatTxn;
}
inline void ResponseUnion::set_has_heartbeat_txn() {
  _oneof_case_[0] = kHeartbeatTxn;
}
inline void ResponseUnion::clear_heartbeat_txn() {
  if (has_heartbeat_txn()) {
    delete value_.heartbeat_txn_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::HeartbeatTxnResponse& ResponseUnion::_internal_heartbeat_txn() const {
  return *value_.heartbeat_txn_;
}
inline ::znbase::roachpb::HeartbeatTxnResponse* ResponseUnion::release_heartbeat_txn() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.heartbeat_txn)
  if (has_heartbeat_txn()) {
    clear_has_value();
      ::znbase::roachpb::HeartbeatTxnResponse* temp = value_.heartbeat_txn_;
    value_.heartbeat_txn_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::HeartbeatTxnResponse& ResponseUnion::heartbeat_txn() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.heartbeat_txn)
  return has_heartbeat_txn()
      ? *value_.heartbeat_txn_
      : *reinterpret_cast< ::znbase::roachpb::HeartbeatTxnResponse*>(&::znbase::roachpb::_HeartbeatTxnResponse_default_instance_);
}
inline ::znbase::roachpb::HeartbeatTxnResponse* ResponseUnion::mutable_heartbeat_txn() {
  if (!has_heartbeat_txn()) {
    clear_value();
    set_has_heartbeat_txn();
    value_.heartbeat_txn_ = CreateMaybeMessage< ::znbase::roachpb::HeartbeatTxnResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.heartbeat_txn)
  return value_.heartbeat_txn_;
}

// .znbase.roachpb.GCResponse gc = 13;
inline bool ResponseUnion::has_gc() const {
  return value_case() == kGc;
}
inline void ResponseUnion::set_has_gc() {
  _oneof_case_[0] = kGc;
}
inline void ResponseUnion::clear_gc() {
  if (has_gc()) {
    delete value_.gc_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::GCResponse& ResponseUnion::_internal_gc() const {
  return *value_.gc_;
}
inline ::znbase::roachpb::GCResponse* ResponseUnion::release_gc() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.gc)
  if (has_gc()) {
    clear_has_value();
      ::znbase::roachpb::GCResponse* temp = value_.gc_;
    value_.gc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::GCResponse& ResponseUnion::gc() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.gc)
  return has_gc()
      ? *value_.gc_
      : *reinterpret_cast< ::znbase::roachpb::GCResponse*>(&::znbase::roachpb::_GCResponse_default_instance_);
}
inline ::znbase::roachpb::GCResponse* ResponseUnion::mutable_gc() {
  if (!has_gc()) {
    clear_value();
    set_has_gc();
    value_.gc_ = CreateMaybeMessage< ::znbase::roachpb::GCResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.gc)
  return value_.gc_;
}

// .znbase.roachpb.PushTxnResponse push_txn = 14;
inline bool ResponseUnion::has_push_txn() const {
  return value_case() == kPushTxn;
}
inline void ResponseUnion::set_has_push_txn() {
  _oneof_case_[0] = kPushTxn;
}
inline void ResponseUnion::clear_push_txn() {
  if (has_push_txn()) {
    delete value_.push_txn_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::PushTxnResponse& ResponseUnion::_internal_push_txn() const {
  return *value_.push_txn_;
}
inline ::znbase::roachpb::PushTxnResponse* ResponseUnion::release_push_txn() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.push_txn)
  if (has_push_txn()) {
    clear_has_value();
      ::znbase::roachpb::PushTxnResponse* temp = value_.push_txn_;
    value_.push_txn_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::PushTxnResponse& ResponseUnion::push_txn() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.push_txn)
  return has_push_txn()
      ? *value_.push_txn_
      : *reinterpret_cast< ::znbase::roachpb::PushTxnResponse*>(&::znbase::roachpb::_PushTxnResponse_default_instance_);
}
inline ::znbase::roachpb::PushTxnResponse* ResponseUnion::mutable_push_txn() {
  if (!has_push_txn()) {
    clear_value();
    set_has_push_txn();
    value_.push_txn_ = CreateMaybeMessage< ::znbase::roachpb::PushTxnResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.push_txn)
  return value_.push_txn_;
}

// .znbase.roachpb.RecoverTxnResponse recover_txn = 46;
inline bool ResponseUnion::has_recover_txn() const {
  return value_case() == kRecoverTxn;
}
inline void ResponseUnion::set_has_recover_txn() {
  _oneof_case_[0] = kRecoverTxn;
}
inline void ResponseUnion::clear_recover_txn() {
  if (has_recover_txn()) {
    delete value_.recover_txn_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::RecoverTxnResponse& ResponseUnion::_internal_recover_txn() const {
  return *value_.recover_txn_;
}
inline ::znbase::roachpb::RecoverTxnResponse* ResponseUnion::release_recover_txn() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.recover_txn)
  if (has_recover_txn()) {
    clear_has_value();
      ::znbase::roachpb::RecoverTxnResponse* temp = value_.recover_txn_;
    value_.recover_txn_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::RecoverTxnResponse& ResponseUnion::recover_txn() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.recover_txn)
  return has_recover_txn()
      ? *value_.recover_txn_
      : *reinterpret_cast< ::znbase::roachpb::RecoverTxnResponse*>(&::znbase::roachpb::_RecoverTxnResponse_default_instance_);
}
inline ::znbase::roachpb::RecoverTxnResponse* ResponseUnion::mutable_recover_txn() {
  if (!has_recover_txn()) {
    clear_value();
    set_has_recover_txn();
    value_.recover_txn_ = CreateMaybeMessage< ::znbase::roachpb::RecoverTxnResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.recover_txn)
  return value_.recover_txn_;
}

// .znbase.roachpb.ResolveIntentResponse resolve_intent = 16;
inline bool ResponseUnion::has_resolve_intent() const {
  return value_case() == kResolveIntent;
}
inline void ResponseUnion::set_has_resolve_intent() {
  _oneof_case_[0] = kResolveIntent;
}
inline void ResponseUnion::clear_resolve_intent() {
  if (has_resolve_intent()) {
    delete value_.resolve_intent_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::ResolveIntentResponse& ResponseUnion::_internal_resolve_intent() const {
  return *value_.resolve_intent_;
}
inline ::znbase::roachpb::ResolveIntentResponse* ResponseUnion::release_resolve_intent() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.resolve_intent)
  if (has_resolve_intent()) {
    clear_has_value();
      ::znbase::roachpb::ResolveIntentResponse* temp = value_.resolve_intent_;
    value_.resolve_intent_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::ResolveIntentResponse& ResponseUnion::resolve_intent() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.resolve_intent)
  return has_resolve_intent()
      ? *value_.resolve_intent_
      : *reinterpret_cast< ::znbase::roachpb::ResolveIntentResponse*>(&::znbase::roachpb::_ResolveIntentResponse_default_instance_);
}
inline ::znbase::roachpb::ResolveIntentResponse* ResponseUnion::mutable_resolve_intent() {
  if (!has_resolve_intent()) {
    clear_value();
    set_has_resolve_intent();
    value_.resolve_intent_ = CreateMaybeMessage< ::znbase::roachpb::ResolveIntentResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.resolve_intent)
  return value_.resolve_intent_;
}

// .znbase.roachpb.ResolveIntentRangeResponse resolve_intent_range = 17;
inline bool ResponseUnion::has_resolve_intent_range() const {
  return value_case() == kResolveIntentRange;
}
inline void ResponseUnion::set_has_resolve_intent_range() {
  _oneof_case_[0] = kResolveIntentRange;
}
inline void ResponseUnion::clear_resolve_intent_range() {
  if (has_resolve_intent_range()) {
    delete value_.resolve_intent_range_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::ResolveIntentRangeResponse& ResponseUnion::_internal_resolve_intent_range() const {
  return *value_.resolve_intent_range_;
}
inline ::znbase::roachpb::ResolveIntentRangeResponse* ResponseUnion::release_resolve_intent_range() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.resolve_intent_range)
  if (has_resolve_intent_range()) {
    clear_has_value();
      ::znbase::roachpb::ResolveIntentRangeResponse* temp = value_.resolve_intent_range_;
    value_.resolve_intent_range_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::ResolveIntentRangeResponse& ResponseUnion::resolve_intent_range() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.resolve_intent_range)
  return has_resolve_intent_range()
      ? *value_.resolve_intent_range_
      : *reinterpret_cast< ::znbase::roachpb::ResolveIntentRangeResponse*>(&::znbase::roachpb::_ResolveIntentRangeResponse_default_instance_);
}
inline ::znbase::roachpb::ResolveIntentRangeResponse* ResponseUnion::mutable_resolve_intent_range() {
  if (!has_resolve_intent_range()) {
    clear_value();
    set_has_resolve_intent_range();
    value_.resolve_intent_range_ = CreateMaybeMessage< ::znbase::roachpb::ResolveIntentRangeResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.resolve_intent_range)
  return value_.resolve_intent_range_;
}

// .znbase.roachpb.MergeResponse merge = 18;
inline bool ResponseUnion::has_merge() const {
  return value_case() == kMerge;
}
inline void ResponseUnion::set_has_merge() {
  _oneof_case_[0] = kMerge;
}
inline void ResponseUnion::clear_merge() {
  if (has_merge()) {
    delete value_.merge_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::MergeResponse& ResponseUnion::_internal_merge() const {
  return *value_.merge_;
}
inline ::znbase::roachpb::MergeResponse* ResponseUnion::release_merge() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.merge)
  if (has_merge()) {
    clear_has_value();
      ::znbase::roachpb::MergeResponse* temp = value_.merge_;
    value_.merge_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::MergeResponse& ResponseUnion::merge() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.merge)
  return has_merge()
      ? *value_.merge_
      : *reinterpret_cast< ::znbase::roachpb::MergeResponse*>(&::znbase::roachpb::_MergeResponse_default_instance_);
}
inline ::znbase::roachpb::MergeResponse* ResponseUnion::mutable_merge() {
  if (!has_merge()) {
    clear_value();
    set_has_merge();
    value_.merge_ = CreateMaybeMessage< ::znbase::roachpb::MergeResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.merge)
  return value_.merge_;
}

// .znbase.roachpb.TruncateLogResponse truncate_log = 19;
inline bool ResponseUnion::has_truncate_log() const {
  return value_case() == kTruncateLog;
}
inline void ResponseUnion::set_has_truncate_log() {
  _oneof_case_[0] = kTruncateLog;
}
inline void ResponseUnion::clear_truncate_log() {
  if (has_truncate_log()) {
    delete value_.truncate_log_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::TruncateLogResponse& ResponseUnion::_internal_truncate_log() const {
  return *value_.truncate_log_;
}
inline ::znbase::roachpb::TruncateLogResponse* ResponseUnion::release_truncate_log() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.truncate_log)
  if (has_truncate_log()) {
    clear_has_value();
      ::znbase::roachpb::TruncateLogResponse* temp = value_.truncate_log_;
    value_.truncate_log_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::TruncateLogResponse& ResponseUnion::truncate_log() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.truncate_log)
  return has_truncate_log()
      ? *value_.truncate_log_
      : *reinterpret_cast< ::znbase::roachpb::TruncateLogResponse*>(&::znbase::roachpb::_TruncateLogResponse_default_instance_);
}
inline ::znbase::roachpb::TruncateLogResponse* ResponseUnion::mutable_truncate_log() {
  if (!has_truncate_log()) {
    clear_value();
    set_has_truncate_log();
    value_.truncate_log_ = CreateMaybeMessage< ::znbase::roachpb::TruncateLogResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.truncate_log)
  return value_.truncate_log_;
}

// .znbase.roachpb.RequestLeaseResponse request_lease = 20;
inline bool ResponseUnion::has_request_lease() const {
  return value_case() == kRequestLease;
}
inline void ResponseUnion::set_has_request_lease() {
  _oneof_case_[0] = kRequestLease;
}
inline void ResponseUnion::clear_request_lease() {
  if (has_request_lease()) {
    delete value_.request_lease_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::RequestLeaseResponse& ResponseUnion::_internal_request_lease() const {
  return *value_.request_lease_;
}
inline ::znbase::roachpb::RequestLeaseResponse* ResponseUnion::release_request_lease() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.request_lease)
  if (has_request_lease()) {
    clear_has_value();
      ::znbase::roachpb::RequestLeaseResponse* temp = value_.request_lease_;
    value_.request_lease_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::RequestLeaseResponse& ResponseUnion::request_lease() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.request_lease)
  return has_request_lease()
      ? *value_.request_lease_
      : *reinterpret_cast< ::znbase::roachpb::RequestLeaseResponse*>(&::znbase::roachpb::_RequestLeaseResponse_default_instance_);
}
inline ::znbase::roachpb::RequestLeaseResponse* ResponseUnion::mutable_request_lease() {
  if (!has_request_lease()) {
    clear_value();
    set_has_request_lease();
    value_.request_lease_ = CreateMaybeMessage< ::znbase::roachpb::RequestLeaseResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.request_lease)
  return value_.request_lease_;
}

// .znbase.roachpb.ReverseScanResponse reverse_scan = 21;
inline bool ResponseUnion::has_reverse_scan() const {
  return value_case() == kReverseScan;
}
inline void ResponseUnion::set_has_reverse_scan() {
  _oneof_case_[0] = kReverseScan;
}
inline void ResponseUnion::clear_reverse_scan() {
  if (has_reverse_scan()) {
    delete value_.reverse_scan_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::ReverseScanResponse& ResponseUnion::_internal_reverse_scan() const {
  return *value_.reverse_scan_;
}
inline ::znbase::roachpb::ReverseScanResponse* ResponseUnion::release_reverse_scan() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.reverse_scan)
  if (has_reverse_scan()) {
    clear_has_value();
      ::znbase::roachpb::ReverseScanResponse* temp = value_.reverse_scan_;
    value_.reverse_scan_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::ReverseScanResponse& ResponseUnion::reverse_scan() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.reverse_scan)
  return has_reverse_scan()
      ? *value_.reverse_scan_
      : *reinterpret_cast< ::znbase::roachpb::ReverseScanResponse*>(&::znbase::roachpb::_ReverseScanResponse_default_instance_);
}
inline ::znbase::roachpb::ReverseScanResponse* ResponseUnion::mutable_reverse_scan() {
  if (!has_reverse_scan()) {
    clear_value();
    set_has_reverse_scan();
    value_.reverse_scan_ = CreateMaybeMessage< ::znbase::roachpb::ReverseScanResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.reverse_scan)
  return value_.reverse_scan_;
}

// .znbase.roachpb.ComputeChecksumResponse compute_checksum = 22;
inline bool ResponseUnion::has_compute_checksum() const {
  return value_case() == kComputeChecksum;
}
inline void ResponseUnion::set_has_compute_checksum() {
  _oneof_case_[0] = kComputeChecksum;
}
inline void ResponseUnion::clear_compute_checksum() {
  if (has_compute_checksum()) {
    delete value_.compute_checksum_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::ComputeChecksumResponse& ResponseUnion::_internal_compute_checksum() const {
  return *value_.compute_checksum_;
}
inline ::znbase::roachpb::ComputeChecksumResponse* ResponseUnion::release_compute_checksum() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.compute_checksum)
  if (has_compute_checksum()) {
    clear_has_value();
      ::znbase::roachpb::ComputeChecksumResponse* temp = value_.compute_checksum_;
    value_.compute_checksum_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::ComputeChecksumResponse& ResponseUnion::compute_checksum() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.compute_checksum)
  return has_compute_checksum()
      ? *value_.compute_checksum_
      : *reinterpret_cast< ::znbase::roachpb::ComputeChecksumResponse*>(&::znbase::roachpb::_ComputeChecksumResponse_default_instance_);
}
inline ::znbase::roachpb::ComputeChecksumResponse* ResponseUnion::mutable_compute_checksum() {
  if (!has_compute_checksum()) {
    clear_value();
    set_has_compute_checksum();
    value_.compute_checksum_ = CreateMaybeMessage< ::znbase::roachpb::ComputeChecksumResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.compute_checksum)
  return value_.compute_checksum_;
}

// .znbase.roachpb.CheckConsistencyResponse check_consistency = 24;
inline bool ResponseUnion::has_check_consistency() const {
  return value_case() == kCheckConsistency;
}
inline void ResponseUnion::set_has_check_consistency() {
  _oneof_case_[0] = kCheckConsistency;
}
inline void ResponseUnion::clear_check_consistency() {
  if (has_check_consistency()) {
    delete value_.check_consistency_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::CheckConsistencyResponse& ResponseUnion::_internal_check_consistency() const {
  return *value_.check_consistency_;
}
inline ::znbase::roachpb::CheckConsistencyResponse* ResponseUnion::release_check_consistency() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.check_consistency)
  if (has_check_consistency()) {
    clear_has_value();
      ::znbase::roachpb::CheckConsistencyResponse* temp = value_.check_consistency_;
    value_.check_consistency_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::CheckConsistencyResponse& ResponseUnion::check_consistency() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.check_consistency)
  return has_check_consistency()
      ? *value_.check_consistency_
      : *reinterpret_cast< ::znbase::roachpb::CheckConsistencyResponse*>(&::znbase::roachpb::_CheckConsistencyResponse_default_instance_);
}
inline ::znbase::roachpb::CheckConsistencyResponse* ResponseUnion::mutable_check_consistency() {
  if (!has_check_consistency()) {
    clear_value();
    set_has_check_consistency();
    value_.check_consistency_ = CreateMaybeMessage< ::znbase::roachpb::CheckConsistencyResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.check_consistency)
  return value_.check_consistency_;
}

// .znbase.roachpb.InitPutResponse init_put = 26;
inline bool ResponseUnion::has_init_put() const {
  return value_case() == kInitPut;
}
inline void ResponseUnion::set_has_init_put() {
  _oneof_case_[0] = kInitPut;
}
inline void ResponseUnion::clear_init_put() {
  if (has_init_put()) {
    delete value_.init_put_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::InitPutResponse& ResponseUnion::_internal_init_put() const {
  return *value_.init_put_;
}
inline ::znbase::roachpb::InitPutResponse* ResponseUnion::release_init_put() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.init_put)
  if (has_init_put()) {
    clear_has_value();
      ::znbase::roachpb::InitPutResponse* temp = value_.init_put_;
    value_.init_put_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::InitPutResponse& ResponseUnion::init_put() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.init_put)
  return has_init_put()
      ? *value_.init_put_
      : *reinterpret_cast< ::znbase::roachpb::InitPutResponse*>(&::znbase::roachpb::_InitPutResponse_default_instance_);
}
inline ::znbase::roachpb::InitPutResponse* ResponseUnion::mutable_init_put() {
  if (!has_init_put()) {
    clear_value();
    set_has_init_put();
    value_.init_put_ = CreateMaybeMessage< ::znbase::roachpb::InitPutResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.init_put)
  return value_.init_put_;
}

// .znbase.roachpb.LeaseInfoResponse lease_info = 30;
inline bool ResponseUnion::has_lease_info() const {
  return value_case() == kLeaseInfo;
}
inline void ResponseUnion::set_has_lease_info() {
  _oneof_case_[0] = kLeaseInfo;
}
inline void ResponseUnion::clear_lease_info() {
  if (has_lease_info()) {
    delete value_.lease_info_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::LeaseInfoResponse& ResponseUnion::_internal_lease_info() const {
  return *value_.lease_info_;
}
inline ::znbase::roachpb::LeaseInfoResponse* ResponseUnion::release_lease_info() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.lease_info)
  if (has_lease_info()) {
    clear_has_value();
      ::znbase::roachpb::LeaseInfoResponse* temp = value_.lease_info_;
    value_.lease_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::LeaseInfoResponse& ResponseUnion::lease_info() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.lease_info)
  return has_lease_info()
      ? *value_.lease_info_
      : *reinterpret_cast< ::znbase::roachpb::LeaseInfoResponse*>(&::znbase::roachpb::_LeaseInfoResponse_default_instance_);
}
inline ::znbase::roachpb::LeaseInfoResponse* ResponseUnion::mutable_lease_info() {
  if (!has_lease_info()) {
    clear_value();
    set_has_lease_info();
    value_.lease_info_ = CreateMaybeMessage< ::znbase::roachpb::LeaseInfoResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.lease_info)
  return value_.lease_info_;
}

// .znbase.roachpb.WriteBatchResponse write_batch = 31;
inline bool ResponseUnion::has_write_batch() const {
  return value_case() == kWriteBatch;
}
inline void ResponseUnion::set_has_write_batch() {
  _oneof_case_[0] = kWriteBatch;
}
inline void ResponseUnion::clear_write_batch() {
  if (has_write_batch()) {
    delete value_.write_batch_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::WriteBatchResponse& ResponseUnion::_internal_write_batch() const {
  return *value_.write_batch_;
}
inline ::znbase::roachpb::WriteBatchResponse* ResponseUnion::release_write_batch() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.write_batch)
  if (has_write_batch()) {
    clear_has_value();
      ::znbase::roachpb::WriteBatchResponse* temp = value_.write_batch_;
    value_.write_batch_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::WriteBatchResponse& ResponseUnion::write_batch() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.write_batch)
  return has_write_batch()
      ? *value_.write_batch_
      : *reinterpret_cast< ::znbase::roachpb::WriteBatchResponse*>(&::znbase::roachpb::_WriteBatchResponse_default_instance_);
}
inline ::znbase::roachpb::WriteBatchResponse* ResponseUnion::mutable_write_batch() {
  if (!has_write_batch()) {
    clear_value();
    set_has_write_batch();
    value_.write_batch_ = CreateMaybeMessage< ::znbase::roachpb::WriteBatchResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.write_batch)
  return value_.write_batch_;
}

// .znbase.roachpb.ExportResponse export = 32;
inline bool ResponseUnion::has_export_() const {
  return value_case() == kExport;
}
inline void ResponseUnion::set_has_export_() {
  _oneof_case_[0] = kExport;
}
inline void ResponseUnion::clear_export_() {
  if (has_export_()) {
    delete value_.export__;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::ExportResponse& ResponseUnion::_internal_export_() const {
  return *value_.export__;
}
inline ::znbase::roachpb::ExportResponse* ResponseUnion::release_export_() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.export)
  if (has_export_()) {
    clear_has_value();
      ::znbase::roachpb::ExportResponse* temp = value_.export__;
    value_.export__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::ExportResponse& ResponseUnion::export_() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.export)
  return has_export_()
      ? *value_.export__
      : *reinterpret_cast< ::znbase::roachpb::ExportResponse*>(&::znbase::roachpb::_ExportResponse_default_instance_);
}
inline ::znbase::roachpb::ExportResponse* ResponseUnion::mutable_export_() {
  if (!has_export_()) {
    clear_value();
    set_has_export_();
    value_.export__ = CreateMaybeMessage< ::znbase::roachpb::ExportResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.export)
  return value_.export__;
}

// .znbase.roachpb.ImportResponse import = 34;
inline bool ResponseUnion::has_import() const {
  return value_case() == kImport;
}
inline void ResponseUnion::set_has_import() {
  _oneof_case_[0] = kImport;
}
inline void ResponseUnion::clear_import() {
  if (has_import()) {
    delete value_.import_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::ImportResponse& ResponseUnion::_internal_import() const {
  return *value_.import_;
}
inline ::znbase::roachpb::ImportResponse* ResponseUnion::release_import() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.import)
  if (has_import()) {
    clear_has_value();
      ::znbase::roachpb::ImportResponse* temp = value_.import_;
    value_.import_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::ImportResponse& ResponseUnion::import() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.import)
  return has_import()
      ? *value_.import_
      : *reinterpret_cast< ::znbase::roachpb::ImportResponse*>(&::znbase::roachpb::_ImportResponse_default_instance_);
}
inline ::znbase::roachpb::ImportResponse* ResponseUnion::mutable_import() {
  if (!has_import()) {
    clear_value();
    set_has_import();
    value_.import_ = CreateMaybeMessage< ::znbase::roachpb::ImportResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.import)
  return value_.import_;
}

// .znbase.roachpb.QueryTxnResponse query_txn = 33;
inline bool ResponseUnion::has_query_txn() const {
  return value_case() == kQueryTxn;
}
inline void ResponseUnion::set_has_query_txn() {
  _oneof_case_[0] = kQueryTxn;
}
inline void ResponseUnion::clear_query_txn() {
  if (has_query_txn()) {
    delete value_.query_txn_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::QueryTxnResponse& ResponseUnion::_internal_query_txn() const {
  return *value_.query_txn_;
}
inline ::znbase::roachpb::QueryTxnResponse* ResponseUnion::release_query_txn() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.query_txn)
  if (has_query_txn()) {
    clear_has_value();
      ::znbase::roachpb::QueryTxnResponse* temp = value_.query_txn_;
    value_.query_txn_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::QueryTxnResponse& ResponseUnion::query_txn() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.query_txn)
  return has_query_txn()
      ? *value_.query_txn_
      : *reinterpret_cast< ::znbase::roachpb::QueryTxnResponse*>(&::znbase::roachpb::_QueryTxnResponse_default_instance_);
}
inline ::znbase::roachpb::QueryTxnResponse* ResponseUnion::mutable_query_txn() {
  if (!has_query_txn()) {
    clear_value();
    set_has_query_txn();
    value_.query_txn_ = CreateMaybeMessage< ::znbase::roachpb::QueryTxnResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.query_txn)
  return value_.query_txn_;
}

// .znbase.roachpb.QueryIntentResponse query_intent = 42;
inline bool ResponseUnion::has_query_intent() const {
  return value_case() == kQueryIntent;
}
inline void ResponseUnion::set_has_query_intent() {
  _oneof_case_[0] = kQueryIntent;
}
inline void ResponseUnion::clear_query_intent() {
  if (has_query_intent()) {
    delete value_.query_intent_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::QueryIntentResponse& ResponseUnion::_internal_query_intent() const {
  return *value_.query_intent_;
}
inline ::znbase::roachpb::QueryIntentResponse* ResponseUnion::release_query_intent() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.query_intent)
  if (has_query_intent()) {
    clear_has_value();
      ::znbase::roachpb::QueryIntentResponse* temp = value_.query_intent_;
    value_.query_intent_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::QueryIntentResponse& ResponseUnion::query_intent() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.query_intent)
  return has_query_intent()
      ? *value_.query_intent_
      : *reinterpret_cast< ::znbase::roachpb::QueryIntentResponse*>(&::znbase::roachpb::_QueryIntentResponse_default_instance_);
}
inline ::znbase::roachpb::QueryIntentResponse* ResponseUnion::mutable_query_intent() {
  if (!has_query_intent()) {
    clear_value();
    set_has_query_intent();
    value_.query_intent_ = CreateMaybeMessage< ::znbase::roachpb::QueryIntentResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.query_intent)
  return value_.query_intent_;
}

// .znbase.roachpb.AdminScatterResponse admin_scatter = 36;
inline bool ResponseUnion::has_admin_scatter() const {
  return value_case() == kAdminScatter;
}
inline void ResponseUnion::set_has_admin_scatter() {
  _oneof_case_[0] = kAdminScatter;
}
inline void ResponseUnion::clear_admin_scatter() {
  if (has_admin_scatter()) {
    delete value_.admin_scatter_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::AdminScatterResponse& ResponseUnion::_internal_admin_scatter() const {
  return *value_.admin_scatter_;
}
inline ::znbase::roachpb::AdminScatterResponse* ResponseUnion::release_admin_scatter() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.admin_scatter)
  if (has_admin_scatter()) {
    clear_has_value();
      ::znbase::roachpb::AdminScatterResponse* temp = value_.admin_scatter_;
    value_.admin_scatter_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::AdminScatterResponse& ResponseUnion::admin_scatter() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.admin_scatter)
  return has_admin_scatter()
      ? *value_.admin_scatter_
      : *reinterpret_cast< ::znbase::roachpb::AdminScatterResponse*>(&::znbase::roachpb::_AdminScatterResponse_default_instance_);
}
inline ::znbase::roachpb::AdminScatterResponse* ResponseUnion::mutable_admin_scatter() {
  if (!has_admin_scatter()) {
    clear_value();
    set_has_admin_scatter();
    value_.admin_scatter_ = CreateMaybeMessage< ::znbase::roachpb::AdminScatterResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.admin_scatter)
  return value_.admin_scatter_;
}

// .znbase.roachpb.AddSSTableResponse add_sstable = 37;
inline bool ResponseUnion::has_add_sstable() const {
  return value_case() == kAddSstable;
}
inline void ResponseUnion::set_has_add_sstable() {
  _oneof_case_[0] = kAddSstable;
}
inline void ResponseUnion::clear_add_sstable() {
  if (has_add_sstable()) {
    delete value_.add_sstable_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::AddSSTableResponse& ResponseUnion::_internal_add_sstable() const {
  return *value_.add_sstable_;
}
inline ::znbase::roachpb::AddSSTableResponse* ResponseUnion::release_add_sstable() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.add_sstable)
  if (has_add_sstable()) {
    clear_has_value();
      ::znbase::roachpb::AddSSTableResponse* temp = value_.add_sstable_;
    value_.add_sstable_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::AddSSTableResponse& ResponseUnion::add_sstable() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.add_sstable)
  return has_add_sstable()
      ? *value_.add_sstable_
      : *reinterpret_cast< ::znbase::roachpb::AddSSTableResponse*>(&::znbase::roachpb::_AddSSTableResponse_default_instance_);
}
inline ::znbase::roachpb::AddSSTableResponse* ResponseUnion::mutable_add_sstable() {
  if (!has_add_sstable()) {
    clear_value();
    set_has_add_sstable();
    value_.add_sstable_ = CreateMaybeMessage< ::znbase::roachpb::AddSSTableResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.add_sstable)
  return value_.add_sstable_;
}

// .znbase.roachpb.RecomputeStatsResponse recompute_stats = 39;
inline bool ResponseUnion::has_recompute_stats() const {
  return value_case() == kRecomputeStats;
}
inline void ResponseUnion::set_has_recompute_stats() {
  _oneof_case_[0] = kRecomputeStats;
}
inline void ResponseUnion::clear_recompute_stats() {
  if (has_recompute_stats()) {
    delete value_.recompute_stats_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::RecomputeStatsResponse& ResponseUnion::_internal_recompute_stats() const {
  return *value_.recompute_stats_;
}
inline ::znbase::roachpb::RecomputeStatsResponse* ResponseUnion::release_recompute_stats() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.recompute_stats)
  if (has_recompute_stats()) {
    clear_has_value();
      ::znbase::roachpb::RecomputeStatsResponse* temp = value_.recompute_stats_;
    value_.recompute_stats_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::RecomputeStatsResponse& ResponseUnion::recompute_stats() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.recompute_stats)
  return has_recompute_stats()
      ? *value_.recompute_stats_
      : *reinterpret_cast< ::znbase::roachpb::RecomputeStatsResponse*>(&::znbase::roachpb::_RecomputeStatsResponse_default_instance_);
}
inline ::znbase::roachpb::RecomputeStatsResponse* ResponseUnion::mutable_recompute_stats() {
  if (!has_recompute_stats()) {
    clear_value();
    set_has_recompute_stats();
    value_.recompute_stats_ = CreateMaybeMessage< ::znbase::roachpb::RecomputeStatsResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.recompute_stats)
  return value_.recompute_stats_;
}

// .znbase.roachpb.RefreshResponse refresh = 40;
inline bool ResponseUnion::has_refresh() const {
  return value_case() == kRefresh;
}
inline void ResponseUnion::set_has_refresh() {
  _oneof_case_[0] = kRefresh;
}
inline void ResponseUnion::clear_refresh() {
  if (has_refresh()) {
    delete value_.refresh_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::RefreshResponse& ResponseUnion::_internal_refresh() const {
  return *value_.refresh_;
}
inline ::znbase::roachpb::RefreshResponse* ResponseUnion::release_refresh() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.refresh)
  if (has_refresh()) {
    clear_has_value();
      ::znbase::roachpb::RefreshResponse* temp = value_.refresh_;
    value_.refresh_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::RefreshResponse& ResponseUnion::refresh() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.refresh)
  return has_refresh()
      ? *value_.refresh_
      : *reinterpret_cast< ::znbase::roachpb::RefreshResponse*>(&::znbase::roachpb::_RefreshResponse_default_instance_);
}
inline ::znbase::roachpb::RefreshResponse* ResponseUnion::mutable_refresh() {
  if (!has_refresh()) {
    clear_value();
    set_has_refresh();
    value_.refresh_ = CreateMaybeMessage< ::znbase::roachpb::RefreshResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.refresh)
  return value_.refresh_;
}

// .znbase.roachpb.RefreshRangeResponse refresh_range = 41;
inline bool ResponseUnion::has_refresh_range() const {
  return value_case() == kRefreshRange;
}
inline void ResponseUnion::set_has_refresh_range() {
  _oneof_case_[0] = kRefreshRange;
}
inline void ResponseUnion::clear_refresh_range() {
  if (has_refresh_range()) {
    delete value_.refresh_range_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::RefreshRangeResponse& ResponseUnion::_internal_refresh_range() const {
  return *value_.refresh_range_;
}
inline ::znbase::roachpb::RefreshRangeResponse* ResponseUnion::release_refresh_range() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.refresh_range)
  if (has_refresh_range()) {
    clear_has_value();
      ::znbase::roachpb::RefreshRangeResponse* temp = value_.refresh_range_;
    value_.refresh_range_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::RefreshRangeResponse& ResponseUnion::refresh_range() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.refresh_range)
  return has_refresh_range()
      ? *value_.refresh_range_
      : *reinterpret_cast< ::znbase::roachpb::RefreshRangeResponse*>(&::znbase::roachpb::_RefreshRangeResponse_default_instance_);
}
inline ::znbase::roachpb::RefreshRangeResponse* ResponseUnion::mutable_refresh_range() {
  if (!has_refresh_range()) {
    clear_value();
    set_has_refresh_range();
    value_.refresh_range_ = CreateMaybeMessage< ::znbase::roachpb::RefreshRangeResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.refresh_range)
  return value_.refresh_range_;
}

// .znbase.roachpb.SubsumeResponse subsume = 43;
inline bool ResponseUnion::has_subsume() const {
  return value_case() == kSubsume;
}
inline void ResponseUnion::set_has_subsume() {
  _oneof_case_[0] = kSubsume;
}
inline void ResponseUnion::clear_subsume() {
  if (has_subsume()) {
    delete value_.subsume_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::SubsumeResponse& ResponseUnion::_internal_subsume() const {
  return *value_.subsume_;
}
inline ::znbase::roachpb::SubsumeResponse* ResponseUnion::release_subsume() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.subsume)
  if (has_subsume()) {
    clear_has_value();
      ::znbase::roachpb::SubsumeResponse* temp = value_.subsume_;
    value_.subsume_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::SubsumeResponse& ResponseUnion::subsume() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.subsume)
  return has_subsume()
      ? *value_.subsume_
      : *reinterpret_cast< ::znbase::roachpb::SubsumeResponse*>(&::znbase::roachpb::_SubsumeResponse_default_instance_);
}
inline ::znbase::roachpb::SubsumeResponse* ResponseUnion::mutable_subsume() {
  if (!has_subsume()) {
    clear_value();
    set_has_subsume();
    value_.subsume_ = CreateMaybeMessage< ::znbase::roachpb::SubsumeResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.subsume)
  return value_.subsume_;
}

// .znbase.roachpb.RangeStatsResponse range_stats = 44;
inline bool ResponseUnion::has_range_stats() const {
  return value_case() == kRangeStats;
}
inline void ResponseUnion::set_has_range_stats() {
  _oneof_case_[0] = kRangeStats;
}
inline void ResponseUnion::clear_range_stats() {
  if (has_range_stats()) {
    delete value_.range_stats_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::RangeStatsResponse& ResponseUnion::_internal_range_stats() const {
  return *value_.range_stats_;
}
inline ::znbase::roachpb::RangeStatsResponse* ResponseUnion::release_range_stats() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.range_stats)
  if (has_range_stats()) {
    clear_has_value();
      ::znbase::roachpb::RangeStatsResponse* temp = value_.range_stats_;
    value_.range_stats_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::RangeStatsResponse& ResponseUnion::range_stats() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.range_stats)
  return has_range_stats()
      ? *value_.range_stats_
      : *reinterpret_cast< ::znbase::roachpb::RangeStatsResponse*>(&::znbase::roachpb::_RangeStatsResponse_default_instance_);
}
inline ::znbase::roachpb::RangeStatsResponse* ResponseUnion::mutable_range_stats() {
  if (!has_range_stats()) {
    clear_value();
    set_has_range_stats();
    value_.range_stats_ = CreateMaybeMessage< ::znbase::roachpb::RangeStatsResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.range_stats)
  return value_.range_stats_;
}

// .znbase.roachpb.RevertResponse revert = 48;
inline bool ResponseUnion::has_revert() const {
  return value_case() == kRevert;
}
inline void ResponseUnion::set_has_revert() {
  _oneof_case_[0] = kRevert;
}
inline void ResponseUnion::clear_revert() {
  if (has_revert()) {
    delete value_.revert_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::RevertResponse& ResponseUnion::_internal_revert() const {
  return *value_.revert_;
}
inline ::znbase::roachpb::RevertResponse* ResponseUnion::release_revert() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.revert)
  if (has_revert()) {
    clear_has_value();
      ::znbase::roachpb::RevertResponse* temp = value_.revert_;
    value_.revert_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::RevertResponse& ResponseUnion::revert() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.revert)
  return has_revert()
      ? *value_.revert_
      : *reinterpret_cast< ::znbase::roachpb::RevertResponse*>(&::znbase::roachpb::_RevertResponse_default_instance_);
}
inline ::znbase::roachpb::RevertResponse* ResponseUnion::mutable_revert() {
  if (!has_revert()) {
    clear_value();
    set_has_revert();
    value_.revert_ = CreateMaybeMessage< ::znbase::roachpb::RevertResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.revert)
  return value_.revert_;
}

// .znbase.roachpb.DumpResponse dump = 49;
inline bool ResponseUnion::has_dump() const {
  return value_case() == kDump;
}
inline void ResponseUnion::set_has_dump() {
  _oneof_case_[0] = kDump;
}
inline void ResponseUnion::clear_dump() {
  if (has_dump()) {
    delete value_.dump_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::DumpResponse& ResponseUnion::_internal_dump() const {
  return *value_.dump_;
}
inline ::znbase::roachpb::DumpResponse* ResponseUnion::release_dump() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.dump)
  if (has_dump()) {
    clear_has_value();
      ::znbase::roachpb::DumpResponse* temp = value_.dump_;
    value_.dump_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::DumpResponse& ResponseUnion::dump() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.dump)
  return has_dump()
      ? *value_.dump_
      : *reinterpret_cast< ::znbase::roachpb::DumpResponse*>(&::znbase::roachpb::_DumpResponse_default_instance_);
}
inline ::znbase::roachpb::DumpResponse* ResponseUnion::mutable_dump() {
  if (!has_dump()) {
    clear_value();
    set_has_dump();
    value_.dump_ = CreateMaybeMessage< ::znbase::roachpb::DumpResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.dump)
  return value_.dump_;
}

// .znbase.roachpb.LoadResponse load = 47;
inline bool ResponseUnion::has_load() const {
  return value_case() == kLoad;
}
inline void ResponseUnion::set_has_load() {
  _oneof_case_[0] = kLoad;
}
inline void ResponseUnion::clear_load() {
  if (has_load()) {
    delete value_.load_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::LoadResponse& ResponseUnion::_internal_load() const {
  return *value_.load_;
}
inline ::znbase::roachpb::LoadResponse* ResponseUnion::release_load() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.load)
  if (has_load()) {
    clear_has_value();
      ::znbase::roachpb::LoadResponse* temp = value_.load_;
    value_.load_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::LoadResponse& ResponseUnion::load() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.load)
  return has_load()
      ? *value_.load_
      : *reinterpret_cast< ::znbase::roachpb::LoadResponse*>(&::znbase::roachpb::_LoadResponse_default_instance_);
}
inline ::znbase::roachpb::LoadResponse* ResponseUnion::mutable_load() {
  if (!has_load()) {
    clear_value();
    set_has_load();
    value_.load_ = CreateMaybeMessage< ::znbase::roachpb::LoadResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.load)
  return value_.load_;
}

// .znbase.roachpb.DumpOnlineResponse dump_online = 50;
inline bool ResponseUnion::has_dump_online() const {
  return value_case() == kDumpOnline;
}
inline void ResponseUnion::set_has_dump_online() {
  _oneof_case_[0] = kDumpOnline;
}
inline void ResponseUnion::clear_dump_online() {
  if (has_dump_online()) {
    delete value_.dump_online_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::DumpOnlineResponse& ResponseUnion::_internal_dump_online() const {
  return *value_.dump_online_;
}
inline ::znbase::roachpb::DumpOnlineResponse* ResponseUnion::release_dump_online() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.dump_online)
  if (has_dump_online()) {
    clear_has_value();
      ::znbase::roachpb::DumpOnlineResponse* temp = value_.dump_online_;
    value_.dump_online_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::DumpOnlineResponse& ResponseUnion::dump_online() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.dump_online)
  return has_dump_online()
      ? *value_.dump_online_
      : *reinterpret_cast< ::znbase::roachpb::DumpOnlineResponse*>(&::znbase::roachpb::_DumpOnlineResponse_default_instance_);
}
inline ::znbase::roachpb::DumpOnlineResponse* ResponseUnion::mutable_dump_online() {
  if (!has_dump_online()) {
    clear_value();
    set_has_dump_online();
    value_.dump_online_ = CreateMaybeMessage< ::znbase::roachpb::DumpOnlineResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.dump_online)
  return value_.dump_online_;
}

// .znbase.roachpb.ClearIntentResponse clear_intent = 52;
inline bool ResponseUnion::has_clear_intent() const {
  return value_case() == kClearIntent;
}
inline void ResponseUnion::set_has_clear_intent() {
  _oneof_case_[0] = kClearIntent;
}
inline void ResponseUnion::clear_clear_intent() {
  if (has_clear_intent()) {
    delete value_.clear_intent_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::ClearIntentResponse& ResponseUnion::_internal_clear_intent() const {
  return *value_.clear_intent_;
}
inline ::znbase::roachpb::ClearIntentResponse* ResponseUnion::release_clear_intent() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.clear_intent)
  if (has_clear_intent()) {
    clear_has_value();
      ::znbase::roachpb::ClearIntentResponse* temp = value_.clear_intent_;
    value_.clear_intent_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::ClearIntentResponse& ResponseUnion::clear_intent() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.clear_intent)
  return has_clear_intent()
      ? *value_.clear_intent_
      : *reinterpret_cast< ::znbase::roachpb::ClearIntentResponse*>(&::znbase::roachpb::_ClearIntentResponse_default_instance_);
}
inline ::znbase::roachpb::ClearIntentResponse* ResponseUnion::mutable_clear_intent() {
  if (!has_clear_intent()) {
    clear_value();
    set_has_clear_intent();
    value_.clear_intent_ = CreateMaybeMessage< ::znbase::roachpb::ClearIntentResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.clear_intent)
  return value_.clear_intent_;
}

// .znbase.roachpb.QueryLockResponse query_lock = 53;
inline bool ResponseUnion::has_query_lock() const {
  return value_case() == kQueryLock;
}
inline void ResponseUnion::set_has_query_lock() {
  _oneof_case_[0] = kQueryLock;
}
inline void ResponseUnion::clear_query_lock() {
  if (has_query_lock()) {
    delete value_.query_lock_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::QueryLockResponse& ResponseUnion::_internal_query_lock() const {
  return *value_.query_lock_;
}
inline ::znbase::roachpb::QueryLockResponse* ResponseUnion::release_query_lock() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.query_lock)
  if (has_query_lock()) {
    clear_has_value();
      ::znbase::roachpb::QueryLockResponse* temp = value_.query_lock_;
    value_.query_lock_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::QueryLockResponse& ResponseUnion::query_lock() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.query_lock)
  return has_query_lock()
      ? *value_.query_lock_
      : *reinterpret_cast< ::znbase::roachpb::QueryLockResponse*>(&::znbase::roachpb::_QueryLockResponse_default_instance_);
}
inline ::znbase::roachpb::QueryLockResponse* ResponseUnion::mutable_query_lock() {
  if (!has_query_lock()) {
    clear_value();
    set_has_query_lock();
    value_.query_lock_ = CreateMaybeMessage< ::znbase::roachpb::QueryLockResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.query_lock)
  return value_.query_lock_;
}

// .znbase.roachpb.VecScanResponse vec_scan = 54;
inline bool ResponseUnion::has_vec_scan() const {
  return value_case() == kVecScan;
}
inline void ResponseUnion::set_has_vec_scan() {
  _oneof_case_[0] = kVecScan;
}
inline void ResponseUnion::clear_vec_scan() {
  if (has_vec_scan()) {
    delete value_.vec_scan_;
    clear_has_value();
  }
}
inline const ::znbase::roachpb::VecScanResponse& ResponseUnion::_internal_vec_scan() const {
  return *value_.vec_scan_;
}
inline ::znbase::roachpb::VecScanResponse* ResponseUnion::release_vec_scan() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.ResponseUnion.vec_scan)
  if (has_vec_scan()) {
    clear_has_value();
      ::znbase::roachpb::VecScanResponse* temp = value_.vec_scan_;
    value_.vec_scan_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::znbase::roachpb::VecScanResponse& ResponseUnion::vec_scan() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.ResponseUnion.vec_scan)
  return has_vec_scan()
      ? *value_.vec_scan_
      : *reinterpret_cast< ::znbase::roachpb::VecScanResponse*>(&::znbase::roachpb::_VecScanResponse_default_instance_);
}
inline ::znbase::roachpb::VecScanResponse* ResponseUnion::mutable_vec_scan() {
  if (!has_vec_scan()) {
    clear_value();
    set_has_vec_scan();
    value_.vec_scan_ = CreateMaybeMessage< ::znbase::roachpb::VecScanResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.ResponseUnion.vec_scan)
  return value_.vec_scan_;
}

inline bool ResponseUnion::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void ResponseUnion::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline ResponseUnion::ValueCase ResponseUnion::value_case() const {
  return ResponseUnion::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Header

inline bool Header::has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != NULL;
}
inline const ::znbase::util::hlc::Timestamp& Header::_internal_timestamp() const {
  return *timestamp_;
}
inline const ::znbase::util::hlc::Timestamp& Header::timestamp() const {
  const ::znbase::util::hlc::Timestamp* p = timestamp_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.Header.timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::util::hlc::Timestamp*>(
      &::znbase::util::hlc::_Timestamp_default_instance_);
}
inline ::znbase::util::hlc::Timestamp* Header::release_timestamp() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.Header.timestamp)
  
  ::znbase::util::hlc::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline ::znbase::util::hlc::Timestamp* Header::mutable_timestamp() {
  
  if (timestamp_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::util::hlc::Timestamp>(GetArenaNoVirtual());
    timestamp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.Header.timestamp)
  return timestamp_;
}
inline void Header::set_allocated_timestamp(::znbase::util::hlc::Timestamp* timestamp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      timestamp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.Header.timestamp)
}

inline bool Header::has_replica() const {
  return this != internal_default_instance() && replica_ != NULL;
}
inline const ::znbase::roachpb::ReplicaDescriptor& Header::_internal_replica() const {
  return *replica_;
}
inline const ::znbase::roachpb::ReplicaDescriptor& Header::replica() const {
  const ::znbase::roachpb::ReplicaDescriptor* p = replica_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.Header.replica)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ReplicaDescriptor*>(
      &::znbase::roachpb::_ReplicaDescriptor_default_instance_);
}
inline ::znbase::roachpb::ReplicaDescriptor* Header::release_replica() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.Header.replica)
  
  ::znbase::roachpb::ReplicaDescriptor* temp = replica_;
  replica_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ReplicaDescriptor* Header::mutable_replica() {
  
  if (replica_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ReplicaDescriptor>(GetArenaNoVirtual());
    replica_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.Header.replica)
  return replica_;
}
inline void Header::set_allocated_replica(::znbase::roachpb::ReplicaDescriptor* replica) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(replica_);
  }
  if (replica) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      replica = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, replica, submessage_arena);
    }
    
  } else {
    
  }
  replica_ = replica;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.Header.replica)
}

inline void Header::clear_range_id() {
  range_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Header::range_id() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.Header.range_id)
  return range_id_;
}
inline void Header::set_range_id(::google::protobuf::int64 value) {
  
  range_id_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.Header.range_id)
}

inline void Header::clear_user_priority() {
  user_priority_ = 0;
}
inline double Header::user_priority() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.Header.user_priority)
  return user_priority_;
}
inline void Header::set_user_priority(double value) {
  
  user_priority_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.Header.user_priority)
}

// .znbase.roachpb.Transaction txn = 5;
inline bool Header::has_txn() const {
  return this != internal_default_instance() && txn_ != NULL;
}
inline const ::znbase::roachpb::Transaction& Header::_internal_txn() const {
  return *txn_;
}
inline const ::znbase::roachpb::Transaction& Header::txn() const {
  const ::znbase::roachpb::Transaction* p = txn_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.Header.txn)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::Transaction*>(
      &::znbase::roachpb::_Transaction_default_instance_);
}
inline ::znbase::roachpb::Transaction* Header::release_txn() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.Header.txn)
  
  ::znbase::roachpb::Transaction* temp = txn_;
  txn_ = NULL;
  return temp;
}
inline ::znbase::roachpb::Transaction* Header::mutable_txn() {
  
  if (txn_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::Transaction>(GetArenaNoVirtual());
    txn_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.Header.txn)
  return txn_;
}
inline void Header::set_allocated_txn(::znbase::roachpb::Transaction* txn) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(txn_);
  }
  if (txn) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      txn = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, txn, submessage_arena);
    }
    
  } else {
    
  }
  txn_ = txn;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.Header.txn)
}

// .znbase.roachpb.ReadConsistencyType read_consistency = 6;
inline void Header::clear_read_consistency() {
  read_consistency_ = 0;
}
inline ::znbase::roachpb::ReadConsistencyType Header::read_consistency() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.Header.read_consistency)
  return static_cast< ::znbase::roachpb::ReadConsistencyType >(read_consistency_);
}
inline void Header::set_read_consistency(::znbase::roachpb::ReadConsistencyType value) {
  
  read_consistency_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.Header.read_consistency)
}

// int64 max_span_request_keys = 8;
inline void Header::clear_max_span_request_keys() {
  max_span_request_keys_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Header::max_span_request_keys() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.Header.max_span_request_keys)
  return max_span_request_keys_;
}
inline void Header::set_max_span_request_keys(::google::protobuf::int64 value) {
  
  max_span_request_keys_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.Header.max_span_request_keys)
}

// bool distinct_spans = 9;
inline void Header::clear_distinct_spans() {
  distinct_spans_ = false;
}
inline bool Header::distinct_spans() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.Header.distinct_spans)
  return distinct_spans_;
}
inline void Header::set_distinct_spans(bool value) {
  
  distinct_spans_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.Header.distinct_spans)
}

// bool return_range_info = 10;
inline void Header::clear_return_range_info() {
  return_range_info_ = false;
}
inline bool Header::return_range_info() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.Header.return_range_info)
  return return_range_info_;
}
inline void Header::set_return_range_info(bool value) {
  
  return_range_info_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.Header.return_range_info)
}

inline void Header::clear_gateway_node_id() {
  gateway_node_id_ = 0;
}
inline ::google::protobuf::int32 Header::gateway_node_id() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.Header.gateway_node_id)
  return gateway_node_id_;
}
inline void Header::set_gateway_node_id(::google::protobuf::int32 value) {
  
  gateway_node_id_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.Header.gateway_node_id)
}

// .znbase.roachpb.ScanOptions scan_options = 12;
inline bool Header::has_scan_options() const {
  return this != internal_default_instance() && scan_options_ != NULL;
}
inline void Header::clear_scan_options() {
  if (GetArenaNoVirtual() == NULL && scan_options_ != NULL) {
    delete scan_options_;
  }
  scan_options_ = NULL;
}
inline const ::znbase::roachpb::ScanOptions& Header::_internal_scan_options() const {
  return *scan_options_;
}
inline const ::znbase::roachpb::ScanOptions& Header::scan_options() const {
  const ::znbase::roachpb::ScanOptions* p = scan_options_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.Header.scan_options)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ScanOptions*>(
      &::znbase::roachpb::_ScanOptions_default_instance_);
}
inline ::znbase::roachpb::ScanOptions* Header::release_scan_options() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.Header.scan_options)
  
  ::znbase::roachpb::ScanOptions* temp = scan_options_;
  scan_options_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ScanOptions* Header::mutable_scan_options() {
  
  if (scan_options_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ScanOptions>(GetArenaNoVirtual());
    scan_options_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.Header.scan_options)
  return scan_options_;
}
inline void Header::set_allocated_scan_options(::znbase::roachpb::ScanOptions* scan_options) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete scan_options_;
  }
  if (scan_options) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      scan_options = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, scan_options, submessage_arena);
    }
    
  } else {
    
  }
  scan_options_ = scan_options;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.Header.scan_options)
}

// bool async_consensus = 13;
inline void Header::clear_async_consensus() {
  async_consensus_ = false;
}
inline bool Header::async_consensus() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.Header.async_consensus)
  return async_consensus_;
}
inline void Header::set_async_consensus(bool value) {
  
  async_consensus_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.Header.async_consensus)
}

// bool can_forward_read = 16;
inline void Header::clear_can_forward_read() {
  can_forward_read_ = false;
}
inline bool Header::can_forward_read() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.Header.can_forward_read)
  return can_forward_read_;
}
inline void Header::set_can_forward_read(bool value) {
  
  can_forward_read_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.Header.can_forward_read)
}

// .znbase.storage.concurrency.lock.WaitPolicy wait_policy = 18;
inline void Header::clear_wait_policy() {
  wait_policy_ = 0;
}
inline ::znbase::storage::concurrency::lock::WaitPolicy Header::wait_policy() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.Header.wait_policy)
  return static_cast< ::znbase::storage::concurrency::lock::WaitPolicy >(wait_policy_);
}
inline void Header::set_wait_policy(::znbase::storage::concurrency::lock::WaitPolicy value) {
  
  wait_policy_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.Header.wait_policy)
}

inline bool Header::has_wait_time() const {
  return this != internal_default_instance() && wait_time_ != NULL;
}
inline const ::znbase::util::hlc::Timestamp& Header::_internal_wait_time() const {
  return *wait_time_;
}
inline const ::znbase::util::hlc::Timestamp& Header::wait_time() const {
  const ::znbase::util::hlc::Timestamp* p = wait_time_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.Header.wait_time)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::util::hlc::Timestamp*>(
      &::znbase::util::hlc::_Timestamp_default_instance_);
}
inline ::znbase::util::hlc::Timestamp* Header::release_wait_time() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.Header.wait_time)
  
  ::znbase::util::hlc::Timestamp* temp = wait_time_;
  wait_time_ = NULL;
  return temp;
}
inline ::znbase::util::hlc::Timestamp* Header::mutable_wait_time() {
  
  if (wait_time_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::util::hlc::Timestamp>(GetArenaNoVirtual());
    wait_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.Header.wait_time)
  return wait_time_;
}
inline void Header::set_allocated_wait_time(::znbase::util::hlc::Timestamp* wait_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(wait_time_);
  }
  if (wait_time) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      wait_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, wait_time, submessage_arena);
    }
    
  } else {
    
  }
  wait_time_ = wait_time;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.Header.wait_time)
}

// bool back_fill = 19;
inline void Header::clear_back_fill() {
  back_fill_ = false;
}
inline bool Header::back_fill() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.Header.back_fill)
  return back_fill_;
}
inline void Header::set_back_fill(bool value) {
  
  back_fill_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.Header.back_fill)
}

// -------------------------------------------------------------------

// BatchRequest

inline bool BatchRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void BatchRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::Header& BatchRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::Header& BatchRequest::header() const {
  const ::znbase::roachpb::Header* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.BatchRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::Header*>(
      &::znbase::roachpb::_Header_default_instance_);
}
inline ::znbase::roachpb::Header* BatchRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.BatchRequest.header)
  
  ::znbase::roachpb::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::Header* BatchRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::Header>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.BatchRequest.header)
  return header_;
}
inline void BatchRequest::set_allocated_header(::znbase::roachpb::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.BatchRequest.header)
}

inline int BatchRequest::requests_size() const {
  return requests_.size();
}
inline void BatchRequest::clear_requests() {
  requests_.Clear();
}
inline ::znbase::roachpb::RequestUnion* BatchRequest::mutable_requests(int index) {
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.BatchRequest.requests)
  return requests_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::RequestUnion >*
BatchRequest::mutable_requests() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.BatchRequest.requests)
  return &requests_;
}
inline const ::znbase::roachpb::RequestUnion& BatchRequest::requests(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.BatchRequest.requests)
  return requests_.Get(index);
}
inline ::znbase::roachpb::RequestUnion* BatchRequest::add_requests() {
  // @@protoc_insertion_point(field_add:znbase.roachpb.BatchRequest.requests)
  return requests_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::RequestUnion >&
BatchRequest::requests() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.BatchRequest.requests)
  return requests_;
}

inline void BatchRequest::clear_dont_need_meta() {
  dont_need_meta_ = false;
}
inline bool BatchRequest::dont_need_meta() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.BatchRequest.dont_need_meta)
  return dont_need_meta_;
}
inline void BatchRequest::set_dont_need_meta(bool value) {
  
  dont_need_meta_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.BatchRequest.dont_need_meta)
}

// -------------------------------------------------------------------

// BatchResponse_Header

// .znbase.roachpb.Error error = 1;
inline bool BatchResponse_Header::has_error() const {
  return this != internal_default_instance() && error_ != NULL;
}
inline const ::znbase::roachpb::Error& BatchResponse_Header::_internal_error() const {
  return *error_;
}
inline const ::znbase::roachpb::Error& BatchResponse_Header::error() const {
  const ::znbase::roachpb::Error* p = error_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.BatchResponse.Header.error)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::Error*>(
      &::znbase::roachpb::_Error_default_instance_);
}
inline ::znbase::roachpb::Error* BatchResponse_Header::release_error() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.BatchResponse.Header.error)
  
  ::znbase::roachpb::Error* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::znbase::roachpb::Error* BatchResponse_Header::mutable_error() {
  
  if (error_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::Error>(GetArenaNoVirtual());
    error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.BatchResponse.Header.error)
  return error_;
}
inline void BatchResponse_Header::set_allocated_error(::znbase::roachpb::Error* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(error_);
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.BatchResponse.Header.error)
}

inline bool BatchResponse_Header::has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != NULL;
}
inline const ::znbase::util::hlc::Timestamp& BatchResponse_Header::_internal_timestamp() const {
  return *timestamp_;
}
inline const ::znbase::util::hlc::Timestamp& BatchResponse_Header::timestamp() const {
  const ::znbase::util::hlc::Timestamp* p = timestamp_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.BatchResponse.Header.Timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::util::hlc::Timestamp*>(
      &::znbase::util::hlc::_Timestamp_default_instance_);
}
inline ::znbase::util::hlc::Timestamp* BatchResponse_Header::release_timestamp() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.BatchResponse.Header.Timestamp)
  
  ::znbase::util::hlc::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline ::znbase::util::hlc::Timestamp* BatchResponse_Header::mutable_timestamp() {
  
  if (timestamp_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::util::hlc::Timestamp>(GetArenaNoVirtual());
    timestamp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.BatchResponse.Header.Timestamp)
  return timestamp_;
}
inline void BatchResponse_Header::set_allocated_timestamp(::znbase::util::hlc::Timestamp* timestamp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      timestamp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.BatchResponse.Header.Timestamp)
}

// .znbase.roachpb.Transaction txn = 3;
inline bool BatchResponse_Header::has_txn() const {
  return this != internal_default_instance() && txn_ != NULL;
}
inline const ::znbase::roachpb::Transaction& BatchResponse_Header::_internal_txn() const {
  return *txn_;
}
inline const ::znbase::roachpb::Transaction& BatchResponse_Header::txn() const {
  const ::znbase::roachpb::Transaction* p = txn_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.BatchResponse.Header.txn)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::Transaction*>(
      &::znbase::roachpb::_Transaction_default_instance_);
}
inline ::znbase::roachpb::Transaction* BatchResponse_Header::release_txn() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.BatchResponse.Header.txn)
  
  ::znbase::roachpb::Transaction* temp = txn_;
  txn_ = NULL;
  return temp;
}
inline ::znbase::roachpb::Transaction* BatchResponse_Header::mutable_txn() {
  
  if (txn_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::Transaction>(GetArenaNoVirtual());
    txn_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.BatchResponse.Header.txn)
  return txn_;
}
inline void BatchResponse_Header::set_allocated_txn(::znbase::roachpb::Transaction* txn) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(txn_);
  }
  if (txn) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      txn = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, txn, submessage_arena);
    }
    
  } else {
    
  }
  txn_ = txn;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.BatchResponse.Header.txn)
}

inline bool BatchResponse_Header::has_now() const {
  return this != internal_default_instance() && now_ != NULL;
}
inline const ::znbase::util::hlc::Timestamp& BatchResponse_Header::_internal_now() const {
  return *now_;
}
inline const ::znbase::util::hlc::Timestamp& BatchResponse_Header::now() const {
  const ::znbase::util::hlc::Timestamp* p = now_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.BatchResponse.Header.now)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::util::hlc::Timestamp*>(
      &::znbase::util::hlc::_Timestamp_default_instance_);
}
inline ::znbase::util::hlc::Timestamp* BatchResponse_Header::release_now() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.BatchResponse.Header.now)
  
  ::znbase::util::hlc::Timestamp* temp = now_;
  now_ = NULL;
  return temp;
}
inline ::znbase::util::hlc::Timestamp* BatchResponse_Header::mutable_now() {
  
  if (now_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::util::hlc::Timestamp>(GetArenaNoVirtual());
    now_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.BatchResponse.Header.now)
  return now_;
}
inline void BatchResponse_Header::set_allocated_now(::znbase::util::hlc::Timestamp* now) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(now_);
  }
  if (now) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      now = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, now, submessage_arena);
    }
    
  } else {
    
  }
  now_ = now;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.BatchResponse.Header.now)
}

inline int BatchResponse_Header::collected_spans_size() const {
  return collected_spans_.size();
}
inline ::znbase::util::tracing::RecordedSpan* BatchResponse_Header::mutable_collected_spans(int index) {
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.BatchResponse.Header.collected_spans)
  return collected_spans_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::znbase::util::tracing::RecordedSpan >*
BatchResponse_Header::mutable_collected_spans() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.BatchResponse.Header.collected_spans)
  return &collected_spans_;
}
inline const ::znbase::util::tracing::RecordedSpan& BatchResponse_Header::collected_spans(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.BatchResponse.Header.collected_spans)
  return collected_spans_.Get(index);
}
inline ::znbase::util::tracing::RecordedSpan* BatchResponse_Header::add_collected_spans() {
  // @@protoc_insertion_point(field_add:znbase.roachpb.BatchResponse.Header.collected_spans)
  return collected_spans_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::znbase::util::tracing::RecordedSpan >&
BatchResponse_Header::collected_spans() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.BatchResponse.Header.collected_spans)
  return collected_spans_;
}

// int64 count_row = 7;
inline void BatchResponse_Header::clear_count_row() {
  count_row_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 BatchResponse_Header::count_row() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.BatchResponse.Header.count_row)
  return count_row_;
}
inline void BatchResponse_Header::set_count_row(::google::protobuf::int64 value) {
  
  count_row_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.BatchResponse.Header.count_row)
}

// -------------------------------------------------------------------

// BatchResponse

inline bool BatchResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void BatchResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::BatchResponse_Header& BatchResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::BatchResponse_Header& BatchResponse::header() const {
  const ::znbase::roachpb::BatchResponse_Header* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.BatchResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::BatchResponse_Header*>(
      &::znbase::roachpb::_BatchResponse_Header_default_instance_);
}
inline ::znbase::roachpb::BatchResponse_Header* BatchResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.BatchResponse.header)
  
  ::znbase::roachpb::BatchResponse_Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::BatchResponse_Header* BatchResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::BatchResponse_Header>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.BatchResponse.header)
  return header_;
}
inline void BatchResponse::set_allocated_header(::znbase::roachpb::BatchResponse_Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.BatchResponse.header)
}

inline int BatchResponse::responses_size() const {
  return responses_.size();
}
inline void BatchResponse::clear_responses() {
  responses_.Clear();
}
inline ::znbase::roachpb::ResponseUnion* BatchResponse::mutable_responses(int index) {
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.BatchResponse.responses)
  return responses_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::ResponseUnion >*
BatchResponse::mutable_responses() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.BatchResponse.responses)
  return &responses_;
}
inline const ::znbase::roachpb::ResponseUnion& BatchResponse::responses(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.BatchResponse.responses)
  return responses_.Get(index);
}
inline ::znbase::roachpb::ResponseUnion* BatchResponse::add_responses() {
  // @@protoc_insertion_point(field_add:znbase.roachpb.BatchResponse.responses)
  return responses_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::ResponseUnion >&
BatchResponse::responses() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.BatchResponse.responses)
  return responses_;
}

// -------------------------------------------------------------------

// RangeFeedRequest

inline bool RangeFeedRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void RangeFeedRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::Header& RangeFeedRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::Header& RangeFeedRequest::header() const {
  const ::znbase::roachpb::Header* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.RangeFeedRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::Header*>(
      &::znbase::roachpb::_Header_default_instance_);
}
inline ::znbase::roachpb::Header* RangeFeedRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RangeFeedRequest.header)
  
  ::znbase::roachpb::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::Header* RangeFeedRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::Header>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RangeFeedRequest.header)
  return header_;
}
inline void RangeFeedRequest::set_allocated_header(::znbase::roachpb::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.RangeFeedRequest.header)
}

inline bool RangeFeedRequest::has_span() const {
  return this != internal_default_instance() && span_ != NULL;
}
inline const ::znbase::roachpb::Span& RangeFeedRequest::_internal_span() const {
  return *span_;
}
inline const ::znbase::roachpb::Span& RangeFeedRequest::span() const {
  const ::znbase::roachpb::Span* p = span_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.RangeFeedRequest.span)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::Span*>(
      &::znbase::roachpb::_Span_default_instance_);
}
inline ::znbase::roachpb::Span* RangeFeedRequest::release_span() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RangeFeedRequest.span)
  
  ::znbase::roachpb::Span* temp = span_;
  span_ = NULL;
  return temp;
}
inline ::znbase::roachpb::Span* RangeFeedRequest::mutable_span() {
  
  if (span_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::Span>(GetArenaNoVirtual());
    span_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RangeFeedRequest.span)
  return span_;
}
inline void RangeFeedRequest::set_allocated_span(::znbase::roachpb::Span* span) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(span_);
  }
  if (span) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      span = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, span, submessage_arena);
    }
    
  } else {
    
  }
  span_ = span;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.RangeFeedRequest.span)
}

// bool with_diff = 3;
inline void RangeFeedRequest::clear_with_diff() {
  with_diff_ = false;
}
inline bool RangeFeedRequest::with_diff() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RangeFeedRequest.with_diff)
  return with_diff_;
}
inline void RangeFeedRequest::set_with_diff(bool value) {
  
  with_diff_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.RangeFeedRequest.with_diff)
}

// .znbase.util.hlc.Timestamp filter = 4;
inline bool RangeFeedRequest::has_filter() const {
  return this != internal_default_instance() && filter_ != NULL;
}
inline const ::znbase::util::hlc::Timestamp& RangeFeedRequest::_internal_filter() const {
  return *filter_;
}
inline const ::znbase::util::hlc::Timestamp& RangeFeedRequest::filter() const {
  const ::znbase::util::hlc::Timestamp* p = filter_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.RangeFeedRequest.filter)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::util::hlc::Timestamp*>(
      &::znbase::util::hlc::_Timestamp_default_instance_);
}
inline ::znbase::util::hlc::Timestamp* RangeFeedRequest::release_filter() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RangeFeedRequest.filter)
  
  ::znbase::util::hlc::Timestamp* temp = filter_;
  filter_ = NULL;
  return temp;
}
inline ::znbase::util::hlc::Timestamp* RangeFeedRequest::mutable_filter() {
  
  if (filter_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::util::hlc::Timestamp>(GetArenaNoVirtual());
    filter_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RangeFeedRequest.filter)
  return filter_;
}
inline void RangeFeedRequest::set_allocated_filter(::znbase::util::hlc::Timestamp* filter) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(filter_);
  }
  if (filter) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      filter = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, filter, submessage_arena);
    }
    
  } else {
    
  }
  filter_ = filter;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.RangeFeedRequest.filter)
}

// -------------------------------------------------------------------

// RangeFeedValue

inline void RangeFeedValue::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RangeFeedValue::key() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.RangeFeedValue.key)
  return key_.GetNoArena();
}
inline void RangeFeedValue::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.RangeFeedValue.key)
}
#if LANG_CXX11
inline void RangeFeedValue::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:znbase.roachpb.RangeFeedValue.key)
}
#endif
inline void RangeFeedValue::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:znbase.roachpb.RangeFeedValue.key)
}
inline void RangeFeedValue::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:znbase.roachpb.RangeFeedValue.key)
}
inline ::std::string* RangeFeedValue::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RangeFeedValue.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RangeFeedValue::release_key() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RangeFeedValue.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RangeFeedValue::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.RangeFeedValue.key)
}

inline bool RangeFeedValue::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline const ::znbase::roachpb::Value& RangeFeedValue::_internal_value() const {
  return *value_;
}
inline const ::znbase::roachpb::Value& RangeFeedValue::value() const {
  const ::znbase::roachpb::Value* p = value_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.RangeFeedValue.value)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::Value*>(
      &::znbase::roachpb::_Value_default_instance_);
}
inline ::znbase::roachpb::Value* RangeFeedValue::release_value() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RangeFeedValue.value)
  
  ::znbase::roachpb::Value* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::znbase::roachpb::Value* RangeFeedValue::mutable_value() {
  
  if (value_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::Value>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RangeFeedValue.value)
  return value_;
}
inline void RangeFeedValue::set_allocated_value(::znbase::roachpb::Value* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(value_);
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.RangeFeedValue.value)
}

inline bool RangeFeedValue::has_prev_value() const {
  return this != internal_default_instance() && prev_value_ != NULL;
}
inline const ::znbase::roachpb::Value& RangeFeedValue::_internal_prev_value() const {
  return *prev_value_;
}
inline const ::znbase::roachpb::Value& RangeFeedValue::prev_value() const {
  const ::znbase::roachpb::Value* p = prev_value_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.RangeFeedValue.prev_value)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::Value*>(
      &::znbase::roachpb::_Value_default_instance_);
}
inline ::znbase::roachpb::Value* RangeFeedValue::release_prev_value() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RangeFeedValue.prev_value)
  
  ::znbase::roachpb::Value* temp = prev_value_;
  prev_value_ = NULL;
  return temp;
}
inline ::znbase::roachpb::Value* RangeFeedValue::mutable_prev_value() {
  
  if (prev_value_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::Value>(GetArenaNoVirtual());
    prev_value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RangeFeedValue.prev_value)
  return prev_value_;
}
inline void RangeFeedValue::set_allocated_prev_value(::znbase::roachpb::Value* prev_value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(prev_value_);
  }
  if (prev_value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      prev_value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, prev_value, submessage_arena);
    }
    
  } else {
    
  }
  prev_value_ = prev_value;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.RangeFeedValue.prev_value)
}

// -------------------------------------------------------------------

// RangeFeedCheckpoint

inline bool RangeFeedCheckpoint::has_span() const {
  return this != internal_default_instance() && span_ != NULL;
}
inline const ::znbase::roachpb::Span& RangeFeedCheckpoint::_internal_span() const {
  return *span_;
}
inline const ::znbase::roachpb::Span& RangeFeedCheckpoint::span() const {
  const ::znbase::roachpb::Span* p = span_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.RangeFeedCheckpoint.span)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::Span*>(
      &::znbase::roachpb::_Span_default_instance_);
}
inline ::znbase::roachpb::Span* RangeFeedCheckpoint::release_span() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RangeFeedCheckpoint.span)
  
  ::znbase::roachpb::Span* temp = span_;
  span_ = NULL;
  return temp;
}
inline ::znbase::roachpb::Span* RangeFeedCheckpoint::mutable_span() {
  
  if (span_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::Span>(GetArenaNoVirtual());
    span_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RangeFeedCheckpoint.span)
  return span_;
}
inline void RangeFeedCheckpoint::set_allocated_span(::znbase::roachpb::Span* span) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(span_);
  }
  if (span) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      span = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, span, submessage_arena);
    }
    
  } else {
    
  }
  span_ = span;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.RangeFeedCheckpoint.span)
}

inline bool RangeFeedCheckpoint::has_resolved_ts() const {
  return this != internal_default_instance() && resolved_ts_ != NULL;
}
inline const ::znbase::util::hlc::Timestamp& RangeFeedCheckpoint::_internal_resolved_ts() const {
  return *resolved_ts_;
}
inline const ::znbase::util::hlc::Timestamp& RangeFeedCheckpoint::resolved_ts() const {
  const ::znbase::util::hlc::Timestamp* p = resolved_ts_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.RangeFeedCheckpoint.resolved_ts)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::util::hlc::Timestamp*>(
      &::znbase::util::hlc::_Timestamp_default_instance_);
}
inline ::znbase::util::hlc::Timestamp* RangeFeedCheckpoint::release_resolved_ts() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RangeFeedCheckpoint.resolved_ts)
  
  ::znbase::util::hlc::Timestamp* temp = resolved_ts_;
  resolved_ts_ = NULL;
  return temp;
}
inline ::znbase::util::hlc::Timestamp* RangeFeedCheckpoint::mutable_resolved_ts() {
  
  if (resolved_ts_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::util::hlc::Timestamp>(GetArenaNoVirtual());
    resolved_ts_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RangeFeedCheckpoint.resolved_ts)
  return resolved_ts_;
}
inline void RangeFeedCheckpoint::set_allocated_resolved_ts(::znbase::util::hlc::Timestamp* resolved_ts) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(resolved_ts_);
  }
  if (resolved_ts) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      resolved_ts = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resolved_ts, submessage_arena);
    }
    
  } else {
    
  }
  resolved_ts_ = resolved_ts;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.RangeFeedCheckpoint.resolved_ts)
}

// -------------------------------------------------------------------

// RangeFeedError

inline bool RangeFeedError::has_error() const {
  return this != internal_default_instance() && error_ != NULL;
}
inline const ::znbase::roachpb::Error& RangeFeedError::_internal_error() const {
  return *error_;
}
inline const ::znbase::roachpb::Error& RangeFeedError::error() const {
  const ::znbase::roachpb::Error* p = error_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.RangeFeedError.error)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::Error*>(
      &::znbase::roachpb::_Error_default_instance_);
}
inline ::znbase::roachpb::Error* RangeFeedError::release_error() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RangeFeedError.error)
  
  ::znbase::roachpb::Error* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::znbase::roachpb::Error* RangeFeedError::mutable_error() {
  
  if (error_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::Error>(GetArenaNoVirtual());
    error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RangeFeedError.error)
  return error_;
}
inline void RangeFeedError::set_allocated_error(::znbase::roachpb::Error* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(error_);
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.RangeFeedError.error)
}

// -------------------------------------------------------------------

// RangeFeedEvent

// .znbase.roachpb.RangeFeedValue val = 1;
inline bool RangeFeedEvent::has_val() const {
  return this != internal_default_instance() && val_ != NULL;
}
inline void RangeFeedEvent::clear_val() {
  if (GetArenaNoVirtual() == NULL && val_ != NULL) {
    delete val_;
  }
  val_ = NULL;
}
inline const ::znbase::roachpb::RangeFeedValue& RangeFeedEvent::_internal_val() const {
  return *val_;
}
inline const ::znbase::roachpb::RangeFeedValue& RangeFeedEvent::val() const {
  const ::znbase::roachpb::RangeFeedValue* p = val_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.RangeFeedEvent.val)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RangeFeedValue*>(
      &::znbase::roachpb::_RangeFeedValue_default_instance_);
}
inline ::znbase::roachpb::RangeFeedValue* RangeFeedEvent::release_val() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RangeFeedEvent.val)
  
  ::znbase::roachpb::RangeFeedValue* temp = val_;
  val_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RangeFeedValue* RangeFeedEvent::mutable_val() {
  
  if (val_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RangeFeedValue>(GetArenaNoVirtual());
    val_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RangeFeedEvent.val)
  return val_;
}
inline void RangeFeedEvent::set_allocated_val(::znbase::roachpb::RangeFeedValue* val) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete val_;
  }
  if (val) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      val = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, val, submessage_arena);
    }
    
  } else {
    
  }
  val_ = val;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.RangeFeedEvent.val)
}

// .znbase.roachpb.RangeFeedCheckpoint checkpoint = 2;
inline bool RangeFeedEvent::has_checkpoint() const {
  return this != internal_default_instance() && checkpoint_ != NULL;
}
inline void RangeFeedEvent::clear_checkpoint() {
  if (GetArenaNoVirtual() == NULL && checkpoint_ != NULL) {
    delete checkpoint_;
  }
  checkpoint_ = NULL;
}
inline const ::znbase::roachpb::RangeFeedCheckpoint& RangeFeedEvent::_internal_checkpoint() const {
  return *checkpoint_;
}
inline const ::znbase::roachpb::RangeFeedCheckpoint& RangeFeedEvent::checkpoint() const {
  const ::znbase::roachpb::RangeFeedCheckpoint* p = checkpoint_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.RangeFeedEvent.checkpoint)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RangeFeedCheckpoint*>(
      &::znbase::roachpb::_RangeFeedCheckpoint_default_instance_);
}
inline ::znbase::roachpb::RangeFeedCheckpoint* RangeFeedEvent::release_checkpoint() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RangeFeedEvent.checkpoint)
  
  ::znbase::roachpb::RangeFeedCheckpoint* temp = checkpoint_;
  checkpoint_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RangeFeedCheckpoint* RangeFeedEvent::mutable_checkpoint() {
  
  if (checkpoint_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RangeFeedCheckpoint>(GetArenaNoVirtual());
    checkpoint_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RangeFeedEvent.checkpoint)
  return checkpoint_;
}
inline void RangeFeedEvent::set_allocated_checkpoint(::znbase::roachpb::RangeFeedCheckpoint* checkpoint) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete checkpoint_;
  }
  if (checkpoint) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      checkpoint = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, checkpoint, submessage_arena);
    }
    
  } else {
    
  }
  checkpoint_ = checkpoint;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.RangeFeedEvent.checkpoint)
}

// .znbase.roachpb.RangeFeedError error = 3;
inline bool RangeFeedEvent::has_error() const {
  return this != internal_default_instance() && error_ != NULL;
}
inline void RangeFeedEvent::clear_error() {
  if (GetArenaNoVirtual() == NULL && error_ != NULL) {
    delete error_;
  }
  error_ = NULL;
}
inline const ::znbase::roachpb::RangeFeedError& RangeFeedEvent::_internal_error() const {
  return *error_;
}
inline const ::znbase::roachpb::RangeFeedError& RangeFeedEvent::error() const {
  const ::znbase::roachpb::RangeFeedError* p = error_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.RangeFeedEvent.error)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RangeFeedError*>(
      &::znbase::roachpb::_RangeFeedError_default_instance_);
}
inline ::znbase::roachpb::RangeFeedError* RangeFeedEvent::release_error() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.RangeFeedEvent.error)
  
  ::znbase::roachpb::RangeFeedError* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RangeFeedError* RangeFeedEvent::mutable_error() {
  
  if (error_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RangeFeedError>(GetArenaNoVirtual());
    error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.RangeFeedEvent.error)
  return error_;
}
inline void RangeFeedEvent::set_allocated_error(::znbase::roachpb::RangeFeedError* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete error_;
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.RangeFeedEvent.error)
}

// -------------------------------------------------------------------

// VecScanRequest

inline bool VecScanRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void VecScanRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::RequestHeader& VecScanRequest::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::RequestHeader& VecScanRequest::header() const {
  const ::znbase::roachpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.VecScanRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::RequestHeader*>(
      &::znbase::roachpb::_RequestHeader_default_instance_);
}
inline ::znbase::roachpb::RequestHeader* VecScanRequest::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.VecScanRequest.header)
  
  ::znbase::roachpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::RequestHeader* VecScanRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.VecScanRequest.header)
  return header_;
}
inline void VecScanRequest::set_allocated_header(::znbase::roachpb::RequestHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.VecScanRequest.header)
}

// int32 override_flags = 2;
inline void VecScanRequest::clear_override_flags() {
  override_flags_ = 0;
}
inline ::google::protobuf::int32 VecScanRequest::override_flags() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.VecScanRequest.override_flags)
  return override_flags_;
}
inline void VecScanRequest::set_override_flags(::google::protobuf::int32 value) {
  
  override_flags_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.VecScanRequest.override_flags)
}

// .znbase.roachpb.ScanFormat scan_format = 3;
inline void VecScanRequest::clear_scan_format() {
  scan_format_ = 0;
}
inline ::znbase::roachpb::ScanFormat VecScanRequest::scan_format() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.VecScanRequest.scan_format)
  return static_cast< ::znbase::roachpb::ScanFormat >(scan_format_);
}
inline void VecScanRequest::set_scan_format(::znbase::roachpb::ScanFormat value) {
  
  scan_format_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.VecScanRequest.scan_format)
}

inline int VecScanRequest::col_ids_size() const {
  return col_ids_.size();
}
inline void VecScanRequest::clear_col_ids() {
  col_ids_.Clear();
}
inline ::google::protobuf::int32 VecScanRequest::col_ids(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.VecScanRequest.col_ids)
  return col_ids_.Get(index);
}
inline void VecScanRequest::set_col_ids(int index, ::google::protobuf::int32 value) {
  col_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:znbase.roachpb.VecScanRequest.col_ids)
}
inline void VecScanRequest::add_col_ids(::google::protobuf::int32 value) {
  col_ids_.Add(value);
  // @@protoc_insertion_point(field_add:znbase.roachpb.VecScanRequest.col_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
VecScanRequest::col_ids() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.VecScanRequest.col_ids)
  return col_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
VecScanRequest::mutable_col_ids() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.VecScanRequest.col_ids)
  return &col_ids_;
}

// uint32 table_id = 5;
inline void VecScanRequest::clear_table_id() {
  table_id_ = 0u;
}
inline ::google::protobuf::uint32 VecScanRequest::table_id() const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.VecScanRequest.table_id)
  return table_id_;
}
inline void VecScanRequest::set_table_id(::google::protobuf::uint32 value) {
  
  table_id_ = value;
  // @@protoc_insertion_point(field_set:znbase.roachpb.VecScanRequest.table_id)
}

// .znbase.roachpb.PushDownExpr push_down = 6;
inline bool VecScanRequest::has_push_down() const {
  return this != internal_default_instance() && push_down_ != NULL;
}
inline const ::znbase::roachpb::PushDownExpr& VecScanRequest::_internal_push_down() const {
  return *push_down_;
}
inline const ::znbase::roachpb::PushDownExpr& VecScanRequest::push_down() const {
  const ::znbase::roachpb::PushDownExpr* p = push_down_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.VecScanRequest.push_down)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::PushDownExpr*>(
      &::znbase::roachpb::_PushDownExpr_default_instance_);
}
inline ::znbase::roachpb::PushDownExpr* VecScanRequest::release_push_down() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.VecScanRequest.push_down)
  
  ::znbase::roachpb::PushDownExpr* temp = push_down_;
  push_down_ = NULL;
  return temp;
}
inline ::znbase::roachpb::PushDownExpr* VecScanRequest::mutable_push_down() {
  
  if (push_down_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::PushDownExpr>(GetArenaNoVirtual());
    push_down_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.VecScanRequest.push_down)
  return push_down_;
}
inline void VecScanRequest::set_allocated_push_down(::znbase::roachpb::PushDownExpr* push_down) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(push_down_);
  }
  if (push_down) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      push_down = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, push_down, submessage_arena);
    }
    
  } else {
    
  }
  push_down_ = push_down;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.VecScanRequest.push_down)
}

// -------------------------------------------------------------------

// VecScanResponse

inline bool VecScanResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void VecScanResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::znbase::roachpb::ResponseHeader& VecScanResponse::_internal_header() const {
  return *header_;
}
inline const ::znbase::roachpb::ResponseHeader& VecScanResponse::header() const {
  const ::znbase::roachpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.VecScanResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::ResponseHeader*>(
      &::znbase::roachpb::_ResponseHeader_default_instance_);
}
inline ::znbase::roachpb::ResponseHeader* VecScanResponse::release_header() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.VecScanResponse.header)
  
  ::znbase::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::znbase::roachpb::ResponseHeader* VecScanResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.VecScanResponse.header)
  return header_;
}
inline void VecScanResponse::set_allocated_header(::znbase::roachpb::ResponseHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.VecScanResponse.header)
}

inline bool VecScanResponse::has_batch() const {
  return this != internal_default_instance() && batch_ != NULL;
}
inline const ::znbase::roachpb::VecResults& VecScanResponse::_internal_batch() const {
  return *batch_;
}
inline const ::znbase::roachpb::VecResults& VecScanResponse::batch() const {
  const ::znbase::roachpb::VecResults* p = batch_;
  // @@protoc_insertion_point(field_get:znbase.roachpb.VecScanResponse.batch)
  return p != NULL ? *p : *reinterpret_cast<const ::znbase::roachpb::VecResults*>(
      &::znbase::roachpb::_VecResults_default_instance_);
}
inline ::znbase::roachpb::VecResults* VecScanResponse::release_batch() {
  // @@protoc_insertion_point(field_release:znbase.roachpb.VecScanResponse.batch)
  
  ::znbase::roachpb::VecResults* temp = batch_;
  batch_ = NULL;
  return temp;
}
inline ::znbase::roachpb::VecResults* VecScanResponse::mutable_batch() {
  
  if (batch_ == NULL) {
    auto* p = CreateMaybeMessage<::znbase::roachpb::VecResults>(GetArenaNoVirtual());
    batch_ = p;
  }
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.VecScanResponse.batch)
  return batch_;
}
inline void VecScanResponse::set_allocated_batch(::znbase::roachpb::VecResults* batch) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(batch_);
  }
  if (batch) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      batch = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, batch, submessage_arena);
    }
    
  } else {
    
  }
  batch_ = batch;
  // @@protoc_insertion_point(field_set_allocated:znbase.roachpb.VecScanResponse.batch)
}

inline int VecScanResponse::intent_rows_size() const {
  return intent_rows_.size();
}
inline ::znbase::roachpb::KeyValue* VecScanResponse::mutable_intent_rows(int index) {
  // @@protoc_insertion_point(field_mutable:znbase.roachpb.VecScanResponse.intent_rows)
  return intent_rows_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::KeyValue >*
VecScanResponse::mutable_intent_rows() {
  // @@protoc_insertion_point(field_mutable_list:znbase.roachpb.VecScanResponse.intent_rows)
  return &intent_rows_;
}
inline const ::znbase::roachpb::KeyValue& VecScanResponse::intent_rows(int index) const {
  // @@protoc_insertion_point(field_get:znbase.roachpb.VecScanResponse.intent_rows)
  return intent_rows_.Get(index);
}
inline ::znbase::roachpb::KeyValue* VecScanResponse::add_intent_rows() {
  // @@protoc_insertion_point(field_add:znbase.roachpb.VecScanResponse.intent_rows)
  return intent_rows_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::znbase::roachpb::KeyValue >&
VecScanResponse::intent_rows() const {
  // @@protoc_insertion_point(field_list:znbase.roachpb.VecScanResponse.intent_rows)
  return intent_rows_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace roachpb
}  // namespace znbase

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::znbase::roachpb::ResponseHeader_ResumeReason> : ::std::true_type {};
template <> struct is_proto_enum< ::znbase::roachpb::CheckConsistencyResponse_Status> : ::std::true_type {};
template <> struct is_proto_enum< ::znbase::roachpb::ReadConsistencyType> : ::std::true_type {};
template <> struct is_proto_enum< ::znbase::roachpb::ScanFormat> : ::std::true_type {};
template <> struct is_proto_enum< ::znbase::roachpb::ChecksumMode> : ::std::true_type {};
template <> struct is_proto_enum< ::znbase::roachpb::PushTxnType> : ::std::true_type {};
template <> struct is_proto_enum< ::znbase::roachpb::ExportStorageProvider> : ::std::true_type {};
template <> struct is_proto_enum< ::znbase::roachpb::MVCCFilter> : ::std::true_type {};
template <> struct is_proto_enum< ::znbase::roachpb::FileCompression> : ::std::true_type {};

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_roachpb_2fapi_2eproto
