// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: roachpb/pushdown.proto

package roachpb

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// 对应Spark.sql.sources包下的Filter
type FilterType int32

const (
	FilterType_AlwaysTrue  FilterType = 0
	FilterType_AlwaysFalse FilterType = 1
	FilterType_IsNotNull   FilterType = 2
	FilterType_IsNull      FilterType = 3
	FilterType_Equal       FilterType = 4
	// similar to [[EqualTo]]. However, this differs from [[EqualTo]]
	// * in that it returns `true` (rather than NULL) if both inputs are NULL .
	FilterType_EqualNullSafe  FilterType = 5
	FilterType_Greater        FilterType = 6
	FilterType_GreaterOrEqual FilterType = 7
	FilterType_Less           FilterType = 8
	FilterType_LessOrEqual    FilterType = 9
	FilterType_In             FilterType = 10
	FilterType_StringContains FilterType = 11
	FilterType_StringEnds     FilterType = 12
	FilterType_StringStarts   FilterType = 13
	// 逻辑过滤
	FilterType_Not        FilterType = 14
	FilterType_Or         FilterType = 15
	FilterType_And        FilterType = 16
	FilterType_Expression FilterType = 20
)

var FilterType_name = map[int32]string{
	0:  "AlwaysTrue",
	1:  "AlwaysFalse",
	2:  "IsNotNull",
	3:  "IsNull",
	4:  "Equal",
	5:  "EqualNullSafe",
	6:  "Greater",
	7:  "GreaterOrEqual",
	8:  "Less",
	9:  "LessOrEqual",
	10: "In",
	11: "StringContains",
	12: "StringEnds",
	13: "StringStarts",
	14: "Not",
	15: "Or",
	16: "And",
	20: "Expression",
}
var FilterType_value = map[string]int32{
	"AlwaysTrue":     0,
	"AlwaysFalse":    1,
	"IsNotNull":      2,
	"IsNull":         3,
	"Equal":          4,
	"EqualNullSafe":  5,
	"Greater":        6,
	"GreaterOrEqual": 7,
	"Less":           8,
	"LessOrEqual":    9,
	"In":             10,
	"StringContains": 11,
	"StringEnds":     12,
	"StringStarts":   13,
	"Not":            14,
	"Or":             15,
	"And":            16,
	"Expression":     20,
}

func (x FilterType) Enum() *FilterType {
	p := new(FilterType)
	*p = x
	return p
}
func (x FilterType) String() string {
	return proto.EnumName(FilterType_name, int32(x))
}
func (x *FilterType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(FilterType_value, data, "FilterType")
	if err != nil {
		return err
	}
	*x = FilterType(value)
	return nil
}
func (FilterType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_pushdown_2b60b53c173e1aa5, []int{0}
}

type ColumnMeta_Type int32

const (
	ColumnMeta_BOOL           ColumnMeta_Type = 0
	ColumnMeta_INT            ColumnMeta_Type = 1
	ColumnMeta_FLOAT          ColumnMeta_Type = 2
	ColumnMeta_DECIMAL        ColumnMeta_Type = 3
	ColumnMeta_DATE           ColumnMeta_Type = 4
	ColumnMeta_TIMESTAMP      ColumnMeta_Type = 5
	ColumnMeta_INTERVAL       ColumnMeta_Type = 6
	ColumnMeta_STRING         ColumnMeta_Type = 7
	ColumnMeta_BYTES          ColumnMeta_Type = 8
	ColumnMeta_TIMESTAMPTZ    ColumnMeta_Type = 9
	ColumnMeta_COLLATEDSTRING ColumnMeta_Type = 10
	ColumnMeta_NAME           ColumnMeta_Type = 11
	ColumnMeta_OID            ColumnMeta_Type = 12
	// NULL is not supported as a table column type, however it can be
	// transferred through distsql streams.
	ColumnMeta_NULL_T     ColumnMeta_Type = 13
	ColumnMeta_UUID       ColumnMeta_Type = 14
	ColumnMeta_ARRAY      ColumnMeta_Type = 15
	ColumnMeta_INET       ColumnMeta_Type = 16
	ColumnMeta_TIME       ColumnMeta_Type = 17
	ColumnMeta_JSONB      ColumnMeta_Type = 18
	ColumnMeta_TIMETZ     ColumnMeta_Type = 19
	ColumnMeta_TUPLE      ColumnMeta_Type = 20
	ColumnMeta_BIT        ColumnMeta_Type = 21
	ColumnMeta_INT2VECTOR ColumnMeta_Type = 200
	ColumnMeta_OIDVECTOR  ColumnMeta_Type = 201
)

var ColumnMeta_Type_name = map[int32]string{
	0:   "BOOL",
	1:   "INT",
	2:   "FLOAT",
	3:   "DECIMAL",
	4:   "DATE",
	5:   "TIMESTAMP",
	6:   "INTERVAL",
	7:   "STRING",
	8:   "BYTES",
	9:   "TIMESTAMPTZ",
	10:  "COLLATEDSTRING",
	11:  "NAME",
	12:  "OID",
	13:  "NULL_T",
	14:  "UUID",
	15:  "ARRAY",
	16:  "INET",
	17:  "TIME",
	18:  "JSONB",
	19:  "TIMETZ",
	20:  "TUPLE",
	21:  "BIT",
	200: "INT2VECTOR",
	201: "OIDVECTOR",
}
var ColumnMeta_Type_value = map[string]int32{
	"BOOL":           0,
	"INT":            1,
	"FLOAT":          2,
	"DECIMAL":        3,
	"DATE":           4,
	"TIMESTAMP":      5,
	"INTERVAL":       6,
	"STRING":         7,
	"BYTES":          8,
	"TIMESTAMPTZ":    9,
	"COLLATEDSTRING": 10,
	"NAME":           11,
	"OID":            12,
	"NULL_T":         13,
	"UUID":           14,
	"ARRAY":          15,
	"INET":           16,
	"TIME":           17,
	"JSONB":          18,
	"TIMETZ":         19,
	"TUPLE":          20,
	"BIT":            21,
	"INT2VECTOR":     200,
	"OIDVECTOR":      201,
}

func (x ColumnMeta_Type) Enum() *ColumnMeta_Type {
	p := new(ColumnMeta_Type)
	*p = x
	return p
}
func (x ColumnMeta_Type) String() string {
	return proto.EnumName(ColumnMeta_Type_name, int32(x))
}
func (x *ColumnMeta_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ColumnMeta_Type_value, data, "ColumnMeta_Type")
	if err != nil {
		return err
	}
	*x = ColumnMeta_Type(value)
	return nil
}
func (ColumnMeta_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_pushdown_2b60b53c173e1aa5, []int{0, 0}
}

// These mirror the aggregate functions supported by sql/parser. See
// sql/parser/aggregate_builtins.go.
type AggregatorPush_Func int32

const (
	AggregatorPush_ANY_NOT_NULL   AggregatorPush_Func = 0
	AggregatorPush_AVG            AggregatorPush_Func = 1
	AggregatorPush_BOOL_AND       AggregatorPush_Func = 2
	AggregatorPush_BOOL_OR        AggregatorPush_Func = 3
	AggregatorPush_CONCAT_AGG     AggregatorPush_Func = 4
	AggregatorPush_COUNT          AggregatorPush_Func = 5
	AggregatorPush_MAX            AggregatorPush_Func = 7
	AggregatorPush_MIN            AggregatorPush_Func = 8
	AggregatorPush_STDDEV         AggregatorPush_Func = 9
	AggregatorPush_SUM            AggregatorPush_Func = 10
	AggregatorPush_SUM_INT        AggregatorPush_Func = 11
	AggregatorPush_VARIANCE       AggregatorPush_Func = 12
	AggregatorPush_XOR_AGG        AggregatorPush_Func = 13
	AggregatorPush_COUNT_ROWS     AggregatorPush_Func = 14
	AggregatorPush_SQRDIFF        AggregatorPush_Func = 15
	AggregatorPush_FINAL_VARIANCE AggregatorPush_Func = 16
	AggregatorPush_FINAL_STDDEV   AggregatorPush_Func = 17
	AggregatorPush_ARRAY_AGG      AggregatorPush_Func = 18
	AggregatorPush_JSON_AGG       AggregatorPush_Func = 19
	// JSONB_AGG is an alias for JSON_AGG, they do the same thing.
	AggregatorPush_JSONB_AGG    AggregatorPush_Func = 20
	AggregatorPush_STRING_AGG   AggregatorPush_Func = 21
	AggregatorPush_MEDIAN       AggregatorPush_Func = 22
	AggregatorPush_GROUP_CONCAT AggregatorPush_Func = 23
	AggregatorPush_LISTAGG      AggregatorPush_Func = 24
	AggregatorPush_COUNT_PD     AggregatorPush_Func = 25
)

var AggregatorPush_Func_name = map[int32]string{
	0:  "ANY_NOT_NULL",
	1:  "AVG",
	2:  "BOOL_AND",
	3:  "BOOL_OR",
	4:  "CONCAT_AGG",
	5:  "COUNT",
	7:  "MAX",
	8:  "MIN",
	9:  "STDDEV",
	10: "SUM",
	11: "SUM_INT",
	12: "VARIANCE",
	13: "XOR_AGG",
	14: "COUNT_ROWS",
	15: "SQRDIFF",
	16: "FINAL_VARIANCE",
	17: "FINAL_STDDEV",
	18: "ARRAY_AGG",
	19: "JSON_AGG",
	20: "JSONB_AGG",
	21: "STRING_AGG",
	22: "MEDIAN",
	23: "GROUP_CONCAT",
	24: "LISTAGG",
	25: "COUNT_PD",
}
var AggregatorPush_Func_value = map[string]int32{
	"ANY_NOT_NULL":   0,
	"AVG":            1,
	"BOOL_AND":       2,
	"BOOL_OR":        3,
	"CONCAT_AGG":     4,
	"COUNT":          5,
	"MAX":            7,
	"MIN":            8,
	"STDDEV":         9,
	"SUM":            10,
	"SUM_INT":        11,
	"VARIANCE":       12,
	"XOR_AGG":        13,
	"COUNT_ROWS":     14,
	"SQRDIFF":        15,
	"FINAL_VARIANCE": 16,
	"FINAL_STDDEV":   17,
	"ARRAY_AGG":      18,
	"JSON_AGG":       19,
	"JSONB_AGG":      20,
	"STRING_AGG":     21,
	"MEDIAN":         22,
	"GROUP_CONCAT":   23,
	"LISTAGG":        24,
	"COUNT_PD":       25,
}

func (x AggregatorPush_Func) Enum() *AggregatorPush_Func {
	p := new(AggregatorPush_Func)
	*p = x
	return p
}
func (x AggregatorPush_Func) String() string {
	return proto.EnumName(AggregatorPush_Func_name, int32(x))
}
func (x *AggregatorPush_Func) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(AggregatorPush_Func_value, data, "AggregatorPush_Func")
	if err != nil {
		return err
	}
	*x = AggregatorPush_Func(value)
	return nil
}
func (AggregatorPush_Func) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_pushdown_2b60b53c173e1aa5, []int{4, 0}
}

type AggregatorPush_Type int32

const (
	// This setting exists just for backwards compatibility; it's equivalent to
	// SCALAR when there are no grouping columns, and to NON_SCALAR when there
	// are grouping columns.
	AggregatorPush_AUTO AggregatorPush_Type = 0
	// A scalar aggregation has no grouping columns and always returns one
	// result row.
	AggregatorPush_SCALAR AggregatorPush_Type = 1
	// A non-scalar aggregation returns no rows if there are no input rows; it
	// may or may not have grouping columns.
	AggregatorPush_NON_SCALAR AggregatorPush_Type = 2
)

var AggregatorPush_Type_name = map[int32]string{
	0: "AUTO",
	1: "SCALAR",
	2: "NON_SCALAR",
}
var AggregatorPush_Type_value = map[string]int32{
	"AUTO":       0,
	"SCALAR":     1,
	"NON_SCALAR": 2,
}

func (x AggregatorPush_Type) Enum() *AggregatorPush_Type {
	p := new(AggregatorPush_Type)
	*p = x
	return p
}
func (x AggregatorPush_Type) String() string {
	return proto.EnumName(AggregatorPush_Type_name, int32(x))
}
func (x *AggregatorPush_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(AggregatorPush_Type_value, data, "AggregatorPush_Type")
	if err != nil {
		return err
	}
	*x = AggregatorPush_Type(value)
	return nil
}
func (AggregatorPush_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_pushdown_2b60b53c173e1aa5, []int{4, 1}
}

// 复制自sqlbase/structured.proto模型中的ColumnType.SemanticType
type ColumnMeta struct {
}

func (m *ColumnMeta) Reset()         { *m = ColumnMeta{} }
func (m *ColumnMeta) String() string { return proto.CompactTextString(m) }
func (*ColumnMeta) ProtoMessage()    {}
func (*ColumnMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_pushdown_2b60b53c173e1aa5, []int{0}
}
func (m *ColumnMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ColumnMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnMeta.Merge(dst, src)
}
func (m *ColumnMeta) XXX_Size() int {
	return m.Size()
}
func (m *ColumnMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnMeta.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnMeta proto.InternalMessageInfo

type BaseFilter struct {
	// 列ID
	Attribute string  `protobuf:"bytes,2,req,name=attribute" json:"attribute"`
	Value     *string `protobuf:"bytes,3,opt,name=value" json:"value,omitempty"`
	// 大部分filter只需要一个value，repeated values数组可用来处理特殊filter, 比如：IN filter
	// note: 当使用values，就不要使用value
	Values []string `protobuf:"bytes,4,rep,name=values" json:"values,omitempty"`
}

func (m *BaseFilter) Reset()         { *m = BaseFilter{} }
func (m *BaseFilter) String() string { return proto.CompactTextString(m) }
func (*BaseFilter) ProtoMessage()    {}
func (*BaseFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_pushdown_2b60b53c173e1aa5, []int{1}
}
func (m *BaseFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BaseFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *BaseFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BaseFilter.Merge(dst, src)
}
func (m *BaseFilter) XXX_Size() int {
	return m.Size()
}
func (m *BaseFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_BaseFilter.DiscardUnknown(m)
}

var xxx_messageInfo_BaseFilter proto.InternalMessageInfo

// LogicalFilter可能会存在嵌套的
// 如： Or(GreaterThan(l_quantity,1500.0),And(EqualTo(l_quantity,0.0),EqualTo(l_status,F)))
type LogicalFilter struct {
	Left  FilterUnion  `protobuf:"bytes,2,req,name=left" json:"left"`
	Right *FilterUnion `protobuf:"bytes,3,opt,name=right" json:"right,omitempty"`
}

func (m *LogicalFilter) Reset()         { *m = LogicalFilter{} }
func (m *LogicalFilter) String() string { return proto.CompactTextString(m) }
func (*LogicalFilter) ProtoMessage()    {}
func (*LogicalFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_pushdown_2b60b53c173e1aa5, []int{2}
}
func (m *LogicalFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogicalFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *LogicalFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogicalFilter.Merge(dst, src)
}
func (m *LogicalFilter) XXX_Size() int {
	return m.Size()
}
func (m *LogicalFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_LogicalFilter.DiscardUnknown(m)
}

var xxx_messageInfo_LogicalFilter proto.InternalMessageInfo

type FilterUnion struct {
	Type FilterType `protobuf:"varint,1,req,name=type,enum=znbase.roachpb.FilterType" json:"type"`
	// Types that are valid to be assigned to Value:
	//	*FilterUnion_Base
	//	*FilterUnion_Logical
	//	*FilterUnion_Expression
	Value isFilterUnion_Value `protobuf_oneof:"value"`
}

func (m *FilterUnion) Reset()         { *m = FilterUnion{} }
func (m *FilterUnion) String() string { return proto.CompactTextString(m) }
func (*FilterUnion) ProtoMessage()    {}
func (*FilterUnion) Descriptor() ([]byte, []int) {
	return fileDescriptor_pushdown_2b60b53c173e1aa5, []int{3}
}
func (m *FilterUnion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FilterUnion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *FilterUnion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FilterUnion.Merge(dst, src)
}
func (m *FilterUnion) XXX_Size() int {
	return m.Size()
}
func (m *FilterUnion) XXX_DiscardUnknown() {
	xxx_messageInfo_FilterUnion.DiscardUnknown(m)
}

var xxx_messageInfo_FilterUnion proto.InternalMessageInfo

type isFilterUnion_Value interface {
	isFilterUnion_Value()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type FilterUnion_Base struct {
	Base *BaseFilter `protobuf:"bytes,2,opt,name=base,oneof"`
}
type FilterUnion_Logical struct {
	Logical *LogicalFilter `protobuf:"bytes,3,opt,name=logical,oneof"`
}
type FilterUnion_Expression struct {
	Expression string `protobuf:"bytes,4,opt,name=expression,oneof"`
}

func (*FilterUnion_Base) isFilterUnion_Value()       {}
func (*FilterUnion_Logical) isFilterUnion_Value()    {}
func (*FilterUnion_Expression) isFilterUnion_Value() {}

func (m *FilterUnion) GetValue() isFilterUnion_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *FilterUnion) GetBase() *BaseFilter {
	if x, ok := m.GetValue().(*FilterUnion_Base); ok {
		return x.Base
	}
	return nil
}

func (m *FilterUnion) GetLogical() *LogicalFilter {
	if x, ok := m.GetValue().(*FilterUnion_Logical); ok {
		return x.Logical
	}
	return nil
}

func (m *FilterUnion) GetExpression() string {
	if x, ok := m.GetValue().(*FilterUnion_Expression); ok {
		return x.Expression
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FilterUnion) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FilterUnion_OneofMarshaler, _FilterUnion_OneofUnmarshaler, _FilterUnion_OneofSizer, []interface{}{
		(*FilterUnion_Base)(nil),
		(*FilterUnion_Logical)(nil),
		(*FilterUnion_Expression)(nil),
	}
}

func _FilterUnion_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FilterUnion)
	// value
	switch x := m.Value.(type) {
	case *FilterUnion_Base:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Base); err != nil {
			return err
		}
	case *FilterUnion_Logical:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Logical); err != nil {
			return err
		}
	case *FilterUnion_Expression:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Expression)
	case nil:
	default:
		return fmt.Errorf("FilterUnion.Value has unexpected type %T", x)
	}
	return nil
}

func _FilterUnion_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FilterUnion)
	switch tag {
	case 2: // value.base
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BaseFilter)
		err := b.DecodeMessage(msg)
		m.Value = &FilterUnion_Base{msg}
		return true, err
	case 3: // value.logical
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LogicalFilter)
		err := b.DecodeMessage(msg)
		m.Value = &FilterUnion_Logical{msg}
		return true, err
	case 4: // value.expression
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Value = &FilterUnion_Expression{x}
		return true, err
	default:
		return false, nil
	}
}

func _FilterUnion_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FilterUnion)
	// value
	switch x := m.Value.(type) {
	case *FilterUnion_Base:
		s := proto.Size(x.Base)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FilterUnion_Logical:
		s := proto.Size(x.Logical)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FilterUnion_Expression:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.Expression)))
		n += len(x.Expression)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// 命名AggregatorPush，与znbase.sql.distsqlrun的AggregatorSpec区分
type AggregatorPush struct {
	Type AggregatorPush_Type `protobuf:"varint,5,opt,name=type,enum=znbase.roachpb.AggregatorPush_Type" json:"type"`
	// The group key is a subset of the columns in the input stream schema on the
	// basis of which we define our groups.
	GroupCols    []uint32                     `protobuf:"varint,2,rep,packed,name=group_cols,json=groupCols" json:"group_cols,omitempty"`
	Aggregations []AggregatorPush_Aggregation `protobuf:"bytes,3,rep,name=aggregations" json:"aggregations"`
	// A subset of the GROUP BY columns which are ordered in the input.
	OrderedGroupCols []uint32 `protobuf:"varint,4,rep,packed,name=ordered_group_cols,json=orderedGroupCols" json:"ordered_group_cols,omitempty"`
}

func (m *AggregatorPush) Reset()         { *m = AggregatorPush{} }
func (m *AggregatorPush) String() string { return proto.CompactTextString(m) }
func (*AggregatorPush) ProtoMessage()    {}
func (*AggregatorPush) Descriptor() ([]byte, []int) {
	return fileDescriptor_pushdown_2b60b53c173e1aa5, []int{4}
}
func (m *AggregatorPush) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AggregatorPush) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *AggregatorPush) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AggregatorPush.Merge(dst, src)
}
func (m *AggregatorPush) XXX_Size() int {
	return m.Size()
}
func (m *AggregatorPush) XXX_DiscardUnknown() {
	xxx_messageInfo_AggregatorPush.DiscardUnknown(m)
}

var xxx_messageInfo_AggregatorPush proto.InternalMessageInfo

type AggregatorPush_Aggregation struct {
	Func AggregatorPush_Func `protobuf:"varint,1,opt,name=func,enum=znbase.roachpb.AggregatorPush_Func" json:"func"`
	// Aggregation functions with distinct = true functions like you would
	// expect '<FUNC> DISTINCT' to operate, the default behavior would be
	// the '<FUNC> ALL' operation.
	Distinct bool `protobuf:"varint,2,opt,name=distinct" json:"distinct"`
	// The column index specifies the argument(s) to the aggregator function.
	//
	// Most aggregations take one argument
	// COUNT_ROWS takes no arguments.
	// FINAL_STDDEV and FINAL_VARIANCE take three arguments (SQRDIFF, SUM,
	// COUNT).
	ColIdx []uint32 `protobuf:"varint,5,rep,name=col_idx,json=colIdx" json:"col_idx,omitempty"`
	// If set, this column index specifies a boolean argument; rows for which
	// this value is not true don't contribute to this aggregation. This enables
	// the filter clause, e.g.:
	//   SELECT SUM(x) FILTER (WHERE y > 1), SUM(x) FILTER (WHERE y < 1) FROM t
	FilterColIdx *uint32 `protobuf:"varint,4,opt,name=filter_col_idx,json=filterColIdx" json:"filter_col_idx,omitempty"`
	// Arguments are const expressions passed to aggregation functions.
	Arguments []string `protobuf:"bytes,6,rep,name=arguments" json:"arguments,omitempty"`
	// true ： 下推的render_expr是有函数名的表达式， false：无函数名
	PushDownToStore *bool            `protobuf:"varint,7,req,name=push_down_to_store,json=pushDownToStore" json:"push_down_to_store,omitempty"`
	ResultType      *ColumnMeta_Type `protobuf:"varint,8,req,name=result_type,json=resultType,enum=znbase.roachpb.ColumnMeta_Type" json:"result_type,omitempty"`
	// 列值再计算的表达式，如：sum((c_acctbal + 10.0))中的 : c_acctbal + 10.0
	RenderExpr *string `protobuf:"bytes,9,opt,name=render_expr,json=renderExpr" json:"render_expr,omitempty"`
}

func (m *AggregatorPush_Aggregation) Reset()         { *m = AggregatorPush_Aggregation{} }
func (m *AggregatorPush_Aggregation) String() string { return proto.CompactTextString(m) }
func (*AggregatorPush_Aggregation) ProtoMessage()    {}
func (*AggregatorPush_Aggregation) Descriptor() ([]byte, []int) {
	return fileDescriptor_pushdown_2b60b53c173e1aa5, []int{4, 0}
}
func (m *AggregatorPush_Aggregation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AggregatorPush_Aggregation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *AggregatorPush_Aggregation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AggregatorPush_Aggregation.Merge(dst, src)
}
func (m *AggregatorPush_Aggregation) XXX_Size() int {
	return m.Size()
}
func (m *AggregatorPush_Aggregation) XXX_DiscardUnknown() {
	xxx_messageInfo_AggregatorPush_Aggregation.DiscardUnknown(m)
}

var xxx_messageInfo_AggregatorPush_Aggregation proto.InternalMessageInfo

// 计算下推条件表达式
type PushDownExpr struct {
	// 数据表的schema信息
	ColIds            []int32           `protobuf:"varint,1,rep,name=col_ids,json=colIds" json:"col_ids,omitempty"`
	ColTypes          []ColumnMeta_Type `protobuf:"varint,2,rep,name=col_types,json=colTypes,enum=znbase.roachpb.ColumnMeta_Type" json:"col_types,omitempty"`
	PrimaryCols       []int32           `protobuf:"varint,3,rep,name=primary_cols,json=primaryCols" json:"primary_cols,omitempty"`
	PrimaryColsDirect []int32           `protobuf:"varint,4,rep,name=primary_cols_direct,json=primaryColsDirect" json:"primary_cols_direct,omitempty"`
	SecondaryCols     []int32           `protobuf:"varint,5,rep,name=secondary_cols,json=secondaryCols" json:"secondary_cols,omitempty"`
	// 排序列
	OrderbyCols []int32 `protobuf:"varint,6,rep,packed,name=orderby_cols,json=orderbyCols" json:"orderby_cols,omitempty"`
	// 排序列的方向，0：小到大顺序， 1：逆序
	OrderDirections []int32 `protobuf:"varint,7,rep,packed,name=order_directions,json=orderDirections" json:"order_directions,omitempty"`
	// 本次查询需要的列
	RequiredCols []int32 `protobuf:"varint,8,rep,name=required_cols,json=requiredCols" json:"required_cols,omitempty"`
	// 多个过滤条件之间AND关系，每个条件内可以有or
	// 如SQL语句:select * from person p1,person2 p2
	//                IsNotNull(name)
	// 注：下推到znbase时，名称将替换为@ID
	// repeated string filters = 8 ;
	Filters    []*FilterUnion  `protobuf:"bytes,9,rep,name=filters" json:"filters,omitempty"`
	Aggregator *AggregatorPush `protobuf:"bytes,10,opt,name=aggregator" json:"aggregator,omitempty"`
}

func (m *PushDownExpr) Reset()         { *m = PushDownExpr{} }
func (m *PushDownExpr) String() string { return proto.CompactTextString(m) }
func (*PushDownExpr) ProtoMessage()    {}
func (*PushDownExpr) Descriptor() ([]byte, []int) {
	return fileDescriptor_pushdown_2b60b53c173e1aa5, []int{5}
}
func (m *PushDownExpr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PushDownExpr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *PushDownExpr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PushDownExpr.Merge(dst, src)
}
func (m *PushDownExpr) XXX_Size() int {
	return m.Size()
}
func (m *PushDownExpr) XXX_DiscardUnknown() {
	xxx_messageInfo_PushDownExpr.DiscardUnknown(m)
}

var xxx_messageInfo_PushDownExpr proto.InternalMessageInfo

func init() {
	proto.RegisterType((*ColumnMeta)(nil), "znbase.roachpb.ColumnMeta")
	proto.RegisterType((*BaseFilter)(nil), "znbase.roachpb.BaseFilter")
	proto.RegisterType((*LogicalFilter)(nil), "znbase.roachpb.LogicalFilter")
	proto.RegisterType((*FilterUnion)(nil), "znbase.roachpb.FilterUnion")
	proto.RegisterType((*AggregatorPush)(nil), "znbase.roachpb.AggregatorPush")
	proto.RegisterType((*AggregatorPush_Aggregation)(nil), "znbase.roachpb.AggregatorPush.Aggregation")
	proto.RegisterType((*PushDownExpr)(nil), "znbase.roachpb.PushDownExpr")
	proto.RegisterEnum("znbase.roachpb.FilterType", FilterType_name, FilterType_value)
	proto.RegisterEnum("znbase.roachpb.ColumnMeta_Type", ColumnMeta_Type_name, ColumnMeta_Type_value)
	proto.RegisterEnum("znbase.roachpb.AggregatorPush_Func", AggregatorPush_Func_name, AggregatorPush_Func_value)
	proto.RegisterEnum("znbase.roachpb.AggregatorPush_Type", AggregatorPush_Type_name, AggregatorPush_Type_value)
}
func (this *BaseFilter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BaseFilter)
	if !ok {
		that2, ok := that.(BaseFilter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Attribute != that1.Attribute {
		return false
	}
	if this.Value != nil && that1.Value != nil {
		if *this.Value != *that1.Value {
			return false
		}
	} else if this.Value != nil {
		return false
	} else if that1.Value != nil {
		return false
	}
	if len(this.Values) != len(that1.Values) {
		return false
	}
	for i := range this.Values {
		if this.Values[i] != that1.Values[i] {
			return false
		}
	}
	return true
}
func (this *LogicalFilter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LogicalFilter)
	if !ok {
		that2, ok := that.(LogicalFilter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Left.Equal(&that1.Left) {
		return false
	}
	if !this.Right.Equal(that1.Right) {
		return false
	}
	return true
}
func (this *FilterUnion) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FilterUnion)
	if !ok {
		that2, ok := that.(FilterUnion)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if that1.Value == nil {
		if this.Value != nil {
			return false
		}
	} else if this.Value == nil {
		return false
	} else if !this.Value.Equal(that1.Value) {
		return false
	}
	return true
}
func (this *FilterUnion_Base) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FilterUnion_Base)
	if !ok {
		that2, ok := that.(FilterUnion_Base)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Base.Equal(that1.Base) {
		return false
	}
	return true
}
func (this *FilterUnion_Logical) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FilterUnion_Logical)
	if !ok {
		that2, ok := that.(FilterUnion_Logical)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Logical.Equal(that1.Logical) {
		return false
	}
	return true
}
func (this *FilterUnion_Expression) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FilterUnion_Expression)
	if !ok {
		that2, ok := that.(FilterUnion_Expression)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Expression != that1.Expression {
		return false
	}
	return true
}
func (this *AggregatorPush) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AggregatorPush)
	if !ok {
		that2, ok := that.(AggregatorPush)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if len(this.GroupCols) != len(that1.GroupCols) {
		return false
	}
	for i := range this.GroupCols {
		if this.GroupCols[i] != that1.GroupCols[i] {
			return false
		}
	}
	if len(this.Aggregations) != len(that1.Aggregations) {
		return false
	}
	for i := range this.Aggregations {
		if !this.Aggregations[i].Equal(&that1.Aggregations[i]) {
			return false
		}
	}
	if len(this.OrderedGroupCols) != len(that1.OrderedGroupCols) {
		return false
	}
	for i := range this.OrderedGroupCols {
		if this.OrderedGroupCols[i] != that1.OrderedGroupCols[i] {
			return false
		}
	}
	return true
}
func (this *AggregatorPush_Aggregation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AggregatorPush_Aggregation)
	if !ok {
		that2, ok := that.(AggregatorPush_Aggregation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Func != that1.Func {
		return false
	}
	if this.Distinct != that1.Distinct {
		return false
	}
	if len(this.ColIdx) != len(that1.ColIdx) {
		return false
	}
	for i := range this.ColIdx {
		if this.ColIdx[i] != that1.ColIdx[i] {
			return false
		}
	}
	if this.FilterColIdx != nil && that1.FilterColIdx != nil {
		if *this.FilterColIdx != *that1.FilterColIdx {
			return false
		}
	} else if this.FilterColIdx != nil {
		return false
	} else if that1.FilterColIdx != nil {
		return false
	}
	if len(this.Arguments) != len(that1.Arguments) {
		return false
	}
	for i := range this.Arguments {
		if this.Arguments[i] != that1.Arguments[i] {
			return false
		}
	}
	if this.PushDownToStore != nil && that1.PushDownToStore != nil {
		if *this.PushDownToStore != *that1.PushDownToStore {
			return false
		}
	} else if this.PushDownToStore != nil {
		return false
	} else if that1.PushDownToStore != nil {
		return false
	}
	if this.ResultType != nil && that1.ResultType != nil {
		if *this.ResultType != *that1.ResultType {
			return false
		}
	} else if this.ResultType != nil {
		return false
	} else if that1.ResultType != nil {
		return false
	}
	if this.RenderExpr != nil && that1.RenderExpr != nil {
		if *this.RenderExpr != *that1.RenderExpr {
			return false
		}
	} else if this.RenderExpr != nil {
		return false
	} else if that1.RenderExpr != nil {
		return false
	}
	return true
}
func (this *PushDownExpr) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PushDownExpr)
	if !ok {
		that2, ok := that.(PushDownExpr)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ColIds) != len(that1.ColIds) {
		return false
	}
	for i := range this.ColIds {
		if this.ColIds[i] != that1.ColIds[i] {
			return false
		}
	}
	if len(this.ColTypes) != len(that1.ColTypes) {
		return false
	}
	for i := range this.ColTypes {
		if this.ColTypes[i] != that1.ColTypes[i] {
			return false
		}
	}
	if len(this.PrimaryCols) != len(that1.PrimaryCols) {
		return false
	}
	for i := range this.PrimaryCols {
		if this.PrimaryCols[i] != that1.PrimaryCols[i] {
			return false
		}
	}
	if len(this.PrimaryColsDirect) != len(that1.PrimaryColsDirect) {
		return false
	}
	for i := range this.PrimaryColsDirect {
		if this.PrimaryColsDirect[i] != that1.PrimaryColsDirect[i] {
			return false
		}
	}
	if len(this.SecondaryCols) != len(that1.SecondaryCols) {
		return false
	}
	for i := range this.SecondaryCols {
		if this.SecondaryCols[i] != that1.SecondaryCols[i] {
			return false
		}
	}
	if len(this.OrderbyCols) != len(that1.OrderbyCols) {
		return false
	}
	for i := range this.OrderbyCols {
		if this.OrderbyCols[i] != that1.OrderbyCols[i] {
			return false
		}
	}
	if len(this.OrderDirections) != len(that1.OrderDirections) {
		return false
	}
	for i := range this.OrderDirections {
		if this.OrderDirections[i] != that1.OrderDirections[i] {
			return false
		}
	}
	if len(this.RequiredCols) != len(that1.RequiredCols) {
		return false
	}
	for i := range this.RequiredCols {
		if this.RequiredCols[i] != that1.RequiredCols[i] {
			return false
		}
	}
	if len(this.Filters) != len(that1.Filters) {
		return false
	}
	for i := range this.Filters {
		if !this.Filters[i].Equal(that1.Filters[i]) {
			return false
		}
	}
	if !this.Aggregator.Equal(that1.Aggregator) {
		return false
	}
	return true
}
func (m *ColumnMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnMeta) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *BaseFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BaseFilter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x12
	i++
	i = encodeVarintPushdown(dAtA, i, uint64(len(m.Attribute)))
	i += copy(dAtA[i:], m.Attribute)
	if m.Value != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPushdown(dAtA, i, uint64(len(*m.Value)))
		i += copy(dAtA[i:], *m.Value)
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *LogicalFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogicalFilter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x12
	i++
	i = encodeVarintPushdown(dAtA, i, uint64(m.Left.Size()))
	n1, err := m.Left.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	if m.Right != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPushdown(dAtA, i, uint64(m.Right.Size()))
		n2, err := m.Right.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *FilterUnion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FilterUnion) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintPushdown(dAtA, i, uint64(m.Type))
	if m.Value != nil {
		nn3, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn3
	}
	return i, nil
}

func (m *FilterUnion_Base) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Base != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPushdown(dAtA, i, uint64(m.Base.Size()))
		n4, err := m.Base.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *FilterUnion_Logical) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Logical != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPushdown(dAtA, i, uint64(m.Logical.Size()))
		n5, err := m.Logical.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *FilterUnion_Expression) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x22
	i++
	i = encodeVarintPushdown(dAtA, i, uint64(len(m.Expression)))
	i += copy(dAtA[i:], m.Expression)
	return i, nil
}
func (m *AggregatorPush) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AggregatorPush) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GroupCols) > 0 {
		dAtA7 := make([]byte, len(m.GroupCols)*10)
		var j6 int
		for _, num := range m.GroupCols {
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintPushdown(dAtA, i, uint64(j6))
		i += copy(dAtA[i:], dAtA7[:j6])
	}
	if len(m.Aggregations) > 0 {
		for _, msg := range m.Aggregations {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintPushdown(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.OrderedGroupCols) > 0 {
		dAtA9 := make([]byte, len(m.OrderedGroupCols)*10)
		var j8 int
		for _, num := range m.OrderedGroupCols {
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintPushdown(dAtA, i, uint64(j8))
		i += copy(dAtA[i:], dAtA9[:j8])
	}
	dAtA[i] = 0x28
	i++
	i = encodeVarintPushdown(dAtA, i, uint64(m.Type))
	return i, nil
}

func (m *AggregatorPush_Aggregation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AggregatorPush_Aggregation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintPushdown(dAtA, i, uint64(m.Func))
	dAtA[i] = 0x10
	i++
	if m.Distinct {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if m.FilterColIdx != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPushdown(dAtA, i, uint64(*m.FilterColIdx))
	}
	if len(m.ColIdx) > 0 {
		for _, num := range m.ColIdx {
			dAtA[i] = 0x28
			i++
			i = encodeVarintPushdown(dAtA, i, uint64(num))
		}
	}
	if len(m.Arguments) > 0 {
		for _, s := range m.Arguments {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.PushDownToStore == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("push_down_to_store")
	} else {
		dAtA[i] = 0x38
		i++
		if *m.PushDownToStore {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ResultType == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("result_type")
	} else {
		dAtA[i] = 0x40
		i++
		i = encodeVarintPushdown(dAtA, i, uint64(*m.ResultType))
	}
	if m.RenderExpr != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintPushdown(dAtA, i, uint64(len(*m.RenderExpr)))
		i += copy(dAtA[i:], *m.RenderExpr)
	}
	return i, nil
}

func (m *PushDownExpr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PushDownExpr) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ColIds) > 0 {
		for _, num := range m.ColIds {
			dAtA[i] = 0x8
			i++
			i = encodeVarintPushdown(dAtA, i, uint64(num))
		}
	}
	if len(m.ColTypes) > 0 {
		for _, num := range m.ColTypes {
			dAtA[i] = 0x10
			i++
			i = encodeVarintPushdown(dAtA, i, uint64(num))
		}
	}
	if len(m.PrimaryCols) > 0 {
		for _, num := range m.PrimaryCols {
			dAtA[i] = 0x18
			i++
			i = encodeVarintPushdown(dAtA, i, uint64(num))
		}
	}
	if len(m.PrimaryColsDirect) > 0 {
		for _, num := range m.PrimaryColsDirect {
			dAtA[i] = 0x20
			i++
			i = encodeVarintPushdown(dAtA, i, uint64(num))
		}
	}
	if len(m.SecondaryCols) > 0 {
		for _, num := range m.SecondaryCols {
			dAtA[i] = 0x28
			i++
			i = encodeVarintPushdown(dAtA, i, uint64(num))
		}
	}
	if len(m.OrderbyCols) > 0 {
		dAtA11 := make([]byte, len(m.OrderbyCols)*10)
		var j10 int
		for _, num1 := range m.OrderbyCols {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		dAtA[i] = 0x32
		i++
		i = encodeVarintPushdown(dAtA, i, uint64(j10))
		i += copy(dAtA[i:], dAtA11[:j10])
	}
	if len(m.OrderDirections) > 0 {
		dAtA13 := make([]byte, len(m.OrderDirections)*10)
		var j12 int
		for _, num1 := range m.OrderDirections {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j12++
			}
			dAtA13[j12] = uint8(num)
			j12++
		}
		dAtA[i] = 0x3a
		i++
		i = encodeVarintPushdown(dAtA, i, uint64(j12))
		i += copy(dAtA[i:], dAtA13[:j12])
	}
	if len(m.RequiredCols) > 0 {
		for _, num := range m.RequiredCols {
			dAtA[i] = 0x40
			i++
			i = encodeVarintPushdown(dAtA, i, uint64(num))
		}
	}
	if len(m.Filters) > 0 {
		for _, msg := range m.Filters {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintPushdown(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Aggregator != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintPushdown(dAtA, i, uint64(m.Aggregator.Size()))
		n14, err := m.Aggregator.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func encodeVarintPushdown(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ColumnMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *BaseFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Attribute)
	n += 1 + l + sovPushdown(uint64(l))
	if m.Value != nil {
		l = len(*m.Value)
		n += 1 + l + sovPushdown(uint64(l))
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			l = len(s)
			n += 1 + l + sovPushdown(uint64(l))
		}
	}
	return n
}

func (m *LogicalFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Left.Size()
	n += 1 + l + sovPushdown(uint64(l))
	if m.Right != nil {
		l = m.Right.Size()
		n += 1 + l + sovPushdown(uint64(l))
	}
	return n
}

func (m *FilterUnion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPushdown(uint64(m.Type))
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *FilterUnion_Base) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Base != nil {
		l = m.Base.Size()
		n += 1 + l + sovPushdown(uint64(l))
	}
	return n
}
func (m *FilterUnion_Logical) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Logical != nil {
		l = m.Logical.Size()
		n += 1 + l + sovPushdown(uint64(l))
	}
	return n
}
func (m *FilterUnion_Expression) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Expression)
	n += 1 + l + sovPushdown(uint64(l))
	return n
}
func (m *AggregatorPush) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.GroupCols) > 0 {
		l = 0
		for _, e := range m.GroupCols {
			l += sovPushdown(uint64(e))
		}
		n += 1 + sovPushdown(uint64(l)) + l
	}
	if len(m.Aggregations) > 0 {
		for _, e := range m.Aggregations {
			l = e.Size()
			n += 1 + l + sovPushdown(uint64(l))
		}
	}
	if len(m.OrderedGroupCols) > 0 {
		l = 0
		for _, e := range m.OrderedGroupCols {
			l += sovPushdown(uint64(e))
		}
		n += 1 + sovPushdown(uint64(l)) + l
	}
	n += 1 + sovPushdown(uint64(m.Type))
	return n
}

func (m *AggregatorPush_Aggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPushdown(uint64(m.Func))
	n += 2
	if m.FilterColIdx != nil {
		n += 1 + sovPushdown(uint64(*m.FilterColIdx))
	}
	if len(m.ColIdx) > 0 {
		for _, e := range m.ColIdx {
			n += 1 + sovPushdown(uint64(e))
		}
	}
	if len(m.Arguments) > 0 {
		for _, s := range m.Arguments {
			l = len(s)
			n += 1 + l + sovPushdown(uint64(l))
		}
	}
	if m.PushDownToStore != nil {
		n += 2
	}
	if m.ResultType != nil {
		n += 1 + sovPushdown(uint64(*m.ResultType))
	}
	if m.RenderExpr != nil {
		l = len(*m.RenderExpr)
		n += 1 + l + sovPushdown(uint64(l))
	}
	return n
}

func (m *PushDownExpr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ColIds) > 0 {
		for _, e := range m.ColIds {
			n += 1 + sovPushdown(uint64(e))
		}
	}
	if len(m.ColTypes) > 0 {
		for _, e := range m.ColTypes {
			n += 1 + sovPushdown(uint64(e))
		}
	}
	if len(m.PrimaryCols) > 0 {
		for _, e := range m.PrimaryCols {
			n += 1 + sovPushdown(uint64(e))
		}
	}
	if len(m.PrimaryColsDirect) > 0 {
		for _, e := range m.PrimaryColsDirect {
			n += 1 + sovPushdown(uint64(e))
		}
	}
	if len(m.SecondaryCols) > 0 {
		for _, e := range m.SecondaryCols {
			n += 1 + sovPushdown(uint64(e))
		}
	}
	if len(m.OrderbyCols) > 0 {
		l = 0
		for _, e := range m.OrderbyCols {
			l += sovPushdown(uint64(e))
		}
		n += 1 + sovPushdown(uint64(l)) + l
	}
	if len(m.OrderDirections) > 0 {
		l = 0
		for _, e := range m.OrderDirections {
			l += sovPushdown(uint64(e))
		}
		n += 1 + sovPushdown(uint64(l)) + l
	}
	if len(m.RequiredCols) > 0 {
		for _, e := range m.RequiredCols {
			n += 1 + sovPushdown(uint64(e))
		}
	}
	if len(m.Filters) > 0 {
		for _, e := range m.Filters {
			l = e.Size()
			n += 1 + l + sovPushdown(uint64(l))
		}
	}
	if m.Aggregator != nil {
		l = m.Aggregator.Size()
		n += 1 + l + sovPushdown(uint64(l))
	}
	return n
}

func sovPushdown(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozPushdown(x uint64) (n int) {
	return sovPushdown(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ColumnMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPushdown
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPushdown(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPushdown
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BaseFilter) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPushdown
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BaseFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BaseFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attribute", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPushdown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPushdown
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attribute = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPushdown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPushdown
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Value = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPushdown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPushdown
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPushdown(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPushdown
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("attribute")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogicalFilter) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPushdown
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogicalFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogicalFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Left", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPushdown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPushdown
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Left.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Right", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPushdown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPushdown
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Right == nil {
				m.Right = &FilterUnion{}
			}
			if err := m.Right.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPushdown(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPushdown
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("left")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FilterUnion) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPushdown
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilterUnion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilterUnion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPushdown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (FilterType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPushdown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPushdown
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BaseFilter{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &FilterUnion_Base{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logical", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPushdown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPushdown
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LogicalFilter{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &FilterUnion_Logical{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expression", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPushdown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPushdown
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = &FilterUnion_Expression{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPushdown(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPushdown
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("type")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AggregatorPush) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPushdown
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AggregatorPush: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AggregatorPush: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPushdown
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GroupCols = append(m.GroupCols, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPushdown
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPushdown
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.GroupCols) == 0 {
					m.GroupCols = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPushdown
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GroupCols = append(m.GroupCols, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupCols", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggregations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPushdown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPushdown
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Aggregations = append(m.Aggregations, AggregatorPush_Aggregation{})
			if err := m.Aggregations[len(m.Aggregations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPushdown
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OrderedGroupCols = append(m.OrderedGroupCols, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPushdown
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPushdown
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OrderedGroupCols) == 0 {
					m.OrderedGroupCols = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPushdown
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OrderedGroupCols = append(m.OrderedGroupCols, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderedGroupCols", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPushdown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (AggregatorPush_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPushdown(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPushdown
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AggregatorPush_Aggregation) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPushdown
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Aggregation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Aggregation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Func", wireType)
			}
			m.Func = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPushdown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Func |= (AggregatorPush_Func(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Distinct", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPushdown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Distinct = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterColIdx", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPushdown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FilterColIdx = &v
		case 5:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPushdown
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColIdx = append(m.ColIdx, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPushdown
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPushdown
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColIdx) == 0 {
					m.ColIdx = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPushdown
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColIdx = append(m.ColIdx, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColIdx", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arguments", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPushdown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPushdown
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Arguments = append(m.Arguments, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushDownToStore", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPushdown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.PushDownToStore = &b
			hasFields[0] |= uint64(0x00000001)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResultType", wireType)
			}
			var v ColumnMeta_Type
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPushdown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (ColumnMeta_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ResultType = &v
			hasFields[0] |= uint64(0x00000002)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RenderExpr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPushdown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPushdown
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.RenderExpr = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPushdown(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPushdown
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("push_down_to_store")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("result_type")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PushDownExpr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPushdown
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PushDownExpr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PushDownExpr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPushdown
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColIds = append(m.ColIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPushdown
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPushdown
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColIds) == 0 {
					m.ColIds = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPushdown
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColIds = append(m.ColIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColIds", wireType)
			}
		case 2:
			if wireType == 0 {
				var v ColumnMeta_Type
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPushdown
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ColumnMeta_Type(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColTypes = append(m.ColTypes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPushdown
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPushdown
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ColTypes) == 0 {
					m.ColTypes = make([]ColumnMeta_Type, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ColumnMeta_Type
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPushdown
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ColumnMeta_Type(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColTypes = append(m.ColTypes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColTypes", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPushdown
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PrimaryCols = append(m.PrimaryCols, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPushdown
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPushdown
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PrimaryCols) == 0 {
					m.PrimaryCols = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPushdown
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PrimaryCols = append(m.PrimaryCols, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryCols", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPushdown
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PrimaryColsDirect = append(m.PrimaryColsDirect, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPushdown
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPushdown
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PrimaryColsDirect) == 0 {
					m.PrimaryColsDirect = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPushdown
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PrimaryColsDirect = append(m.PrimaryColsDirect, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryColsDirect", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPushdown
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SecondaryCols = append(m.SecondaryCols, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPushdown
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPushdown
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SecondaryCols) == 0 {
					m.SecondaryCols = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPushdown
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SecondaryCols = append(m.SecondaryCols, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondaryCols", wireType)
			}
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPushdown
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OrderbyCols = append(m.OrderbyCols, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPushdown
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPushdown
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OrderbyCols) == 0 {
					m.OrderbyCols = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPushdown
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OrderbyCols = append(m.OrderbyCols, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderbyCols", wireType)
			}
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPushdown
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OrderDirections = append(m.OrderDirections, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPushdown
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPushdown
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OrderDirections) == 0 {
					m.OrderDirections = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPushdown
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OrderDirections = append(m.OrderDirections, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderDirections", wireType)
			}
		case 8:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPushdown
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RequiredCols = append(m.RequiredCols, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPushdown
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPushdown
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RequiredCols) == 0 {
					m.RequiredCols = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPushdown
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RequiredCols = append(m.RequiredCols, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredCols", wireType)
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPushdown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPushdown
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filters = append(m.Filters, &FilterUnion{})
			if err := m.Filters[len(m.Filters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggregator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPushdown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPushdown
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Aggregator == nil {
				m.Aggregator = &AggregatorPush{}
			}
			if err := m.Aggregator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPushdown(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPushdown
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPushdown(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPushdown
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPushdown
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPushdown
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthPushdown
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPushdown
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPushdown(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPushdown = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPushdown   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("roachpb/pushdown.proto", fileDescriptor_pushdown_2b60b53c173e1aa5) }

var fileDescriptor_pushdown_2b60b53c173e1aa5 = []byte{
	// 1432 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x56, 0xcd, 0x72, 0xdb, 0x46,
	0x12, 0x26, 0x40, 0x50, 0x24, 0x9b, 0x3f, 0x6a, 0x8d, 0x65, 0x1b, 0xeb, 0xf5, 0x52, 0x34, 0xbd,
	0xae, 0x62, 0x79, 0x77, 0x65, 0xaf, 0x2a, 0x3e, 0xe4, 0xb7, 0x02, 0x92, 0x90, 0x0c, 0x17, 0x09,
	0x28, 0x20, 0xa8, 0xd8, 0xbe, 0xa0, 0x20, 0x12, 0xa2, 0x50, 0x05, 0x03, 0x34, 0x00, 0xc6, 0x52,
	0xee, 0xb9, 0xe4, 0x94, 0x47, 0xc8, 0x31, 0x6f, 0x90, 0x57, 0x50, 0x6e, 0xbe, 0xc5, 0x27, 0x57,
	0x2c, 0x1f, 0x92, 0x57, 0xc8, 0x2d, 0xd5, 0x03, 0x88, 0x94, 0x94, 0x94, 0xe3, 0xdb, 0xf4, 0xdf,
	0xd7, 0x3d, 0xd3, 0xdd, 0x1f, 0x00, 0xd7, 0xa2, 0xd0, 0x19, 0x1f, 0xce, 0xf6, 0xef, 0xcd, 0xe6,
	0xf1, 0xe1, 0x24, 0x7c, 0x11, 0x6c, 0xce, 0xa2, 0x30, 0x09, 0x59, 0xfd, 0xeb, 0x60, 0xdf, 0x89,
	0xdd, 0xcd, 0xcc, 0x7c, 0x63, 0x7d, 0x1a, 0x4e, 0x43, 0x6e, 0xba, 0x47, 0xa7, 0xd4, 0xab, 0xf5,
	0xa3, 0x08, 0xd0, 0x0d, 0xfd, 0xf9, 0xb3, 0x60, 0xe0, 0x26, 0x4e, 0xeb, 0x07, 0x11, 0x24, 0xeb,
	0x78, 0xe6, 0xb2, 0x12, 0x48, 0x1d, 0xc3, 0xe8, 0x63, 0x8e, 0x15, 0x21, 0xaf, 0xe9, 0x16, 0x0a,
	0xac, 0x0c, 0x85, 0xed, 0xbe, 0xa1, 0x58, 0x28, 0xb2, 0x0a, 0x14, 0x7b, 0x6a, 0x57, 0x1b, 0x28,
	0x7d, 0xcc, 0x93, 0x6b, 0x4f, 0xb1, 0x54, 0x94, 0x58, 0x0d, 0xca, 0x96, 0x36, 0x50, 0x87, 0x96,
	0x32, 0xd8, 0xc5, 0x02, 0xab, 0x42, 0x49, 0xd3, 0x2d, 0xd5, 0xdc, 0x53, 0xfa, 0xb8, 0xc2, 0x00,
	0x56, 0x86, 0x96, 0xa9, 0xe9, 0x3b, 0x58, 0x24, 0xa8, 0xce, 0x13, 0x4b, 0x1d, 0x62, 0x89, 0xad,
	0x42, 0x65, 0x11, 0x63, 0x3d, 0xc5, 0x32, 0x63, 0x50, 0xef, 0x1a, 0xfd, 0xbe, 0x62, 0xa9, 0xbd,
	0xcc, 0x1f, 0x28, 0x85, 0xae, 0x0c, 0x54, 0xac, 0x50, 0x35, 0x86, 0xd6, 0xc3, 0x2a, 0xc1, 0xe9,
	0xa3, 0x7e, 0xdf, 0xb6, 0xb0, 0x46, 0xe6, 0xd1, 0x48, 0xeb, 0x61, 0x9d, 0x80, 0x15, 0xd3, 0x54,
	0x9e, 0xe0, 0x2a, 0x29, 0x35, 0x5d, 0xb5, 0x10, 0xe9, 0x44, 0x29, 0x70, 0x8d, 0xcc, 0x8f, 0x86,
	0x86, 0xde, 0x41, 0x46, 0xf1, 0xa4, 0xb4, 0x9e, 0xe2, 0x15, 0x52, 0x5b, 0xa3, 0xdd, 0xbe, 0x8a,
	0xeb, 0x84, 0xdf, 0xd1, 0x2c, 0xbc, 0xca, 0x56, 0x01, 0x34, 0xdd, 0xda, 0xda, 0x53, 0xbb, 0x96,
	0x61, 0xe2, 0x89, 0xc0, 0xea, 0x50, 0x36, 0xb4, 0x5e, 0x26, 0xff, 0x24, 0xb4, 0x66, 0x00, 0x1d,
	0x27, 0x76, 0xb7, 0x3d, 0x3f, 0x71, 0x23, 0xd6, 0x82, 0xb2, 0x93, 0x24, 0x91, 0xb7, 0x3f, 0x4f,
	0x5c, 0x59, 0x6c, 0x8a, 0xed, 0x72, 0x47, 0x3a, 0x79, 0xbd, 0x91, 0x33, 0x97, 0x6a, 0xb6, 0x0e,
	0x85, 0xaf, 0x1c, 0x7f, 0xee, 0xca, 0xf9, 0xa6, 0xd0, 0x2e, 0x9b, 0xa9, 0xc0, 0x6e, 0xc2, 0x0a,
	0x3f, 0xc4, 0xb2, 0xd4, 0xcc, 0x67, 0x61, 0x82, 0x99, 0xe9, 0x3e, 0x92, 0x7e, 0xfb, 0x7e, 0x43,
	0x78, 0x24, 0x95, 0x04, 0x14, 0x5b, 0xdf, 0x08, 0x50, 0xeb, 0x87, 0x53, 0x6f, 0xec, 0xf8, 0x59,
	0xd6, 0x07, 0x20, 0xf9, 0xee, 0x41, 0xc2, 0x13, 0x56, 0xb6, 0xfe, 0xb9, 0x79, 0xb1, 0xe5, 0x9b,
	0xa9, 0xd7, 0x28, 0xf0, 0xc2, 0x20, 0xab, 0x86, 0xbb, 0xb3, 0xff, 0x43, 0x21, 0xf2, 0xa6, 0x87,
	0x09, 0x2f, 0xe4, 0xdd, 0x71, 0x66, 0xea, 0x79, 0xa1, 0x8e, 0x37, 0x02, 0x54, 0xce, 0xb9, 0xb0,
	0x0f, 0x40, 0x4a, 0x8e, 0x67, 0xae, 0x2c, 0x34, 0xc5, 0x76, 0x7d, 0xeb, 0xc6, 0x5f, 0xa3, 0xd1,
	0x54, 0x9d, 0x15, 0x41, 0xde, 0xec, 0x3e, 0x48, 0xe4, 0x26, 0x8b, 0xbc, 0x86, 0x3f, 0x45, 0x2d,
	0xdf, 0xf6, 0x61, 0xce, 0xe4, 0x9e, 0xec, 0x43, 0x28, 0xfa, 0xe9, 0xf5, 0xb3, 0xc2, 0xff, 0x75,
	0x39, 0xe8, 0xc2, 0xeb, 0x3c, 0xcc, 0x99, 0x67, 0xfe, 0xac, 0x09, 0xe0, 0x1e, 0xcd, 0x22, 0x37,
	0x8e, 0xbd, 0x30, 0x90, 0x25, 0x7a, 0xff, 0x87, 0x39, 0xf3, 0x9c, 0x2e, 0xbd, 0x60, 0xa7, 0x98,
	0xb5, 0xa8, 0xf5, 0x7b, 0x11, 0xea, 0xca, 0x74, 0x1a, 0xb9, 0x53, 0x27, 0x09, 0xa3, 0xdd, 0x79,
	0x7c, 0xc8, 0x6e, 0x01, 0x4c, 0xa3, 0x70, 0x3e, 0xb3, 0xc7, 0xa1, 0x1f, 0xcb, 0x62, 0x33, 0xdf,
	0xae, 0x75, 0x44, 0x14, 0xcc, 0x32, 0xd7, 0x76, 0x43, 0x3f, 0x66, 0x16, 0x54, 0x9d, 0x2c, 0xc8,
	0x0b, 0x83, 0x58, 0xce, 0x37, 0xf3, 0xed, 0xca, 0xd6, 0xdd, 0xcb, 0x65, 0x5e, 0x04, 0x5e, 0x88,
	0xcb, 0x36, 0x5d, 0x40, 0x61, 0xf7, 0x81, 0x85, 0xd1, 0xc4, 0x8d, 0xdc, 0x89, 0x7d, 0xae, 0x00,
	0x69, 0x51, 0x00, 0x66, 0xd6, 0x9d, 0x45, 0x1d, 0x9f, 0x66, 0x1d, 0x29, 0x34, 0x85, 0x76, 0x7d,
	0xeb, 0xf6, 0xdf, 0xe4, 0xbf, 0xdc, 0x9a, 0x1b, 0xbf, 0x8a, 0x50, 0x39, 0x57, 0x14, 0xc1, 0x1d,
	0xcc, 0x83, 0xb1, 0x2c, 0xbc, 0x17, 0xdc, 0xf6, 0x3c, 0x18, 0x9f, 0xc1, 0x51, 0x18, 0x6b, 0x42,
	0x69, 0xe2, 0xc5, 0x89, 0x17, 0x8c, 0x13, 0xde, 0xed, 0x52, 0x66, 0x5d, 0x68, 0xd9, 0xbf, 0xa1,
	0x7e, 0xc0, 0x7b, 0x46, 0x57, 0xb3, 0xbd, 0xc9, 0x11, 0x6f, 0x51, 0xcd, 0xac, 0xa6, 0xda, 0x6e,
	0xe8, 0x6b, 0x93, 0x23, 0x76, 0x1d, 0x8a, 0x67, 0xe6, 0x02, 0x5d, 0xde, 0x5c, 0x19, 0xa7, 0x86,
	0x9b, 0x50, 0x76, 0xa2, 0xe9, 0xfc, 0x99, 0x1b, 0x24, 0xb1, 0xbc, 0x42, 0x5b, 0x64, 0x2e, 0x15,
	0xec, 0x3f, 0xc0, 0x88, 0x1a, 0x6d, 0xe2, 0x46, 0x3b, 0x09, 0xed, 0x38, 0x09, 0x23, 0x57, 0x2e,
	0x36, 0xc5, 0x76, 0xc9, 0x5c, 0x25, 0x4b, 0x2f, 0x7c, 0x11, 0x58, 0xe1, 0x90, 0xd4, 0xec, 0x73,
	0xa8, 0x44, 0x6e, 0x3c, 0xf7, 0x13, 0x9b, 0x3f, 0x60, 0x89, 0x8f, 0xf4, 0xc6, 0xe5, 0x1b, 0x2f,
	0x19, 0x93, 0x3f, 0x9e, 0x09, 0x69, 0x0c, 0x67, 0xce, 0x0d, 0x42, 0x08, 0x26, 0x6e, 0x64, 0xd3,
	0x74, 0xc9, 0x65, 0xbe, 0xeb, 0x90, 0xaa, 0xd4, 0xa3, 0x59, 0xb4, 0x58, 0xa5, 0x3c, 0x4a, 0xad,
	0xd7, 0x22, 0x48, 0xf4, 0x5e, 0x0c, 0xa1, 0xaa, 0xe8, 0x4f, 0x6c, 0xdd, 0xb0, 0x6c, 0xa2, 0xb5,
	0x94, 0x77, 0x95, 0xbd, 0x1d, 0x14, 0x88, 0x46, 0x89, 0x8a, 0x6d, 0x45, 0xef, 0xa5, 0xd4, 0xcb,
	0x25, 0xc3, 0xc4, 0x3c, 0xab, 0x03, 0x74, 0x0d, 0xbd, 0xab, 0x58, 0xb6, 0xb2, 0xb3, 0x83, 0x12,
	0x11, 0x59, 0xd7, 0x18, 0xe9, 0x16, 0x16, 0x28, 0x7c, 0xa0, 0x3c, 0xc6, 0x22, 0x3f, 0x68, 0x3a,
	0x96, 0x52, 0x02, 0xee, 0xf5, 0xd4, 0x3d, 0x2c, 0x93, 0x72, 0x38, 0x1a, 0x20, 0x10, 0xdc, 0x70,
	0x34, 0xb0, 0x89, 0xe1, 0x2b, 0x94, 0x69, 0x4f, 0x31, 0x35, 0x45, 0xef, 0xaa, 0x58, 0x25, 0xd3,
	0x63, 0xc3, 0xe4, 0xc8, 0xb5, 0x34, 0xd3, 0x48, 0xb7, 0x6c, 0xd3, 0xf8, 0x72, 0x88, 0x75, 0x1e,
	0xf7, 0x85, 0xd9, 0xd3, 0xb6, 0xb7, 0x71, 0x95, 0x28, 0x7b, 0x5b, 0xd3, 0x95, 0xbe, 0xbd, 0x88,
	0x46, 0xba, 0x50, 0xaa, 0xcb, 0x72, 0xae, 0xd1, 0xd7, 0x81, 0x73, 0x33, 0x47, 0x64, 0x94, 0x8c,
	0xb8, 0x98, 0x4b, 0x57, 0xc8, 0xc8, 0x99, 0x99, 0x8b, 0xeb, 0x94, 0x2e, 0x25, 0x7f, 0x2e, 0x5f,
	0xa5, 0xda, 0x07, 0x6a, 0x4f, 0x53, 0x74, 0xbc, 0x46, 0xc8, 0x3b, 0xa6, 0x31, 0xda, 0xb5, 0xd3,
	0xab, 0xe3, 0x75, 0x2a, 0xa6, 0xaf, 0x0d, 0x2d, 0x72, 0x95, 0x09, 0x37, 0xad, 0x74, 0xb7, 0x87,
	0xff, 0x68, 0xfd, 0x77, 0xf9, 0x3d, 0x53, 0x46, 0x96, 0x81, 0x39, 0xfe, 0x0c, 0x5d, 0xa5, 0xaf,
	0x98, 0x48, 0x9c, 0x0e, 0xba, 0xa1, 0xdb, 0x99, 0x2c, 0xa6, 0xad, 0x69, 0xfd, 0x9c, 0x87, 0xea,
	0x6e, 0x36, 0x17, 0xd4, 0xb1, 0xe5, 0xe0, 0xc5, 0xb2, 0xd0, 0xcc, 0xb7, 0x0b, 0xd9, 0xe0, 0xc5,
	0xec, 0x13, 0x28, 0x93, 0x81, 0x46, 0x25, 0x65, 0x84, 0xf7, 0x98, 0x95, 0xd2, 0x38, 0xf4, 0xe9,
	0x10, 0xb3, 0x5b, 0x50, 0x9d, 0x45, 0xde, 0x33, 0x27, 0x3a, 0x4e, 0x37, 0x3a, 0xcf, 0xb1, 0x2b,
	0x99, 0x8e, 0x2f, 0xf2, 0x26, 0x5c, 0x39, 0xef, 0x62, 0x4f, 0xbc, 0xc8, 0x1d, 0x27, 0x7c, 0xf7,
	0x0b, 0xe6, 0xda, 0x39, 0xcf, 0x1e, 0x37, 0xb0, 0x3b, 0x50, 0x8f, 0xdd, 0x71, 0x18, 0x4c, 0x16,
	0xa0, 0x05, 0xee, 0x5a, 0x5b, 0x68, 0x39, 0xec, 0x1d, 0xa8, 0x72, 0xce, 0xd8, 0xcf, 0x9c, 0x68,
	0x67, 0x0a, 0x9c, 0x4b, 0x2a, 0x99, 0x9e, 0xbb, 0xfd, 0x0f, 0x52, 0x6a, 0xc9, 0xd2, 0x72, 0x4a,
	0x2b, 0x2e, 0x5c, 0x57, 0xb9, 0xad, 0xb7, 0x30, 0xb1, 0xdb, 0x50, 0x8b, 0xdc, 0xe7, 0x73, 0x8f,
	0x88, 0x8a, 0xc3, 0x96, 0x78, 0xee, 0xea, 0x99, 0x92, 0x63, 0x3e, 0x80, 0x62, 0xba, 0xd4, 0xb1,
	0x5c, 0xe6, 0xec, 0xf8, 0xce, 0xaf, 0xcf, 0x99, 0x2f, 0xfb, 0x0c, 0xc0, 0x59, 0xd0, 0x8c, 0x0c,
	0x9c, 0xfe, 0x1b, 0xef, 0x26, 0x22, 0xf3, 0x5c, 0x44, 0xda, 0xd9, 0xbb, 0xdf, 0x8a, 0x00, 0xcb,
	0xcf, 0x11, 0xb5, 0x5f, 0xf1, 0x5f, 0x38, 0xc7, 0xb1, 0x15, 0xcd, 0x5d, 0xcc, 0xd1, 0xbf, 0x48,
	0x2a, 0x6f, 0x3b, 0x7e, 0xec, 0xa2, 0x40, 0x53, 0xa9, 0xc5, 0x7a, 0x98, 0xe8, 0x73, 0xdf, 0x47,
	0x91, 0x46, 0x47, 0x8b, 0xf9, 0x39, 0x4f, 0xab, 0xa6, 0x3e, 0x9f, 0x3b, 0x3e, 0x4a, 0x6c, 0x0d,
	0x6a, 0xfc, 0x48, 0x96, 0xa1, 0x73, 0xe0, 0x62, 0x81, 0x26, 0x72, 0x27, 0x72, 0x9d, 0xc4, 0x8d,
	0x70, 0x85, 0xd6, 0x23, 0x13, 0x8c, 0x28, 0x8d, 0x29, 0xd2, 0x3c, 0xf6, 0xdd, 0x38, 0x4e, 0x7f,
	0x80, 0xe8, 0x74, 0x66, 0x2a, 0xb3, 0x15, 0x10, 0xb5, 0x00, 0x81, 0xc2, 0x86, 0x49, 0xe4, 0x05,
	0xd3, 0x6e, 0x18, 0x24, 0x8e, 0x17, 0xc4, 0x58, 0xe1, 0x7b, 0xc1, 0x75, 0x6a, 0x30, 0x89, 0xb1,
	0x4a, 0xbb, 0x90, 0xca, 0xc3, 0xc4, 0x89, 0x92, 0x18, 0x6b, 0xb4, 0xd9, 0x7a, 0x98, 0x60, 0x9d,
	0x60, 0x8c, 0x08, 0x57, 0x39, 0x8f, 0x04, 0x13, 0x44, 0x8a, 0x55, 0x17, 0xdf, 0x3b, 0x5c, 0xef,
	0x7c, 0x7c, 0xf2, 0xa6, 0x91, 0x3b, 0x39, 0x6d, 0x08, 0x2f, 0x4f, 0x1b, 0xc2, 0xab, 0xd3, 0x86,
	0xf0, 0xcb, 0x69, 0x43, 0xf8, 0xee, 0x6d, 0x23, 0xf7, 0xf2, 0x6d, 0x23, 0xf7, 0xea, 0x6d, 0x23,
	0x07, 0x97, 0x7e, 0x21, 0x77, 0x85, 0xa7, 0xc5, 0xec, 0xf8, 0x47, 0x00, 0x00, 0x00, 0xff, 0xff,
	0xe5, 0x82, 0xdc, 0x74, 0x76, 0x0a, 0x00, 0x00,
}
