// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: jobs/jobspb/jobs.proto

package jobspb

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import roachpb "github.com/znbasedb/znbase/pkg/roachpb"
import sqlbase "github.com/znbasedb/znbase/pkg/sql/sqlbase"
import hlc "github.com/znbasedb/znbase/pkg/util/hlc"

import github_com_znbasedb_znbase_pkg_roachpb "github.com/znbasedb/znbase/pkg/roachpb"
import github_com_znbasedb_znbase_pkg_sql_sqlbase "github.com/znbasedb/znbase/pkg/sql/sqlbase"
import github_com_znbasedb_znbase_pkg_sql_sem_tree "github.com/znbasedb/znbase/pkg/sql/sem/tree"

import github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Status int32

const (
	Status_DRAINING_NAMES       Status = 0
	Status_WAIT_FOR_GC_INTERVAL Status = 1
	Status_ROCKSDB_COMPACTION   Status = 2
	Status_DONE                 Status = 10
)

var Status_name = map[int32]string{
	0:  "DRAINING_NAMES",
	1:  "WAIT_FOR_GC_INTERVAL",
	2:  "ROCKSDB_COMPACTION",
	10: "DONE",
}
var Status_value = map[string]int32{
	"DRAINING_NAMES":       0,
	"WAIT_FOR_GC_INTERVAL": 1,
	"ROCKSDB_COMPACTION":   2,
	"DONE":                 10,
}

func (x Status) String() string {
	return proto.EnumName(Status_name, int32(x))
}
func (Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_jobs_d8caa83bd0f9be11, []int{0}
}

type Type int32

const (
	TypeUnspecified     Type = 0
	TypeBackup          Type = 1
	TypeRestore         Type = 2
	TypeSchemaChange    Type = 3
	TypeImport          Type = 4
	TypeChangefeed      Type = 5
	TypeCreateStats     Type = 6
	TypeAutoCreateStats Type = 7
	TypeDump            Type = 8
	TypeSchemaChangeGC  Type = 9
)

var Type_name = map[int32]string{
	0: "UNSPECIFIED",
	1: "BACKUP",
	2: "RESTORE",
	3: "SCHEMA_CHANGE",
	4: "IMPORT",
	5: "CHANGEFEED",
	6: "CREATE_STATS",
	7: "AUTO_CREATE_STATS",
	8: "DUMP",
	9: "SCHEMA_CHANGE_GC",
}
var Type_value = map[string]int32{
	"UNSPECIFIED":       0,
	"BACKUP":            1,
	"RESTORE":           2,
	"SCHEMA_CHANGE":     3,
	"IMPORT":            4,
	"CHANGEFEED":        5,
	"CREATE_STATS":      6,
	"AUTO_CREATE_STATS": 7,
	"DUMP":              8,
	"SCHEMA_CHANGE_GC":  9,
}

func (Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_jobs_d8caa83bd0f9be11, []int{1}
}

type SchemaChangeGCProgress_Status int32

const (
	// Waiting for the index/table to expire.
	SchemaChangeGCProgress_WAITING_FOR_GC SchemaChangeGCProgress_Status = 0
	// The GC TTL has expired. This element is marked for imminent deletion
	SchemaChangeGCProgress_DELETING SchemaChangeGCProgress_Status = 1
	// This element has been deleted. The job is done when all elements are in
	// this state.
	SchemaChangeGCProgress_DELETED SchemaChangeGCProgress_Status = 2
)

var SchemaChangeGCProgress_Status_name = map[int32]string{
	0: "WAITING_FOR_GC",
	1: "DELETING",
	2: "DELETED",
}
var SchemaChangeGCProgress_Status_value = map[string]int32{
	"WAITING_FOR_GC": 0,
	"DELETING":       1,
	"DELETED":        2,
}

func (x SchemaChangeGCProgress_Status) String() string {
	return proto.EnumName(SchemaChangeGCProgress_Status_name, int32(x))
}
func (SchemaChangeGCProgress_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_jobs_d8caa83bd0f9be11, []int{14, 0}
}

type Lease struct {
	// The ID of the node that holds the lease.
	NodeID github_com_znbasedb_znbase_pkg_roachpb.NodeID `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3,casttype=github.com/znbasedb/znbase/pkg/roachpb.NodeID" json:"node_id,omitempty"`
	// The epoch of the lease holder's node liveness entry.
	Epoch int64 `protobuf:"varint,2,opt,name=epoch,proto3" json:"epoch,omitempty"`
}

func (m *Lease) Reset()         { *m = Lease{} }
func (m *Lease) String() string { return proto.CompactTextString(m) }
func (*Lease) ProtoMessage()    {}
func (*Lease) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_d8caa83bd0f9be11, []int{0}
}
func (m *Lease) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Lease) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *Lease) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Lease.Merge(dst, src)
}
func (m *Lease) XXX_Size() int {
	return m.Size()
}
func (m *Lease) XXX_DiscardUnknown() {
	xxx_messageInfo_Lease.DiscardUnknown(m)
}

var xxx_messageInfo_Lease proto.InternalMessageInfo

type BackupDetails struct {
	StartTime        hlc.Timestamp                  `protobuf:"bytes,1,opt,name=start_time,json=startTime,proto3" json:"start_time"`
	EndTime          hlc.Timestamp                  `protobuf:"bytes,2,opt,name=end_time,json=endTime,proto3" json:"end_time"`
	URI              string                         `protobuf:"bytes,3,opt,name=uri,proto3" json:"uri,omitempty"`
	BackupDescriptor []byte                         `protobuf:"bytes,4,opt,name=backup_descriptor,json=backupDescriptor,proto3" json:"backup_descriptor,omitempty"`
	Encryption       *roachpb.FileEncryptionOptions `protobuf:"bytes,6,opt,name=encryption,proto3" json:"encryption,omitempty"`
}

func (m *BackupDetails) Reset()         { *m = BackupDetails{} }
func (m *BackupDetails) String() string { return proto.CompactTextString(m) }
func (*BackupDetails) ProtoMessage()    {}
func (*BackupDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_d8caa83bd0f9be11, []int{1}
}
func (m *BackupDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackupDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *BackupDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackupDetails.Merge(dst, src)
}
func (m *BackupDetails) XXX_Size() int {
	return m.Size()
}
func (m *BackupDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_BackupDetails.DiscardUnknown(m)
}

var xxx_messageInfo_BackupDetails proto.InternalMessageInfo

type BackupProgress struct {
}

func (m *BackupProgress) Reset()         { *m = BackupProgress{} }
func (m *BackupProgress) String() string { return proto.CompactTextString(m) }
func (*BackupProgress) ProtoMessage()    {}
func (*BackupProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_d8caa83bd0f9be11, []int{2}
}
func (m *BackupProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackupProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *BackupProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackupProgress.Merge(dst, src)
}
func (m *BackupProgress) XXX_Size() int {
	return m.Size()
}
func (m *BackupProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_BackupProgress.DiscardUnknown(m)
}

var xxx_messageInfo_BackupProgress proto.InternalMessageInfo

type DumpDetails struct {
	StartTime        hlc.Timestamp                    `protobuf:"bytes,1,opt,name=start_time,json=startTime,proto3" json:"start_time"`
	EndTime          hlc.Timestamp                    `protobuf:"bytes,2,opt,name=end_time,json=endTime,proto3" json:"end_time"`
	URI              string                           `protobuf:"bytes,3,opt,name=uri,proto3" json:"uri,omitempty"`
	DumpDescriptor   []byte                           `protobuf:"bytes,4,opt,name=dump_descriptor,json=dumpDescriptor,proto3" json:"dump_descriptor,omitempty"`
	Encryption       *roachpb.FileEncryptionOptions   `protobuf:"bytes,6,opt,name=encryption,proto3" json:"encryption,omitempty"`
	CompressionCodec roachpb.FileCompression          `protobuf:"varint,7,opt,name=compression_codec,json=compressionCodec,proto3,enum=znbase.roachpb.FileCompression" json:"compression_codec,omitempty"`
	DumpOnline       bool                             `protobuf:"varint,8,opt,name=dump_online,json=dumpOnline,proto3" json:"dump_online,omitempty"`
	DumpOnlineFiles  roachpb.DumpOnlineResponse_Files `protobuf:"bytes,9,opt,name=dump_online_files,json=dumpOnlineFiles,proto3" json:"dump_online_files"`
	HttpHeader       string                           `protobuf:"bytes,10,opt,name=http_header,json=httpHeader,proto3" json:"http_header,omitempty"`
}

func (m *DumpDetails) Reset()         { *m = DumpDetails{} }
func (m *DumpDetails) String() string { return proto.CompactTextString(m) }
func (*DumpDetails) ProtoMessage()    {}
func (*DumpDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_d8caa83bd0f9be11, []int{3}
}
func (m *DumpDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DumpDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *DumpDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DumpDetails.Merge(dst, src)
}
func (m *DumpDetails) XXX_Size() int {
	return m.Size()
}
func (m *DumpDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_DumpDetails.DiscardUnknown(m)
}

var xxx_messageInfo_DumpDetails proto.InternalMessageInfo

type DumpProgress struct {
}

func (m *DumpProgress) Reset()         { *m = DumpProgress{} }
func (m *DumpProgress) String() string { return proto.CompactTextString(m) }
func (*DumpProgress) ProtoMessage()    {}
func (*DumpProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_d8caa83bd0f9be11, []int{4}
}
func (m *DumpProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DumpProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *DumpProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DumpProgress.Merge(dst, src)
}
func (m *DumpProgress) XXX_Size() int {
	return m.Size()
}
func (m *DumpProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_DumpProgress.DiscardUnknown(m)
}

var xxx_messageInfo_DumpProgress proto.InternalMessageInfo

type RestoreDetails struct {
	EndTime            hlc.Timestamp                                                                  `protobuf:"bytes,4,opt,name=end_time,json=endTime,proto3" json:"end_time"`
	TableRewrites      map[github_com_znbasedb_znbase_pkg_sql_sqlbase.ID]*RestoreDetails_TableRewrite `protobuf:"bytes,2,rep,name=table_rewrites,json=tableRewrites,proto3,castkey=github.com/znbasedb/znbase/pkg/sql/sqlbase.ID" json:"table_rewrites,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	URIs               []string                                                                       `protobuf:"bytes,3,rep,name=uris,proto3" json:"uris,omitempty"`
	TableDescs         []*sqlbase.TableDescriptor                                                     `protobuf:"bytes,5,rep,name=table_descs,json=tableDescs,proto3" json:"table_descs,omitempty"`
	SchemaDescs        []*sqlbase.SchemaDescriptor                                                    `protobuf:"bytes,15,rep,name=schema_descs,json=schemaDescs,proto3" json:"schema_descs,omitempty"`
	DatabaseDescs      []*sqlbase.DatabaseDescriptor                                                  `protobuf:"bytes,16,rep,name=database_descs,json=databaseDescs,proto3" json:"database_descs,omitempty"`
	OverrideDB         string                                                                         `protobuf:"bytes,6,opt,name=override_db,json=overrideDb,proto3" json:"override_db,omitempty"`
	Encryption         *roachpb.FileEncryptionOptions                                                 `protobuf:"bytes,12,opt,name=encryption,proto3" json:"encryption,omitempty"`
	DescriptorCoverage github_com_znbasedb_znbase_pkg_sql_sem_tree.DescriptorCoverage                 `protobuf:"varint,11,opt,name=descriptor_coverage,json=descriptorCoverage,proto3,casttype=github.com/znbasedb/znbase/pkg/sql/sem/tree.DescriptorCoverage" json:"descriptor_coverage,omitempty"`
	HttpHeader         string                                                                         `protobuf:"bytes,13,opt,name=http_header,json=httpHeader,proto3" json:"http_header,omitempty"`
	// once during the lifetime of a job. Note, that this state may be shared
	// between job versions, so updates to this map must be considered carefully.
	// It maps system table names to whether or not they have already been
	// restored.
	SystemTablesRestored map[string]bool `protobuf:"bytes,14,rep,name=system_tables_restored,json=systemTablesRestored,proto3" json:"system_tables_restored,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	SystemTmpRestored    bool            `protobuf:"varint,17,opt,name=system_tmp_restored,json=systemTmpRestored,proto3" json:"system_tmp_restored,omitempty"`
	PrepareCompleted     bool            `protobuf:"varint,18,opt,name=prepare_completed,json=prepareCompleted,proto3" json:"prepare_completed,omitempty"`
}

func (m *RestoreDetails) Reset()         { *m = RestoreDetails{} }
func (m *RestoreDetails) String() string { return proto.CompactTextString(m) }
func (*RestoreDetails) ProtoMessage()    {}
func (*RestoreDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_d8caa83bd0f9be11, []int{5}
}
func (m *RestoreDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RestoreDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *RestoreDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RestoreDetails.Merge(dst, src)
}
func (m *RestoreDetails) XXX_Size() int {
	return m.Size()
}
func (m *RestoreDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_RestoreDetails.DiscardUnknown(m)
}

var xxx_messageInfo_RestoreDetails proto.InternalMessageInfo

type RestoreDetails_TableRewrite struct {
	TableID  github_com_znbasedb_znbase_pkg_sql_sqlbase.ID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/znbasedb/znbase/pkg/sql/sqlbase.ID" json:"table_id,omitempty"`
	ParentID github_com_znbasedb_znbase_pkg_sql_sqlbase.ID `protobuf:"varint,2,opt,name=parent_id,json=parentId,proto3,casttype=github.com/znbasedb/znbase/pkg/sql/sqlbase.ID" json:"parent_id,omitempty"`
}

func (m *RestoreDetails_TableRewrite) Reset()         { *m = RestoreDetails_TableRewrite{} }
func (m *RestoreDetails_TableRewrite) String() string { return proto.CompactTextString(m) }
func (*RestoreDetails_TableRewrite) ProtoMessage()    {}
func (*RestoreDetails_TableRewrite) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_d8caa83bd0f9be11, []int{5, 0}
}
func (m *RestoreDetails_TableRewrite) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RestoreDetails_TableRewrite) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *RestoreDetails_TableRewrite) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RestoreDetails_TableRewrite.Merge(dst, src)
}
func (m *RestoreDetails_TableRewrite) XXX_Size() int {
	return m.Size()
}
func (m *RestoreDetails_TableRewrite) XXX_DiscardUnknown() {
	xxx_messageInfo_RestoreDetails_TableRewrite.DiscardUnknown(m)
}

var xxx_messageInfo_RestoreDetails_TableRewrite proto.InternalMessageInfo

type RestoreProgress struct {
	HighWater []byte `protobuf:"bytes,1,opt,name=high_water,json=highWater,proto3" json:"high_water,omitempty"`
}

func (m *RestoreProgress) Reset()         { *m = RestoreProgress{} }
func (m *RestoreProgress) String() string { return proto.CompactTextString(m) }
func (*RestoreProgress) ProtoMessage()    {}
func (*RestoreProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_d8caa83bd0f9be11, []int{6}
}
func (m *RestoreProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RestoreProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *RestoreProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RestoreProgress.Merge(dst, src)
}
func (m *RestoreProgress) XXX_Size() int {
	return m.Size()
}
func (m *RestoreProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_RestoreProgress.DiscardUnknown(m)
}

var xxx_messageInfo_RestoreProgress proto.InternalMessageInfo

type ImportDetails struct {
	Tables     []ImportDetails_Table                         `protobuf:"bytes,1,rep,name=tables,proto3" json:"tables"`
	URIs       []string                                      `protobuf:"bytes,2,rep,name=uris,proto3" json:"uris,omitempty"`
	Format     roachpb.IOFileFormat                          `protobuf:"bytes,3,opt,name=format,proto3" json:"format"`
	SSTSize    int64                                         `protobuf:"varint,4,opt,name=sst_size,json=sstSize,proto3" json:"sst_size,omitempty"`
	Oversample int64                                         `protobuf:"varint,9,opt,name=oversample,proto3" json:"oversample,omitempty"`
	SkipFKs    bool                                          `protobuf:"varint,10,opt,name=skip_fks,json=skipFks,proto3" json:"skip_fks,omitempty"`
	Walltime   int64                                         `protobuf:"varint,5,opt,name=walltime,proto3" json:"walltime,omitempty"`
	ParentID   github_com_znbasedb_znbase_pkg_sql_sqlbase.ID `protobuf:"varint,6,opt,name=parent_id,json=parentId,proto3,casttype=github.com/znbasedb/znbase/pkg/sql/sqlbase.ID" json:"parent_id,omitempty"`
	BackupPath string                                        `protobuf:"bytes,7,opt,name=backup_path,json=backupPath,proto3" json:"backup_path,omitempty"`
	// samples is a sampling of znbase KV keys generated from the input data.
	// It is populated with the sampling phase's results. These must be
	// used if a job is resumed to guarantee that AddSSTable will not attempt
	// to add ranges with an old split point within them.
	Samples [][]byte `protobuf:"bytes,8,rep,name=samples,proto3" json:"samples,omitempty"`
	// ingest_directly means the Import job directly ingests the data as readers
	// produce it instead of sampling it and then setting up a distsql shuffle and
	// sort that produced sorted, non-overlapping data to ingest. When ingesting
	// directly, many other fields like samples, oversample, sst_size are ignored.
	IngestDirectly  bool                           `protobuf:"varint,11,opt,name=ingest_directly,json=ingestDirectly,proto3" json:"ingest_directly,omitempty"`
	Encoding        string                         `protobuf:"bytes,12,opt,name=encoding,proto3" json:"encoding,omitempty"`
	Encryption      *roachpb.FileEncryptionOptions `protobuf:"bytes,24,opt,name=encryption,proto3" json:"encryption,omitempty"`
	Databases       []ImportDetails_Database       `protobuf:"bytes,25,rep,name=databases,proto3" json:"databases"`
	Schemas         []*sqlbase.SchemaDescriptor    `protobuf:"bytes,26,rep,name=schemas,proto3" json:"schemas,omitempty"`
	PrepareComplete bool                           `protobuf:"varint,27,opt,name=prepare_complete,json=prepareComplete,proto3" json:"prepare_complete,omitempty"`
}

func (m *ImportDetails) Reset()         { *m = ImportDetails{} }
func (m *ImportDetails) String() string { return proto.CompactTextString(m) }
func (*ImportDetails) ProtoMessage()    {}
func (*ImportDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_d8caa83bd0f9be11, []int{7}
}
func (m *ImportDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImportDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ImportDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImportDetails.Merge(dst, src)
}
func (m *ImportDetails) XXX_Size() int {
	return m.Size()
}
func (m *ImportDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_ImportDetails.DiscardUnknown(m)
}

var xxx_messageInfo_ImportDetails proto.InternalMessageInfo

type ImportDetails_Database struct {
	Database *sqlbase.DatabaseDescriptor `protobuf:"bytes,1,opt,name=database,proto3" json:"database,omitempty"`
	Schemas  []*sqlbase.SchemaDescriptor `protobuf:"bytes,2,rep,name=schemas,proto3" json:"schemas,omitempty"`
}

func (m *ImportDetails_Database) Reset()         { *m = ImportDetails_Database{} }
func (m *ImportDetails_Database) String() string { return proto.CompactTextString(m) }
func (*ImportDetails_Database) ProtoMessage()    {}
func (*ImportDetails_Database) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_d8caa83bd0f9be11, []int{7, 0}
}
func (m *ImportDetails_Database) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImportDetails_Database) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ImportDetails_Database) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImportDetails_Database.Merge(dst, src)
}
func (m *ImportDetails_Database) XXX_Size() int {
	return m.Size()
}
func (m *ImportDetails_Database) XXX_DiscardUnknown() {
	xxx_messageInfo_ImportDetails_Database.DiscardUnknown(m)
}

var xxx_messageInfo_ImportDetails_Database proto.InternalMessageInfo

type ImportDetails_Table struct {
	Desc       *sqlbase.TableDescriptor `protobuf:"bytes,1,opt,name=desc,proto3" json:"desc,omitempty"`
	Name       string                   `protobuf:"bytes,18,opt,name=name,proto3" json:"name,omitempty"`
	SeqVal     int64                    `protobuf:"varint,19,opt,name=seq_val,json=seqVal,proto3" json:"seq_val,omitempty"`
	IsNew      bool                     `protobuf:"varint,20,opt,name=is_new,json=isNew,proto3" json:"is_new,omitempty"`
	TargetCols []string                 `protobuf:"bytes,21,rep,name=target_cols,json=targetCols,proto3" json:"target_cols,omitempty"`
}

func (m *ImportDetails_Table) Reset()         { *m = ImportDetails_Table{} }
func (m *ImportDetails_Table) String() string { return proto.CompactTextString(m) }
func (*ImportDetails_Table) ProtoMessage()    {}
func (*ImportDetails_Table) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_d8caa83bd0f9be11, []int{7, 1}
}
func (m *ImportDetails_Table) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImportDetails_Table) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ImportDetails_Table) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImportDetails_Table.Merge(dst, src)
}
func (m *ImportDetails_Table) XXX_Size() int {
	return m.Size()
}
func (m *ImportDetails_Table) XXX_DiscardUnknown() {
	xxx_messageInfo_ImportDetails_Table.DiscardUnknown(m)
}

var xxx_messageInfo_ImportDetails_Table proto.InternalMessageInfo

type ImportProgress struct {
	SamplingProgress []float32                      `protobuf:"fixed32,1,rep,packed,name=sampling_progress,json=samplingProgress,proto3" json:"sampling_progress,omitempty"`
	ReadProgress     []float32                      `protobuf:"fixed32,2,rep,packed,name=read_progress,json=readProgress,proto3" json:"read_progress,omitempty"`
	WriteProgress    []float32                      `protobuf:"fixed32,3,rep,packed,name=write_progress,json=writeProgress,proto3" json:"write_progress,omitempty"`
	SpanProgress     []*ImportProgress_SpanProgress `protobuf:"bytes,4,rep,name=span_progress,json=spanProgress,proto3" json:"span_progress,omitempty"`
}

func (m *ImportProgress) Reset()         { *m = ImportProgress{} }
func (m *ImportProgress) String() string { return proto.CompactTextString(m) }
func (*ImportProgress) ProtoMessage()    {}
func (*ImportProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_d8caa83bd0f9be11, []int{8}
}
func (m *ImportProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImportProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ImportProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImportProgress.Merge(dst, src)
}
func (m *ImportProgress) XXX_Size() int {
	return m.Size()
}
func (m *ImportProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_ImportProgress.DiscardUnknown(m)
}

var xxx_messageInfo_ImportProgress proto.InternalMessageInfo

// The spans of split keys which have had their SSTable's generated.
// This allows us to skip the shuffle stage for already-completed
// spans when resuming an import job.
type ImportProgress_SpanProgress struct {
	Table        sqlbase.TableDescriptor `protobuf:"bytes,1,opt,name=table,proto3" json:"table"`
	SpanProgress []roachpb.Span          `protobuf:"bytes,2,rep,name=span_progress,json=spanProgress,proto3" json:"span_progress"`
}

func (m *ImportProgress_SpanProgress) Reset()         { *m = ImportProgress_SpanProgress{} }
func (m *ImportProgress_SpanProgress) String() string { return proto.CompactTextString(m) }
func (*ImportProgress_SpanProgress) ProtoMessage()    {}
func (*ImportProgress_SpanProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_d8caa83bd0f9be11, []int{8, 0}
}
func (m *ImportProgress_SpanProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImportProgress_SpanProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ImportProgress_SpanProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImportProgress_SpanProgress.Merge(dst, src)
}
func (m *ImportProgress_SpanProgress) XXX_Size() int {
	return m.Size()
}
func (m *ImportProgress_SpanProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_ImportProgress_SpanProgress.DiscardUnknown(m)
}

var xxx_messageInfo_ImportProgress_SpanProgress proto.InternalMessageInfo

type ResumeSpanList struct {
	ResumeSpans []roachpb.Span `protobuf:"bytes,1,rep,name=resume_spans,json=resumeSpans,proto3" json:"resume_spans"`
}

func (m *ResumeSpanList) Reset()         { *m = ResumeSpanList{} }
func (m *ResumeSpanList) String() string { return proto.CompactTextString(m) }
func (*ResumeSpanList) ProtoMessage()    {}
func (*ResumeSpanList) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_d8caa83bd0f9be11, []int{9}
}
func (m *ResumeSpanList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResumeSpanList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ResumeSpanList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResumeSpanList.Merge(dst, src)
}
func (m *ResumeSpanList) XXX_Size() int {
	return m.Size()
}
func (m *ResumeSpanList) XXX_DiscardUnknown() {
	xxx_messageInfo_ResumeSpanList.DiscardUnknown(m)
}

var xxx_messageInfo_ResumeSpanList proto.InternalMessageInfo

type DroppedTableDetails struct {
	Name   string                                        `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	ID     github_com_znbasedb_znbase_pkg_sql_sqlbase.ID `protobuf:"varint,2,opt,name=ID,proto3,casttype=github.com/znbasedb/znbase/pkg/sql/sqlbase.ID" json:"ID,omitempty"`
	Status Status                                        `protobuf:"varint,3,opt,name=status,proto3,enum=znbase.sql.jobs.jobspb.Status" json:"status,omitempty"`
}

func (m *DroppedTableDetails) Reset()         { *m = DroppedTableDetails{} }
func (m *DroppedTableDetails) String() string { return proto.CompactTextString(m) }
func (*DroppedTableDetails) ProtoMessage()    {}
func (*DroppedTableDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_d8caa83bd0f9be11, []int{10}
}
func (m *DroppedTableDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DroppedTableDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *DroppedTableDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DroppedTableDetails.Merge(dst, src)
}
func (m *DroppedTableDetails) XXX_Size() int {
	return m.Size()
}
func (m *DroppedTableDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_DroppedTableDetails.DiscardUnknown(m)
}

var xxx_messageInfo_DroppedTableDetails proto.InternalMessageInfo

// SchemaChangeGCDetails should resemble one of the following:
//
// 1. Index (non-interleaved) deletions: One or more deletions of an index on a
// table.
//      details.Indexes -> the indexes to GC. These indexes must be
//      non-interleaved.
//      details.ParentID -> the table with the indexes.
//
// 2. Table deletions: The deletion of a single table.
//      details.Tables -> the tables to be deleted.
//
// 3. Database deletions: The deletion of a database and therefore all its tables.
//      details.Tables -> the IDs of the tables to GC.
//      details.ParentID -> the ID of the database to drop.
type SchemaChangeGCDetails struct {
	// Indexes to GC.
	Indexes []SchemaChangeGCDetails_DroppedIndex `protobuf:"bytes,1,rep,name=indexes,proto3" json:"indexes"`
	// Entire tables to GC.
	Tables []SchemaChangeGCDetails_DroppedID `protobuf:"bytes,2,rep,name=tables,proto3" json:"tables"`
	// If dropping indexes, the table ID which has those indexes. If dropping a
	// database, the database ID.
	ParentID github_com_znbasedb_znbase_pkg_sql_sqlbase.ID `protobuf:"varint,3,opt,name=parent_id,json=parentId,proto3,casttype=github.com/znbasedb/znbase/pkg/sql/sqlbase.ID" json:"parent_id,omitempty"`
}

func (m *SchemaChangeGCDetails) Reset()         { *m = SchemaChangeGCDetails{} }
func (m *SchemaChangeGCDetails) String() string { return proto.CompactTextString(m) }
func (*SchemaChangeGCDetails) ProtoMessage()    {}
func (*SchemaChangeGCDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_d8caa83bd0f9be11, []int{11}
}
func (m *SchemaChangeGCDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaChangeGCDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *SchemaChangeGCDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaChangeGCDetails.Merge(dst, src)
}
func (m *SchemaChangeGCDetails) XXX_Size() int {
	return m.Size()
}
func (m *SchemaChangeGCDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaChangeGCDetails.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaChangeGCDetails proto.InternalMessageInfo

type SchemaChangeGCDetails_DroppedIndex struct {
	IndexID  github_com_znbasedb_znbase_pkg_sql_sqlbase.IndexID `protobuf:"varint,1,opt,name=index_id,json=indexId,proto3,casttype=github.com/znbasedb/znbase/pkg/sql/sqlbase.IndexID" json:"index_id,omitempty"`
	DropTime int64                                              `protobuf:"varint,2,opt,name=drop_time,json=dropTime,proto3" json:"drop_time,omitempty"`
}

func (m *SchemaChangeGCDetails_DroppedIndex) Reset()         { *m = SchemaChangeGCDetails_DroppedIndex{} }
func (m *SchemaChangeGCDetails_DroppedIndex) String() string { return proto.CompactTextString(m) }
func (*SchemaChangeGCDetails_DroppedIndex) ProtoMessage()    {}
func (*SchemaChangeGCDetails_DroppedIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_d8caa83bd0f9be11, []int{11, 0}
}
func (m *SchemaChangeGCDetails_DroppedIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaChangeGCDetails_DroppedIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *SchemaChangeGCDetails_DroppedIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaChangeGCDetails_DroppedIndex.Merge(dst, src)
}
func (m *SchemaChangeGCDetails_DroppedIndex) XXX_Size() int {
	return m.Size()
}
func (m *SchemaChangeGCDetails_DroppedIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaChangeGCDetails_DroppedIndex.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaChangeGCDetails_DroppedIndex proto.InternalMessageInfo

type SchemaChangeGCDetails_DroppedID struct {
	ID       github_com_znbasedb_znbase_pkg_sql_sqlbase.ID `protobuf:"varint,1,opt,name=id,proto3,casttype=github.com/znbasedb/znbase/pkg/sql/sqlbase.ID" json:"id,omitempty"`
	DropTime int64                                         `protobuf:"varint,2,opt,name=drop_time,json=dropTime,proto3" json:"drop_time,omitempty"`
}

func (m *SchemaChangeGCDetails_DroppedID) Reset()         { *m = SchemaChangeGCDetails_DroppedID{} }
func (m *SchemaChangeGCDetails_DroppedID) String() string { return proto.CompactTextString(m) }
func (*SchemaChangeGCDetails_DroppedID) ProtoMessage()    {}
func (*SchemaChangeGCDetails_DroppedID) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_d8caa83bd0f9be11, []int{11, 1}
}
func (m *SchemaChangeGCDetails_DroppedID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaChangeGCDetails_DroppedID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *SchemaChangeGCDetails_DroppedID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaChangeGCDetails_DroppedID.Merge(dst, src)
}
func (m *SchemaChangeGCDetails_DroppedID) XXX_Size() int {
	return m.Size()
}
func (m *SchemaChangeGCDetails_DroppedID) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaChangeGCDetails_DroppedID.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaChangeGCDetails_DroppedID proto.InternalMessageInfo

type SchemaChangeDetails struct {
	// A schema change can involve running multiple processors backfilling
	// or deleting data. They occasionally checkpoint Spans so that the
	// processing can resume in the event of a node failure. The spans are
	// non-overlapping contiguous areas of the KV space that still need to
	// be processed. The index represents the index of a mutation in a
	// mutation list containing mutations for the same mutationID.
	ResumeSpanList []ResumeSpanList      `protobuf:"bytes,2,rep,name=resume_span_list,json=resumeSpanList,proto3" json:"resume_span_list"`
	DroppedTables  []DroppedTableDetails `protobuf:"bytes,3,rep,name=dropped_tables,json=droppedTables,proto3" json:"dropped_tables"`
	// The descriptor ID of the dropped database which created this job.
	DroppedDatabaseID github_com_znbasedb_znbase_pkg_sql_sqlbase.ID `protobuf:"varint,4,opt,name=dropped_database_id,json=droppedDatabaseId,proto3,casttype=github.com/znbasedb/znbase/pkg/sql/sqlbase.ID" json:"dropped_database_id,omitempty"`
}

func (m *SchemaChangeDetails) Reset()         { *m = SchemaChangeDetails{} }
func (m *SchemaChangeDetails) String() string { return proto.CompactTextString(m) }
func (*SchemaChangeDetails) ProtoMessage()    {}
func (*SchemaChangeDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_d8caa83bd0f9be11, []int{12}
}
func (m *SchemaChangeDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaChangeDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *SchemaChangeDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaChangeDetails.Merge(dst, src)
}
func (m *SchemaChangeDetails) XXX_Size() int {
	return m.Size()
}
func (m *SchemaChangeDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaChangeDetails.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaChangeDetails proto.InternalMessageInfo

type SchemaChangeProgress struct {
}

func (m *SchemaChangeProgress) Reset()         { *m = SchemaChangeProgress{} }
func (m *SchemaChangeProgress) String() string { return proto.CompactTextString(m) }
func (*SchemaChangeProgress) ProtoMessage()    {}
func (*SchemaChangeProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_d8caa83bd0f9be11, []int{13}
}
func (m *SchemaChangeProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaChangeProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *SchemaChangeProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaChangeProgress.Merge(dst, src)
}
func (m *SchemaChangeProgress) XXX_Size() int {
	return m.Size()
}
func (m *SchemaChangeProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaChangeProgress.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaChangeProgress proto.InternalMessageInfo

type SchemaChangeGCProgress struct {
	// Indexes to GC.
	Indexes []SchemaChangeGCProgress_IndexProgress `protobuf:"bytes,1,rep,name=indexes,proto3" json:"indexes"`
	// Entire tables to GC.
	Tables []SchemaChangeGCProgress_TableProgress `protobuf:"bytes,2,rep,name=tables,proto3" json:"tables"`
}

func (m *SchemaChangeGCProgress) Reset()         { *m = SchemaChangeGCProgress{} }
func (m *SchemaChangeGCProgress) String() string { return proto.CompactTextString(m) }
func (*SchemaChangeGCProgress) ProtoMessage()    {}
func (*SchemaChangeGCProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_d8caa83bd0f9be11, []int{14}
}
func (m *SchemaChangeGCProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaChangeGCProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *SchemaChangeGCProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaChangeGCProgress.Merge(dst, src)
}
func (m *SchemaChangeGCProgress) XXX_Size() int {
	return m.Size()
}
func (m *SchemaChangeGCProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaChangeGCProgress.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaChangeGCProgress proto.InternalMessageInfo

type SchemaChangeGCProgress_IndexProgress struct {
	IndexID github_com_znbasedb_znbase_pkg_sql_sqlbase.IndexID `protobuf:"varint,1,opt,name=index_id,json=indexId,proto3,casttype=github.com/znbasedb/znbase/pkg/sql/sqlbase.IndexID" json:"index_id,omitempty"`
	Status  SchemaChangeGCProgress_Status                      `protobuf:"varint,2,opt,name=status,proto3,enum=znbase.sql.jobs.jobspb.SchemaChangeGCProgress_Status" json:"status,omitempty"`
}

func (m *SchemaChangeGCProgress_IndexProgress) Reset()         { *m = SchemaChangeGCProgress_IndexProgress{} }
func (m *SchemaChangeGCProgress_IndexProgress) String() string { return proto.CompactTextString(m) }
func (*SchemaChangeGCProgress_IndexProgress) ProtoMessage()    {}
func (*SchemaChangeGCProgress_IndexProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_d8caa83bd0f9be11, []int{14, 0}
}
func (m *SchemaChangeGCProgress_IndexProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaChangeGCProgress_IndexProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *SchemaChangeGCProgress_IndexProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaChangeGCProgress_IndexProgress.Merge(dst, src)
}
func (m *SchemaChangeGCProgress_IndexProgress) XXX_Size() int {
	return m.Size()
}
func (m *SchemaChangeGCProgress_IndexProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaChangeGCProgress_IndexProgress.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaChangeGCProgress_IndexProgress proto.InternalMessageInfo

type SchemaChangeGCProgress_TableProgress struct {
	ID     github_com_znbasedb_znbase_pkg_sql_sqlbase.ID `protobuf:"varint,1,opt,name=id,proto3,casttype=github.com/znbasedb/znbase/pkg/sql/sqlbase.ID" json:"id,omitempty"`
	Status SchemaChangeGCProgress_Status                 `protobuf:"varint,2,opt,name=status,proto3,enum=znbase.sql.jobs.jobspb.SchemaChangeGCProgress_Status" json:"status,omitempty"`
}

func (m *SchemaChangeGCProgress_TableProgress) Reset()         { *m = SchemaChangeGCProgress_TableProgress{} }
func (m *SchemaChangeGCProgress_TableProgress) String() string { return proto.CompactTextString(m) }
func (*SchemaChangeGCProgress_TableProgress) ProtoMessage()    {}
func (*SchemaChangeGCProgress_TableProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_d8caa83bd0f9be11, []int{14, 1}
}
func (m *SchemaChangeGCProgress_TableProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaChangeGCProgress_TableProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *SchemaChangeGCProgress_TableProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaChangeGCProgress_TableProgress.Merge(dst, src)
}
func (m *SchemaChangeGCProgress_TableProgress) XXX_Size() int {
	return m.Size()
}
func (m *SchemaChangeGCProgress_TableProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaChangeGCProgress_TableProgress.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaChangeGCProgress_TableProgress proto.InternalMessageInfo

type ChangefeedTarget struct {
	StatementTimeName string `protobuf:"bytes,1,opt,name=statement_time_name,json=statementTimeName,proto3" json:"statement_time_name,omitempty"`
}

func (m *ChangefeedTarget) Reset()         { *m = ChangefeedTarget{} }
func (m *ChangefeedTarget) String() string { return proto.CompactTextString(m) }
func (*ChangefeedTarget) ProtoMessage()    {}
func (*ChangefeedTarget) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_d8caa83bd0f9be11, []int{15}
}
func (m *ChangefeedTarget) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangefeedTarget) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ChangefeedTarget) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangefeedTarget.Merge(dst, src)
}
func (m *ChangefeedTarget) XXX_Size() int {
	return m.Size()
}
func (m *ChangefeedTarget) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangefeedTarget.DiscardUnknown(m)
}

var xxx_messageInfo_ChangefeedTarget proto.InternalMessageInfo

type ChangefeedDetails struct {
	// Targets contains the user-specified tables and databases to watch, mapping
	// the descriptor id to the name at the time of changefeed creating. There is
	// a 1:1 correspondance between unique targets in the original sql query and
	// entries in this map.
	//
	// - A watched table is stored here under its table id
	// - TODO(dan): A watched database is stored here under its database id
	// - TODO(dan): A db.* expansion is treated identicially to watching the
	//   database
	//
	// Note that the TODOs mean this field currently is guaranteed to only hold
	// table ids and a cluster version check will be added when this changes.
	//
	// The names at resolution time are included so that table and database
	// renames can be detected. They are also used to construct an error message
	// if the descriptor id no longer exists when the jobs is unpaused (which can
	// happen if it was dropped or truncated).
	Targets       ChangefeedTargets                   `protobuf:"bytes,6,rep,name=targets,proto3,casttype=ChangefeedTargets,castkey=github.com/znbasedb/znbase/pkg/sql/sqlbase.ID" json:"targets" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	SinkURI       string                              `protobuf:"bytes,3,opt,name=sink_uri,json=sinkUri,proto3" json:"sink_uri,omitempty"`
	Opts          map[string]string                   `protobuf:"bytes,4,rep,name=opts,proto3" json:"opts,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	StatementTime hlc.Timestamp                       `protobuf:"bytes,7,opt,name=statement_time,json=statementTime,proto3" json:"statement_time"`
	Tables        map[uint32]*sqlbase.TableDescriptor `protobuf:"bytes,8,rep,name=tables,proto3" json:"tables,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *ChangefeedDetails) Reset()         { *m = ChangefeedDetails{} }
func (m *ChangefeedDetails) String() string { return proto.CompactTextString(m) }
func (*ChangefeedDetails) ProtoMessage()    {}
func (*ChangefeedDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_d8caa83bd0f9be11, []int{16}
}
func (m *ChangefeedDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangefeedDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ChangefeedDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangefeedDetails.Merge(dst, src)
}
func (m *ChangefeedDetails) XXX_Size() int {
	return m.Size()
}
func (m *ChangefeedDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangefeedDetails.DiscardUnknown(m)
}

var xxx_messageInfo_ChangefeedDetails proto.InternalMessageInfo

type ResolvedSpan struct {
	Span            roachpb.Span  `protobuf:"bytes,1,opt,name=span,proto3" json:"span"`
	Timestamp       hlc.Timestamp `protobuf:"bytes,2,opt,name=timestamp,proto3" json:"timestamp"`
	BoundaryReached bool          `protobuf:"varint,3,opt,name=boundary_reached,json=boundaryReached,proto3" json:"boundary_reached,omitempty"`
}

func (m *ResolvedSpan) Reset()         { *m = ResolvedSpan{} }
func (m *ResolvedSpan) String() string { return proto.CompactTextString(m) }
func (*ResolvedSpan) ProtoMessage()    {}
func (*ResolvedSpan) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_d8caa83bd0f9be11, []int{17}
}
func (m *ResolvedSpan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResolvedSpan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ResolvedSpan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResolvedSpan.Merge(dst, src)
}
func (m *ResolvedSpan) XXX_Size() int {
	return m.Size()
}
func (m *ResolvedSpan) XXX_DiscardUnknown() {
	xxx_messageInfo_ResolvedSpan.DiscardUnknown(m)
}

var xxx_messageInfo_ResolvedSpan proto.InternalMessageInfo

type ChangefeedProgress struct {
	ResolvedSpans []ResolvedSpan `protobuf:"bytes,2,rep,name=resolved_spans,json=resolvedSpans,proto3" json:"resolved_spans"`
}

func (m *ChangefeedProgress) Reset()         { *m = ChangefeedProgress{} }
func (m *ChangefeedProgress) String() string { return proto.CompactTextString(m) }
func (*ChangefeedProgress) ProtoMessage()    {}
func (*ChangefeedProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_d8caa83bd0f9be11, []int{18}
}
func (m *ChangefeedProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangefeedProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ChangefeedProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangefeedProgress.Merge(dst, src)
}
func (m *ChangefeedProgress) XXX_Size() int {
	return m.Size()
}
func (m *ChangefeedProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangefeedProgress.DiscardUnknown(m)
}

var xxx_messageInfo_ChangefeedProgress proto.InternalMessageInfo

// CreateStatsDetails are used for the CreateStats job, which is triggered
// whenever the `CREATE STATISTICS` SQL statement is run. The CreateStats job
// collects table statistics, which contain info such as the number of rows in
// the table or the number of distinct values in a column.
type CreateStatsDetails struct {
	Name            string                       `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Table           sqlbase.TableDescriptor      `protobuf:"bytes,2,opt,name=table,proto3" json:"table"`
	ColumnLists     []CreateStatsDetails_ColList `protobuf:"bytes,3,rep,name=column_lists,json=columnLists,proto3" json:"column_lists"`
	Statement       string                       `protobuf:"bytes,4,opt,name=statement,proto3" json:"statement,omitempty"`
	AsOf            *hlc.Timestamp               `protobuf:"bytes,5,opt,name=as_of,json=asOf,proto3" json:"as_of,omitempty"`
	MaxFractionIdle float64                      `protobuf:"fixed64,7,opt,name=max_fraction_idle,json=maxFractionIdle,proto3" json:"max_fraction_idle,omitempty"`
	// Fully qualified table name.
	FQTableName string `protobuf:"bytes,6,opt,name=fq_table_name,json=fqTableName,proto3" json:"fq_table_name,omitempty"`
}

func (m *CreateStatsDetails) Reset()         { *m = CreateStatsDetails{} }
func (m *CreateStatsDetails) String() string { return proto.CompactTextString(m) }
func (*CreateStatsDetails) ProtoMessage()    {}
func (*CreateStatsDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_d8caa83bd0f9be11, []int{19}
}
func (m *CreateStatsDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateStatsDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *CreateStatsDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateStatsDetails.Merge(dst, src)
}
func (m *CreateStatsDetails) XXX_Size() int {
	return m.Size()
}
func (m *CreateStatsDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateStatsDetails.DiscardUnknown(m)
}

var xxx_messageInfo_CreateStatsDetails proto.InternalMessageInfo

type CreateStatsDetails_ColList struct {
	IDs []github_com_znbasedb_znbase_pkg_sql_sqlbase.ColumnID `protobuf:"varint,1,rep,packed,name=ids,proto3,casttype=github.com/znbasedb/znbase/pkg/sql/sqlbase.ColumnID" json:"ids,omitempty"`
	// Indicates whether this column stat should include a histogram.
	HasHistogram bool `protobuf:"varint,2,opt,name=has_histogram,json=hasHistogram,proto3" json:"has_histogram,omitempty"`
	// Indicates whether this column stat is over an inverted index.
	Inverted bool `protobuf:"varint,3,opt,name=inverted,proto3" json:"inverted,omitempty"`
	// If this column stat includes a histogram, indicates the maximum number
	// of buckets that should be created. If this field is unset, a default
	// maximum of 200 buckets are created.
	HistogramMaxBuckets uint32 `protobuf:"varint,4,opt,name=histogram_max_buckets,json=histogramMaxBuckets,proto3" json:"histogram_max_buckets,omitempty"`
}

func (m *CreateStatsDetails_ColList) Reset()         { *m = CreateStatsDetails_ColList{} }
func (m *CreateStatsDetails_ColList) String() string { return proto.CompactTextString(m) }
func (*CreateStatsDetails_ColList) ProtoMessage()    {}
func (*CreateStatsDetails_ColList) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_d8caa83bd0f9be11, []int{19, 0}
}
func (m *CreateStatsDetails_ColList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateStatsDetails_ColList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *CreateStatsDetails_ColList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateStatsDetails_ColList.Merge(dst, src)
}
func (m *CreateStatsDetails_ColList) XXX_Size() int {
	return m.Size()
}
func (m *CreateStatsDetails_ColList) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateStatsDetails_ColList.DiscardUnknown(m)
}

var xxx_messageInfo_CreateStatsDetails_ColList proto.InternalMessageInfo

type CreateStatsProgress struct {
}

func (m *CreateStatsProgress) Reset()         { *m = CreateStatsProgress{} }
func (m *CreateStatsProgress) String() string { return proto.CompactTextString(m) }
func (*CreateStatsProgress) ProtoMessage()    {}
func (*CreateStatsProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_d8caa83bd0f9be11, []int{20}
}
func (m *CreateStatsProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateStatsProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *CreateStatsProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateStatsProgress.Merge(dst, src)
}
func (m *CreateStatsProgress) XXX_Size() int {
	return m.Size()
}
func (m *CreateStatsProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateStatsProgress.DiscardUnknown(m)
}

var xxx_messageInfo_CreateStatsProgress proto.InternalMessageInfo

type Payload struct {
	Description string `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	// If empty, the description is assumed to be the statement.
	Statement string `protobuf:"bytes,16,opt,name=statement,proto3" json:"statement,omitempty"`
	Username  string `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
	// For consistency with the SQL timestamp type, which has microsecond
	// precision, we avoid the timestamp.Timestamp WKT, which has nanosecond
	// precision, and use microsecond integers directly.
	StartedMicros  int64                                           `protobuf:"varint,3,opt,name=started_micros,json=startedMicros,proto3" json:"started_micros,omitempty"`
	FinishedMicros int64                                           `protobuf:"varint,4,opt,name=finished_micros,json=finishedMicros,proto3" json:"finished_micros,omitempty"`
	DescriptorIDs  []github_com_znbasedb_znbase_pkg_sql_sqlbase.ID `protobuf:"varint,6,rep,packed,name=descriptor_ids,json=descriptorIds,proto3,casttype=github.com/znbasedb/znbase/pkg/sql/sqlbase.ID" json:"descriptor_ids,omitempty"`
	Error          string                                          `protobuf:"bytes,8,opt,name=error,proto3" json:"error,omitempty"`
	// ID 9 is intentionally reserved for lease information.
	Lease *Lease `protobuf:"bytes,9,opt,name=lease,proto3" json:"lease,omitempty"`
	// Noncancelable is used to denote when a job cannot be canceled.
	Noncancelable bool `protobuf:"varint,20,opt,name=noncancelable,proto3" json:"noncancelable,omitempty"`
	// Types that are valid to be assigned to Details:
	//	*Payload_Backup
	//	*Payload_Restore
	//	*Payload_SchemaChange
	//	*Payload_Import
	//	*Payload_Changefeed
	//	*Payload_CreateStats
	//	*Payload_Dump
	//	*Payload_SchemaChangeGC
	Details isPayload_Details `protobuf_oneof:"details"`
}

func (m *Payload) Reset()         { *m = Payload{} }
func (m *Payload) String() string { return proto.CompactTextString(m) }
func (*Payload) ProtoMessage()    {}
func (*Payload) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_d8caa83bd0f9be11, []int{21}
}
func (m *Payload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Payload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *Payload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Payload.Merge(dst, src)
}
func (m *Payload) XXX_Size() int {
	return m.Size()
}
func (m *Payload) XXX_DiscardUnknown() {
	xxx_messageInfo_Payload.DiscardUnknown(m)
}

var xxx_messageInfo_Payload proto.InternalMessageInfo

type isPayload_Details interface {
	isPayload_Details()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Payload_Backup struct {
	Backup *BackupDetails `protobuf:"bytes,10,opt,name=backup,proto3,oneof"`
}
type Payload_Restore struct {
	Restore *RestoreDetails `protobuf:"bytes,11,opt,name=restore,proto3,oneof"`
}
type Payload_SchemaChange struct {
	SchemaChange *SchemaChangeDetails `protobuf:"bytes,12,opt,name=schemaChange,proto3,oneof"`
}
type Payload_Import struct {
	Import *ImportDetails `protobuf:"bytes,13,opt,name=import,proto3,oneof"`
}
type Payload_Changefeed struct {
	Changefeed *ChangefeedDetails `protobuf:"bytes,14,opt,name=changefeed,proto3,oneof"`
}
type Payload_CreateStats struct {
	CreateStats *CreateStatsDetails `protobuf:"bytes,15,opt,name=createStats,proto3,oneof"`
}
type Payload_Dump struct {
	Dump *DumpDetails `protobuf:"bytes,17,opt,name=dump,proto3,oneof"`
}
type Payload_SchemaChangeGC struct {
	SchemaChangeGC *SchemaChangeGCDetails `protobuf:"bytes,18,opt,name=schemaChangeGC,proto3,oneof"`
}

func (*Payload_Backup) isPayload_Details()         {}
func (*Payload_Restore) isPayload_Details()        {}
func (*Payload_SchemaChange) isPayload_Details()   {}
func (*Payload_Import) isPayload_Details()         {}
func (*Payload_Changefeed) isPayload_Details()     {}
func (*Payload_CreateStats) isPayload_Details()    {}
func (*Payload_Dump) isPayload_Details()           {}
func (*Payload_SchemaChangeGC) isPayload_Details() {}

func (m *Payload) GetDetails() isPayload_Details {
	if m != nil {
		return m.Details
	}
	return nil
}

func (m *Payload) GetBackup() *BackupDetails {
	if x, ok := m.GetDetails().(*Payload_Backup); ok {
		return x.Backup
	}
	return nil
}

func (m *Payload) GetRestore() *RestoreDetails {
	if x, ok := m.GetDetails().(*Payload_Restore); ok {
		return x.Restore
	}
	return nil
}

func (m *Payload) GetSchemaChange() *SchemaChangeDetails {
	if x, ok := m.GetDetails().(*Payload_SchemaChange); ok {
		return x.SchemaChange
	}
	return nil
}

func (m *Payload) GetImport() *ImportDetails {
	if x, ok := m.GetDetails().(*Payload_Import); ok {
		return x.Import
	}
	return nil
}

func (m *Payload) GetChangefeed() *ChangefeedDetails {
	if x, ok := m.GetDetails().(*Payload_Changefeed); ok {
		return x.Changefeed
	}
	return nil
}

func (m *Payload) GetCreateStats() *CreateStatsDetails {
	if x, ok := m.GetDetails().(*Payload_CreateStats); ok {
		return x.CreateStats
	}
	return nil
}

func (m *Payload) GetDump() *DumpDetails {
	if x, ok := m.GetDetails().(*Payload_Dump); ok {
		return x.Dump
	}
	return nil
}

func (m *Payload) GetSchemaChangeGC() *SchemaChangeGCDetails {
	if x, ok := m.GetDetails().(*Payload_SchemaChangeGC); ok {
		return x.SchemaChangeGC
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Payload) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Payload_OneofMarshaler, _Payload_OneofUnmarshaler, _Payload_OneofSizer, []interface{}{
		(*Payload_Backup)(nil),
		(*Payload_Restore)(nil),
		(*Payload_SchemaChange)(nil),
		(*Payload_Import)(nil),
		(*Payload_Changefeed)(nil),
		(*Payload_CreateStats)(nil),
		(*Payload_Dump)(nil),
		(*Payload_SchemaChangeGC)(nil),
	}
}

func _Payload_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Payload)
	// details
	switch x := m.Details.(type) {
	case *Payload_Backup:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Backup); err != nil {
			return err
		}
	case *Payload_Restore:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Restore); err != nil {
			return err
		}
	case *Payload_SchemaChange:
		_ = b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SchemaChange); err != nil {
			return err
		}
	case *Payload_Import:
		_ = b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Import); err != nil {
			return err
		}
	case *Payload_Changefeed:
		_ = b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Changefeed); err != nil {
			return err
		}
	case *Payload_CreateStats:
		_ = b.EncodeVarint(15<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CreateStats); err != nil {
			return err
		}
	case *Payload_Dump:
		_ = b.EncodeVarint(17<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Dump); err != nil {
			return err
		}
	case *Payload_SchemaChangeGC:
		_ = b.EncodeVarint(18<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SchemaChangeGC); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Payload.Details has unexpected type %T", x)
	}
	return nil
}

func _Payload_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Payload)
	switch tag {
	case 10: // details.backup
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BackupDetails)
		err := b.DecodeMessage(msg)
		m.Details = &Payload_Backup{msg}
		return true, err
	case 11: // details.restore
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RestoreDetails)
		err := b.DecodeMessage(msg)
		m.Details = &Payload_Restore{msg}
		return true, err
	case 12: // details.schemaChange
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SchemaChangeDetails)
		err := b.DecodeMessage(msg)
		m.Details = &Payload_SchemaChange{msg}
		return true, err
	case 13: // details.import
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ImportDetails)
		err := b.DecodeMessage(msg)
		m.Details = &Payload_Import{msg}
		return true, err
	case 14: // details.changefeed
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ChangefeedDetails)
		err := b.DecodeMessage(msg)
		m.Details = &Payload_Changefeed{msg}
		return true, err
	case 15: // details.createStats
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CreateStatsDetails)
		err := b.DecodeMessage(msg)
		m.Details = &Payload_CreateStats{msg}
		return true, err
	case 17: // details.dump
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DumpDetails)
		err := b.DecodeMessage(msg)
		m.Details = &Payload_Dump{msg}
		return true, err
	case 18: // details.schemaChangeGC
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SchemaChangeGCDetails)
		err := b.DecodeMessage(msg)
		m.Details = &Payload_SchemaChangeGC{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Payload_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Payload)
	// details
	switch x := m.Details.(type) {
	case *Payload_Backup:
		s := proto.Size(x.Backup)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Payload_Restore:
		s := proto.Size(x.Restore)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Payload_SchemaChange:
		s := proto.Size(x.SchemaChange)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Payload_Import:
		s := proto.Size(x.Import)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Payload_Changefeed:
		s := proto.Size(x.Changefeed)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Payload_CreateStats:
		s := proto.Size(x.CreateStats)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Payload_Dump:
		s := proto.Size(x.Dump)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Payload_SchemaChangeGC:
		s := proto.Size(x.SchemaChangeGC)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Progress struct {
	// Types that are valid to be assigned to Progress:
	//	*Progress_FractionCompleted
	//	*Progress_HighWater
	Progress       isProgress_Progress `protobuf_oneof:"progress"`
	ModifiedMicros int64               `protobuf:"varint,2,opt,name=modified_micros,json=modifiedMicros,proto3" json:"modified_micros,omitempty"`
	RunningStatus  string              `protobuf:"bytes,4,opt,name=running_status,json=runningStatus,proto3" json:"running_status,omitempty"`
	// Types that are valid to be assigned to Details:
	//	*Progress_Backup
	//	*Progress_Restore
	//	*Progress_SchemaChange
	//	*Progress_Import
	//	*Progress_Changefeed
	//	*Progress_CreateStats
	//	*Progress_Dump
	//	*Progress_SchemaChangeGC
	Details isProgress_Details `protobuf_oneof:"details"`
}

func (m *Progress) Reset()         { *m = Progress{} }
func (m *Progress) String() string { return proto.CompactTextString(m) }
func (*Progress) ProtoMessage()    {}
func (*Progress) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_d8caa83bd0f9be11, []int{22}
}
func (m *Progress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Progress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *Progress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Progress.Merge(dst, src)
}
func (m *Progress) XXX_Size() int {
	return m.Size()
}
func (m *Progress) XXX_DiscardUnknown() {
	xxx_messageInfo_Progress.DiscardUnknown(m)
}

var xxx_messageInfo_Progress proto.InternalMessageInfo

type isProgress_Progress interface {
	isProgress_Progress()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isProgress_Details interface {
	isProgress_Details()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Progress_FractionCompleted struct {
	FractionCompleted float32 `protobuf:"fixed32,1,opt,name=fraction_completed,json=fractionCompleted,proto3,oneof"`
}
type Progress_HighWater struct {
	HighWater *hlc.Timestamp `protobuf:"bytes,3,opt,name=high_water,json=highWater,proto3,oneof"`
}
type Progress_Backup struct {
	Backup *BackupProgress `protobuf:"bytes,10,opt,name=backup,proto3,oneof"`
}
type Progress_Restore struct {
	Restore *RestoreProgress `protobuf:"bytes,11,opt,name=restore,proto3,oneof"`
}
type Progress_SchemaChange struct {
	SchemaChange *SchemaChangeProgress `protobuf:"bytes,12,opt,name=schemaChange,proto3,oneof"`
}
type Progress_Import struct {
	Import *ImportProgress `protobuf:"bytes,13,opt,name=import,proto3,oneof"`
}
type Progress_Changefeed struct {
	Changefeed *ChangefeedProgress `protobuf:"bytes,14,opt,name=changefeed,proto3,oneof"`
}
type Progress_CreateStats struct {
	CreateStats *CreateStatsProgress `protobuf:"bytes,15,opt,name=createStats,proto3,oneof"`
}
type Progress_Dump struct {
	Dump *DumpProgress `protobuf:"bytes,17,opt,name=dump,proto3,oneof"`
}
type Progress_SchemaChangeGC struct {
	SchemaChangeGC *SchemaChangeGCProgress `protobuf:"bytes,19,opt,name=schemaChangeGC,proto3,oneof"`
}

func (*Progress_FractionCompleted) isProgress_Progress() {}
func (*Progress_HighWater) isProgress_Progress()         {}
func (*Progress_Backup) isProgress_Details()             {}
func (*Progress_Restore) isProgress_Details()            {}
func (*Progress_SchemaChange) isProgress_Details()       {}
func (*Progress_Import) isProgress_Details()             {}
func (*Progress_Changefeed) isProgress_Details()         {}
func (*Progress_CreateStats) isProgress_Details()        {}
func (*Progress_Dump) isProgress_Details()               {}
func (*Progress_SchemaChangeGC) isProgress_Details()     {}

func (m *Progress) GetProgress() isProgress_Progress {
	if m != nil {
		return m.Progress
	}
	return nil
}
func (m *Progress) GetDetails() isProgress_Details {
	if m != nil {
		return m.Details
	}
	return nil
}

func (m *Progress) GetFractionCompleted() float32 {
	if x, ok := m.GetProgress().(*Progress_FractionCompleted); ok {
		return x.FractionCompleted
	}
	return 0
}

func (m *Progress) GetHighWater() *hlc.Timestamp {
	if x, ok := m.GetProgress().(*Progress_HighWater); ok {
		return x.HighWater
	}
	return nil
}

func (m *Progress) GetBackup() *BackupProgress {
	if x, ok := m.GetDetails().(*Progress_Backup); ok {
		return x.Backup
	}
	return nil
}

func (m *Progress) GetRestore() *RestoreProgress {
	if x, ok := m.GetDetails().(*Progress_Restore); ok {
		return x.Restore
	}
	return nil
}

func (m *Progress) GetSchemaChange() *SchemaChangeProgress {
	if x, ok := m.GetDetails().(*Progress_SchemaChange); ok {
		return x.SchemaChange
	}
	return nil
}

func (m *Progress) GetImport() *ImportProgress {
	if x, ok := m.GetDetails().(*Progress_Import); ok {
		return x.Import
	}
	return nil
}

func (m *Progress) GetChangefeed() *ChangefeedProgress {
	if x, ok := m.GetDetails().(*Progress_Changefeed); ok {
		return x.Changefeed
	}
	return nil
}

func (m *Progress) GetCreateStats() *CreateStatsProgress {
	if x, ok := m.GetDetails().(*Progress_CreateStats); ok {
		return x.CreateStats
	}
	return nil
}

func (m *Progress) GetDump() *DumpProgress {
	if x, ok := m.GetDetails().(*Progress_Dump); ok {
		return x.Dump
	}
	return nil
}

func (m *Progress) GetSchemaChangeGC() *SchemaChangeGCProgress {
	if x, ok := m.GetDetails().(*Progress_SchemaChangeGC); ok {
		return x.SchemaChangeGC
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Progress) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Progress_OneofMarshaler, _Progress_OneofUnmarshaler, _Progress_OneofSizer, []interface{}{
		(*Progress_FractionCompleted)(nil),
		(*Progress_HighWater)(nil),
		(*Progress_Backup)(nil),
		(*Progress_Restore)(nil),
		(*Progress_SchemaChange)(nil),
		(*Progress_Import)(nil),
		(*Progress_Changefeed)(nil),
		(*Progress_CreateStats)(nil),
		(*Progress_Dump)(nil),
		(*Progress_SchemaChangeGC)(nil),
	}
}

func _Progress_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Progress)
	// progress
	switch x := m.Progress.(type) {
	case *Progress_FractionCompleted:
		_ = b.EncodeVarint(1<<3 | proto.WireFixed32)
		_ = b.EncodeFixed32(uint64(math.Float32bits(x.FractionCompleted)))
	case *Progress_HighWater:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.HighWater); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Progress.Progress has unexpected type %T", x)
	}
	// details
	switch x := m.Details.(type) {
	case *Progress_Backup:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Backup); err != nil {
			return err
		}
	case *Progress_Restore:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Restore); err != nil {
			return err
		}
	case *Progress_SchemaChange:
		_ = b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SchemaChange); err != nil {
			return err
		}
	case *Progress_Import:
		_ = b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Import); err != nil {
			return err
		}
	case *Progress_Changefeed:
		_ = b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Changefeed); err != nil {
			return err
		}
	case *Progress_CreateStats:
		_ = b.EncodeVarint(15<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CreateStats); err != nil {
			return err
		}
	case *Progress_Dump:
		_ = b.EncodeVarint(17<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Dump); err != nil {
			return err
		}
	case *Progress_SchemaChangeGC:
		_ = b.EncodeVarint(19<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SchemaChangeGC); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Progress.Details has unexpected type %T", x)
	}
	return nil
}

func _Progress_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Progress)
	switch tag {
	case 1: // progress.fraction_completed
		if wire != proto.WireFixed32 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed32()
		m.Progress = &Progress_FractionCompleted{math.Float32frombits(uint32(x))}
		return true, err
	case 3: // progress.high_water
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(hlc.Timestamp)
		err := b.DecodeMessage(msg)
		m.Progress = &Progress_HighWater{msg}
		return true, err
	case 10: // details.backup
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BackupProgress)
		err := b.DecodeMessage(msg)
		m.Details = &Progress_Backup{msg}
		return true, err
	case 11: // details.restore
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RestoreProgress)
		err := b.DecodeMessage(msg)
		m.Details = &Progress_Restore{msg}
		return true, err
	case 12: // details.schemaChange
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SchemaChangeProgress)
		err := b.DecodeMessage(msg)
		m.Details = &Progress_SchemaChange{msg}
		return true, err
	case 13: // details.import
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ImportProgress)
		err := b.DecodeMessage(msg)
		m.Details = &Progress_Import{msg}
		return true, err
	case 14: // details.changefeed
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ChangefeedProgress)
		err := b.DecodeMessage(msg)
		m.Details = &Progress_Changefeed{msg}
		return true, err
	case 15: // details.createStats
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CreateStatsProgress)
		err := b.DecodeMessage(msg)
		m.Details = &Progress_CreateStats{msg}
		return true, err
	case 17: // details.dump
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DumpProgress)
		err := b.DecodeMessage(msg)
		m.Details = &Progress_Dump{msg}
		return true, err
	case 19: // details.schemaChangeGC
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SchemaChangeGCProgress)
		err := b.DecodeMessage(msg)
		m.Details = &Progress_SchemaChangeGC{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Progress_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Progress)
	// progress
	switch x := m.Progress.(type) {
	case *Progress_FractionCompleted:
		n += 1 // tag and wire
		n += 4
	case *Progress_HighWater:
		s := proto.Size(x.HighWater)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// details
	switch x := m.Details.(type) {
	case *Progress_Backup:
		s := proto.Size(x.Backup)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Progress_Restore:
		s := proto.Size(x.Restore)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Progress_SchemaChange:
		s := proto.Size(x.SchemaChange)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Progress_Import:
		s := proto.Size(x.Import)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Progress_Changefeed:
		s := proto.Size(x.Changefeed)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Progress_CreateStats:
		s := proto.Size(x.CreateStats)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Progress_Dump:
		s := proto.Size(x.Dump)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Progress_SchemaChangeGC:
		s := proto.Size(x.SchemaChangeGC)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*Lease)(nil), "znbase.sql.jobs.jobspb.Lease")
	proto.RegisterType((*BackupDetails)(nil), "znbase.sql.jobs.jobspb.BackupDetails")
	proto.RegisterType((*BackupProgress)(nil), "znbase.sql.jobs.jobspb.BackupProgress")
	proto.RegisterType((*DumpDetails)(nil), "znbase.sql.jobs.jobspb.DumpDetails")
	proto.RegisterType((*DumpProgress)(nil), "znbase.sql.jobs.jobspb.DumpProgress")
	proto.RegisterType((*RestoreDetails)(nil), "znbase.sql.jobs.jobspb.RestoreDetails")
	proto.RegisterMapType((map[string]bool)(nil), "znbase.sql.jobs.jobspb.RestoreDetails.SystemTablesRestoredEntry")
	proto.RegisterMapType((map[github_com_znbasedb_znbase_pkg_sql_sqlbase.ID]*RestoreDetails_TableRewrite)(nil), "znbase.sql.jobs.jobspb.RestoreDetails.TableRewritesEntry")
	proto.RegisterType((*RestoreDetails_TableRewrite)(nil), "znbase.sql.jobs.jobspb.RestoreDetails.TableRewrite")
	proto.RegisterType((*RestoreProgress)(nil), "znbase.sql.jobs.jobspb.RestoreProgress")
	proto.RegisterType((*ImportDetails)(nil), "znbase.sql.jobs.jobspb.ImportDetails")
	proto.RegisterType((*ImportDetails_Database)(nil), "znbase.sql.jobs.jobspb.ImportDetails.Database")
	proto.RegisterType((*ImportDetails_Table)(nil), "znbase.sql.jobs.jobspb.ImportDetails.Table")
	proto.RegisterType((*ImportProgress)(nil), "znbase.sql.jobs.jobspb.ImportProgress")
	proto.RegisterType((*ImportProgress_SpanProgress)(nil), "znbase.sql.jobs.jobspb.ImportProgress.SpanProgress")
	proto.RegisterType((*ResumeSpanList)(nil), "znbase.sql.jobs.jobspb.ResumeSpanList")
	proto.RegisterType((*DroppedTableDetails)(nil), "znbase.sql.jobs.jobspb.DroppedTableDetails")
	proto.RegisterType((*SchemaChangeGCDetails)(nil), "znbase.sql.jobs.jobspb.SchemaChangeGCDetails")
	proto.RegisterType((*SchemaChangeGCDetails_DroppedIndex)(nil), "znbase.sql.jobs.jobspb.SchemaChangeGCDetails.DroppedIndex")
	proto.RegisterType((*SchemaChangeGCDetails_DroppedID)(nil), "znbase.sql.jobs.jobspb.SchemaChangeGCDetails.DroppedID")
	proto.RegisterType((*SchemaChangeDetails)(nil), "znbase.sql.jobs.jobspb.SchemaChangeDetails")
	proto.RegisterType((*SchemaChangeProgress)(nil), "znbase.sql.jobs.jobspb.SchemaChangeProgress")
	proto.RegisterType((*SchemaChangeGCProgress)(nil), "znbase.sql.jobs.jobspb.SchemaChangeGCProgress")
	proto.RegisterType((*SchemaChangeGCProgress_IndexProgress)(nil), "znbase.sql.jobs.jobspb.SchemaChangeGCProgress.IndexProgress")
	proto.RegisterType((*SchemaChangeGCProgress_TableProgress)(nil), "znbase.sql.jobs.jobspb.SchemaChangeGCProgress.TableProgress")
	proto.RegisterType((*ChangefeedTarget)(nil), "znbase.sql.jobs.jobspb.ChangefeedTarget")
	proto.RegisterType((*ChangefeedDetails)(nil), "znbase.sql.jobs.jobspb.ChangefeedDetails")
	proto.RegisterMapType((map[string]string)(nil), "znbase.sql.jobs.jobspb.ChangefeedDetails.OptsEntry")
	proto.RegisterMapType((map[uint32]*sqlbase.TableDescriptor)(nil), "znbase.sql.jobs.jobspb.ChangefeedDetails.TablesEntry")
	proto.RegisterMapType((ChangefeedTargets)(nil), "znbase.sql.jobs.jobspb.ChangefeedDetails.TargetsEntry")
	proto.RegisterType((*ResolvedSpan)(nil), "znbase.sql.jobs.jobspb.ResolvedSpan")
	proto.RegisterType((*ChangefeedProgress)(nil), "znbase.sql.jobs.jobspb.ChangefeedProgress")
	proto.RegisterType((*CreateStatsDetails)(nil), "znbase.sql.jobs.jobspb.CreateStatsDetails")
	proto.RegisterType((*CreateStatsDetails_ColList)(nil), "znbase.sql.jobs.jobspb.CreateStatsDetails.ColList")
	proto.RegisterType((*CreateStatsProgress)(nil), "znbase.sql.jobs.jobspb.CreateStatsProgress")
	proto.RegisterType((*Payload)(nil), "znbase.sql.jobs.jobspb.Payload")
	proto.RegisterType((*Progress)(nil), "znbase.sql.jobs.jobspb.Progress")
	proto.RegisterEnum("znbase.sql.jobs.jobspb.Status", Status_name, Status_value)
	proto.RegisterEnum("znbase.sql.jobs.jobspb.Type", Type_name, Type_value)
	proto.RegisterEnum("znbase.sql.jobs.jobspb.SchemaChangeGCProgress_Status", SchemaChangeGCProgress_Status_name, SchemaChangeGCProgress_Status_value)
}
func (this *Lease) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Lease)
	if !ok {
		that2, ok := that.(Lease)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NodeID != that1.NodeID {
		return false
	}
	if this.Epoch != that1.Epoch {
		return false
	}
	return true
}
func (m *Lease) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Lease) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NodeID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.NodeID))
	}
	if m.Epoch != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Epoch))
	}
	return i, nil
}

func (m *BackupDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackupDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintJobs(dAtA, i, uint64(m.StartTime.Size()))
	n1, err := m.StartTime.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintJobs(dAtA, i, uint64(m.EndTime.Size()))
	n2, err := m.EndTime.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	if len(m.URI) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.URI)))
		i += copy(dAtA[i:], m.URI)
	}
	if len(m.BackupDescriptor) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.BackupDescriptor)))
		i += copy(dAtA[i:], m.BackupDescriptor)
	}
	if m.Encryption != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Encryption.Size()))
		n3, err := m.Encryption.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *BackupProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackupProgress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *DumpDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DumpDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintJobs(dAtA, i, uint64(m.StartTime.Size()))
	n4, err := m.StartTime.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	dAtA[i] = 0x12
	i++
	i = encodeVarintJobs(dAtA, i, uint64(m.EndTime.Size()))
	n5, err := m.EndTime.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	if len(m.URI) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.URI)))
		i += copy(dAtA[i:], m.URI)
	}
	if len(m.DumpDescriptor) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.DumpDescriptor)))
		i += copy(dAtA[i:], m.DumpDescriptor)
	}
	if m.Encryption != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Encryption.Size()))
		n6, err := m.Encryption.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.CompressionCodec != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.CompressionCodec))
	}
	if m.DumpOnline {
		dAtA[i] = 0x40
		i++
		if m.DumpOnline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	dAtA[i] = 0x4a
	i++
	i = encodeVarintJobs(dAtA, i, uint64(m.DumpOnlineFiles.Size()))
	n7, err := m.DumpOnlineFiles.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	if len(m.HttpHeader) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.HttpHeader)))
		i += copy(dAtA[i:], m.HttpHeader)
	}
	return i, nil
}

func (m *DumpProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DumpProgress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *RestoreDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RestoreDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TableRewrites) > 0 {
		keysForTableRewrites := make([]uint32, 0, len(m.TableRewrites))
		for k := range m.TableRewrites {
			keysForTableRewrites = append(keysForTableRewrites, uint32(k))
		}
		github_com_gogo_protobuf_sortkeys.Uint32s(keysForTableRewrites)
		for _, k := range keysForTableRewrites {
			dAtA[i] = 0x12
			i++
			v := m.TableRewrites[github_com_znbasedb_znbase_pkg_sql_sqlbase.ID(k)]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovJobs(uint64(msgSize))
			}
			mapSize := 1 + sovJobs(uint64(k)) + msgSize
			i = encodeVarintJobs(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintJobs(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintJobs(dAtA, i, uint64(v.Size()))
				n8, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n8
			}
		}
	}
	if len(m.URIs) > 0 {
		for _, s := range m.URIs {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	dAtA[i] = 0x22
	i++
	i = encodeVarintJobs(dAtA, i, uint64(m.EndTime.Size()))
	n9, err := m.EndTime.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	if len(m.TableDescs) > 0 {
		for _, msg := range m.TableDescs {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.OverrideDB) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.OverrideDB)))
		i += copy(dAtA[i:], m.OverrideDB)
	}
	if m.DescriptorCoverage != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.DescriptorCoverage))
	}
	if m.Encryption != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Encryption.Size()))
		n10, err := m.Encryption.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if len(m.HttpHeader) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.HttpHeader)))
		i += copy(dAtA[i:], m.HttpHeader)
	}
	if len(m.SystemTablesRestored) > 0 {
		keysForSystemTablesRestored := make([]string, 0, len(m.SystemTablesRestored))
		for k := range m.SystemTablesRestored {
			keysForSystemTablesRestored = append(keysForSystemTablesRestored, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForSystemTablesRestored)
		for _, k := range keysForSystemTablesRestored {
			dAtA[i] = 0x72
			i++
			v := m.SystemTablesRestored[string(k)]
			mapSize := 1 + len(k) + sovJobs(uint64(len(k))) + 1 + 1
			i = encodeVarintJobs(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintJobs(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if len(m.SchemaDescs) > 0 {
		for _, msg := range m.SchemaDescs {
			dAtA[i] = 0x7a
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.DatabaseDescs) > 0 {
		for _, msg := range m.DatabaseDescs {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.SystemTmpRestored {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		if m.SystemTmpRestored {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PrepareCompleted {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		if m.PrepareCompleted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RestoreDetails_TableRewrite) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RestoreDetails_TableRewrite) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TableID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.TableID))
	}
	if m.ParentID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.ParentID))
	}
	return i, nil
}

func (m *RestoreProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RestoreProgress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HighWater) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.HighWater)))
		i += copy(dAtA[i:], m.HighWater)
	}
	return i, nil
}

func (m *ImportDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImportDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Tables) > 0 {
		for _, msg := range m.Tables {
			dAtA[i] = 0xa
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.URIs) > 0 {
		for _, s := range m.URIs {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintJobs(dAtA, i, uint64(m.Format.Size()))
	n11, err := m.Format.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	if m.SSTSize != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.SSTSize))
	}
	if m.Walltime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Walltime))
	}
	if m.ParentID != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.ParentID))
	}
	if len(m.BackupPath) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.BackupPath)))
		i += copy(dAtA[i:], m.BackupPath)
	}
	if len(m.Samples) > 0 {
		for _, b := range m.Samples {
			dAtA[i] = 0x42
			i++
			i = encodeVarintJobs(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.Oversample != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Oversample))
	}
	if m.SkipFKs {
		dAtA[i] = 0x50
		i++
		if m.SkipFKs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IngestDirectly {
		dAtA[i] = 0x58
		i++
		if m.IngestDirectly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Encoding) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.Encoding)))
		i += copy(dAtA[i:], m.Encoding)
	}
	if m.Encryption != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Encryption.Size()))
		n12, err := m.Encryption.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if len(m.Databases) > 0 {
		for _, msg := range m.Databases {
			dAtA[i] = 0xca
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Schemas) > 0 {
		for _, msg := range m.Schemas {
			dAtA[i] = 0xd2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PrepareComplete {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		if m.PrepareComplete {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ImportDetails_Database) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImportDetails_Database) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Database != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Database.Size()))
		n13, err := m.Database.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if len(m.Schemas) > 0 {
		for _, msg := range m.Schemas {
			dAtA[i] = 0x12
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ImportDetails_Table) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImportDetails_Table) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Desc != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Desc.Size()))
		n14, err := m.Desc.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.SeqVal != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.SeqVal))
	}
	if m.IsNew {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		if m.IsNew {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.TargetCols) > 0 {
		for _, s := range m.TargetCols {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *ImportProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImportProgress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SamplingProgress) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.SamplingProgress)*4))
		for _, num := range m.SamplingProgress {
			f15 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f15))
			i += 4
		}
	}
	if len(m.ReadProgress) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.ReadProgress)*4))
		for _, num := range m.ReadProgress {
			f16 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f16))
			i += 4
		}
	}
	if len(m.WriteProgress) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.WriteProgress)*4))
		for _, num := range m.WriteProgress {
			f17 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f17))
			i += 4
		}
	}
	if len(m.SpanProgress) > 0 {
		for _, msg := range m.SpanProgress {
			dAtA[i] = 0x22
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ImportProgress_SpanProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImportProgress_SpanProgress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintJobs(dAtA, i, uint64(m.Table.Size()))
	n18, err := m.Table.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n18
	if len(m.SpanProgress) > 0 {
		for _, msg := range m.SpanProgress {
			dAtA[i] = 0x12
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ResumeSpanList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResumeSpanList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ResumeSpans) > 0 {
		for _, msg := range m.ResumeSpans {
			dAtA[i] = 0xa
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DroppedTableDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DroppedTableDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.ID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.ID))
	}
	if m.Status != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Status))
	}
	return i, nil
}

func (m *SchemaChangeGCDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaChangeGCDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Indexes) > 0 {
		for _, msg := range m.Indexes {
			dAtA[i] = 0xa
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Tables) > 0 {
		for _, msg := range m.Tables {
			dAtA[i] = 0x12
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ParentID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.ParentID))
	}
	return i, nil
}

func (m *SchemaChangeGCDetails_DroppedIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaChangeGCDetails_DroppedIndex) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IndexID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.IndexID))
	}
	if m.DropTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.DropTime))
	}
	return i, nil
}

func (m *SchemaChangeGCDetails_DroppedID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaChangeGCDetails_DroppedID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.ID))
	}
	if m.DropTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.DropTime))
	}
	return i, nil
}

func (m *SchemaChangeDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaChangeDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ResumeSpanList) > 0 {
		for _, msg := range m.ResumeSpanList {
			dAtA[i] = 0x12
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.DroppedTables) > 0 {
		for _, msg := range m.DroppedTables {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.DroppedDatabaseID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.DroppedDatabaseID))
	}
	return i, nil
}

func (m *SchemaChangeProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaChangeProgress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *SchemaChangeGCProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaChangeGCProgress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Indexes) > 0 {
		for _, msg := range m.Indexes {
			dAtA[i] = 0xa
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Tables) > 0 {
		for _, msg := range m.Tables {
			dAtA[i] = 0x12
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SchemaChangeGCProgress_IndexProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaChangeGCProgress_IndexProgress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IndexID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.IndexID))
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Status))
	}
	return i, nil
}

func (m *SchemaChangeGCProgress_TableProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaChangeGCProgress_TableProgress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.ID))
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Status))
	}
	return i, nil
}

func (m *ChangefeedTarget) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangefeedTarget) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.StatementTimeName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.StatementTimeName)))
		i += copy(dAtA[i:], m.StatementTimeName)
	}
	return i, nil
}

func (m *ChangefeedDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangefeedDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SinkURI) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.SinkURI)))
		i += copy(dAtA[i:], m.SinkURI)
	}
	if len(m.Opts) > 0 {
		keysForOpts := make([]string, 0, len(m.Opts))
		for k := range m.Opts {
			keysForOpts = append(keysForOpts, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForOpts)
		for _, k := range keysForOpts {
			dAtA[i] = 0x22
			i++
			v := m.Opts[string(k)]
			mapSize := 1 + len(k) + sovJobs(uint64(len(k))) + 1 + len(v) + sovJobs(uint64(len(v)))
			i = encodeVarintJobs(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintJobs(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintJobs(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Targets) > 0 {
		keysForTargets := make([]uint32, 0, len(m.Targets))
		for k := range m.Targets {
			keysForTargets = append(keysForTargets, uint32(k))
		}
		github_com_gogo_protobuf_sortkeys.Uint32s(keysForTargets)
		for _, k := range keysForTargets {
			dAtA[i] = 0x32
			i++
			v := m.Targets[github_com_znbasedb_znbase_pkg_sql_sqlbase.ID(k)]
			msgSize := 0
			if (&v) != nil {
				msgSize = (&v).Size()
				msgSize += 1 + sovJobs(uint64(msgSize))
			}
			mapSize := 1 + sovJobs(uint64(k)) + msgSize
			i = encodeVarintJobs(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintJobs(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintJobs(dAtA, i, uint64((&v).Size()))
			n19, err := (&v).MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n19
		}
	}
	dAtA[i] = 0x3a
	i++
	i = encodeVarintJobs(dAtA, i, uint64(m.StatementTime.Size()))
	n20, err := m.StatementTime.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n20
	if len(m.Tables) > 0 {
		keysForTables := make([]uint32, 0, len(m.Tables))
		for k := range m.Tables {
			keysForTables = append(keysForTables, uint32(k))
		}
		github_com_gogo_protobuf_sortkeys.Uint32s(keysForTables)
		for _, k := range keysForTables {
			dAtA[i] = 0x42
			i++
			v := m.Tables[uint32(k)]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovJobs(uint64(msgSize))
			}
			mapSize := 1 + sovJobs(uint64(k)) + msgSize
			i = encodeVarintJobs(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintJobs(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintJobs(dAtA, i, uint64(v.Size()))
				n21, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n21
			}
		}
	}
	return i, nil
}

func (m *ResolvedSpan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResolvedSpan) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintJobs(dAtA, i, uint64(m.Span.Size()))
	n22, err := m.Span.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n22
	dAtA[i] = 0x12
	i++
	i = encodeVarintJobs(dAtA, i, uint64(m.Timestamp.Size()))
	n23, err := m.Timestamp.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n23
	if m.BoundaryReached {
		dAtA[i] = 0x18
		i++
		if m.BoundaryReached {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ChangefeedProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangefeedProgress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ResolvedSpans) > 0 {
		for _, msg := range m.ResolvedSpans {
			dAtA[i] = 0x12
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CreateStatsDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateStatsDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintJobs(dAtA, i, uint64(m.Table.Size()))
	n24, err := m.Table.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n24
	if len(m.ColumnLists) > 0 {
		for _, msg := range m.ColumnLists {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Statement) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.Statement)))
		i += copy(dAtA[i:], m.Statement)
	}
	if m.AsOf != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.AsOf.Size()))
		n25, err := m.AsOf.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if len(m.FQTableName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.FQTableName)))
		i += copy(dAtA[i:], m.FQTableName)
	}
	if m.MaxFractionIdle != 0 {
		dAtA[i] = 0x39
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MaxFractionIdle))))
		i += 8
	}
	return i, nil
}

func (m *CreateStatsDetails_ColList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateStatsDetails_ColList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IDs) > 0 {
		dAtA27 := make([]byte, len(m.IDs)*10)
		var j26 int
		for _, num := range m.IDs {
			for num >= 1<<7 {
				dAtA27[j26] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j26++
			}
			dAtA27[j26] = uint8(num)
			j26++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintJobs(dAtA, i, uint64(j26))
		i += copy(dAtA[i:], dAtA27[:j26])
	}
	if m.HasHistogram {
		dAtA[i] = 0x10
		i++
		if m.HasHistogram {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Inverted {
		dAtA[i] = 0x18
		i++
		if m.Inverted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.HistogramMaxBuckets != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.HistogramMaxBuckets))
	}
	return i, nil
}

func (m *CreateStatsProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateStatsProgress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *Payload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Payload) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Description) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Username) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	if m.StartedMicros != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.StartedMicros))
	}
	if m.FinishedMicros != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.FinishedMicros))
	}
	if len(m.DescriptorIDs) > 0 {
		dAtA29 := make([]byte, len(m.DescriptorIDs)*10)
		var j28 int
		for _, num := range m.DescriptorIDs {
			for num >= 1<<7 {
				dAtA29[j28] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j28++
			}
			dAtA29[j28] = uint8(num)
			j28++
		}
		dAtA[i] = 0x32
		i++
		i = encodeVarintJobs(dAtA, i, uint64(j28))
		i += copy(dAtA[i:], dAtA29[:j28])
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if m.Lease != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Lease.Size()))
		n30, err := m.Lease.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.Details != nil {
		nn31, err := m.Details.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn31
	}
	if len(m.Statement) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.Statement)))
		i += copy(dAtA[i:], m.Statement)
	}
	if m.Noncancelable {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		if m.Noncancelable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Payload_Backup) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Backup != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Backup.Size()))
		n32, err := m.Backup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}
func (m *Payload_Restore) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Restore != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Restore.Size()))
		n33, err := m.Restore.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	return i, nil
}
func (m *Payload_SchemaChange) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SchemaChange != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.SchemaChange.Size()))
		n34, err := m.SchemaChange.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	return i, nil
}
func (m *Payload_Import) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Import != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Import.Size()))
		n35, err := m.Import.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	return i, nil
}
func (m *Payload_Changefeed) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Changefeed != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Changefeed.Size()))
		n36, err := m.Changefeed.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	return i, nil
}
func (m *Payload_CreateStats) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CreateStats != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.CreateStats.Size()))
		n37, err := m.CreateStats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	return i, nil
}
func (m *Payload_Dump) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Dump != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Dump.Size()))
		n38, err := m.Dump.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	return i, nil
}
func (m *Payload_SchemaChangeGC) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SchemaChangeGC != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.SchemaChangeGC.Size()))
		n39, err := m.SchemaChangeGC.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	return i, nil
}
func (m *Progress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Progress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Progress != nil {
		nn40, err := m.Progress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn40
	}
	if m.ModifiedMicros != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.ModifiedMicros))
	}
	if len(m.RunningStatus) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.RunningStatus)))
		i += copy(dAtA[i:], m.RunningStatus)
	}
	if m.Details != nil {
		nn41, err := m.Details.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn41
	}
	return i, nil
}

func (m *Progress_FractionCompleted) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0xd
	i++
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.FractionCompleted))))
	i += 4
	return i, nil
}
func (m *Progress_HighWater) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.HighWater != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.HighWater.Size()))
		n42, err := m.HighWater.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	return i, nil
}
func (m *Progress_Backup) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Backup != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Backup.Size()))
		n43, err := m.Backup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	return i, nil
}
func (m *Progress_Restore) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Restore != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Restore.Size()))
		n44, err := m.Restore.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	return i, nil
}
func (m *Progress_SchemaChange) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SchemaChange != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.SchemaChange.Size()))
		n45, err := m.SchemaChange.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	return i, nil
}
func (m *Progress_Import) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Import != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Import.Size()))
		n46, err := m.Import.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	return i, nil
}
func (m *Progress_Changefeed) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Changefeed != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Changefeed.Size()))
		n47, err := m.Changefeed.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	return i, nil
}
func (m *Progress_CreateStats) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CreateStats != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.CreateStats.Size()))
		n48, err := m.CreateStats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	return i, nil
}
func (m *Progress_Dump) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Dump != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Dump.Size()))
		n49, err := m.Dump.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	return i, nil
}
func (m *Progress_SchemaChangeGC) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SchemaChangeGC != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.SchemaChangeGC.Size()))
		n50, err := m.SchemaChangeGC.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	return i, nil
}
func encodeVarintJobs(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Lease) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovJobs(uint64(m.NodeID))
	}
	if m.Epoch != 0 {
		n += 1 + sovJobs(uint64(m.Epoch))
	}
	return n
}

func (m *BackupDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.StartTime.Size()
	n += 1 + l + sovJobs(uint64(l))
	l = m.EndTime.Size()
	n += 1 + l + sovJobs(uint64(l))
	l = len(m.URI)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	l = len(m.BackupDescriptor)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	if m.Encryption != nil {
		l = m.Encryption.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}

func (m *BackupProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *DumpDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.StartTime.Size()
	n += 1 + l + sovJobs(uint64(l))
	l = m.EndTime.Size()
	n += 1 + l + sovJobs(uint64(l))
	l = len(m.URI)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	l = len(m.DumpDescriptor)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	if m.Encryption != nil {
		l = m.Encryption.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	if m.CompressionCodec != 0 {
		n += 1 + sovJobs(uint64(m.CompressionCodec))
	}
	if m.DumpOnline {
		n += 2
	}
	l = m.DumpOnlineFiles.Size()
	n += 1 + l + sovJobs(uint64(l))
	l = len(m.HttpHeader)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}

func (m *DumpProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *RestoreDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TableRewrites) > 0 {
		for k, v := range m.TableRewrites {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovJobs(uint64(l))
			}
			mapEntrySize := 1 + sovJobs(uint64(k)) + l
			n += mapEntrySize + 1 + sovJobs(uint64(mapEntrySize))
		}
	}
	if len(m.URIs) > 0 {
		for _, s := range m.URIs {
			l = len(s)
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	l = m.EndTime.Size()
	n += 1 + l + sovJobs(uint64(l))
	if len(m.TableDescs) > 0 {
		for _, e := range m.TableDescs {
			l = e.Size()
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	l = len(m.OverrideDB)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	if m.DescriptorCoverage != 0 {
		n += 1 + sovJobs(uint64(m.DescriptorCoverage))
	}
	if m.Encryption != nil {
		l = m.Encryption.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	l = len(m.HttpHeader)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	if len(m.SystemTablesRestored) > 0 {
		for k, v := range m.SystemTablesRestored {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovJobs(uint64(len(k))) + 1 + 1
			n += mapEntrySize + 1 + sovJobs(uint64(mapEntrySize))
		}
	}
	if len(m.SchemaDescs) > 0 {
		for _, e := range m.SchemaDescs {
			l = e.Size()
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	if len(m.DatabaseDescs) > 0 {
		for _, e := range m.DatabaseDescs {
			l = e.Size()
			n += 2 + l + sovJobs(uint64(l))
		}
	}
	if m.SystemTmpRestored {
		n += 3
	}
	if m.PrepareCompleted {
		n += 3
	}
	return n
}

func (m *RestoreDetails_TableRewrite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovJobs(uint64(m.TableID))
	}
	if m.ParentID != 0 {
		n += 1 + sovJobs(uint64(m.ParentID))
	}
	return n
}

func (m *RestoreProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HighWater)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}

func (m *ImportDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Tables) > 0 {
		for _, e := range m.Tables {
			l = e.Size()
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	if len(m.URIs) > 0 {
		for _, s := range m.URIs {
			l = len(s)
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	l = m.Format.Size()
	n += 1 + l + sovJobs(uint64(l))
	if m.SSTSize != 0 {
		n += 1 + sovJobs(uint64(m.SSTSize))
	}
	if m.Walltime != 0 {
		n += 1 + sovJobs(uint64(m.Walltime))
	}
	if m.ParentID != 0 {
		n += 1 + sovJobs(uint64(m.ParentID))
	}
	l = len(m.BackupPath)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	if len(m.Samples) > 0 {
		for _, b := range m.Samples {
			l = len(b)
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	if m.Oversample != 0 {
		n += 1 + sovJobs(uint64(m.Oversample))
	}
	if m.SkipFKs {
		n += 2
	}
	if m.IngestDirectly {
		n += 2
	}
	l = len(m.Encoding)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	if m.Encryption != nil {
		l = m.Encryption.Size()
		n += 2 + l + sovJobs(uint64(l))
	}
	if len(m.Databases) > 0 {
		for _, e := range m.Databases {
			l = e.Size()
			n += 2 + l + sovJobs(uint64(l))
		}
	}
	if len(m.Schemas) > 0 {
		for _, e := range m.Schemas {
			l = e.Size()
			n += 2 + l + sovJobs(uint64(l))
		}
	}
	if m.PrepareComplete {
		n += 3
	}
	return n
}

func (m *ImportDetails_Database) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Database != nil {
		l = m.Database.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	if len(m.Schemas) > 0 {
		for _, e := range m.Schemas {
			l = e.Size()
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	return n
}

func (m *ImportDetails_Table) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Desc != nil {
		l = m.Desc.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 2 + l + sovJobs(uint64(l))
	}
	if m.SeqVal != 0 {
		n += 2 + sovJobs(uint64(m.SeqVal))
	}
	if m.IsNew {
		n += 3
	}
	if len(m.TargetCols) > 0 {
		for _, s := range m.TargetCols {
			l = len(s)
			n += 2 + l + sovJobs(uint64(l))
		}
	}
	return n
}

func (m *ImportProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SamplingProgress) > 0 {
		n += 1 + sovJobs(uint64(len(m.SamplingProgress)*4)) + len(m.SamplingProgress)*4
	}
	if len(m.ReadProgress) > 0 {
		n += 1 + sovJobs(uint64(len(m.ReadProgress)*4)) + len(m.ReadProgress)*4
	}
	if len(m.WriteProgress) > 0 {
		n += 1 + sovJobs(uint64(len(m.WriteProgress)*4)) + len(m.WriteProgress)*4
	}
	if len(m.SpanProgress) > 0 {
		for _, e := range m.SpanProgress {
			l = e.Size()
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	return n
}

func (m *ImportProgress_SpanProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Table.Size()
	n += 1 + l + sovJobs(uint64(l))
	if len(m.SpanProgress) > 0 {
		for _, e := range m.SpanProgress {
			l = e.Size()
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	return n
}

func (m *ResumeSpanList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ResumeSpans) > 0 {
		for _, e := range m.ResumeSpans {
			l = e.Size()
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	return n
}

func (m *DroppedTableDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	if m.ID != 0 {
		n += 1 + sovJobs(uint64(m.ID))
	}
	if m.Status != 0 {
		n += 1 + sovJobs(uint64(m.Status))
	}
	return n
}

func (m *SchemaChangeGCDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Indexes) > 0 {
		for _, e := range m.Indexes {
			l = e.Size()
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	if len(m.Tables) > 0 {
		for _, e := range m.Tables {
			l = e.Size()
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	if m.ParentID != 0 {
		n += 1 + sovJobs(uint64(m.ParentID))
	}
	return n
}

func (m *SchemaChangeGCDetails_DroppedIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IndexID != 0 {
		n += 1 + sovJobs(uint64(m.IndexID))
	}
	if m.DropTime != 0 {
		n += 1 + sovJobs(uint64(m.DropTime))
	}
	return n
}

func (m *SchemaChangeGCDetails_DroppedID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovJobs(uint64(m.ID))
	}
	if m.DropTime != 0 {
		n += 1 + sovJobs(uint64(m.DropTime))
	}
	return n
}

func (m *SchemaChangeDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ResumeSpanList) > 0 {
		for _, e := range m.ResumeSpanList {
			l = e.Size()
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	if len(m.DroppedTables) > 0 {
		for _, e := range m.DroppedTables {
			l = e.Size()
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	if m.DroppedDatabaseID != 0 {
		n += 1 + sovJobs(uint64(m.DroppedDatabaseID))
	}
	return n
}

func (m *SchemaChangeProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SchemaChangeGCProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Indexes) > 0 {
		for _, e := range m.Indexes {
			l = e.Size()
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	if len(m.Tables) > 0 {
		for _, e := range m.Tables {
			l = e.Size()
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	return n
}

func (m *SchemaChangeGCProgress_IndexProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IndexID != 0 {
		n += 1 + sovJobs(uint64(m.IndexID))
	}
	if m.Status != 0 {
		n += 1 + sovJobs(uint64(m.Status))
	}
	return n
}

func (m *SchemaChangeGCProgress_TableProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovJobs(uint64(m.ID))
	}
	if m.Status != 0 {
		n += 1 + sovJobs(uint64(m.Status))
	}
	return n
}

func (m *ChangefeedTarget) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StatementTimeName)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}

func (m *ChangefeedDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SinkURI)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	if len(m.Opts) > 0 {
		for k, v := range m.Opts {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovJobs(uint64(len(k))) + 1 + len(v) + sovJobs(uint64(len(v)))
			n += mapEntrySize + 1 + sovJobs(uint64(mapEntrySize))
		}
	}
	if len(m.Targets) > 0 {
		for k, v := range m.Targets {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + sovJobs(uint64(k)) + 1 + l + sovJobs(uint64(l))
			n += mapEntrySize + 1 + sovJobs(uint64(mapEntrySize))
		}
	}
	l = m.StatementTime.Size()
	n += 1 + l + sovJobs(uint64(l))
	if len(m.Tables) > 0 {
		for k, v := range m.Tables {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovJobs(uint64(l))
			}
			mapEntrySize := 1 + sovJobs(uint64(k)) + l
			n += mapEntrySize + 1 + sovJobs(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ResolvedSpan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Span.Size()
	n += 1 + l + sovJobs(uint64(l))
	l = m.Timestamp.Size()
	n += 1 + l + sovJobs(uint64(l))
	if m.BoundaryReached {
		n += 2
	}
	return n
}

func (m *ChangefeedProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ResolvedSpans) > 0 {
		for _, e := range m.ResolvedSpans {
			l = e.Size()
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	return n
}

func (m *CreateStatsDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	l = m.Table.Size()
	n += 1 + l + sovJobs(uint64(l))
	if len(m.ColumnLists) > 0 {
		for _, e := range m.ColumnLists {
			l = e.Size()
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	l = len(m.Statement)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	if m.AsOf != nil {
		l = m.AsOf.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	l = len(m.FQTableName)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	if m.MaxFractionIdle != 0 {
		n += 9
	}
	return n
}

func (m *CreateStatsDetails_ColList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.IDs) > 0 {
		l = 0
		for _, e := range m.IDs {
			l += sovJobs(uint64(e))
		}
		n += 1 + sovJobs(uint64(l)) + l
	}
	if m.HasHistogram {
		n += 2
	}
	if m.Inverted {
		n += 2
	}
	if m.HistogramMaxBuckets != 0 {
		n += 1 + sovJobs(uint64(m.HistogramMaxBuckets))
	}
	return n
}

func (m *CreateStatsProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Payload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	if m.StartedMicros != 0 {
		n += 1 + sovJobs(uint64(m.StartedMicros))
	}
	if m.FinishedMicros != 0 {
		n += 1 + sovJobs(uint64(m.FinishedMicros))
	}
	if len(m.DescriptorIDs) > 0 {
		l = 0
		for _, e := range m.DescriptorIDs {
			l += sovJobs(uint64(e))
		}
		n += 1 + sovJobs(uint64(l)) + l
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	if m.Lease != nil {
		l = m.Lease.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	if m.Details != nil {
		n += m.Details.Size()
	}
	l = len(m.Statement)
	if l > 0 {
		n += 2 + l + sovJobs(uint64(l))
	}
	if m.Noncancelable {
		n += 3
	}
	return n
}

func (m *Payload_Backup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Backup != nil {
		l = m.Backup.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Payload_Restore) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Restore != nil {
		l = m.Restore.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Payload_SchemaChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SchemaChange != nil {
		l = m.SchemaChange.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Payload_Import) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Import != nil {
		l = m.Import.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Payload_Changefeed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Changefeed != nil {
		l = m.Changefeed.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Payload_CreateStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateStats != nil {
		l = m.CreateStats.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Payload_Dump) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dump != nil {
		l = m.Dump.Size()
		n += 2 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Payload_SchemaChangeGC) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SchemaChangeGC != nil {
		l = m.SchemaChangeGC.Size()
		n += 2 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Progress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Progress != nil {
		n += m.Progress.Size()
	}
	if m.ModifiedMicros != 0 {
		n += 1 + sovJobs(uint64(m.ModifiedMicros))
	}
	l = len(m.RunningStatus)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	if m.Details != nil {
		n += m.Details.Size()
	}
	return n
}

func (m *Progress_FractionCompleted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 5
	return n
}
func (m *Progress_HighWater) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HighWater != nil {
		l = m.HighWater.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Progress_Backup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Backup != nil {
		l = m.Backup.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Progress_Restore) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Restore != nil {
		l = m.Restore.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Progress_SchemaChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SchemaChange != nil {
		l = m.SchemaChange.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Progress_Import) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Import != nil {
		l = m.Import.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Progress_Changefeed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Changefeed != nil {
		l = m.Changefeed.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Progress_CreateStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateStats != nil {
		l = m.CreateStats.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Progress_Dump) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dump != nil {
		l = m.Dump.Size()
		n += 2 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Progress_SchemaChangeGC) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SchemaChangeGC != nil {
		l = m.SchemaChangeGC.Size()
		n += 2 + l + sovJobs(uint64(l))
	}
	return n
}

func sovJobs(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozJobs(x uint64) (n int) {
	return sovJobs(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Lease) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Lease: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Lease: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= (github_com_znbasedb_znbase_pkg_roachpb.NodeID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackupDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackupDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackupDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EndTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupDescriptor", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BackupDescriptor = append(m.BackupDescriptor[:0], dAtA[iNdEx:postIndex]...)
			if m.BackupDescriptor == nil {
				m.BackupDescriptor = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encryption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Encryption == nil {
				m.Encryption = &roachpb.FileEncryptionOptions{}
			}
			if err := m.Encryption.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackupProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackupProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackupProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DumpDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DumpDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DumpDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EndTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DumpDescriptor", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DumpDescriptor = append(m.DumpDescriptor[:0], dAtA[iNdEx:postIndex]...)
			if m.DumpDescriptor == nil {
				m.DumpDescriptor = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encryption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Encryption == nil {
				m.Encryption = &roachpb.FileEncryptionOptions{}
			}
			if err := m.Encryption.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressionCodec", wireType)
			}
			m.CompressionCodec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompressionCodec |= (roachpb.FileCompression(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DumpOnline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DumpOnline = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DumpOnlineFiles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DumpOnlineFiles.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpHeader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HttpHeader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DumpProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DumpProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DumpProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RestoreDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RestoreDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RestoreDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableRewrites", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableRewrites == nil {
				m.TableRewrites = make(map[github_com_znbasedb_znbase_pkg_sql_sqlbase.ID]*RestoreDetails_TableRewrite)
			}
			var mapkey uint32
			var mapvalue *RestoreDetails_TableRewrite
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthJobs
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthJobs
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RestoreDetails_TableRewrite{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipJobs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthJobs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TableRewrites[github_com_znbasedb_znbase_pkg_sql_sqlbase.ID(mapkey)] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URIs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URIs = append(m.URIs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EndTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDescs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableDescs = append(m.TableDescs, &sqlbase.TableDescriptor{})
			if err := m.TableDescs[len(m.TableDescs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverrideDB", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OverrideDB = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorCoverage", wireType)
			}
			m.DescriptorCoverage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DescriptorCoverage |= (github_com_znbasedb_znbase_pkg_sql_sem_tree.DescriptorCoverage(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encryption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Encryption == nil {
				m.Encryption = &roachpb.FileEncryptionOptions{}
			}
			if err := m.Encryption.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpHeader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HttpHeader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemTablesRestored", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SystemTablesRestored == nil {
				m.SystemTablesRestored = make(map[string]bool)
			}
			var mapkey string
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthJobs
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipJobs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthJobs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SystemTablesRestored[mapkey] = mapvalue
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaDescs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaDescs = append(m.SchemaDescs, &sqlbase.SchemaDescriptor{})
			if err := m.SchemaDescs[len(m.SchemaDescs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseDescs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatabaseDescs = append(m.DatabaseDescs, &sqlbase.DatabaseDescriptor{})
			if err := m.DatabaseDescs[len(m.DatabaseDescs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemTmpRestored", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SystemTmpRestored = bool(v != 0)
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrepareCompleted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PrepareCompleted = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RestoreDetails_TableRewrite) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableRewrite: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableRewrite: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= (github_com_znbasedb_znbase_pkg_sql_sqlbase.ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentID", wireType)
			}
			m.ParentID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentID |= (github_com_znbasedb_znbase_pkg_sql_sqlbase.ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RestoreProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RestoreProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RestoreProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighWater", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HighWater = append(m.HighWater[:0], dAtA[iNdEx:postIndex]...)
			if m.HighWater == nil {
				m.HighWater = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImportDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImportDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImportDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tables = append(m.Tables, ImportDetails_Table{})
			if err := m.Tables[len(m.Tables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URIs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URIs = append(m.URIs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Format.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SSTSize", wireType)
			}
			m.SSTSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SSTSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Walltime", wireType)
			}
			m.Walltime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Walltime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentID", wireType)
			}
			m.ParentID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentID |= (github_com_znbasedb_znbase_pkg_sql_sqlbase.ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BackupPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Samples", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Samples = append(m.Samples, make([]byte, postIndex-iNdEx))
			copy(m.Samples[len(m.Samples)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oversample", wireType)
			}
			m.Oversample = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Oversample |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipFKs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipFKs = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngestDirectly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IngestDirectly = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encoding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Encoding = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encryption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Encryption == nil {
				m.Encryption = &roachpb.FileEncryptionOptions{}
			}
			if err := m.Encryption.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Databases", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Databases = append(m.Databases, ImportDetails_Database{})
			if err := m.Databases[len(m.Databases)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schemas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schemas = append(m.Schemas, &sqlbase.SchemaDescriptor{})
			if err := m.Schemas[len(m.Schemas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrepareComplete", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PrepareComplete = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImportDetails_Database) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Database: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Database: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Database == nil {
				m.Database = &sqlbase.DatabaseDescriptor{}
			}
			if err := m.Database.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schemas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schemas = append(m.Schemas, &sqlbase.SchemaDescriptor{})
			if err := m.Schemas[len(m.Schemas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImportDetails_Table) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Table: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Table: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Desc == nil {
				m.Desc = &sqlbase.TableDescriptor{}
			}
			if err := m.Desc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqVal", wireType)
			}
			m.SeqVal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqVal |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNew", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsNew = bool(v != 0)
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetCols", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetCols = append(m.TargetCols, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImportProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImportProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImportProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.SamplingProgress = append(m.SamplingProgress, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthJobs
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.SamplingProgress) == 0 {
					m.SamplingProgress = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.SamplingProgress = append(m.SamplingProgress, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SamplingProgress", wireType)
			}
		case 2:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.ReadProgress = append(m.ReadProgress, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthJobs
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.ReadProgress) == 0 {
					m.ReadProgress = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.ReadProgress = append(m.ReadProgress, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadProgress", wireType)
			}
		case 3:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.WriteProgress = append(m.WriteProgress, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthJobs
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.WriteProgress) == 0 {
					m.WriteProgress = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.WriteProgress = append(m.WriteProgress, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteProgress", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanProgress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpanProgress = append(m.SpanProgress, &ImportProgress_SpanProgress{})
			if err := m.SpanProgress[len(m.SpanProgress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImportProgress_SpanProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Table.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanProgress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpanProgress = append(m.SpanProgress, roachpb.Span{})
			if err := m.SpanProgress[len(m.SpanProgress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResumeSpanList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResumeSpanList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResumeSpanList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResumeSpans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResumeSpans = append(m.ResumeSpans, roachpb.Span{})
			if err := m.ResumeSpans[len(m.ResumeSpans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DroppedTableDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DroppedTableDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DroppedTableDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (github_com_znbasedb_znbase_pkg_sql_sqlbase.ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaChangeGCDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaChangeGCDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaChangeGCDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Indexes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Indexes = append(m.Indexes, SchemaChangeGCDetails_DroppedIndex{})
			if err := m.Indexes[len(m.Indexes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tables = append(m.Tables, SchemaChangeGCDetails_DroppedID{})
			if err := m.Tables[len(m.Tables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentID", wireType)
			}
			m.ParentID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentID |= (github_com_znbasedb_znbase_pkg_sql_sqlbase.ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaChangeGCDetails_DroppedIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DroppedIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DroppedIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= (github_com_znbasedb_znbase_pkg_sql_sqlbase.IndexID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropTime", wireType)
			}
			m.DropTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DropTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaChangeGCDetails_DroppedID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DroppedID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DroppedID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (github_com_znbasedb_znbase_pkg_sql_sqlbase.ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropTime", wireType)
			}
			m.DropTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DropTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaChangeDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaChangeDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaChangeDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResumeSpanList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResumeSpanList = append(m.ResumeSpanList, ResumeSpanList{})
			if err := m.ResumeSpanList[len(m.ResumeSpanList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DroppedTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DroppedTables = append(m.DroppedTables, DroppedTableDetails{})
			if err := m.DroppedTables[len(m.DroppedTables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DroppedDatabaseID", wireType)
			}
			m.DroppedDatabaseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DroppedDatabaseID |= (github_com_znbasedb_znbase_pkg_sql_sqlbase.ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaChangeProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaChangeProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaChangeProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaChangeGCProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaChangeGCProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaChangeGCProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Indexes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Indexes = append(m.Indexes, SchemaChangeGCProgress_IndexProgress{})
			if err := m.Indexes[len(m.Indexes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tables = append(m.Tables, SchemaChangeGCProgress_TableProgress{})
			if err := m.Tables[len(m.Tables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaChangeGCProgress_IndexProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= (github_com_znbasedb_znbase_pkg_sql_sqlbase.IndexID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (SchemaChangeGCProgress_Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaChangeGCProgress_TableProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (github_com_znbasedb_znbase_pkg_sql_sqlbase.ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (SchemaChangeGCProgress_Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangefeedTarget) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangefeedTarget: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangefeedTarget: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatementTimeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatementTimeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangefeedDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangefeedDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangefeedDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SinkURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SinkURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opts == nil {
				m.Opts = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthJobs
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthJobs
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipJobs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthJobs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Opts[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Targets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Targets == nil {
				m.Targets = make(ChangefeedTargets)
			}
			var mapkey uint32
			mapvalue := &ChangefeedTarget{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthJobs
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthJobs
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ChangefeedTarget{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipJobs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthJobs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Targets[github_com_znbasedb_znbase_pkg_sql_sqlbase.ID(mapkey)] = *mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatementTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StatementTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tables == nil {
				m.Tables = make(map[uint32]*sqlbase.TableDescriptor)
			}
			var mapkey uint32
			var mapvalue *sqlbase.TableDescriptor
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthJobs
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthJobs
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &sqlbase.TableDescriptor{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipJobs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthJobs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tables[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResolvedSpan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResolvedSpan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResolvedSpan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Span.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoundaryReached", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BoundaryReached = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangefeedProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangefeedProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangefeedProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolvedSpans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResolvedSpans = append(m.ResolvedSpans, ResolvedSpan{})
			if err := m.ResolvedSpans[len(m.ResolvedSpans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateStatsDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateStatsDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateStatsDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Table.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnLists", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColumnLists = append(m.ColumnLists, CreateStatsDetails_ColList{})
			if err := m.ColumnLists[len(m.ColumnLists)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Statement", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Statement = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsOf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AsOf == nil {
				m.AsOf = &hlc.Timestamp{}
			}
			if err := m.AsOf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FQTableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FQTableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxFractionIdle", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MaxFractionIdle = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateStatsDetails_ColList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v github_com_znbasedb_znbase_pkg_sql_sqlbase.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (github_com_znbasedb_znbase_pkg_sql_sqlbase.ColumnID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IDs = append(m.IDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthJobs
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.IDs) == 0 {
					m.IDs = make([]github_com_znbasedb_znbase_pkg_sql_sqlbase.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_znbasedb_znbase_pkg_sql_sqlbase.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (github_com_znbasedb_znbase_pkg_sql_sqlbase.ColumnID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IDs = append(m.IDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IDs", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasHistogram", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasHistogram = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inverted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Inverted = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistogramMaxBuckets", wireType)
			}
			m.HistogramMaxBuckets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HistogramMaxBuckets |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateStatsProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateStatsProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateStatsProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Payload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Payload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Payload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedMicros", wireType)
			}
			m.StartedMicros = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartedMicros |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinishedMicros", wireType)
			}
			m.FinishedMicros = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FinishedMicros |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 0 {
				var v github_com_znbasedb_znbase_pkg_sql_sqlbase.ID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (github_com_znbasedb_znbase_pkg_sql_sqlbase.ID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DescriptorIDs = append(m.DescriptorIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthJobs
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DescriptorIDs) == 0 {
					m.DescriptorIDs = make([]github_com_znbasedb_znbase_pkg_sql_sqlbase.ID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_znbasedb_znbase_pkg_sql_sqlbase.ID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (github_com_znbasedb_znbase_pkg_sql_sqlbase.ID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DescriptorIDs = append(m.DescriptorIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorIDs", wireType)
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lease", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lease == nil {
				m.Lease = &Lease{}
			}
			if err := m.Lease.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Backup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BackupDetails{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Payload_Backup{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Restore", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RestoreDetails{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Payload_Restore{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaChange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SchemaChangeDetails{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Payload_SchemaChange{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Import", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ImportDetails{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Payload_Import{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Changefeed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ChangefeedDetails{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Payload_Changefeed{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CreateStatsDetails{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Payload_CreateStats{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Statement", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Statement = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dump", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DumpDetails{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Payload_Dump{v}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaChangeGC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SchemaChangeGCDetails{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Payload_SchemaChangeGC{v}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Noncancelable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Noncancelable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Progress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Progress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Progress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FractionCompleted", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Progress = &Progress_FractionCompleted{float32(math.Float32frombits(v))}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModifiedMicros", wireType)
			}
			m.ModifiedMicros = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModifiedMicros |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighWater", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &hlc.Timestamp{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Progress = &Progress_HighWater{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunningStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RunningStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Backup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BackupProgress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Progress_Backup{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Restore", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RestoreProgress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Progress_Restore{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaChange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SchemaChangeProgress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Progress_SchemaChange{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Import", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ImportProgress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Progress_Import{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Changefeed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ChangefeedProgress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Progress_Changefeed{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CreateStatsProgress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Progress_CreateStats{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dump", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DumpProgress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Progress_Dump{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaChangeGC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SchemaChangeGCProgress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Progress_SchemaChangeGC{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipJobs(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthJobs
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipJobs(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthJobs = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowJobs   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("jobs/jobspb/jobs.proto", fileDescriptor_jobs_d8caa83bd0f9be11) }

var fileDescriptor_jobs_d8caa83bd0f9be11 = []byte{
	// 3438 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x5a, 0x4d, 0x6c, 0x1b, 0x49,
	0x76, 0x66, 0x93, 0x2d, 0xb2, 0xf9, 0xf8, 0xa3, 0x66, 0x49, 0xf6, 0x72, 0xb8, 0x5e, 0x91, 0xe0,
	0xce, 0x78, 0xb4, 0xf6, 0x0e, 0x95, 0x95, 0xb1, 0xeb, 0x8c, 0x67, 0xd7, 0x33, 0xe2, 0x8f, 0x24,
	0x72, 0x2c, 0x51, 0x53, 0x92, 0x66, 0x06, 0xce, 0x22, 0x8d, 0x16, 0xbb, 0x24, 0x76, 0x44, 0x76,
	0xb7, 0xbb, 0x9a, 0xf6, 0x68, 0x8e, 0x0b, 0x04, 0x48, 0x7c, 0x08, 0x16, 0xc8, 0x75, 0x0d, 0x04,
	0xc8, 0x06, 0x49, 0x8e, 0x39, 0x27, 0xb7, 0x20, 0xc0, 0x04, 0x08, 0x82, 0x39, 0xee, 0x89, 0x49,
	0x34, 0x97, 0x9c, 0x83, 0x60, 0x0e, 0x73, 0x0a, 0xaa, 0xaa, 0xbb, 0xd9, 0xa4, 0x65, 0x99, 0x12,
	0x1c, 0x60, 0x2f, 0x32, 0xfb, 0xd5, 0x7b, 0xaf, 0xea, 0xbd, 0x7a, 0xef, 0x7b, 0xaf, 0xaa, 0x0c,
	0x37, 0xff, 0xc4, 0x3e, 0xa2, 0x6b, 0xec, 0x8f, 0x73, 0xc4, 0xff, 0xa9, 0x39, 0xae, 0xed, 0xd9,
	0xe8, 0xe6, 0x97, 0xd6, 0x91, 0x4e, 0x49, 0x8d, 0x3e, 0x19, 0xd4, 0x38, 0x59, 0xb0, 0x94, 0x96,
	0x4f, 0xec, 0x13, 0x9b, 0xb3, 0xac, 0xb1, 0x5f, 0x82, 0xbb, 0x54, 0x70, 0x6d, 0xbd, 0xd7, 0x77,
	0x8e, 0xd6, 0x74, 0xc7, 0xf4, 0x49, 0x28, 0x20, 0x19, 0xba, 0xa7, 0xfb, 0xb4, 0x62, 0x40, 0x33,
	0xed, 0xf7, 0x8e, 0x6d, 0x77, 0xa8, 0x7b, 0xfe, 0x74, 0xa5, 0x5b, 0xf4, 0xc9, 0x60, 0x8d, 0x3e,
	0x19, 0xb0, 0x39, 0xd7, 0xa8, 0xe7, 0x8e, 0x7a, 0xde, 0xc8, 0x25, 0x46, 0x20, 0x37, 0xf2, 0xcc,
	0xc1, 0x5a, 0x7f, 0xd0, 0x5b, 0xf3, 0xcc, 0x21, 0xa1, 0x9e, 0x3e, 0x74, 0xc4, 0x48, 0xf5, 0x0c,
	0x16, 0x1e, 0x11, 0x9d, 0x12, 0x74, 0x00, 0x29, 0xcb, 0x36, 0x88, 0x66, 0x1a, 0x45, 0xa9, 0x22,
	0xad, 0xe6, 0xea, 0x1f, 0x9c, 0x8f, 0xcb, 0xc9, 0x5d, 0xdb, 0x20, 0xed, 0xe6, 0x77, 0xe3, 0xf2,
	0x7b, 0x27, 0xa6, 0xd7, 0x1f, 0x1d, 0xd5, 0x7a, 0xf6, 0x70, 0x4d, 0x58, 0x66, 0x1c, 0xf9, 0x3f,
	0xd6, 0x9c, 0xd3, 0x93, 0x35, 0x7f, 0x61, 0x35, 0x21, 0x80, 0x93, 0x4c, 0x57, 0xdb, 0x40, 0xcb,
	0xb0, 0x40, 0x1c, 0xbb, 0xd7, 0x2f, 0xc6, 0x2b, 0xd2, 0x6a, 0x02, 0x8b, 0x8f, 0x07, 0xf2, 0x7f,
	0xff, 0x55, 0x59, 0xaa, 0xfe, 0x26, 0x0e, 0xb9, 0xba, 0xde, 0x3b, 0x1d, 0x39, 0x4d, 0xe2, 0xe9,
	0xe6, 0x80, 0xa2, 0x0f, 0x01, 0xa8, 0xa7, 0xbb, 0x9e, 0xc6, 0x56, 0xc9, 0x97, 0x91, 0x59, 0x2f,
	0xd5, 0x7c, 0x47, 0x32, 0x13, 0x6a, 0xfd, 0x41, 0xaf, 0x76, 0x10, 0x98, 0x50, 0x97, 0xbf, 0x1a,
	0x97, 0x63, 0x38, 0xcd, 0x65, 0x18, 0x15, 0x7d, 0x00, 0x0a, 0xb1, 0x0c, 0x21, 0x1e, 0x9f, 0x53,
	0x3c, 0x45, 0x2c, 0x83, 0x0b, 0xbf, 0x05, 0x89, 0x91, 0x6b, 0x16, 0x13, 0x15, 0x69, 0x35, 0x5d,
	0x4f, 0x9d, 0x8f, 0xcb, 0x89, 0x43, 0xdc, 0xc6, 0x8c, 0x86, 0xee, 0x42, 0xe1, 0x88, 0xaf, 0x54,
	0x33, 0x08, 0xed, 0xb9, 0xa6, 0xe3, 0xd9, 0x6e, 0x51, 0xae, 0x48, 0xab, 0x59, 0xac, 0x1e, 0xf9,
	0x26, 0x04, 0x74, 0xd4, 0x02, 0x20, 0x56, 0xcf, 0x3d, 0x73, 0x3c, 0xd3, 0xb6, 0x8a, 0x49, 0xbe,
	0x8c, 0x77, 0x82, 0x65, 0x04, 0x7e, 0xda, 0x34, 0x07, 0xa4, 0x15, 0x72, 0x75, 0xf9, 0x5f, 0x8a,
	0x23, 0x82, 0x55, 0x15, 0xf2, 0xc2, 0x3b, 0x7b, 0xae, 0x7d, 0xe2, 0x12, 0x4a, 0xab, 0xbf, 0x92,
	0x21, 0xd3, 0x1c, 0x0d, 0x7f, 0xff, 0xdd, 0xf5, 0x2e, 0x2c, 0x1a, 0xa3, 0xe1, 0x05, 0xce, 0xca,
	0x1b, 0x7c, 0xf9, 0x6f, 0xd8, 0x55, 0xe8, 0x11, 0x14, 0x7a, 0xf6, 0xd0, 0x61, 0x4e, 0x32, 0x6d,
	0x4b, 0xeb, 0xd9, 0x06, 0xe9, 0x15, 0x53, 0x15, 0x69, 0x35, 0xbf, 0x5e, 0xbe, 0x48, 0x5b, 0x63,
	0xc2, 0x8c, 0xd5, 0x88, 0x64, 0x83, 0x09, 0xa2, 0x32, 0x64, 0xf8, 0xea, 0x6d, 0x6b, 0x60, 0x5a,
	0xa4, 0xa8, 0x54, 0xa4, 0x55, 0x05, 0x03, 0x23, 0x75, 0x39, 0x05, 0x3d, 0x86, 0x42, 0x84, 0x41,
	0x3b, 0x36, 0x07, 0x84, 0x16, 0xd3, 0x7c, 0xf1, 0xab, 0xb3, 0xd3, 0x35, 0x43, 0x31, 0x4c, 0xa8,
	0x63, 0x5b, 0x94, 0xf0, 0x15, 0x50, 0xdf, 0x9b, 0x8b, 0x13, 0xb5, 0x9c, 0xcc, 0x26, 0xef, 0x7b,
	0x9e, 0xa3, 0xf5, 0x89, 0x6e, 0x10, 0xb7, 0x08, 0xcc, 0xbb, 0x18, 0x18, 0x69, 0x9b, 0x53, 0xaa,
	0x79, 0xc8, 0x32, 0x9d, 0x61, 0x50, 0xfc, 0x3b, 0x40, 0x1e, 0x13, 0xea, 0xd9, 0x2e, 0x09, 0xe2,
	0xe2, 0x2f, 0x25, 0xc8, 0x7b, 0xfa, 0xd1, 0x80, 0x68, 0x2e, 0x79, 0xe6, 0x9a, 0x1e, 0xa1, 0xc5,
	0x78, 0x25, 0xb1, 0x9a, 0x59, 0x7f, 0xbf, 0x76, 0x31, 0x28, 0xd5, 0xa6, 0x15, 0xd4, 0x0e, 0x98,
	0x30, 0xf6, 0x65, 0x5b, 0x96, 0xe7, 0x9e, 0xd5, 0x7f, 0xf2, 0xab, 0xff, 0x78, 0x2d, 0x06, 0x44,
	0x20, 0xa8, 0xd6, 0x6e, 0xe2, 0x9c, 0x17, 0x55, 0x83, 0x6e, 0x81, 0x3c, 0x72, 0x4d, 0x5a, 0x4c,
	0x54, 0x12, 0xab, 0xe9, 0xba, 0x72, 0x3e, 0x2e, 0xcb, 0x87, 0xb8, 0x4d, 0x31, 0xa7, 0x4e, 0x85,
	0xa2, 0x7c, 0xd5, 0x50, 0x6c, 0x42, 0x46, 0xd8, 0xcb, 0x02, 0x8e, 0x16, 0x17, 0xb8, 0xb1, 0x3f,
	0x8c, 0x1a, 0x1b, 0x2c, 0x8b, 0x5b, 0x36, 0x09, 0x40, 0x0c, 0x5e, 0x40, 0xa0, 0x68, 0x0d, 0x32,
	0xf6, 0x53, 0xe2, 0xba, 0xa6, 0x41, 0x34, 0xe3, 0x88, 0x47, 0x63, 0xba, 0x9e, 0x3f, 0x1f, 0x97,
	0xa1, 0xeb, 0x93, 0x9b, 0x75, 0x0c, 0x01, 0x4b, 0xf3, 0x08, 0x51, 0x58, 0x9a, 0x44, 0xb8, 0xd6,
	0x63, 0x23, 0xfa, 0x09, 0x29, 0x66, 0x2a, 0xd2, 0xea, 0x42, 0xbd, 0xfe, 0xdd, 0xb8, 0xfc, 0x70,
	0x1e, 0x87, 0x91, 0xe1, 0x9a, 0xe7, 0x12, 0x52, 0x9b, 0xac, 0xaa, 0xe1, 0x6b, 0xc2, 0xc8, 0x78,
	0x89, 0x36, 0x93, 0x32, 0xd9, 0xeb, 0xa6, 0xcc, 0x4c, 0x9c, 0xe5, 0x66, 0xe3, 0x0c, 0x3d, 0x85,
	0x9b, 0xf4, 0x8c, 0x7a, 0x64, 0xa8, 0x71, 0x17, 0x51, 0xcd, 0x15, 0x31, 0x62, 0x14, 0xf3, 0xdc,
	0xbd, 0x1f, 0xcd, 0x19, 0x4b, 0xfb, 0x5c, 0x09, 0xf7, 0x3b, 0xf5, 0x87, 0x0c, 0x1e, 0x52, 0x78,
	0x99, 0x5e, 0x30, 0x84, 0xb6, 0x20, 0x4b, 0x7b, 0x7d, 0x32, 0xd4, 0xfd, 0xcd, 0x5c, 0xe4, 0xb3,
	0xbd, 0x7d, 0xd1, 0x66, 0xee, 0x73, 0xbe, 0xc8, 0x6e, 0x66, 0x68, 0x48, 0xa1, 0x68, 0x07, 0xf2,
	0xac, 0x72, 0x32, 0x4e, 0x5f, 0x95, 0xca, 0x55, 0xdd, 0xbe, 0x48, 0x55, 0xd3, 0xe7, 0x8c, 0x28,
	0xcb, 0x19, 0x11, 0x1a, 0x45, 0x35, 0x58, 0x0a, 0xfc, 0x31, 0x74, 0x26, 0xce, 0x28, 0x70, 0x74,
	0x28, 0xf8, 0xa6, 0x0c, 0x9d, 0xd0, 0x8e, 0xbb, 0x50, 0x70, 0x5c, 0xe2, 0xe8, 0x2e, 0xd1, 0x18,
	0xc2, 0x0c, 0x88, 0x47, 0x8c, 0x22, 0xe2, 0xdc, 0xaa, 0x3f, 0xd0, 0x08, 0xe8, 0xa5, 0x7f, 0x96,
	0x20, 0x1b, 0x4d, 0x3a, 0xf4, 0x19, 0x28, 0x22, 0xa2, 0xc3, 0x72, 0xfc, 0xf3, 0xf3, 0x71, 0x39,
	0xc5, 0x79, 0xe6, 0xaa, 0xc7, 0x33, 0xb9, 0x98, 0xe2, 0xda, 0xda, 0x06, 0x7a, 0x0c, 0x69, 0x36,
	0xb5, 0xe5, 0x31, 0xcd, 0x71, 0xae, 0xf9, 0x17, 0xe7, 0xe3, 0xb2, 0xb2, 0xc7, 0x89, 0xd7, 0x51,
	0xad, 0x08, 0x7d, 0x6d, 0xa3, 0x34, 0x02, 0xf4, 0x32, 0x72, 0x20, 0x15, 0x12, 0xa7, 0xe4, 0x4c,
	0x58, 0x81, 0xd9, 0x4f, 0xd4, 0x86, 0x85, 0xa7, 0xfa, 0x60, 0x14, 0xd4, 0x9c, 0x7b, 0xd7, 0x40,
	0x25, 0x2c, 0x34, 0x3c, 0x88, 0xff, 0xa1, 0x54, 0xda, 0x82, 0xb7, 0x5e, 0x19, 0x64, 0xd1, 0xd9,
	0xd3, 0x62, 0xf6, 0xe5, 0xe8, 0xec, 0x4a, 0x44, 0x51, 0x47, 0x56, 0x24, 0x35, 0x5e, 0xfd, 0x03,
	0x58, 0xf4, 0x55, 0x04, 0x18, 0x8b, 0x7e, 0x00, 0xd0, 0x37, 0x4f, 0xfa, 0xda, 0x33, 0xdd, 0x23,
	0x2e, 0xd7, 0x95, 0xc5, 0x69, 0x46, 0xf9, 0x8c, 0x11, 0xaa, 0xff, 0x98, 0x86, 0x5c, 0x7b, 0xe8,
	0xd8, 0xae, 0x17, 0x20, 0x70, 0x1b, 0x92, 0x22, 0x6b, 0x8a, 0x12, 0x8f, 0xb9, 0xbb, 0xaf, 0x32,
	0x71, 0x4a, 0x4c, 0x58, 0xe8, 0x83, 0x9b, 0xaf, 0x20, 0x84, 0xcd, 0xf8, 0x85, 0xb0, 0xf9, 0x00,
	0x92, 0xa2, 0x0f, 0xe4, 0x75, 0x38, 0xb3, 0x7e, 0x6b, 0x16, 0x09, 0xda, 0x5d, 0x86, 0x05, 0x9b,
	0x9c, 0x27, 0xd0, 0x2c, 0x24, 0xd0, 0x6d, 0x50, 0x28, 0xf5, 0x34, 0x6a, 0x7e, 0x29, 0x20, 0x37,
	0x51, 0xcf, 0xb0, 0x18, 0xdb, 0xdf, 0x3f, 0xd8, 0x37, 0xbf, 0x24, 0x38, 0x45, 0xa9, 0xc7, 0x7e,
	0xa0, 0x12, 0x28, 0xcf, 0xf4, 0xc1, 0x80, 0x43, 0xf3, 0x02, 0x6f, 0xe3, 0xc2, 0xef, 0xe9, 0x70,
	0x4a, 0xbe, 0xd1, 0x70, 0x62, 0x10, 0xe5, 0x37, 0x5d, 0x8e, 0xee, 0xf5, 0x79, 0x3d, 0x4f, 0x63,
	0x10, 0xa4, 0x3d, 0xdd, 0xeb, 0xa3, 0x22, 0xa4, 0xa8, 0xce, 0x52, 0x88, 0x16, 0x95, 0x4a, 0x62,
	0x35, 0x8b, 0x83, 0x4f, 0xb4, 0x02, 0x1c, 0xa7, 0xc5, 0x27, 0x2f, 0xcd, 0x09, 0x1c, 0xa1, 0x70,
	0xd3, 0x4f, 0x4d, 0x47, 0x3b, 0x3e, 0xa5, 0xbc, 0xc4, 0x2a, 0xbe, 0xe9, 0xa7, 0xa6, 0xb3, 0xf9,
	0x31, 0xc5, 0x29, 0x36, 0xb8, 0x79, 0x4a, 0x59, 0x23, 0x63, 0x5a, 0x27, 0x84, 0x7a, 0x9a, 0x61,
	0xba, 0xa4, 0xe7, 0x0d, 0xce, 0x38, 0xba, 0x2b, 0x38, 0x2f, 0xc8, 0x4d, 0x9f, 0xca, 0x7c, 0x44,
	0xac, 0x9e, 0x6d, 0x98, 0xd6, 0x09, 0xc7, 0xe4, 0x34, 0x0e, 0xbf, 0x67, 0x10, 0xbb, 0x78, 0x5d,
	0xc4, 0xc6, 0x90, 0x0e, 0x10, 0x89, 0x16, 0xdf, 0xe2, 0x61, 0x55, 0x9b, 0x2f, 0xac, 0x02, 0x70,
	0x0b, 0x1a, 0xc0, 0x50, 0x0d, 0x7a, 0x08, 0x29, 0x01, 0x99, 0xb4, 0x58, 0xba, 0x02, 0xce, 0x06,
	0x42, 0xe8, 0x47, 0xa0, 0xce, 0x82, 0x5c, 0xf1, 0xfb, 0xdc, 0x41, 0x8b, 0x33, 0x18, 0x57, 0xfa,
	0x0b, 0x09, 0x94, 0x60, 0x21, 0xa8, 0x0e, 0x4a, 0xb0, 0x08, 0xbf, 0x6f, 0x9d, 0x17, 0x95, 0x43,
	0xb9, 0xe8, 0xda, 0xe3, 0xd7, 0x58, 0x7b, 0xe9, 0x4f, 0xe3, 0xb0, 0xc0, 0x13, 0x0e, 0xdd, 0x07,
	0x99, 0x15, 0x08, 0x7f, 0x25, 0x73, 0xf5, 0x0d, 0x5c, 0x00, 0x21, 0x90, 0x2d, 0x7d, 0x48, 0x38,
	0xac, 0xa7, 0x31, 0xff, 0x8d, 0xbe, 0x07, 0x29, 0x4a, 0x9e, 0x68, 0x4f, 0xf5, 0x41, 0x71, 0x89,
	0xc7, 0x5d, 0x92, 0x92, 0x27, 0x9f, 0xea, 0x03, 0x74, 0x03, 0x92, 0x26, 0xd5, 0x2c, 0xf2, 0xac,
	0xb8, 0x2c, 0x80, 0xc7, 0xa4, 0xbb, 0xe4, 0x19, 0x8b, 0x72, 0x4f, 0x77, 0x4f, 0x88, 0xa7, 0xf5,
	0xec, 0x01, 0x2d, 0xde, 0x60, 0x69, 0xce, 0xda, 0x12, 0x46, 0x6a, 0xd8, 0x03, 0xda, 0x91, 0x95,
	0xb8, 0x9a, 0xe8, 0xc8, 0x4a, 0x42, 0x95, 0x3b, 0xb2, 0x22, 0xab, 0x0b, 0x1d, 0x59, 0x59, 0x50,
	0x93, 0x1d, 0x59, 0x49, 0xaa, 0xa9, 0x8e, 0xac, 0xa4, 0x54, 0xa5, 0x23, 0x2b, 0x8a, 0x9a, 0xee,
	0xc8, 0x4a, 0x5a, 0x85, 0x8e, 0xac, 0x80, 0x9a, 0xe9, 0xc8, 0x4a, 0x46, 0xcd, 0x76, 0x64, 0x25,
	0xab, 0xe6, 0x3a, 0xb2, 0x92, 0x53, 0xf3, 0x1d, 0x59, 0xc9, 0xab, 0x8b, 0x1d, 0x59, 0x59, 0x54,
	0xd5, 0x8e, 0xac, 0xa8, 0x6a, 0xa1, 0x23, 0x2b, 0x05, 0x15, 0x55, 0xbf, 0x8d, 0x43, 0x5e, 0xc4,
	0x4b, 0x88, 0x77, 0x77, 0xa1, 0xc0, 0x13, 0xc5, 0xb4, 0x4e, 0x34, 0xc7, 0x27, 0x72, 0x24, 0x8b,
	0x63, 0x35, 0x18, 0x08, 0x99, 0x7f, 0x08, 0x39, 0x97, 0xe8, 0xc6, 0x84, 0x31, 0xce, 0x19, 0xb3,
	0x8c, 0x18, 0x32, 0xbd, 0x03, 0x79, 0x8e, 0xdb, 0x13, 0xae, 0x04, 0xe7, 0xca, 0x71, 0x6a, 0xc8,
	0xf6, 0x39, 0xe4, 0xa8, 0xa3, 0x5b, 0x13, 0x2e, 0x99, 0xef, 0xec, 0xbd, 0xcb, 0xe3, 0x3c, 0x10,
	0xaf, 0xed, 0x3b, 0xba, 0x15, 0x7c, 0xe0, 0x2c, 0x8d, 0x7c, 0x95, 0x7e, 0x2d, 0x41, 0x36, 0x3a,
	0x8c, 0x3e, 0x84, 0x05, 0x8e, 0xb0, 0x57, 0xd8, 0x75, 0x3f, 0x7f, 0x84, 0x1c, 0xfa, 0x70, 0x76,
	0xad, 0x22, 0x0a, 0x97, 0x67, 0x33, 0x9b, 0xcd, 0xea, 0x4b, 0x4e, 0x2d, 0xa9, 0xda, 0xe5, 0x8d,
	0xfb, 0x68, 0x48, 0x18, 0xc7, 0x23, 0x93, 0x7a, 0xe8, 0x17, 0x90, 0x75, 0x39, 0x45, 0x63, 0x8c,
	0x41, 0xf1, 0xb8, 0x4c, 0x63, 0xc6, 0x0d, 0x35, 0xd0, 0xea, 0x6f, 0x25, 0x58, 0x6a, 0xba, 0xb6,
	0xe3, 0x10, 0xc3, 0x5f, 0xb9, 0xa8, 0x46, 0x41, 0x98, 0x4a, 0x91, 0x30, 0xdd, 0x80, 0x78, 0xbb,
	0xe9, 0x37, 0x00, 0x3f, 0xb9, 0x3a, 0x4a, 0xc7, 0xdb, 0x4d, 0xf4, 0x33, 0x48, 0x52, 0x4f, 0xf7,
	0x46, 0x94, 0xd7, 0x9e, 0xfc, 0xfa, 0xca, 0xab, 0x76, 0x69, 0x9f, 0x73, 0x61, 0x9f, 0xbb, 0xfa,
	0x37, 0x32, 0xdc, 0x10, 0x69, 0xd9, 0xe8, 0xeb, 0xd6, 0x09, 0xd9, 0x6a, 0x04, 0x0b, 0x7d, 0x0c,
	0x29, 0xd3, 0x32, 0xc8, 0x17, 0x61, 0xdd, 0x7c, 0xf0, 0x4a, 0x95, 0x17, 0xc9, 0xd7, 0x7c, 0xe3,
	0xdb, 0x4c, 0x47, 0x70, 0x46, 0xf0, 0x15, 0xa2, 0xc3, 0xb0, 0x24, 0x8b, 0x7d, 0xba, 0x7f, 0x3d,
	0xd5, 0xcd, 0x99, 0xf2, 0x3c, 0x55, 0x00, 0x13, 0xbc, 0x8a, 0xbe, 0xb1, 0x7e, 0xea, 0xcf, 0x25,
	0xc8, 0x46, 0x4d, 0x42, 0xbf, 0x04, 0x85, 0x9b, 0x13, 0x74, 0x85, 0x89, 0xfa, 0x06, 0x2b, 0x5b,
	0x7c, 0x90, 0x4f, 0xb5, 0x7e, 0x95, 0xa9, 0x84, 0x94, 0xef, 0xa1, 0xb6, 0x81, 0xbe, 0x0f, 0x69,
	0xc3, 0xb5, 0x9d, 0xc9, 0x75, 0x40, 0x02, 0x2b, 0x8c, 0xc0, 0x8e, 0x58, 0xa5, 0x27, 0x90, 0x0e,
	0x5d, 0x80, 0xb6, 0x20, 0x1e, 0xae, 0xe0, 0xfe, 0xf9, 0xb8, 0x1c, 0xbf, 0x8e, 0x9d, 0x71, 0xf3,
	0xf2, 0x29, 0xab, 0xff, 0x12, 0x87, 0xa5, 0xe8, 0x66, 0x04, 0x51, 0xf2, 0x29, 0xa8, 0x91, 0x2c,
	0xd1, 0x06, 0x26, 0xf5, 0xfc, 0x3d, 0xbd, 0x7d, 0x49, 0x27, 0x19, 0xc9, 0x33, 0x7f, 0x0b, 0xf3,
	0xee, 0x74, 0xf6, 0x7d, 0x0e, 0x79, 0x43, 0x98, 0xe8, 0x1f, 0x79, 0x38, 0x46, 0x5d, 0xd2, 0xbc,
	0x5d, 0x90, 0x6b, 0xbe, 0xea, 0x9c, 0x11, 0x19, 0xa2, 0xe8, 0x29, 0x2c, 0x05, 0x9a, 0xc3, 0x23,
	0x89, 0x69, 0xf0, 0xa6, 0x2b, 0x57, 0xdf, 0x3c, 0x1f, 0x97, 0x0b, 0xbe, 0xaa, 0xa0, 0xe0, 0x5d,
	0xc7, 0x9f, 0x05, 0x63, 0x46, 0x87, 0xe1, 0x37, 0xb4, 0x37, 0x61, 0x39, 0xea, 0xc6, 0x10, 0x7f,
	0xfe, 0x57, 0x86, 0x9b, 0xd3, 0xc1, 0x1e, 0x82, 0xe3, 0x2f, 0x67, 0x13, 0xf1, 0xe7, 0xf3, 0x65,
	0x4b, 0x88, 0xc4, 0x3c, 0xb8, 0x82, 0xaf, 0xd9, 0x54, 0x7c, 0x3c, 0x93, 0x8a, 0x57, 0x55, 0xce,
	0xbd, 0x3a, 0xa3, 0xdc, 0xd7, 0x58, 0xfa, 0x27, 0x09, 0x72, 0x53, 0x93, 0xff, 0x3f, 0x27, 0xcd,
	0x4e, 0x08, 0x82, 0x71, 0x0e, 0x82, 0x3f, 0xbd, 0xa2, 0x2d, 0xd3, 0xd8, 0x58, 0xfa, 0x5b, 0x09,
	0x72, 0x53, 0xe6, 0xbd, 0xb9, 0x5c, 0x7b, 0xb3, 0x2b, 0xad, 0xde, 0x87, 0xa4, 0xa0, 0x20, 0x04,
	0xf9, 0xcf, 0x36, 0xda, 0x07, 0xed, 0xdd, 0x2d, 0x6d, 0xb3, 0x8b, 0xb5, 0xad, 0x86, 0x1a, 0x43,
	0x59, 0x50, 0x9a, 0xad, 0x47, 0x2d, 0x46, 0x54, 0x25, 0x94, 0x81, 0x14, 0xff, 0x6a, 0x35, 0xd5,
	0x78, 0xb5, 0x0e, 0xaa, 0xd0, 0x7d, 0x4c, 0x58, 0x82, 0xb0, 0x3e, 0x87, 0x1f, 0xae, 0x3d, 0xdd,
	0x23, 0x43, 0x06, 0xa4, 0x0c, 0x0c, 0xb4, 0x48, 0xc1, 0x2a, 0x84, 0x43, 0x0c, 0x16, 0x76, 0xf5,
	0x21, 0xa9, 0xfe, 0xdb, 0x02, 0x14, 0x26, 0x4a, 0x02, 0x60, 0x60, 0x5d, 0xbd, 0x69, 0x9d, 0x6a,
	0x93, 0x6b, 0x49, 0xd1, 0xd5, 0x9b, 0xd6, 0xe9, 0x21, 0x6e, 0xe3, 0x14, 0x1b, 0x3c, 0x74, 0x4d,
	0xb4, 0x05, 0xb2, 0xed, 0x78, 0xaf, 0x6d, 0x2e, 0x5e, 0x9a, 0xa0, 0xd6, 0x75, 0x3c, 0x71, 0xa8,
	0xc5, 0x5c, 0x01, 0xfa, 0x8d, 0x04, 0x29, 0xd1, 0xa9, 0xd1, 0x62, 0x92, 0x2b, 0xfb, 0xd9, 0xfc,
	0xca, 0x84, 0xe9, 0xfe, 0xf5, 0x5a, 0x87, 0x05, 0xf1, 0x77, 0xe3, 0x72, 0x61, 0xd6, 0x35, 0xf4,
	0xea, 0xf7, 0x6e, 0xc1, 0x92, 0xd0, 0x16, 0xe4, 0xa7, 0xbd, 0xca, 0xcf, 0x50, 0xf3, 0xdc, 0xac,
	0xe5, 0xa6, 0x5c, 0xce, 0x42, 0xc7, 0x4f, 0x58, 0x85, 0x5b, 0xf9, 0xd3, 0xab, 0x58, 0xc9, 0xe4,
	0x84, 0xd3, 0x82, 0x1c, 0x35, 0x20, 0x1b, 0x35, 0xfe, 0x82, 0x1b, 0x82, 0x87, 0xd3, 0x37, 0x04,
	0xab, 0xaf, 0x9f, 0x4f, 0x28, 0x8c, 0x5e, 0x0b, 0xdc, 0x87, 0x74, 0xb8, 0x5f, 0xaf, 0xbb, 0x06,
	0x48, 0x47, 0x05, 0xff, 0x18, 0x32, 0x91, 0x55, 0x5f, 0xb0, 0xba, 0xf7, 0xa7, 0x57, 0x37, 0xd7,
	0x81, 0x61, 0xf6, 0x9a, 0x21, 0x6c, 0xeb, 0x17, 0xd4, 0x64, 0xf5, 0xef, 0x25, 0xc8, 0x62, 0x42,
	0xed, 0xc1, 0x53, 0x62, 0xb0, 0x72, 0x84, 0x6a, 0x20, 0xb3, 0xda, 0xe6, 0xf7, 0xa6, 0x97, 0x35,
	0x80, 0x9c, 0x0f, 0x3d, 0x84, 0x74, 0xf8, 0xb0, 0x33, 0xf7, 0x4d, 0xfe, 0x44, 0x84, 0x9d, 0xe3,
	0x8e, 0xec, 0x91, 0x65, 0xe8, 0xee, 0x99, 0xe6, 0x12, 0xbd, 0xd7, 0x27, 0xa2, 0x99, 0x51, 0xf0,
	0x62, 0x40, 0xc7, 0x82, 0x5c, 0x1d, 0x02, 0x9a, 0x78, 0x3d, 0x44, 0xa9, 0x4f, 0x80, 0x55, 0x53,
	0x6e, 0x80, 0xdf, 0xbb, 0x5e, 0x70, 0x26, 0x9b, 0xa9, 0xc8, 0xa1, 0xb9, 0x41, 0xd0, 0xb9, 0x11,
	0x1a, 0xf5, 0x8b, 0xd7, 0xbf, 0xca, 0x80, 0x1a, 0x2e, 0xd1, 0x3d, 0xc2, 0xd0, 0x86, 0x5e, 0xd6,
	0xd2, 0x86, 0x1d, 0x7d, 0xfc, 0x9a, 0x1d, 0xfd, 0x1f, 0x41, 0xb6, 0x67, 0x0f, 0x46, 0x43, 0xd1,
	0x53, 0x04, 0xe5, 0x7f, 0xfd, 0x95, 0xc1, 0xf7, 0xd2, 0xb2, 0x6a, 0x0d, 0x7b, 0x10, 0x69, 0x30,
	0x32, 0x42, 0x1b, 0xa3, 0x50, 0x74, 0x0b, 0xd2, 0x61, 0x52, 0xf1, 0xca, 0x9f, 0xc6, 0x13, 0x02,
	0x5a, 0x83, 0x05, 0x9d, 0x6a, 0xf6, 0x31, 0xbf, 0x60, 0xb9, 0x74, 0xf3, 0xb0, 0xac, 0xd3, 0xee,
	0x31, 0xba, 0x07, 0xb9, 0xe3, 0x27, 0xa2, 0x4f, 0x11, 0x58, 0x29, 0xae, 0xab, 0x17, 0xcf, 0xc7,
	0xe5, 0xcc, 0xe6, 0x27, 0xdc, 0x4c, 0x86, 0x94, 0x38, 0x73, 0xfc, 0x24, 0xfc, 0x40, 0x77, 0xa0,
	0x30, 0xd4, 0xbf, 0xd0, 0x8e, 0x5d, 0xbd, 0xe7, 0x99, 0xb6, 0xa5, 0x99, 0xc6, 0x40, 0x60, 0x82,
	0x84, 0x17, 0x87, 0xfa, 0x17, 0x9b, 0x3e, 0xbd, 0x6d, 0x0c, 0x48, 0xe9, 0x6b, 0x09, 0x52, 0xbe,
	0x39, 0x68, 0x0f, 0x12, 0xa6, 0x21, 0x5a, 0x81, 0x5c, 0xfd, 0xe1, 0xf9, 0xb8, 0x9c, 0x68, 0x37,
	0xe9, 0x77, 0xe3, 0xf2, 0xbd, 0x2b, 0x00, 0x53, 0x83, 0xfb, 0xa2, 0xdd, 0xc4, 0x4c, 0x15, 0x3b,
	0x34, 0xf6, 0x75, 0xaa, 0xf5, 0x4d, 0xea, 0xd9, 0x27, 0xae, 0x3e, 0xf4, 0x2f, 0xe3, 0xb2, 0x7d,
	0x9d, 0x6e, 0x07, 0x34, 0x54, 0x62, 0x95, 0xfb, 0x29, 0x71, 0xbd, 0x30, 0x1a, 0xc3, 0x6f, 0xb4,
	0x0e, 0x37, 0x42, 0x61, 0x8d, 0x19, 0x75, 0x34, 0xea, 0x9d, 0x12, 0x0e, 0xea, 0x2c, 0x4f, 0x97,
	0xc2, 0xc1, 0x1d, 0xfd, 0x8b, 0xba, 0x18, 0xaa, 0xde, 0x80, 0xa5, 0xc8, 0x9e, 0x85, 0x7d, 0xd0,
	0xff, 0xa4, 0x20, 0xb5, 0xa7, 0x9f, 0x0d, 0x6c, 0xdd, 0x40, 0x15, 0xc8, 0x04, 0x77, 0xee, 0xa6,
	0x6d, 0xf9, 0xe1, 0x15, 0x25, 0xb1, 0x45, 0x8d, 0x28, 0x71, 0xb9, 0xcf, 0x05, 0x74, 0x84, 0xdf,
	0xec, 0x94, 0xcb, 0x1f, 0xd7, 0x88, 0xa1, 0x0d, 0xcd, 0x9e, 0x6b, 0x8b, 0x93, 0x51, 0x82, 0xc3,
	0x29, 0xa3, 0xee, 0x70, 0x22, 0x7a, 0x17, 0x16, 0x8f, 0x4d, 0xcb, 0xa4, 0xfd, 0x09, 0x1f, 0xbf,
	0x7f, 0xc3, 0xf9, 0x80, 0xec, 0x33, 0x9a, 0x90, 0x8f, 0x3c, 0x30, 0xb0, 0x2d, 0x48, 0xf2, 0x2d,
	0xa8, 0x9f, 0x8f, 0xcb, 0xb9, 0x49, 0x14, 0x8b, 0xcd, 0xb8, 0xea, 0xeb, 0xcc, 0x44, 0x73, 0xdb,
	0xa0, 0xfc, 0xa1, 0xd6, 0x75, 0x6d, 0x97, 0x3f, 0x77, 0xa5, 0xb1, 0xf8, 0x40, 0xf7, 0x60, 0x61,
	0x40, 0x74, 0x4a, 0xfc, 0xd7, 0xad, 0x1f, 0xbc, 0x2a, 0x15, 0xf8, 0x13, 0x32, 0x16, 0xbc, 0xe8,
	0x43, 0x48, 0x8a, 0x4b, 0x3a, 0x7e, 0xb5, 0x16, 0xb9, 0xeb, 0x9a, 0x95, 0x9a, 0x7a, 0xfc, 0xdd,
	0x8e, 0x61, 0x5f, 0x0c, 0xd5, 0x21, 0xe5, 0xdf, 0xaf, 0xf3, 0xdb, 0xb6, 0xcb, 0xfb, 0xfa, 0xc8,
	0x0d, 0xf1, 0x76, 0x0c, 0x07, 0x82, 0xe8, 0x93, 0xe0, 0x19, 0x41, 0x80, 0x95, 0xff, 0x50, 0x72,
	0x77, 0x9e, 0x9e, 0x67, 0xa2, 0x6d, 0x4a, 0x05, 0xb3, 0xcb, 0xe4, 0xf7, 0x0d, 0xfc, 0xb5, 0xe4,
	0x12, 0xbb, 0xa6, 0x6e, 0xdf, 0x98, 0x5d, 0x42, 0x0c, 0x7d, 0x0c, 0xd0, 0x0b, 0xa1, 0xb3, 0x98,
	0xe7, 0x4a, 0x7e, 0x34, 0x77, 0x29, 0xdd, 0x8e, 0xe1, 0x88, 0x38, 0xda, 0x85, 0x4c, 0x6f, 0x12,
	0xcc, 0xc5, 0x45, 0xae, 0xed, 0xce, 0xfc, 0x58, 0xb5, 0xcd, 0xf0, 0x69, 0x42, 0x9d, 0xc6, 0x27,
	0x75, 0x16, 0x9f, 0xde, 0x07, 0xd9, 0x18, 0x0d, 0x1d, 0xfe, 0xdc, 0x31, 0x03, 0xad, 0x53, 0x27,
	0xa2, 0xc9, 0xeb, 0xf4, 0x76, 0x0c, 0x73, 0x11, 0xf4, 0x19, 0xe4, 0xe9, 0x54, 0x47, 0xc9, 0xaf,
	0xcb, 0x32, 0xeb, 0xef, 0x5d, 0xe9, 0x00, 0xbe, 0x1d, 0xc3, 0x33, 0x6a, 0xd0, 0xdb, 0x90, 0xb3,
	0x6c, 0xab, 0xa7, 0x5b, 0x3d, 0x32, 0xe0, 0xb8, 0x2f, 0xee, 0xd5, 0xa6, 0x89, 0xf5, 0x34, 0xa4,
	0x0c, 0xa1, 0x22, 0xbc, 0x37, 0x4b, 0xa9, 0x4a, 0xf5, 0x1f, 0x92, 0xa0, 0x84, 0xd5, 0x6b, 0x0d,
	0x50, 0x88, 0x89, 0x93, 0xc7, 0x1a, 0x96, 0xfc, 0xf1, 0xed, 0x18, 0x2e, 0x04, 0x63, 0xe1, 0x7b,
	0x0d, 0xcb, 0xe0, 0xa1, 0x6d, 0x98, 0xc7, 0xe6, 0x24, 0x83, 0xc5, 0xe9, 0x35, 0x1f, 0x90, 0xfd,
	0x0c, 0xfe, 0x60, 0xea, 0xe5, 0x20, 0xf1, 0x3a, 0x70, 0xdf, 0x8e, 0x45, 0xde, 0x15, 0x18, 0x9c,
	0xb8, 0x23, 0xcb, 0x32, 0xad, 0x13, 0xcd, 0xef, 0xdc, 0x45, 0xdd, 0xc8, 0xf9, 0x54, 0xbf, 0xff,
	0xfe, 0x68, 0x26, 0xdf, 0x6e, 0x5f, 0x9e, 0x6f, 0x81, 0xd5, 0xdb, 0x52, 0x98, 0x70, 0x8d, 0xd9,
	0x84, 0x7b, 0xf7, 0x35, 0x09, 0x17, 0xd1, 0x11, 0x66, 0x1c, 0xbe, 0x30, 0xe3, 0x7e, 0x3c, 0xcf,
	0x2e, 0x47, 0xd4, 0x4d, 0xa7, 0xdc, 0x47, 0x33, 0x29, 0x77, 0x7b, 0xbe, 0x8b, 0x40, 0x66, 0x9a,
	0x9f, 0x73, 0x8f, 0x2e, 0xc8, 0xb9, 0x3b, 0xaf, 0xcf, 0xb9, 0x88, 0xa6, 0x68, 0xd2, 0x75, 0x2f,
	0x4a, 0xba, 0xbb, 0x73, 0x24, 0x5d, 0x44, 0xdf, 0x54, 0xd6, 0x3d, 0x98, 0xca, 0xab, 0xb7, 0x2f,
	0xcb, 0xab, 0x88, 0x0a, 0x91, 0x58, 0x9f, 0xbf, 0x94, 0x58, 0x4b, 0x5c, 0x4b, 0xed, 0x6a, 0x07,
	0xbb, 0x6d, 0x69, 0x36, 0xb3, 0xea, 0x00, 0x4a, 0x70, 0xab, 0x19, 0xc9, 0x9f, 0x3b, 0x9f, 0x47,
	0x8f, 0x7c, 0x4d, 0xbc, 0xd1, 0xde, 0x65, 0x67, 0xbe, 0xdd, 0x8d, 0x9d, 0xd6, 0xbe, 0x1a, 0x43,
	0x45, 0x58, 0x66, 0xc7, 0x40, 0xff, 0x0c, 0xa8, 0xb5, 0x77, 0x0f, 0x5a, 0xf8, 0xd3, 0x8d, 0x47,
	0xaa, 0x84, 0x6e, 0x02, 0xc2, 0xdd, 0xc6, 0xc7, 0xfb, 0xcd, 0xba, 0xd6, 0xe8, 0xee, 0xec, 0x6d,
	0x34, 0x0e, 0xda, 0xdd, 0x5d, 0x35, 0x8e, 0x14, 0x90, 0x9b, 0xdd, 0xdd, 0x96, 0x0a, 0x77, 0xbe,
	0x8d, 0x83, 0x7c, 0x70, 0xe6, 0x10, 0xf4, 0x36, 0x64, 0x0e, 0x77, 0xf7, 0xf7, 0x5a, 0x8d, 0xf6,
	0x66, 0xbb, 0xd5, 0x54, 0x63, 0xa5, 0xa5, 0xe7, 0x2f, 0x2a, 0x8b, 0x6c, 0xe8, 0xd0, 0xa2, 0x0e,
	0xe9, 0xf1, 0xdc, 0x42, 0x25, 0x48, 0xd6, 0x37, 0x1a, 0x1f, 0x1f, 0xee, 0xa9, 0x52, 0x29, 0xff,
	0xfc, 0x45, 0x05, 0x18, 0x83, 0x88, 0x6e, 0x74, 0x0b, 0x52, 0xb8, 0xb5, 0x7f, 0xd0, 0xc5, 0x2d,
	0x35, 0x5e, 0x5a, 0x7c, 0xfe, 0xa2, 0x92, 0x61, 0x83, 0x7e, 0xdc, 0xa2, 0x77, 0x21, 0xb7, 0xdf,
	0xd8, 0x6e, 0xed, 0x6c, 0x68, 0x8d, 0xed, 0x8d, 0xdd, 0xad, 0x96, 0x9a, 0x28, 0x2d, 0x3f, 0x7f,
	0x51, 0x51, 0x19, 0x4f, 0xd4, 0x3d, 0x6c, 0x8a, 0xf6, 0xce, 0x5e, 0x17, 0x1f, 0xa8, 0xf2, 0x64,
	0x0a, 0x11, 0x65, 0xa8, 0x0a, 0x20, 0xa4, 0x37, 0x5b, 0xad, 0xa6, 0xba, 0x50, 0x42, 0xcf, 0x5f,
	0x54, 0xf2, 0x6c, 0x7c, 0x12, 0x3f, 0xe8, 0x1d, 0xc8, 0x36, 0x70, 0x6b, 0xe3, 0xa0, 0xa5, 0xed,
	0x1f, 0x6c, 0x1c, 0xec, 0xab, 0xc9, 0x89, 0x25, 0x91, 0xb0, 0x40, 0x35, 0x28, 0x6c, 0x1c, 0x1e,
	0x74, 0xb5, 0x29, 0xde, 0x54, 0xe9, 0x7b, 0xcf, 0x5f, 0x54, 0x96, 0x18, 0xef, 0xc6, 0xc8, 0xb3,
	0xa3, 0xfc, 0x37, 0x41, 0x6e, 0x1e, 0xee, 0xec, 0xa9, 0x4a, 0x29, 0xfb, 0xfc, 0x45, 0x45, 0x61,
	0x2c, 0x2c, 0x36, 0xd0, 0x8f, 0x41, 0x9d, 0xb2, 0x8b, 0x9d, 0xc2, 0xd3, 0xa5, 0x9b, 0xcf, 0x5f,
	0x54, 0xd0, 0xac, 0x69, 0x5b, 0x8d, 0x92, 0xf2, 0x67, 0x7f, 0xbd, 0x12, 0xfb, 0xbb, 0xdf, 0xae,
	0xc4, 0xea, 0xab, 0x5f, 0xfd, 0xd7, 0x4a, 0xec, 0xab, 0xf3, 0x15, 0xe9, 0xeb, 0xf3, 0x15, 0xe9,
	0x77, 0xe7, 0x2b, 0xd2, 0x7f, 0x9e, 0xaf, 0x48, 0xbf, 0xfe, 0x66, 0x25, 0xf6, 0xf5, 0x37, 0x2b,
	0xb1, 0xdf, 0x7d, 0xb3, 0x12, 0x7b, 0x9c, 0x14, 0xc1, 0x73, 0x94, 0xe4, 0xff, 0x5f, 0xec, 0xde,
	0xff, 0x05, 0x00, 0x00, 0xff, 0xff, 0x64, 0xad, 0x99, 0xbc, 0xf0, 0x26, 0x00, 0x00,
}
