# LogicTest: local-opt

# use defaultdb, for test
statement ok
use defaultdb

#-------测试内容------#
#-1、支持的数据类型
#-2、begin end中执行各类型语句测试
#-3、报错SQL测试
#-4、回滚测试
#-5、 user、role、权限操作
#-6、视图操作
#-7、索引操作
#-8、队列操作
#-9、对其他存储过程进行操作 重命名
#-10、其他set和reset
#-11、RESET（会话变量）（不支持）
#-12、case when结构测试
#-13、PG另一种case when语法
#-14、约束问题测试
#-15、IF结构测试
#-16、LOOP、while、for、foreach循环结构测试
#-17、赋值测试
#-18、运算符测试
#-19、数据类型赋值测试
#-20、存储过程名后定义参数测试
#-21、事务-commit测试
#-22、constant静态参数测试
#-23、位置参数测试
#-24、alias别名测试
#-25、变量约束测试
#-26、游标测试
#-27、动态SQL测试
#-28、function创建测试——不支持
#-29、关键字测试
#-30、快照创建和删除测试（不支持）
#-31、大小写问题测试
#-32、schema测试
#-33、数据类型支持测试
#-34、DDL和DML测试
#-35、补充：大数据量
#-------------------#


#支持的数据类型用例#
statement ok
CREATE OR REPLACE PROCEDURE pg_count()
AS $$
DECLARE
p1 INT;
p2 SMALLINT;
p3 BIGINT;
p4 INTEGER;
p5 INT2;
p6 INT4;
p7 INT8;
p8 INT64;
p15 FLOAT;
p16 REAL;
p17 DOUBLE PRECISION;
p18 FLOAT4;
p19 FLOAT8;
p20 DECIMAL;
p21 DEC;
p22 NUMERIC;
p23 BOOL;
p24 BOOLEAN;
p25 BIT;
p26 BIT(3);
p27 VARBIT;
p28 VARBIT(3);
p31 BYTEA;
p32 STRING;
p33 CHARACTER;
p34 CHAR;
p35 VARCHAR;
p36 TEXT;
p37 STRING(5);
p38 CHARACTER(5);
p39 CHARACTER VARYING(5);
p40 CHAR(5);
p41 CHAR VARYING(5);
p42 VARCHAR(5);
p45 DATE;
p46 TIME;
p47 TIMESTAMP;
p48 TIMESTAMPTZ;
p49 TIMESTAMP WITHOUT TIME ZONE;
p50 TIMESTAMP WITH TIME ZONE;
p51 INTERVAL;
p52 INET;
p53 UUID;
p54 JSONB;
p55 JSON;
p56 INT ARRAY;
p57 INT[];
p58 STRING ARRAY;
BEGIN
    NULL;
END
$$ LANGUAGE plpgsql;

statement ok
CREATE OR REPLACE PROCEDURE pg_count()
AS $$
DECLARE
p29 BYTES;
p59 STRING[];
BEGIN
    NULL;
END
$$ LANGUAGE plpgsql;

#---准备操作---#
statement ok
create table test(a int,b int);

statement ok
create database proc1;

# begin end中执行各类型语句测试
#1、DDL（database的应正常报错，其他应可执行）
#1.1 database操作

statement ok
CREATE OR REPLACE PROCEDURE test_proc() AS $$
BEGIN
    create DATABASE proc1;
END
$$ LANGUAGE plpgsql;

#-- CREATE DATABASE IF NOT EXISTS语法
statement error pq: ZNBase PLSQL ERMSG: invalid syntax: syntax error at or near "if"\nDETAIL:source SQL:\ncreate DATABASE proc1 IF NOT EXISTS\n                      \^
CREATE OR REPLACE PROCEDURE test_proc() AS $$
    BEGIN
        create DATABASE proc1 IF NOT EXISTS;
    END
$$ LANGUAGE plpgsql;

statement ok
CREATE OR REPLACE PROCEDURE test_proc() AS $$
    BEGIN
        create DATABASE IF NOT EXISTS proc2;
    END
$$ LANGUAGE plpgsql;

statement error pq: ZNBase PLSQL ERMSG: XXOOO:CREATE DATABASE cannot be executed from a function
call test_proc()

statement ok
CREATE OR REPLACE PROCEDURE test_proc() AS $$
BEGIN
    drop DATABASE proc1;
END
$$ LANGUAGE plpgsql;

statement ok
call test_proc();

#1.2 table操作#
statement ok
create database proc;

statement ok
CREATE OR REPLACE PROCEDURE test_proc() AS $$
BEGIN
    CREATE TABLE proc.tb1(a int primary key,b varchar);
    alter table tb1 rename to tbtb1;
    drop table tbtb1;
END
$$ LANGUAGE plpgsql;

statement ok
CREATE OR REPLACE PROCEDURE test_proc() AS $$
BEGIN
    create table t1 as select * from test;
END
$$ LANGUAGE plpgsql;

#报错SQL测试
statement ok
CREATE OR REPLACE PROCEDURE test_proc() AS $$
BEGIN
    create table a(a int);
    create table a(a int);
END
$$ LANGUAGE plpgsql;

statement error pq: ZNBase PLSQL ERMSG: 42P07:relation "a" already exists
call test_proc();

query TT
SHOW TABLES;
----
test root

#2、 DML（除select外应全部正常执行）
statement ok
CREATE OR REPLACE PROCEDURE test_proc() AS $$
BEGIN
    insert into test values(1,2),(3,4);
    update test set a=5 where a=1 or a=2;
    delete from test where b=2;
    truncate test;
END
$$ LANGUAGE plpgsql;

statement ok
CREATE OR REPLACE PROCEDURE test_proc() AS $$
    BEGIN
        select * from test;
    END
$$ LANGUAGE plpgsql;

statement error pq: ZNBase PLSQL ERMSG: query has no destination for result data
call test_proc();

#回滚测试
statement ok
CREATE OR REPLACE PROCEDURE test_proc() AS $$
BEGIN
    insert into test values(1,2);
    insert into test values(1,2,3);
END
$$ LANGUAGE plpgsql;

statement error pq: ZNBase PLSQL ERMSG: 42601:INSERT has more expressions than target columns, 3 expressions for 2 targets
call test_proc();

query II
select * from test;
----


#-- DDL
statement ok
CREATE OR REPLACE PROCEDURE test_proc() AS $$
BEGIN
    create table tt(a INT);
    create table tt(a INT);
END
$$ LANGUAGE plpgsql;

statement error pq: ZNBase PLSQL ERMSG: 42P07:relation "tt" already exists
call test_proc();


#带drdb内置函数的语句#
statement ok
CREATE OR REPLACE PROCEDURE test_proc() AS $$
BEGIN
    insert into test values(mod(23,3),abs(-100));
END
$$ LANGUAGE plpgsql;

statement ok
call test_proc();

query II
select * from test;
----
2   100

#3、 user、role、权限操作

statement ok
CREATE OR REPLACE PROCEDURE test_proc() AS $$
BEGIN
    create user u1;
    grant usage on database defaultdb to u1 with grant option;
    grant all on database defaultdb to u1;
    revoke grant option for usage on database defaultdb from u1;
    revoke all on database defaultdb from u1;
    create role role1;
    grant role1 to u1 with admin option;
   grant all on database defaultdb to role1;
   revoke admin option for role1 from u1;
   revoke role1 from u1;
   revoke all on database defaultdb from role1;
   drop user u1;
   drop role role1;
END
$$ LANGUAGE plpgsql;

#下列语句 原u1被root代替  jira-6106
statement error pq: ZNBase PLSQL ERMSG: can not use SHOW in procedure/function
CREATE OR REPLACE PROCEDURE test_proc() AS $$
BEGIN
    show grants on database defaultdb for root;
END
$$ LANGUAGE plpgsql;

#4、视图操作
statement ok
create table t1(a int);


statement ok
CREATE OR REPLACE PROCEDURE test_proc() as $$
BEGIN
    create view v1 as select a from t1;
    alter view v1 rename to v1v1;
    drop view v1v1;
END
$$ language plpgsql;


#5、索引操作
statement ok
create table tb1(a int,b int);

statement ok
CREATE OR REPLACE PROCEDURE test_proc() as $$
BEGIN
    create index index1 on tb1(a);
    ALTER INDEX index1 RENAME TO index_rename;
    drop index index_rename;
END
$$ language plpgsql;


#6、队列操作
statement ok
CREATE OR REPLACE PROCEDURE test_proc() as $$
BEGIN
    CREATE SEQUENCE sequence_seq START -1 INCREMENT -2;
    ALTER SEQUENCE sequence_seq INCREMENT 2;
    DROP SEQUENCE sequence_seq;
END
$$ language plpgsql;

#7、对其他存储过程进行操作 重命名
statement ok
CREATE OR REPLACE PROCEDURE test_proc() as $$
BEGIN
    ALTER PROCEDURE test_proc() RENAME TO test_pppp;
END
$$ language plpgsql;

statement ok
call test_proc();

statement error pq: No function/procedure matches the given name and argument types.
call test_proc();

#删除
statement ok
CREATE OR REPLACE PROCEDURE test_proc() as $$
BEGIN
    drop procedure test_proc();
END
$$ language plpgsql;

statement ok
call test_proc();

statement error pq: No function/procedure matches the given name and argument types.
call test_proc();


#创建：（不支持）
statement error pq: ZNBase PLSQL ERMSG: invalid syntax: syntax error at or near "\$"\nDETAIL:source SQL:\nCREATE PROCEDURE test1\(\) as \$a\$ BEGIN NULL\n                            \^\nHINT:try \\h CREATE
CREATE OR REPLACE PROCEDURE test_proc() as $$
BEGIN
    CREATE PROCEDURE test1() as $a$ BEGIN NULL; END $a$ language plpgsql;
END
$$ language plpgsql;

#调用其他存储过程：（不支持）

statement ok
CREATE OR REPLACE PROCEDURE test_proc() as $$
BEGIN
    insert into test values(1);
END
$$ language plpgsql;

statement ok
CREATE OR REPLACE PROCEDURE test_proc2() as $$
BEGIN
    call test_proc();
END
$$ language plpgsql;

statement ok
call test_proc2();

query II
select * from test
----
2   100
1   NULL

#8、其他
#设置cluster setting（不支持)

statement ok
CREATE OR REPLACE PROCEDURE test_proc() as $$
BEGIN
SET CLUSTER SETTING kv.transaction.write_pipelining_max_batch_size=1024;
END
$$ language plpgsql;

#其他设置（不支持）
statement ok
CREATE OR REPLACE PROCEDURE test_proc() as $$
BEGIN
set sql_safe_updates=false;
END
$$ language plpgsql;

#创建统计信息
statement ok
CREATE OR REPLACE PROCEDURE test_proc() as $$
BEGIN
    CREATE STATISTICS kvalues ON a FROM test;
END
$$ language plpgsql;

statement ok
call test_proc();



#RESET（会话变量）（不支持）
statement ok
CREATE OR REPLACE PROCEDURE test_proc() as $$
BEGIN
    RESET extra_float_digits;
END
$$ language plpgsql;

statement ok
create table test_data(r INT);

statement ok
create or replace procedure pg_count(aa int)
as $$
DECLARE
result int;
cursor1 CURSOR for select a from test;
BEGIN
open cursor1;
loop
fetch cursor1 into result;
exit when not found;
insert into test_data values (result);
end loop;
END
$$ LANGUAGE plpgsql;

statement ok
call pg_count(1);

statement ok
call pg_count(1);

#case when结构测试
statement ok
CREATE OR REPLACE PROCEDURE test_proc() as $$
DECLARE
x int;
BEGIN
x=1;
CASE x
    WHEN 1, 2 THEN
        insert into test values(1);
    ELSE
        insert into test values(2);
END CASE;
END
$$ language plpgsql;

statement ok
truncate test;

statement ok
call test_proc();

query II
select * from test;
----
1   NULL


#PG另一种case when语法
statement ok
create table t(c1 varchar);

statement ok
CREATE OR REPLACE PROCEDURE test_proc() as $$
DECLARE
x int;
msg varchar;
BEGIN
x=1;
CASE
    WHEN x BETWEEN 0 AND 10 THEN
        msg := 'value is between zero and ten';
    WHEN x BETWEEN 11 AND 20 THEN
        msg := 'value is between eleven and twenty';
END CASE;
insert into t values(msg);
END
$$ language plpgsql;

statement ok
call test_proc();

query T
select * from t;
----
value is between zero and ten

#约束问题测试
statement ok
CREATE OR REPLACE PROCEDURE test_proc() AS $$
BEGIN
    CREATE DATABASE IF NOT EXISTS proc2;
END
$$ LANGUAGE plpgsql;

statement error pq: ZNBase PLSQL ERMSG: XXOOO:CREATE DATABASE cannot be executed from a function
call test_proc();

statement ok
CREATE OR REPLACE PROCEDURE test_proc() AS $$
BEGIN
    CREATE DATABASE proc2;
END
$$ LANGUAGE plpgsql;

statement error pq: ZNBase PLSQL ERMSG: XXOOO:CREATE DATABASE cannot be executed from a function
CALL test_proc();

statement error pq: database "proc" already exists
create database proc;

statement ok
create table proc.customers(id INT primary key);

#--以下语法均可识别触发
statement ok
CREATE TABLE proc.tb1(a int primary key,b varchar);

statement ok
CREATE TABLE proc.tb2(a int,b varchar,primary key(a));

statement ok
CREATE TABLE proc.tb3(a int,b varchar,primary key(a,b));

statement ok
CREATE TABLE proc.tb4(a int primary key,b varchar,c int check(c>10));

statement ok
CREATE TABLE proc.tb5(a int default 100,b varchar);

statement ok
CREATE TABLE proc.tb6(a int default 100,b varchar);

statement ok
CREATE TABLE proc.tb7(a int not null,b varchar);

statement ok
CREATE TABLE proc.tb8(a int unique,b varchar);

statement ok
CREATE TABLE proc.tb9(a int primary key,b varchar,CONSTRAINT c1 CHECK (a > 0 AND a BETWEEN 100 AND 200));

statement ok
CREATE TABLE proc.tb10(id INT PRIMARY KEY,b INT NOT NULL REFERENCES proc.customers (id) ON DELETE CASCADE);

statement ok
CREATE TABLE proc.tb11(id INT PRIMARY KEY, name varchar, INDEX id(id));

statement ok
CREATE TABLE proc.tb12(id INT PRIMARY KEY,name varchar,FAMILY "primary" (id, name));

statement ok
CREATE OR REPLACE PROCEDURE test_proc() AS $$
BEGIN
CREATE TABLE proc.tb13 (a INT, b INT, c INT, PRIMARY KEY (a, b))
    PARTITION BY LIST (a) (
        PARTITION p1 VALUES IN (1),
        PARTITION p2 VALUES IN (default)
    );
END
$$ LANGUAGE plpgsql;

statement ok
CREATE OR REPLACE PROCEDURE test_proc() AS $$
BEGIN
CREATE TABLE test (a INT, b INT);
ALTER TABLE test PARTITION BY range(rowid)(partition p1 values from (minvalue) to  (maxvalue));
END
$$ LANGUAGE plpgsql;

##IF结构测试
statement ok
drop table t1;

statement ok
create table t1(a INT);

statement ok
CREATE OR REPLACE PROCEDURE doifelse(c INT) AS $$
BEGIN
    IF c=1 THEN
        INSERT INTO t1 VALUES (1111);
    ELSIF c=2 THEN
        INSERT INTO t1 VALUES (2222);
    ELSE
        IF c=3 THEN
            INSERT INTO t1 VALUES (3333);
        ELSE
            INSERT INTO t1 VALUES (7777);
        END IF;
    END IF;
END
$$ LANGUAGE plpgsql;

statement ok
call doifelse(1);

statement ok
call doifelse(2);

statement ok
call doifelse(3);

statement ok
call doifelse(4);

query I
select * from t1;
----
  1111
  2222
  3333
  7777


##LOOP循环结构测试

statement ok
CREATE OR REPLACE PROCEDURE test_proc() as $$
DECLARE
count int;
BEGIN
count=1;
LOOP
    insert into test values(count);
    IF count > 5 THEN
        EXIT;
    END IF;
    count=count+1;
END LOOP;
END
$$ language plpgsql;

#LOOP无限循环测试
statement ok
CREATE OR REPLACE PROCEDURE test_proc2() as $$
BEGIN
LOOP
    insert into test values(1);
END LOOP;
END
$$ language plpgsql;

statement ok
call test_proc();

statement ok
CREATE OR REPLACE PROCEDURE test_proc() as $$
DECLARE
count int;
BEGIN
count=1;
LOOP
    insert into test values(count);
    count = count - 1;
    EXIT WHEN count = 0;
END LOOP;
END
$$ language plpgsql;

#运行正确的语句
statement ok
call test_proc();

#为变量赋值测试
statement ok
CREATE OR REPLACE PROCEDURE test_proc2() as $$
DECLARE
var int;
BEGIN
var=1;
insert into test values(var);
END
$$ language plpgsql;


#WHILE循环测试

statement ok
 CREATE OR REPLACE PROCEDURE test_proc() as $$
 DECLARE
 var int;
 BEGIN
 var=10;
 WHILE var>0 AND var<100 LOOP
     var=var+20;
     insert into test values(1);
 END LOOP;
 END
 $$ language plpgsql;


#while无限循环测试
statement ok
CREATE OR REPLACE PROCEDURE test_proc12() as $$
BEGIN
WHILE NOT done LOOP
   insert into test values(1);
END LOOP;
END
$$ language plpgsql;

statement error pq: ZNBase PLSQL ERMSG: XXOOO:column "done" does not exist
call test_proc12();

# 此用例为死循环，不执行
# CREATE OR REPLACE PROCEDURE test_proc() as $$
# BEGIN
#     WHILE 1 LOOP
#         insert into test values(1);
#     END LOOP;
# END
# $$ language plpgsql;

# 此用例为死循环，不执行
# statement ok
# CREATE OR REPLACE PROCEDURE test_proc() as $$
# BEGIN
#     WHILE 1>0 LOOP
#         insert into test values(1);
#     END LOOP;
# END
# $$ language plpgsql;
#
# statement ok
# call test_proc();

#for循环测试
statement ok
CREATE OR REPLACE PROCEDURE test_proc() as $$
  BEGIN
  FOR i IN 1..10 LOOP
      insert into test values(i);
  END LOOP;
  END
  $$ language plpgsql;

statement ok
CREATE OR REPLACE PROCEDURE test_proc() as $$
  BEGIN
  FOR i IN REVERSE 10..1 BY 2 LOOP
      insert into test values(i);
  END LOOP;
  END
  $$ language plpgsql;

statement error pq: ZNBase PLSQL ERMSG: unrecognized exception condition "notice"
CREATE OR REPLACE PROCEDURE test_proc() as $$
DECLARE
    x int;
    y int;
BEGIN
    x := x + 1;
    y := x / 0;
EXCEPTION
    WHEN division_by_zero THEN
        RAISE NOTICE 'caught division_by_zero';
END;
$$ language plpgsql;

statement ok
drop procedure test_proc()

statement error pq: ZNBase PLSQL ERMSG: unrecognized exception condition "notice"
CREATE OR REPLACE PROCEDURE test_proc() as $$
  DECLARE
  x int;
  y int;
  BEGIN
      x := 1;
      y := x / 0;
      RAISE NOTICE 'caught division_by_zero';
  END;
$$ language plpgsql;

statement ok
drop procedure if exists test_proc()

#:=赋值测试
statement ok
CREATE OR REPLACE PROCEDURE test_proc() as $$
   DECLARE
   var int;
   BEGIN
   var := 0.006;
       insert into test values(var);
   END
   $$ language plpgsql;

#运算符测试
statement ok
CREATE OR REPLACE PROCEDURE test_proc() as $$
    DECLARE
    var int;
    BEGIN
    var=10;
    insert into test values(var);
    var=10+10;
    insert into test values(var);
    var=10*10;
    insert into test values(var);
    var=20-10;
    insert into test values(var);
    var=3%2;
        insert into test values(var);
    var=3^2;
        insert into test values(var);
    END
    $$ language plpgsql;

statement ok
CREATE OR REPLACE PROCEDURE test_proc() as $$
DECLARE
var int;
BEGIN
var=10;
insert into test values(var);
insert into test values(var+10);
END
$$ language plpgsql;

#数据类型赋值测试
statement ok
 CREATE OR REPLACE PROCEDURE test_proc() as $$
 DECLARE
 var int;
 BEGIN
 var := 0.003;
     insert into test values(var);
 var = 'test';
     insert into test values(var);
 var = '';
     insert into test values(var);
 END
 $$ language plpgsql;

statement error pq: ZNBase PLSQL ERMSG: XXOOO:cannot cast '' to type INT8\nDETAIL: cannot parse "" as decimal
call test_proc();

#比较运算测试（>= <= = > <）
statement ok
CREATE OR REPLACE PROCEDURE test_proc(c INT) AS $$
 BEGIN
     IF c>=1 THEN
         IF c=50 or c=10 THEN
             INSERT INTO t1 VALUES (1111);
         ELSE
             INSERT INTO t1 VALUES (7777);
         END IF;
     ELSE
         INSERT INTO t1 VALUES (3333);
     END IF;
 END
$$ LANGUAGE plpgsql;

statement ok
CREATE OR REPLACE PROCEDURE test_proc(c INT) AS $$
BEGIN
    IF c=1 or c=2 THEN
        INSERT INTO t1 VALUES (1111);
    ELSE
        INSERT INTO t1 VALUES (2222);
    END IF;
END
$$ LANGUAGE plpgsql;

statement ok
CREATE OR REPLACE PROCEDURE test_proc(c INT) AS $$
BEGIN
    IF c>=20 and c<25 THEN
        INSERT INTO t1 VALUES (1111);
    ELSE
        INSERT INTO t1 VALUES (2222);
    END IF;
END
$$ LANGUAGE plpgsql;


#不等于号测试
statement ok
 CREATE OR REPLACE PROCEDURE test_proc(c INT) AS $$
 BEGIN
     IF c!=1 THEN
             INSERT INTO t1 VALUES (1111);
     END IF;
 END
 $$ LANGUAGE plpgsql;


#is not null测试
statement ok
CREATE OR REPLACE PROCEDURE test_proc(c INT) AS $$
  BEGIN
    IF c>=20 and c is not null THEN
        INSERT INTO t1 VALUES (1111);
    ELSE
        INSERT INTO t1 VALUES (2222);
    END IF;
END
$$ LANGUAGE plpgsql;


#<>比较运算测试
statement ok
CREATE OR REPLACE PROCEDURE test_proc(c INT) AS $$
 BEGIN
     IF c<>33 THEN
         INSERT INTO t1 VALUES (1111);
     ELSE
         INSERT INTO t1 VALUES (2222);
     END IF;
END
$$ LANGUAGE plpgsql;

#存储过程名后定义参数测试
statement ok
CREATE OR REPLACE PROCEDURE test_proc(a INT,b int,c int) AS $$
 BEGIN
     INSERT INTO test VALUES (a,b,c);
 END
 $$ LANGUAGE plpgsql;


#事务-commit测试
statement error pq: ZNBase PLSQL ERMSG: procedure does not support transaction
CREATE OR REPLACE PROCEDURE test_proc()
LANGUAGE plpgsql
 AS $$
 BEGIN
     INSERT INTO test VALUES (1,2);
     INSERT INTO test VALUES (3,4);
     commit;
 END;
$$ LANGUAGE plpgsql;

statement error pq: ZNBase PLSQL ERMSG: procedure does not support transaction
CREATE OR REPLACE PROCEDURE test_proc()
 LANGUAGE plpgsql
AS $$
BEGIN
    INSERT INTO test VALUES (1,2);
    INSERT INTO test VALUES (3,4);
    rollback;
END;
$$ LANGUAGE plpgsql;

statement error pq: procedure does not support transaction
CREATE OR REPLACE PROCEDURE test_proc()
 LANGUAGE plpgsql
AS $$
BEGIN
    INSERT INTO test VALUES (1,2);
    INSERT INTO test VALUES (3,4);
    abort;
END;
$$ LANGUAGE plpgsql;

statement error pq: ZNBase PLSQL ERMSG: invalid syntax: syntax error at or near "EOF"\nDETAIL:source SQL:\nsavepoint\n         \^\nHINT:try \\h SAVEPOINT
CREATE OR REPLACE PROCEDURE test_proc()
 LANGUAGE plpgsql
AS $$
BEGIN
    INSERT INTO test VALUES (1,2);
    INSERT INTO test VALUES (3,4);
    savepoint;
END;
$$ LANGUAGE plpgsql;

#constant静态参数测试
statement error pq: ZNBase PLSQL ERMSG: variable "var2" is declared CONSTANT
CREATE OR REPLACE PROCEDURE test_proc()
AS $$
DECLARE
var2 CONSTANT integer := 10;
BEGIN
    var2=20;
    INSERT INTO test VALUES (var2);
END;
$$ LANGUAGE plpgsql;


#位置参数测试
statement ok
drop procedure test_proc(int)

statement ok
CREATE OR REPLACE PROCEDURE test_proc(var1 int)
AS $$
BEGIN
    INSERT INTO t1 VALUES ($1);
END;
$$ LANGUAGE plpgsql;

statement ok
call test_proc(123)

statement ok
drop procedure test_proc(int)

#alias别名测试
statement ok
CREATE OR REPLACE PROCEDURE test_proc(c int) AS $$
DECLARE
    var ALIAS FOR $1;
BEGIN
    truncate test;
    INSERT INTO test VALUES (var);
END;
$$ LANGUAGE plpgsql;


#变量默认值约束测试
 statement ok
 create table t2(id INT);

#暂不支持的类型
#statement error pq: ZNBase PLSQL ERMSG: type "t2.id%!T(MISSING)YPE " does not exist
#CREATE OR REPLACE PROCEDURE test_proc() AS $$
# DECLARE
#    id t2.id%TYPE default 100;
# BEGIN
#    INSERT INTO t2 VALUES (id);
#END;
#$$ LANGUAGE plpgsql;


#变量约束组合测试
statement ok
CREATE OR REPLACE PROCEDURE test_proc() AS $$
DECLARE
    id CONSTANT int NOT NULL DEFAULT 100;
BEGIN
    INSERT INTO test VALUES (id);
END;
$$ LANGUAGE plpgsql;


#游标测试
statement ok
drop table test;

statement ok
drop table test_data;

statement ok
create table test_data(c1 INT);

statement ok
drop procedure if exists pg_count(int)

statement ok
create or replace procedure pg_count(a int)
as $$
DECLARE
result int;
cursor1 CURSOR for select a;
BEGIN
open cursor1;
loop
fetch cursor1 into result;
exit when not found;
insert into test_data values (result);
end loop;
close cursor1;
END
$$ LANGUAGE plpgsql;

statement ok
call pg_count(456)

query I
select * from test_data
----
456

statement ok
truncate test_data;

statement ok
drop procedure if exists pg_count(int)

#定义游标的可选关键字测试
statement ok
create table test1(a INT, b INT);

statement ok
insert into test1 values(1,2),(2,3),(3,4);

statement ok
create table test_curs(id int);

statement ok
insert into test_curs values(1),(2),(NULL),(NULL);

statement ok
create table test_cursor(a int);

statement ok
create or replace procedure test_proc2()
as $$
DECLARE
result int;
cursor1 CURSOR for select id from test_curs;
BEGIN
open cursor1;
loop
fetch cursor1 into result;
exit when not found;
insert into test_cursor values (result);
end loop;
close cursor1;
END
$$ LANGUAGE plpgsql;

statement ok
create or replace procedure test_proc() as $$
BEGIN
    insert into test1 values(NULL,1);
END
$$ LANGUAGE plpgsql;

statement ok
drop table test1;

statement ok
create table test1(a int,b int);

statement ok
insert into test1 values(NULL,1);

statement ok
create or replace procedure test_proc() as $$
BEGIN
    insert into test1 values(1,2);
    update test1 set b=3 where a is NULL;
    delete from test1 where a is NULL;
END
$$ LANGUAGE plpgsql;


#move关键字测试
#-- 如果仅想移动游标并不返回行，可以使用move语句
statement ok
truncate test_cursor;

statement ok
truncate test_curs;

statement ok
insert into test_curs values(1),(2),(3),(4),(5),(6),(7),(8),(9),(10);

statement ok
create or replace procedure test_proc()
as $$
DECLARE
result int;
cursor1 CURSOR for select id from test_curs;
BEGIN
open cursor1;
loop
move backward 1 from cursor1;
exit when not found;
insert into test_cursor values (result);
end loop;
close cursor1;
END
$$ LANGUAGE plpgsql;

statement ok
call test_proc();

query I
select * from test_cursor;
----


statement ok
create or replace procedure test_proc()
as $$
DECLARE
result int;
cursor1 CURSOR for select id from test_curs;
BEGIN
open cursor1;
loop
move forward 1 from cursor1;
fetch cursor1 into result;
exit when not found;
insert into test_cursor values (result);
end loop;
close cursor1;
END
$$ LANGUAGE plpgsql;

#statement ok
#close cursor1;

statement ok
call test_proc();

query I
select * from test_cursor;
----
   2
   4
   6
   8
   10


#动态SQL测试
statement ok
create table test(a int, b int)

statement ok
insert into test values (1, 22), (2, 33)

statement ok
create or replace procedure proc1(a int)
as $$
BEGIN
execute 'insert into test_data values($1)' using $1;
END;
$$ language plpgsql;

statement ok
create or replace procedure proc1(a int)
as $$
BEGIN
execute 'insert into test values($1)' using a;
END;
$$ language plpgsql;

statement ok
call proc1(678)

query II
select * from test
----
1   22
2   33
678 NULL

statement ok
drop procedure proc1(int)

statement ok
create or replace procedure proc1(var1 int,var2 int)
as $$
BEGIN
execute 'update test set a=$1 where b=$2' using $1,$2;
END;
$$ language plpgsql;

statement ok
call proc1(10, 22)

query II
select * from test
----
10   22
2    33
678  NULL

statement ok
drop procedure proc1(int, int)

#foreach循环测试
statement ok
create or replace procedure proc1() as $$
DECLARE
var1 int ARRAY;
var2 int;
BEGIN
    var1=ARRAY[1,2,3,4,5];
    FOREACH var2 IN ARRAY var1
    LOOP
        insert into test values(var2);
    END LOOP;
END;
$$ language plpgsql;

statement ok
call proc1()

query II
select * from test
----
10   22
2    33
678  NULL
1   NULL
2   NULL
3   NULL
4   NULL
5   NULL

statement ok
drop table test

#function创建测试——不支持
statement ok
create FUNCTION test() RETURNS int AS $$
    BEGIN
         NULL;
    END;
$$ LANGUAGE plpgsql;

statement ok
CREATE OR REPLACE FUNCTION increment(i INT) RETURNS INT AS $$
        BEGIN
                RETURN i + 1;
        END;
$$ LANGUAGE plpgsql;


#关键字测试
# 1、like
statement ok
create table test2(a int,b varchar);

statement ok
insert into test2 values(1,'drdb');

statement ok
CREATE OR REPLACE PROCEDURE test_proc() AS $$
BEGIN
    update test2 set a=2  where b like '%db';
END
$$ LANGUAGE plpgsql;


#2、SIMILAR TO
statement ok
CREATE OR REPLACE PROCEDURE test_proc() AS $$
BEGIN
    update test2 set a=3  where b SIMILAR TO 'dr%';
END
$$ LANGUAGE plpgsql;


#3、NULLIF
statement ok
CREATE OR REPLACE PROCEDURE test_proc() AS $$
BEGIN
    insert into test2 values(NULLIF(1,0),NULLIF('a','a'));
END
$$ LANGUAGE plpgsql;


#4、COALESCE（√）
statement ok
CREATE OR REPLACE PROCEDURE test_proc() AS $$
BEGIN
    insert into test2 values(COALESCE(NULL,1,2));
END
$$ LANGUAGE plpgsql;


#5、GREATEST/LEAST
statement ok
CREATE OR REPLACE PROCEDURE test_proc() AS $$
BEGIN
    insert into test2 values(greatest(1,2,3,4,5));
    insert into test2 values(least(1,2,3,4,5));
END
$$ LANGUAGE plpgsql;


#6、EXISTS/NOT EXISTS
statement ok
CREATE OR REPLACE PROCEDURE test_proc() AS $$
BEGIN
    update test2 set a=2  where EXISTS(SELECT 1 FROM test2 WHERE b = 'drdb' );
END
$$ LANGUAGE plpgsql;

statement ok
CREATE OR REPLACE PROCEDURE test_proc() AS $$
BEGIN
    update test2 set a=2  where NOT EXISTS(select a from test);
END
$$ LANGUAGE plpgsql;

#7、IN
statement ok
CREATE OR REPLACE PROCEDURE test_proc() AS $$
BEGIN
    update test set id=2 where id NOT IN (1,2,3);
END
$$ LANGUAGE plpgsql;

#8、NOT IN
statement ok
CREATE OR REPLACE PROCEDURE test_proc() AS $$
BEGIN
    update test set id=2 where id NOT IN (1,2,3);
END
$$ LANGUAGE plpgsql;


#9、some/all/any
statement ok
CREATE OR REPLACE PROCEDURE test_proc() AS $$
BEGIN
    update test1 set a=666 where a>any(select b from test1);
    update test1 set a=777 where a>some(select b from test1);
    update test1 set a=888 where a>all(select b from test1);
END
$$ LANGUAGE plpgsql;


#10、order by limit（不支持）
statement ok
CREATE OR REPLACE PROCEDURE test_proc() AS $$
BEGIN
    update test set a=1 order by a DESC limit 2;
    delete from test order by a ASC limit 3;
END
$$ LANGUAGE plpgsql;


#11、DEFAULT VALUES
statement ok
CREATE OR REPLACE PROCEDURE test_proc() AS $$
BEGIN
    INSERT INTO test DEFAULT VALUES;
END
$$ LANGUAGE plpgsql;


#12、UPSERT（不支持）
#statement error pq: ZNBase PLSQL ERMSG: "test" is not a known variable
statement ok
CREATE OR REPLACE PROCEDURE test_proc() AS $$
BEGIN
    UPSERT INTO test VALUES(1, 'abc');
END
$$ LANGUAGE plpgsql;

statement ok
drop table test2;

#13、insert on conflict（不支持）
statement ok
create table test2(a int primary key,b int);

statement ok
insert into test2 values(1, 2);

statement ok
CREATE OR REPLACE PROCEDURE test_proc() AS $$
BEGIN
   INSERT INTO test2 VALUES(1, 3) ON CONFLICT(a) DO UPDATE SET b=EXCLUDED.b;
END
$$ LANGUAGE plpgsql;

statement ok
call test_proc();

#14、RETURNING（不支持）

statement ok
create table test3(a INT default 1, b INT default 0);

statement ok
CREATE OR REPLACE PROCEDURE test_proc() AS $$
BEGIN
    INSERT INTO test3 VALUES (DEFAULT, 1000), (DEFAULT, 250) RETURNING a,b;
END
$$ LANGUAGE plpgsql;


#15、truncate
statement ok
CREATE OR REPLACE PROCEDURE test_proc() AS $$
BEGIN
    truncate table test CASCADE;
    truncate table test RESTRICT;
END
$$ LANGUAGE plpgsql;


#16、select
statement ok
CREATE TABLE SJCX01(A INT DEFAULT 10,B INT,C VARCHAR,D VARCHAR);

statement ok
INSERT INTO SJCX01 VALUES(1,1,'A','DFFDARG'),(6,3,'B','ABCDEFV'),(4,1,'C','VDWFSF'),(6,4,'D','GDSDFDS'),(8,3,'E','DFDSFFF'),(11,5,'F','DFSFFDS'),(1,13,'G','FGACFG'),(0,21,'H','DDDVF'),(NULL,NULL,NULL,NULL);

statement ok
CREATE OR REPLACE PROCEDURE test_proc() AS $$
BEGIN
    SELECT * FROM SJCX01;
    SELECT A,B FROM SJCX01;
    SELECT 5 FROM SJCX01;
    SELECT A>B FROM SJCX01;
    SELECT DISTINCT A FROM SJCX01;
    SELECT DISTINCT A,B FROM SJCX01;
    SELECT DISTINCT * FROM SJCX01;
END
$$ LANGUAGE plpgsql;

statement error pq: ZNBase PLSQL ERMSG: query has no destination for result data
call test_proc();


#快照创建和删除（不支持）
statement ok
CREATE OR REPLACE PROCEDURE test_proc() AS $$
BEGIN
    CREATE SNAPSHOT sn1 on table test;
END
$$ LANGUAGE plpgsql;

statement ok
CREATE OR REPLACE PROCEDURE test_proc() AS $$
BEGIN
    DROP SNAPSHOT sn1;
END
$$ LANGUAGE plpgsql;

#大小写问题测试
statement ok
create table test(id int, name string);

statement ok
create table test_data1(a varchar);

statement ok
CREATE OR REPLACE PROCEDURE test_proc() AS $$
BEGIN
INSERT INTO test_data1 VALUES ('TEST');
END
$$ LANGUAGE plpgsql;

statement ok
call test_proc();

query T
select * from test_data1;
----
TEST

statement ok
CREATE OR REPLACE PROCEDURE test_proc() AS $$
BEGIN
    create table t1 as select * from test;
END
$$ LANGUAGE plpgsql;

statement ok
drop table t1;

statement ok
call test_proc();

query TT
show create table t1;
----
            t1  CREATE TABLE t1 (
                id INT8 NULL,
                name STRING NULL,
                FAMILY "primary" (id, name, rowid)
            )

query TT
show create table test;
----
            test  CREATE TABLE test (
                  id INT NULL,
                  name STRING NULL,
                  FAMILY "primary" (id, name, rowid)
            )


#schema测试
# 1、schema创建
statement ok
CREATE OR REPLACE PROCEDURE test_proc() AS $$
BEGIN
    create schema s1;
END
$$ LANGUAGE plpgsql;

statement ok
CREATE OR REPLACE PROCEDURE test_proc() AS $$
BEGIN
    create schema IF NOT EXISTS s1;
END
$$ LANGUAGE plpgsql;

#2、schema重命名
statement ok
CREATE OR REPLACE PROCEDURE test_proc() AS $$
BEGIN
    ALTER SCHEMA s1 RENAME TO ss1;
END
$$ LANGUAGE plpgsql;

#3、schema删除
statement ok
CREATE OR REPLACE PROCEDURE test_proc() AS $$
BEGIN
    DROP SCHEMA IF EXISTS ss1 CASCADE;
END
$$ LANGUAGE plpgsql;

statement ok
CREATE SCHEMA IF NOT EXISTS test_schema;

statement ok
CREATE OR REPLACE PROCEDURE test_proc() AS $$
BEGIN
    create table test_schema.test1(a int,b varchar);
    alter table test_schema.test1 rename to test111;
END
$$ LANGUAGE plpgsql;

statement ok
CREATE OR REPLACE PROCEDURE test_proc() AS $$
BEGIN
    create table IF NOT EXISTS test1(a int,b varchar);
    insert into test1 values(1,'test'),(2,'test2');
    update test1 set b='ok' where a=1;
    delete from test1 where a=2;
END
$$ LANGUAGE plpgsql;

statement ok
CREATE OR REPLACE PROCEDURE test_proc() AS $$
BEGIN
create view test_schema.v1 as select a,b from test1;
END
$$ LANGUAGE plpgsql;

##han

##一些补充用例：

statement ok
drop table t;

statement ok
CREATE TABLE t(a INT, b STRING);

#statement ok
statement ok
CREATE OR REPLACE PROCEDURE proc1(a INT) AS $$
BEGIN
INSERT INTO t VALUES (1, 'int');
END
$$ LANGUAGE plpgsql;

statement ok
call proc1(1)

query IT
select * from t
----
1 int

statement ok
CREATE OR REPLACE PROCEDURE proc1(a INT) AS $$
BEGIN
INSERT INTO t VALUES (2, 'two');
END
$$ LANGUAGE plpgsql;

statement ok
call proc1(1)

query IT
select * from t
----
1 int
2 two

statement ok
create table test_trigger(a decimal);

statement ok
CREATE OR REPLACE PROCEDURE proc1(re DECIMAL) AS $$
BEGIN
    INSERT INTO t VALUES (1, 'decimal');
END
$$ LANGUAGE plpgsql;

statement ok
call proc1(1.3);

query IT
select * from t;
----
1  int
2  two
1  decimal

statement error pq: syntax error at or near "detail"
                        DETAIL: source SQL:
                        DETAIL: source SQL:
                        ^
call proc1(null);

statement ok
CREATE OR REPLACE PROCEDURE proc_tri(re DECIMAL) AS $$
BEGIN
    INSERT INTO test_trigger VALUES (re);
END
$$ LANGUAGE plpgsql;

statement ok
CREATE TRIGGER t1 BEFORE INSERT ON t FOR EACH STATEMENT EXECUTE PROCEDURE proc_tri(1);

statement ok
CREATE TRIGGER t2 BEFORE INSERT ON t FOR EACH STATEMENT EXECUTE PROCEDURE proc_tri(1.3);

statement ok
insert into t values(100,'a');

query IT
select * from t;
----
1    int
2    two
1    decimal
100  a

# TODO : trigger
#query R
#select * from test_trigger;
#----
#1
#1.3

statement ok
CREATE SCHEMA IF NOT EXISTS sch;

statement ok
CREATE OR REPLACE PROCEDURE sch.proc1(re INT) AS $$
BEGIN
    INSERT INTO t VALUES (4, 'four');
END
$$ LANGUAGE plpgsql;

statement ok
call sch.proc1(1);

query IT
select * from t
----
1    int
2    two
1    decimal
100  a
4    four

##(BUG)
statement ok
ALTER PROCEDURE proc1(INT) RENAME TO proc;

statement ok
ALTER PROCEDURE sch.proc1(INT) RENAME TO proc;

statement error pq: procedure proc1\(INT\) does not exist
drop PROCEDURE sch.proc1(int)

statement ok
ALTER PROCEDURE proc1(DECIMAL) RENAME TO sch.proc1;

statement ok
drop procedure proc(int)

statement ok
drop procedure sch.proc(int)

statement ok
drop procedure sch.proc1(DECIMAL)

statement ok
drop table t;

##更改表结构BUG，已经修复
statement ok
create table t(a INT);

statement ok
alter table t add column b STRING;

statement ok
CREATE OR REPLACE PROCEDURE proc(a DECIMAL) AS $$
BEGIN
    INSERT INTO t values(123, 'int');
END
$$language plpgsql;

statement ok
call proc(1.1);

query IT
select * from t;
----
123   int

statement ok
drop procedure proc(decimal)

statement ok
drop table t

##补充动态sql测试
##数据类型支持测试

statement ok
CREATE TABLE type(
p1 INT,
p2 SMALLINT,
p3 BIGINT,
p4 INTEGER,
p5 INT2,
p6 INT4,
p7 INT8,
p8 INT64,
p15 FLOAT,
p16 REAL,
p17 DOUBLE PRECISION,
p18 FLOAT4,
p19 FLOAT8,
p20 DECIMAL,
p21 DEC,
p22 NUMERIC,
p23 BOOL,
p24 BOOLEAN,
p25 BIT,
p26 BIT(3),
p27 VARBIT,
p28 VARBIT(3),
p31 BYTEA,
p32 STRING,
p33 CHARACTER,
p34 CHAR,
p35 VARCHAR,
p36 TEXT,
p37 STRING(5),
p38 CHARACTER(5),
p39 CHARACTER VARYING(5),
p40 CHAR(5),
p41 CHAR VARYING(5),
p42 VARCHAR(5),
p45 DATE,
p46 TIME,
p47 TIMESTAMP,
p48 TIMESTAMPTZ,
p49 TIMESTAMP WITHOUT TIME ZONE,
p50 TIMESTAMP WITH TIME ZONE,
p51 INTERVAL,
p52 INET,
p53 UUID,
p54 JSONB,
p55 JSON,
p56 INT ARRAY,
p57 INT[],
p58 STRING ARRAY);

statement ok
CREATE OR REPLACE procedure proc1(a INT)
as $$
BEGIN
execute 'insert into type(p1) values($1)' using a;
END;
$$ language plpgsql;

statement ok
CREATE OR REPLACE procedure proc1(a FLOAT)
as $$
BEGIN
execute 'insert into type(p15) values($1)' using a;
END;
$$ language plpgsql;

statement ok
CREATE OR REPLACE procedure proc1(a BOOL)
as $$
BEGIN
execute 'insert into type(p23) values($1)' using a;
END;
$$ language plpgsql;

statement ok
CREATE OR REPLACE procedure proc1(a BIT)
as $$
BEGIN
execute 'insert into type(p25) values($1)' using a;
END;
$$ language plpgsql;

statement ok
CREATE OR REPLACE procedure proc1(a STRING)
as $$
BEGIN
execute 'insert into type(p32) values($1)' using a;
END;
$$ language plpgsql;

statement ok
CREATE OR REPLACE procedure proc1(a DATE)
as $$
BEGIN
execute 'insert into type(p45) values($1)' using a;
END;
$$ language plpgsql;

statement ok
CREATE OR REPLACE procedure proc1(a TIME)
as $$
BEGIN
execute 'insert into type(p46) values($1)' using a;
END;
$$ language plpgsql;

statement ok
CREATE OR REPLACE procedure proc1(a INT ARRAY)
as $$
BEGIN
execute 'insert into type(p56) values($1)' using a;
END;
$$ language plpgsql;

statement ok
call proc1(ARRAY[10,20,30]);

statement ok
CREATE OR REPLACE procedure proc1(a INT[])
as $$
BEGIN
execute 'insert into type(p57) values($1)' using a;
END;
$$ language plpgsql;

statement ok
call proc1(ARRAY[10,20,30]);

statement ok
CREATE OR REPLACE procedure proc1(a STRING ARRAY)
as $$
BEGIN
execute 'insert into type(p58) values($1)' using a;
END;
$$ language plpgsql;

statement ok
call proc1(ARRAY['sky', 'road', 'car']);

statement ok
CREATE OR REPLACE procedure proc1(a INT, b STRING)
as $$
BEGIN
execute 'insert into type(p1, P32) values($1, $2)' using a;
END;
$$ language plpgsql;

statement ok
call proc1(100, string 'string');

##多参数动态SQL
statement ok
drop table if exists t;

statement ok
CREATE TABLE t(a INT, b INT);

statement ok
CREATE OR REPLACE procedure proc1(a INT, b INT)
as $$
BEGIN
    execute 'insert into t values($1, $2)' using a, b;
END;
$$ language plpgsql;

statement error pq: No function/procedure matches the given name and argument types.
CALL proc1(1, 1.3);

statement ok
DROP TABLE t

statement ok
drop procedure proc1(int, int)

##其他DML语句
statement ok
CREATE TABLE t(a INT, b STRING);

statement ok
INSERT INTO t VALUES(1, 'a'), (2, 'b'), (3, 'c');

##BUG：语法不识别
statement ok
CREATE OR REPLACE procedure proc1(a INT)
as $$
BEGIN
    execute E'INSERT INTO t VALUES($1, \'insert\')' using a;
END;
$$ language plpgsql;

statement ok
CALL proc1(4)

statement ok
CREATE OR REPLACE procedure proc1(a INT)
as $$
BEGIN
    execute E'UPDATE t SET a=$1 where b=\'b\''  using a;
END;
$$ language plpgsql;

statement ok
CALL proc1(6)

statement ok
CREATE OR REPLACE procedure proc1(a INT)
as $$
BEGIN
    execute E'UPDATE t SET b=\'update\' where a=$1' using a;
END;
$$ language plpgsql;

statement ok
CALL proc1(1)

query IT
select * from t;
----
1   update
6   b
3   c
4   insert

statement ok
CREATE OR REPLACE procedure proc1(a INT)
as $$
BEGIN
    execute 'DELETE FROM t WHERE a=$1' using a;
END;
$$ language plpgsql;

statement ok
call proc1(1);

query IT
select * from t;
----
6   b
3   c
4   insert

##补充游标测试
##数据类型，不全

statement ok
CREATE DATABASE db;

#测试需要。添加

statement ok
CREATE SCHEMA db.sch;

statement ok
CREATE TABLE db.sch.type(
p1 INT,
p2 SMALLINT,
p3 BIGINT,
p4 INTEGER,
p5 INT2,
p6 INT4,
p7 INT8,
p8 INT64,
p15 FLOAT,
p16 REAL,
p17 DOUBLE PRECISION,
p18 FLOAT4,
p19 FLOAT8,
p20 DECIMAL,
p21 DEC,
p22 NUMERIC,
p23 BOOL,
p24 BOOLEAN,
p25 BIT,
p26 BIT(3),
p27 VARBIT,
p28 VARBIT(3),
p31 BYTEA,
p32 STRING,
p33 CHARACTER,
p34 CHAR,
p35 VARCHAR,
p36 TEXT,
p37 STRING(5),
p38 CHARACTER(5),
p39 CHARACTER VARYING(5),
p40 CHAR(5),
p41 CHAR VARYING(5),
p42 VARCHAR(5),
p45 DATE,
p46 TIME,
p47 TIMESTAMP,
p48 TIMESTAMPTZ,
p49 TIMESTAMP WITHOUT TIME ZONE,
p50 TIMESTAMP WITH TIME ZONE,
p51 INTERVAL,
p52 INET,
p53 UUID,
p54 JSONB,
p55 JSON,
p56 INT ARRAY,
p57 INT[],
p58 STRING ARRAY);

statement ok
CREATE TABLE db.sch.type_data(
p1 INT,
p2 SMALLINT,
p3 BIGINT,
p4 INTEGER,
p5 INT2,
p6 INT4,
p7 INT8,
p8 INT64,
p15 FLOAT,
p16 REAL,
p17 DOUBLE PRECISION,
p18 FLOAT4,
p19 FLOAT8,
p20 DECIMAL,
p21 DEC,
p22 NUMERIC,
p23 BOOL,
p24 BOOLEAN,
p25 BIT,
p26 BIT(3),
p27 VARBIT,
p28 VARBIT(3),
p31 BYTEA,
p32 STRING,
p33 CHARACTER,
p34 CHAR,
p35 VARCHAR,
p36 TEXT,
p37 STRING(5),
p38 CHARACTER(5),
p39 CHARACTER VARYING(5),
p40 CHAR(5),
p41 CHAR VARYING(5),
p42 VARCHAR(5),
p45 DATE,
p46 TIME,
p47 TIMESTAMP,
p48 TIMESTAMPTZ,
p49 TIMESTAMP WITHOUT TIME ZONE,
p50 TIMESTAMP WITH TIME ZONE,
p51 INTERVAL,
p52 INET,
p53 UUID,
p54 JSONB,
p55 JSON,
p56 INT ARRAY,
p57 INT[],
p58 STRING ARRAY);

statement ok
insert into	db.sch.type (
    p1,
	p2,
	p3,
	p4,
	p5,
	p6,
	p7,
	p8,
	p15,
	p16,
	p17,
	p18,
	p19,
	p20,
	p21,
	p22,
	p23,
	p24,
	p25,
	p26,
	p27,
	p28,
	p32,
	p33,
	p34,
	p35,
	p36,
	p37,
	p38,
	p39,
	p40,
	p41,
	p42,
	p45,
	p46,
	p47,
	p48,
	p49,
	p50,
	p51,
	p52,
	p53,
	p54,
	p55,
	p56,
	p57,
	p58)
values (1,
2,
3,
1,
1,
1,
1,
1,
1.22,
1.22,
1.22,
2.22,
2.22,
2.22,
2.22,
2.22,
false,
true,
'1',
'010',
'111111',
'111',
'adfdsfgfdh',
'a',
'a',
'sdfh',
'adhia中文',
'aaaaa',
'aaaaa',
'aaaaa',
'aaaaa',
'aaaaa',
'aaaaa',
'2020-09-12',
'09:00:00',
'2020-09-12 09:00:00.000',
'2020-09-12 09:00:00.000',
'2020-09-12 09:00:00.000',
'2020-09-12 09:00:00.000',
'1-2 3',
'2001:4f8:3:ba:2e0:81ff:fe22:d1f1/120',
'63616665-6630-3064-6465-616462656562',
'{"a": "aa", "b": "bb", "c": "cc"}',
'{"a": "aa", "b": "bb", "c": "cc"}',
'{1,22222,121}',
'{1,222}',
'{a,b,c,d}');

statement ok
create or replace procedure proc1()
as $$
DECLARE
result int;
cursor1 CURSOR for select p1 from db.sch.type;
BEGIN
open cursor1;
loop
fetch cursor1 into result;
exit when not found;
insert into db.sch.type_data(p1) values (result);
end loop;
close cursor1;
END
$$ LANGUAGE plpgsql;

statement ok
call proc1()

query I
select p1 from db.sch.type_data
----
1

statement ok
create or replace procedure proc1()
as $$
DECLARE
result INTEGER;
cursor1 CURSOR for select p4 from db.sch.type;
BEGIN
open cursor1;
loop
fetch cursor1 into result;
exit when not found;
insert into db.sch.type_data(p4) values (result);
end loop;
close cursor1;
END
$$ LANGUAGE plpgsql;

statement ok
call proc1()

query I
select p4 from db.sch.type_data
----
NULL
1

statement ok
create or replace procedure proc1()
as $$
DECLARE
result DOUBLE PRECISION;
cursor1 CURSOR for select p17 from db.sch.type;
BEGIN
open cursor1;
loop
fetch cursor1 into result;
exit when not found;
insert into db.sch.type_data(p17) values (result);
end loop;
close cursor1;
END
$$ LANGUAGE plpgsql;

statement ok
call proc1()

query R
select p17 from db.sch.type_data
----
NULL
NULL
1.22

statement ok
create or replace procedure proc1()
as $$
DECLARE
result string;
cursor1 CURSOR for select p32 from db.sch.type;
BEGIN
open cursor1;
loop
fetch cursor1 into result;
exit when not found;
insert into db.sch.type_data(p32) values (result);
end loop;
close cursor1;
END
$$ LANGUAGE plpgsql;

statement ok
call proc1()

query T
select p32 from db.sch.type_data
----
NULL
NULL
NULL
adfdsfgfdh

statement ok
create or replace procedure proc1()
as $$
DECLARE
result CHARACTER;
cursor1 CURSOR for select p33 from db.sch.type;
BEGIN
open cursor1;
loop
fetch cursor1 into result;
exit when not found;
insert into db.sch.type_data(p33) values (result);
end loop;
close cursor1;
END
$$ LANGUAGE plpgsql;

statement ok
call proc1()

query T
select p33 from db.sch.type_data
----
NULL
NULL
NULL
NULL
a

statement ok
create or replace procedure proc1()
as $$
DECLARE
result CHAR;
cursor1 CURSOR for select p34 from db.sch.type;
BEGIN
open cursor1;
loop
fetch cursor1 into result;
exit when not found;
insert into db.sch.type_data(p34) values (result);
end loop;
close cursor1;
END
$$ LANGUAGE plpgsql;

statement ok
call proc1()

query T
select p34 from db.sch.type_data
----
NULL
NULL
NULL
NULL
NULL
a

statement ok
create or replace procedure proc1()
as $$
DECLARE
result CHARACTER(5);
cursor1 CURSOR for select p38 from db.sch.type;
BEGIN
open cursor1;
loop
fetch cursor1 into result;
exit when not found;
insert into db.sch.type_data(p38) values (result);
end loop;
close cursor1;
END
$$ LANGUAGE plpgsql;

statement ok
call proc1()

query T
select p38 from db.sch.type_data
----
NULL
NULL
NULL
NULL
NULL
NULL
aaaaa

statement ok
create or replace procedure proc1()
as $$
DECLARE
result CHARACTER VARYING(5);
cursor1 CURSOR for select p39 from db.sch.type;
BEGIN
open cursor1;
loop
fetch cursor1 into result;
exit when not found;
insert into db.sch.type_data(p39) values (result);
end loop;
close cursor1;
END
$$ LANGUAGE plpgsql;

statement ok
call proc1()

query T
select p39 from db.sch.type_data
----
NULL
NULL
NULL
NULL
NULL
NULL
NULL
aaaaa

statement ok
create or replace procedure proc1()
as $$
DECLARE
result JSON;
cursor1 CURSOR for select p55 from db.sch.type;
BEGIN
open cursor1;
loop
fetch cursor1 into result;
exit when not found;
insert into db.sch.type_data(p55) values (result);
end loop;
close cursor1;
END
$$ LANGUAGE plpgsql;

statement ok
call proc1()

query T
select p55 from db.sch.type_data
----
NULL
NULL
NULL
NULL
NULL
NULL
NULL
NULL
{"a": "aa", "b": "bb", "c": "cc"}

statement ok
create or replace procedure proc1()
as $$
DECLARE
result int[];
cursor1 CURSOR for select p57 from db.sch.type;
BEGIN
open cursor1;
loop
fetch cursor1 into result;
exit when not found;
insert into db.sch.type_data(p57) values (result);
end loop;
close cursor1;
END
$$ LANGUAGE plpgsql;

statement ok
call proc1()

query T
select p57 from db.sch.type_data
----
NULL
NULL
NULL
NULL
NULL
NULL
NULL
NULL
NULL
{1,222}

statement ok
create or replace procedure proc1()
as $$
DECLARE
result TIMESTAMP;
cursor1 CURSOR for select p47 from db.sch.type;
BEGIN
open cursor1;
loop
fetch cursor1 into result;
exit when not found;
insert into db.sch.type_data(p47) values (result);
end loop;
close cursor1;
END
$$ LANGUAGE plpgsql;

statement ok
call proc1();

query T
select p47 from db.sch.type_data
----
NULL
NULL
NULL
NULL
NULL
NULL
NULL
NULL
NULL
NULL
2020-09-12 09:00:00 +0000 +0000

#测试需要，添加语句
statement ok
drop table db.sch.type;

#测试需要，添加语句
statement ok
drop table db.sch.type_data;

##其他DML
statement ok
drop table test;

statement ok
CREATE TABLE test(a INT, b INT, c STRING);

statement ok
drop table test_data;

statement ok
CREATE TABLE test_data(a INT);

statement ok
INSERT INTO test VALUES
(1, 1, 'a'),
(11, 11, 'b'),
(111, 111, 'c'),
(1111, 1111, 'd'),
(11111, 11111, 'e');

##INSERT
statement ok
create or replace procedure proc1()
as $$
DECLARE
result int;
cursor1 CURSOR for select a from test;
BEGIN
open cursor1;
loop
fetch cursor1 into result;
exit when not found;
insert into test_data values (result+1), (result*2), (power(result, 2));
end loop;
close cursor1;
END
$$ LANGUAGE plpgsql;

# TODO :builtin functions sometimes not found in udr such as power
statement error pq: ZNBase PLSQL ERMSG: 42883:unknown signature: power\(int, int\) \(desired \<int\>\)
call proc1();

# TODO :builtin functions sometimes not found in udr such as power
# query I
# select * from test_data;
# ----
# 2
# 2
# 1
# 12
# 22
# 121
# 112
# 222
# 12321
# 1112
# 2222
# 1234321
# 11112
# 22222
# 123454321


##DELETE
statement ok
create or replace procedure proc1()
as $$
DECLARE
result int;
cursor1 CURSOR for select a from test;
BEGIN
open cursor1;
loop
fetch cursor1 into result;
exit when not found;
delete from test_data where a=result or a>100000000;
end loop;
close cursor1;
END
$$ LANGUAGE plpgsql;

statement ok
call proc1();

# TODO :builtin functions sometimes not found in udr such as power
#query I
#select * from test_data;
#----
#        2
#        2
#       12
#       22
#      121
#      112
#      222
#    12321
#     1112
#     2222
#  1234321
#    11112
#    22222

statement ok
create or replace procedure proc1(a INT)
as $$
DECLARE
result int;
cursor1 CURSOR IS select * from test_data;
BEGIN
open cursor1;
loop
fetch cursor1 into result;
exit when not found;
IF result=a THEN
        DELETE FROM test_data WHERE CURRENT OF cursor1;
END IF;
END LOOP;
close cursor1;
END
$$ LANGUAGE plpgsql;

statement ok
CALL proc1(2);

# TODO :builtin functions sometimes not found in udr such as power
# query I
# select * from test_data;
# ----
# 12
# 22
# 121
# 112
# 222
# 12321
# 1112
# 2222
# 1234321
# 11112
# 22222


##UPDATE
statement ok
create or replace procedure proc1()
as $$
DECLARE
result int;
cursor1 CURSOR for select a from test;
BEGIN
open cursor1;
loop
fetch cursor1 into result;
exit when not found;
IF result%2=1 THEN
    UPDATE test set b=b+1;
END IF;
END LOOP;
close cursor1;
END
$$ LANGUAGE plpgsql;

statement ok
CALL proc1();

query IIT
select * from test;
----
1      6      a
11     16     b
111    116    c
1111   1116   d
11111  11116  e

statement ok
create or replace procedure proc1()
as $$
DECLARE
result int;
cursor1 CURSOR for select a from test;
BEGIN
open cursor1;
loop
fetch cursor1 into result;
exit when not found;
IF result%2=1 THEN
    UPDATE test set b=result+1;
END IF;
END LOOP;
close cursor1;
END
$$ LANGUAGE plpgsql;

statement ok
CALL proc1();

query IIT
select * from test;
----
1      11112  a
11     11112  b
111    11112  c
1111   11112  d
11111  11112  e

statement ok
create or replace procedure proc1()
as $$
DECLARE
result int;
cursor1 CURSOR for select a from test;
BEGIN
open cursor1;
loop
fetch cursor1 into result;
exit when not found;
IF result%2=1 THEN
    UPDATE test set b=b+1 WHERE CURRENT OF cursor1;
END IF;
END LOOP;
close cursor1;
END
$$ LANGUAGE plpgsql;

statement ok
CALL proc1();

query IIT
select * from test;
----
1      11113  a
11     11113  b
111    11113  c
1111   11113  d
11111  11113  e

statement ok
create or replace procedure proc1()
as $$
DECLARE
result int;
cursor1 CURSOR for select a from test;
BEGIN
open cursor1;
loop
fetch cursor1 into result;
exit when not found;
IF result%2=1 THEN
    UPDATE test set b=result+1 WHERE CURRENT OF cursor1;
END IF;
END LOOP;
close cursor1;
END
$$ LANGUAGE plpgsql;

statement ok
CALL proc1();

query IIT
select * from test;
----
1      2      a
11     12     b
111    112    c
1111   1112   d
11111  11112  e


statement ok
create or replace procedure proc1(a INT)
as $$
DECLARE
result int;
cursor1 CURSOR for select a from test;
BEGIN
open cursor1;
loop
fetch cursor1 into result;
exit when not found;
IF result%2=1 THEN
    UPDATE test set b=result+a WHERE CURRENT OF cursor1;
END IF;
END LOOP;
close cursor1;
END
$$ LANGUAGE plpgsql;

statement ok
CALL proc1(6);

query IIT
select * from test;
----
1      2      a
11     22     b
111    222    c
1111   2222   d
11111  22222  e

statement ok
DROP PROCEDURE proc1();

statement ok
DROP PROCEDURE proc1(INT);

statement ok
DROP TABLE test;

statement ok
DROP TABLE test_data;

##声明query
statement ok
CREATE TABLE student(id INT PRIMARY KEY, name STRING, gender STRING, age INT, city STRING);

statement ok
INSERT INTO student VALUES
(1, 'a', 'm', 18, 'bj'),
(2, 'b', 'f', 20, 'tj'),
(3, 'c', 'm', 21, 'nj'),
(4, 'd', 'f', 18, 'bj'),
(5, 'e', 'f', 23, 'nj'),
(6, 'f', 'm', 16, 'bj'),
(7, 'c', 'm', 17, 'bj'),
(8, 'a', 'f', 22, 'ah'),
(9, 'g', 'm', 24, 'bj'),
(10, 'k', 'm', 25, 'wh');

statement ok
CREATE TABLE st(c1 STRING);

statement ok
CREATE TABLE it(c1 INT);

statement ok
CREATE TABLE student_data(id INT PRIMARY KEY, name STRING, city STRING);

## DISTINCT
statement ok
create or replace procedure proc1()
as $$
DECLARE
result string;
cursor1 CURSOR for SELECT DISTINCT city FROM student WHERE id>2;
BEGIN
open cursor1;
loop
fetch cursor1 into result;
exit when not found;
INSERT INTO st VALUES (result);
end loop;
close cursor1;
END
$$ LANGUAGE plpgsql;

statement ok
call proc1();

query T
select * from st;
----
nj
bj
ah
wh

statement ok
truncate st;

##ORDER BY
statement ok
create or replace procedure proc1()
as $$
DECLARE
result int;
cursor1 CURSOR for SELECT age FROM student ORDER BY age;
BEGIN
open cursor1;
loop
fetch cursor1 into result;
exit when not found;
INSERT INTO it VALUES (result);
end loop;
close cursor1;
END
$$ LANGUAGE plpgsql;

statement ok
call proc1();

query I
select * from it;
----
16
17
18
18
20
21
22
23
24
25

statement ok
truncate st;

##别名 & like
statement ok
create or replace procedure proc1()
as $$
DECLARE
result string;
cursor1 CURSOR for SELECT name as n FROM student WHERE city LIKE '%j';
BEGIN
open cursor1;
loop
fetch cursor1 into result;
exit when not found;
INSERT INTO st VALUES (result);
end loop;
close cursor1;
END
$$ LANGUAGE plpgsql;

statement ok
call proc1();

query T
select * from st
----
a
b
c
d
e
f
c
g

statement ok
truncate it;

##GROUP BY & HAVING
statement ok
create or replace procedure proc1()
as $$
DECLARE
result int;
cursor1 CURSOR for SELECT count(*) FROM student GROUP BY city HAVING count(*)>1 ORDER BY count(*);
BEGIN
open cursor1;
loop
fetch cursor1 into result;
exit when not found;
INSERT INTO it VALUES (result);
end loop;
close cursor1;
END
$$ LANGUAGE plpgsql;

statement ok
call proc1();

query I
select * from it;
----
2
5

statement ok
truncate it;

# ## has problem to solve in cursor with parameters
# ## arguments
# statement ok
# create or replace procedure proc1()
# as $$
# DECLARE
# c1 INT;
# c2 STRING;
# c3 STRING;
# cursor1 CURSOR(arg INT) for SELECT id,name,city FROM student where id>=arg;
# BEGIN
# open cursor1(5);
# loop
# fetch cursor1 into c1,c2,c3;
# exit when not found;
# INSERT INTO student_data VALUES (c1, c2, c3);
# end loop;
# close cursor1;
# END
# $$ LANGUAGE plpgsql;
#
# # 待解决问题
# statement ok
# call proc1();
#
# query ITT
# select * from student_data;
# ----
# 5   e  nj
# 6   f  bj
# 7   c  bj
# 8   a  ah
# 9   g  bj
# 10  k  wh

##补充：大数据量
statement ok
drop table t1;

statement ok
CREATE TABLE t1(c1 INT, c2 INT);

statement ok
CREATE OR REPLACE PROCEDURE proc1(re INT) AS $$
BEGIN
    for i in 1..$1
    LOOP
        INSERT INTO t1 VALUES(i, i);
    END LOOP;
END
$$ LANGUAGE plpgsql;

statement ok
CALL proc1(100);

query I
select count(*) from t1;
----
100

statement ok
CREATE OR REPLACE PROCEDURE proc1(a int , b int , c int ,d int ,e int ) AS $$
BEGIN
NULL;
END
$$ LANGUAGE plpgsql;

statement ok
call proc1(1,2,3,4,5)

# jira-6470 procedure change output parameters
statement ok
CREATE OR REPLACE procedure proc_3 ( x int,IN y int,INOUT z int ) AS
$$
BEGIN
    z=x+y+z;
END
$$ LANGUAGE PLPGSQL;

statement error cannot change whether a procedure has output parameters\nUse DROP PROCEDURE proc_3\(INT,INT,INT\) first.
CREATE OR REPLACE procedure proc_3 ( x int,IN y int,IN z int ) AS
$$
BEGIN
    z=x+y+z+1;
    insert into test1 values (1,z);
END
$$ LANGUAGE PLPGSQL;

statement ok
drop procedure proc_3(int, int, int)
