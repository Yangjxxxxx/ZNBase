// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sql/sqlbase/locking.proto

package sqlbase

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// ScanLockingStrength controls the row-level locking mode used by scans.
// ScanLockingStrength控制扫描使用的行级锁定模式。
//
// Typically, SQL scans read sequential keys from the key-value layer without
// acquiring any locks. This means that two scans by different transactions will
// not conflict and cause one of the two transactions to block the other. This
// is usually desirable, as it increases concurrency between readers.
// 通常，SQL扫描从键值层读取顺序键，而不获取任何锁。 这意味着不同事务的两次扫描不会冲突，
// 并且不会导致两个事务之一阻塞另一个事务。 这通常是理想的，因为它增加了读者之间的并发性。
//
// However, there are cases where a SQL scan would like to acquire locks on each
// of the keys that it reads to more carefully control concurrent access to the
// data that it reads. The prototypical example of this is a scan that is used
// to fetch the initial value of a row that its transction intends to later
// update. In this case, it would be beneficial to acquire a lock on the row
// during the initial scan instead of waiting until the mutation to acquire a
// lock. This prevents the row from being modified between the scan and the
// mutation. It also prevents situations that can lead to deadlocks.
// 但是，在某些情况下，SQL扫描希望获取其读取的每个键的锁，以更仔细地控制对读取数据的并发访问。
// 一个典型的例子是扫描，该扫描用于获取其转换要稍后更新的行的初始值。 在这种情况下，有益的是在
// 初始扫描期间在行上获取锁，而不是等到突变获取锁为止。 这样可以防止在扫描和突变之间修改行。
// 它还可以防止可能导致死锁的情况。
//
// Locking modes have differing levels of strength, growing from "weakest" to
// "strongest" in the order that the variants are presented in the enumeration.
// The "stronger" a locking mode, the more protection it provides for the lock
// holder but the more restrictive it is to concurrent transactions attempting
// to access the same keys.
// 锁定模式具有不同的强度级别，从“最弱”到“最强”的增长顺序是在枚举中显示。 锁定模式“越强”，
// 它为锁持有者提供的保护就越多，但是对尝试访问相同密钥的并发事务的限制就越大。
//
// The following matrix presents the compatibility of locking strengths with one
// another.
// 以下矩阵显示了锁定强度之间的兼容性。
//
//  +-------------------+---------------+-----------+-------------------+------------+
//  |                   | FOR_KEY_SHARE | FOR_SHARE | FOR_NO_KEY_UPDATE | FOR_UPDATE |
//  +-------------------+---------------+-----------+-------------------+------------+
//  | FOR_KEY_SHARE     |               |           |                   |      X     |
//  +-------------------+---------------+-----------+-------------------+------------+
//  | FOR_SHARE         |               |           |         X         |      X     |
//  +-------------------+---------------+-----------+-------------------+------------+
//  | FOR_NO_KEY_UPDATE |               |     X     |         X         |      X     |
//  +-------------------+---------------+-----------+-------------------+------------+
//  | FOR_UPDATE        |       X       |     X     |         X         |      X     |
//  +-------------------+---------------+-----------+-------------------+------------+
//
// A transaction can hold conflicting locks on the same row, but two different
// transactions can never hold conflicting locks on the same row. Once acquired,
// a lock is held until the end of the transaction.
// 一个事务可以在同一行上持有冲突的锁，但是两个不同的事务永远不能在同一行上持有冲突的锁。
// 一旦获得，锁将一直保持到交易结束。
type ScanLockingStrength int32

const (
	// FOR_NONE represents the default - no row-level locking.
	// FOR_NONE代表默认值-无行级锁定。
	ScanLockingStrength_FOR_NONE ScanLockingStrength = 0
	//
	// NOTE: FOR_KEY_SHARE is currently ignored. No locks are acquired.
	// 注意：FOR_KEY_SHARE当前被忽略。 没有锁。
	ScanLockingStrength_FOR_KEY_SHARE ScanLockingStrength = 1
	// FOR_SHARE represents the FOR SHARE row-level locking mode.
	// FOR_SHARE表示FOR SHARE行级锁定模式。
	//
	// The mode behaves similarly to FOR NO KEY UPDATE, except that it acquires a
	// shared lock rather than exclusive lock on each retrieved row. A shared lock
	// blocks other transactions from performing UPDATE, DELETE, SELECT FOR UPDATE
	// or SELECT FOR NO KEY UPDATE on these rows, but it does not prevent them
	// from performing SELECT FOR SHARE or SELECT FOR KEY SHARE.
	// 该模式的行为与FOR NO KEY UPDATE相似，除了它在每个检索到的行上获取一个共享锁而不是互斥锁。
	// 共享锁可阻止其他事务在这些行上执行UPDATE，DELETE，SELECT FOR UPDATE或SELECT FOR NO
	// KEY UPDATE，但不会阻止它们执行SELECT FOR SHARE或SELECT FOR KEY SHARE。
	//
	// NOTE: FOR_SHARE is currently ignored. No locks are acquired.
	// 注意：FOR_SHARE当前被忽略。 没有锁。
	ScanLockingStrength_FOR_SHARE ScanLockingStrength = 2
	//
	// NOTE: FOR_NO_KEY_UPDATE is currently promoted to FOR_UPDATE.
	// 注意：FOR_NO_KEY_UPDATE当前提升为FOR_UPDATE。
	ScanLockingStrength_FOR_NO_KEY_UPDATE ScanLockingStrength = 3
	// FOR_UPDATE represents the FOR UPDATE row-level locking mode.
	// FOR_UPDATE表示FOR UPDATE行级锁定模式。
	//
	// The mode causes the rows retrieved by the scan to be locked as though for
	// update. This prevents them from being locked, modified or deleted by other
	// transactions until the current transaction ends. That is, other
	// transactions that attempt UPDATE, DELETE, SELECT FOR UPDATE, SELECT FOR NO
	// KEY UPDATE, SELECT FOR SHARE or SELECT FOR KEY SHARE of these rows will be
	// blocked until the current transaction ends. Conversely, SELECT FOR UPDATE
	// will wait for a concurrent transaction that has run any of those commands
	// on the same row, and will then lock and return the updated row (or no row,
	// if the row was deleted).
	// 该模式使扫描检索到的行被锁定，好像要进行更新一样。 这样可以防止它们被其他事务锁定，修改或删除，
	// 直到当前事务结束为止。 也就是说，将阻止这些行尝试执行UPDATE，DELETE，SELECT FOR UPDATE，
	// SELECT FOR NO KEY UPDATE，SELECT FOR SHARE或SELECT FOR KEY SHARE的其他事务，直到当前
	// 事务结束为止。 相反，SELECT FOR UPDATE将等待在同一行上运行了任何这些命令的并发事务，然后将
	// 锁定并返回更新的行（如果删除了该行，则不返回任何行）。
	//
	// NOTE: FOR_UPDATE is currently implemented by acquiring lock.Exclusive locks
	// on each key scanned.
	// 注意：FOR_UPDATE当前是通过获取锁来实现的。每个扫描键上的排他锁。
	ScanLockingStrength_FOR_UPDATE ScanLockingStrength = 4
)

var ScanLockingStrength_name = map[int32]string{
	0: "FOR_NONE",
	1: "FOR_KEY_SHARE",
	2: "FOR_SHARE",
	3: "FOR_NO_KEY_UPDATE",
	4: "FOR_UPDATE",
}
var ScanLockingStrength_value = map[string]int32{
	"FOR_NONE":          0,
	"FOR_KEY_SHARE":     1,
	"FOR_SHARE":         2,
	"FOR_NO_KEY_UPDATE": 3,
	"FOR_UPDATE":        4,
}

func (x ScanLockingStrength) Enum() *ScanLockingStrength {
	p := new(ScanLockingStrength)
	*p = x
	return p
}
func (x ScanLockingStrength) String() string {
	return proto.EnumName(ScanLockingStrength_name, int32(x))
}
func (x *ScanLockingStrength) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ScanLockingStrength_value, data, "ScanLockingStrength")
	if err != nil {
		return err
	}
	*x = ScanLockingStrength(value)
	return nil
}
func (ScanLockingStrength) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_locking_b6d0ababd27f897e, []int{0}
}

type ScanLockingWaitLevel int32

const (
	// BLOCK represents the default - wait for the lock to become available.
	// BLOCK代表默认值-等待锁可用。
	ScanLockingWaitLevel_BLOCK ScanLockingWaitLevel = 0
	ScanLockingWaitLevel_SKIP  ScanLockingWaitLevel = 1
	// ERROR represents NOWAIT - raise an error if a row cannot be locked.
	// ERROR表示NOWAIT-如果无法锁定行，则会引发错误。
	ScanLockingWaitLevel_ERROR ScanLockingWaitLevel = 2
	// ScanLockingWaitPolicy_WAIT is a lock with a wait.
	ScanLockingWaitLevel_WAIT ScanLockingWaitLevel = 3
)

var ScanLockingWaitLevel_name = map[int32]string{
	0: "BLOCK",
	1: "SKIP",
	2: "ERROR",
	3: "WAIT",
}
var ScanLockingWaitLevel_value = map[string]int32{
	"BLOCK": 0,
	"SKIP":  1,
	"ERROR": 2,
	"WAIT":  3,
}

func (x ScanLockingWaitLevel) Enum() *ScanLockingWaitLevel {
	p := new(ScanLockingWaitLevel)
	*p = x
	return p
}
func (x ScanLockingWaitLevel) String() string {
	return proto.EnumName(ScanLockingWaitLevel_name, int32(x))
}
func (x *ScanLockingWaitLevel) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ScanLockingWaitLevel_value, data, "ScanLockingWaitLevel")
	if err != nil {
		return err
	}
	*x = ScanLockingWaitLevel(value)
	return nil
}
func (ScanLockingWaitLevel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_locking_b6d0ababd27f897e, []int{1}
}

// LockingWaitPolicy controls the policy used for handling conflicting locks
// held by other active transactions when attempting to lock rows due to FOR
// UPDATE/SHARE clauses (i.e. it represents the NOWAIT and SKIP LOCKED options).
// LockingWaitPolicy控制用于处理由于FOR UPDATE / SHARE子句而试图锁定行时其他活动事务持有
// 的冲突锁的策略（即，它代表NOWAIT和SKIP LOCKED选项）。
type ScanLockingWaitPolicy struct {
	LockLevel ScanLockingWaitLevel `protobuf:"varint,1,opt,name=lock_level,json=lockLevel,enum=znbase.sql.sqlbase.ScanLockingWaitLevel" json:"lock_level"`
	WaitTime  int64                `protobuf:"varint,2,opt,name=wait_time,json=waitTime" json:"wait_time"`
}

func (m *ScanLockingWaitPolicy) Reset()         { *m = ScanLockingWaitPolicy{} }
func (m *ScanLockingWaitPolicy) String() string { return proto.CompactTextString(m) }
func (*ScanLockingWaitPolicy) ProtoMessage()    {}
func (*ScanLockingWaitPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_locking_b6d0ababd27f897e, []int{0}
}
func (m *ScanLockingWaitPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScanLockingWaitPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ScanLockingWaitPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScanLockingWaitPolicy.Merge(dst, src)
}
func (m *ScanLockingWaitPolicy) XXX_Size() int {
	return m.Size()
}
func (m *ScanLockingWaitPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_ScanLockingWaitPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_ScanLockingWaitPolicy proto.InternalMessageInfo

func init() {
	proto.RegisterType((*ScanLockingWaitPolicy)(nil), "znbase.sql.sqlbase.ScanLockingWaitPolicy")
	proto.RegisterEnum("znbase.sql.sqlbase.ScanLockingStrength", ScanLockingStrength_name, ScanLockingStrength_value)
	proto.RegisterEnum("znbase.sql.sqlbase.ScanLockingWaitLevel", ScanLockingWaitLevel_name, ScanLockingWaitLevel_value)
}
func (m *ScanLockingWaitPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScanLockingWaitPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintLocking(dAtA, i, uint64(m.LockLevel))
	dAtA[i] = 0x10
	i++
	i = encodeVarintLocking(dAtA, i, uint64(m.WaitTime))
	return i, nil
}

func encodeVarintLocking(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ScanLockingWaitPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovLocking(uint64(m.LockLevel))
	n += 1 + sovLocking(uint64(m.WaitTime))
	return n
}

func sovLocking(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozLocking(x uint64) (n int) {
	return sovLocking(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ScanLockingWaitPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScanLockingWaitPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScanLockingWaitPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockLevel", wireType)
			}
			m.LockLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockLevel |= (ScanLockingWaitLevel(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitTime", wireType)
			}
			m.WaitTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WaitTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLocking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipLocking(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowLocking
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLocking
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLocking
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthLocking
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowLocking
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipLocking(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthLocking = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowLocking   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("sql/sqlbase/locking.proto", fileDescriptor_locking_b6d0ababd27f897e) }

var fileDescriptor_locking_b6d0ababd27f897e = []byte{
	// 326 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x90, 0xc1, 0x4e, 0xc2, 0x30,
	0x1c, 0xc6, 0x5b, 0xc0, 0xc8, 0xfe, 0x11, 0x52, 0x2a, 0x24, 0xe8, 0xa1, 0xa2, 0x27, 0xe4, 0x30,
	0x12, 0x9f, 0x40, 0xd0, 0x19, 0x09, 0xc8, 0xc8, 0x86, 0x21, 0x7a, 0x59, 0x26, 0x59, 0xe6, 0x62,
	0x59, 0x85, 0x35, 0x1a, 0x7d, 0x03, 0x6f, 0x3e, 0x16, 0x47, 0x8e, 0x9c, 0x8c, 0x8e, 0x17, 0x31,
	0xdd, 0x76, 0x30, 0xea, 0xad, 0xdf, 0xaf, 0xbf, 0xef, 0x4b, 0x53, 0xd8, 0x8b, 0xe6, 0xbc, 0x1d,
	0xcd, 0xf9, 0x9d, 0x1b, 0x79, 0x6d, 0x2e, 0xa6, 0x0f, 0x41, 0xe8, 0xeb, 0x8f, 0x0b, 0x21, 0x05,
	0xa5, 0xaf, 0xa1, 0xa2, 0x7a, 0x34, 0xe7, 0x7a, 0x66, 0xec, 0x57, 0x7d, 0xe1, 0x8b, 0xe4, 0xba,
	0xad, 0x4e, 0xa9, 0x79, 0xf4, 0x86, 0xa1, 0x66, 0x4f, 0xdd, 0x70, 0x90, 0xf6, 0x27, 0x6e, 0x20,
	0x47, 0x82, 0x07, 0xd3, 0x17, 0x7a, 0x05, 0xa0, 0x46, 0x1d, 0xee, 0x3d, 0x79, 0xbc, 0x8e, 0x1b,
	0xb8, 0x59, 0x3e, 0x69, 0xea, 0x7f, 0x87, 0xf5, 0x5f, 0xf5, 0x81, 0xf2, 0xbb, 0x85, 0xe5, 0xc7,
	0x01, 0xb2, 0x34, 0xb5, 0x90, 0x00, 0x7a, 0x08, 0xda, 0xb3, 0x1b, 0x48, 0x47, 0x06, 0x33, 0xaf,
	0x9e, 0x6b, 0xe0, 0x66, 0x3e, 0x73, 0x8a, 0x0a, 0x8f, 0x83, 0x99, 0xd7, 0xe2, 0xb0, 0xfb, 0x63,
	0xcb, 0x96, 0x0b, 0x2f, 0xf4, 0xe5, 0x3d, 0xdd, 0x81, 0xe2, 0x85, 0x69, 0x39, 0x43, 0x73, 0x68,
	0x10, 0x44, 0x2b, 0x50, 0x52, 0xa9, 0x6f, 0xdc, 0x38, 0xf6, 0x65, 0xc7, 0x32, 0x08, 0xa6, 0x25,
	0xd0, 0x14, 0x4a, 0x63, 0x8e, 0xd6, 0xa0, 0x92, 0xfa, 0x89, 0x74, 0x3d, 0x3a, 0xef, 0x8c, 0x0d,
	0x92, 0xa7, 0x65, 0x00, 0x85, 0xb3, 0x5c, 0x68, 0x9d, 0x42, 0xf5, 0xbf, 0x97, 0x53, 0x0d, 0xb6,
	0xba, 0x03, 0xf3, 0xac, 0x4f, 0x10, 0x2d, 0x42, 0xc1, 0xee, 0xf7, 0x46, 0x04, 0x2b, 0x68, 0x58,
	0x96, 0x69, 0x91, 0x9c, 0x82, 0x93, 0x4e, 0x6f, 0x4c, 0xf2, 0xdd, 0xe3, 0xe5, 0x17, 0x43, 0xcb,
	0x98, 0xe1, 0x55, 0xcc, 0xf0, 0x3a, 0x66, 0xf8, 0x33, 0x66, 0xf8, 0x7d, 0xc3, 0xd0, 0x6a, 0xc3,
	0xd0, 0x7a, 0xc3, 0xd0, 0xed, 0x76, 0xf6, 0x47, 0xdf, 0x01, 0x00, 0x00, 0xff, 0xff, 0xfd, 0xa7,
	0x97, 0xff, 0xac, 0x01, 0x00, 0x00,
}
